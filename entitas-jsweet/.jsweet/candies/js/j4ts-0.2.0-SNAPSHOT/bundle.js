"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var java;
(function (java) {
    var awt;
    (function (awt) {
        var Color = (function () {
            function Color(r, g, b) {
                this.r = 0;
                this.g = 0;
                this.b = 0;
                this.r = r;
                this.g = g;
                this.b = b;
            }
            Color.prototype.toHTML = function () {
                var sb = new java.lang.StringBuilder();
                sb.append("#");
                var s = javaemul.internal.IntegerHelper.toHexString(this.r);
                if (s.length === 1) {
                    sb.append("0");
                }
                sb.append(s);
                s = javaemul.internal.IntegerHelper.toHexString(this.g);
                if (s.length === 1) {
                    sb.append("0");
                }
                sb.append(s);
                s = javaemul.internal.IntegerHelper.toHexString(this.b);
                if (s.length === 1) {
                    sb.append("0");
                }
                sb.append(s);
                return sb.toString();
            };
            return Color;
        }());
        awt.Color = Color;
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        var Component = (function () {
            function Component() {
            }
            return Component;
        }());
        awt.Component = Component;
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        var event;
        (function (event) {
            var ActionEvent = (function () {
                function ActionEvent(source, actionCommand) {
                    this.source = source;
                    this.actionCommand = actionCommand;
                }
                ActionEvent.prototype.getSource = function () {
                    return this.source;
                };
                ActionEvent.prototype.getActionCommand = function () {
                    return this.actionCommand;
                };
                return ActionEvent;
            }());
            event.ActionEvent = ActionEvent;
        })(event = awt.event || (awt.event = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The <code>AffineTransform</code> class represents a 2D affine transform
             * that performs a linear mapping from 2D coordinates to other 2D
             * coordinates that preserves the "straightness" and
             * "parallelness" of lines.  Affine transformations can be constructed
             * using sequences of translations, scales, flips, rotations, and shears.
             * <p>
             * Such a coordinate transformation can be represented by a 3 row by
             * 3 column matrix with an implied last row of [ 0 0 1 ].  This matrix
             * transforms source coordinates {@code (x,y)} into
             * destination coordinates {@code (x',y')} by considering
             * them to be a column vector and multiplying the coordinate vector
             * by the matrix according to the following process:
             * <pre>
             * [ x']   [  m00  m01  m02  ] [ x ]   [ m00x + m01y + m02 ]
             * [ y'] = [  m10  m11  m12  ] [ y ] = [ m10x + m11y + m12 ]
             * [ 1 ]   [   0    0    1   ] [ 1 ]   [         1         ]
             * </pre>
             * <h3><a name="quadrantapproximation">Handling 90-Degree Rotations</a></h3>
             * <p>
             * In some variations of the <code>rotate</code> methods in the
             * <code>AffineTransform</code> class, a double-precision argument
             * specifies the angle of rotation in radians.
             * These methods have special handling for rotations of approximately
             * 90 degrees (including multiples such as 180, 270, and 360 degrees),
             * so that the common case of quadrant rotation is handled more
             * efficiently.
             * This special handling can cause angles very close to multiples of
             * 90 degrees to be treated as if they were exact multiples of
             * 90 degrees.
             * For small multiples of 90 degrees the range of angles treated
             * as a quadrant rotation is approximately 0.00000121 degrees wide.
             * This section explains why such special care is needed and how
             * it is implemented.
             * <p>
             * Since 90 degrees is represented as <code>PI/2</code> in radians,
             * and since PI is a transcendental (and therefore irrational) number,
             * it is not possible to exactly represent a multiple of 90 degrees as
             * an exact double precision value measured in radians.
             * As a result it is theoretically impossible to describe quadrant
             * rotations (90, 180, 270 or 360 degrees) using these values.
             * Double precision floating point values can get very close to
             * non-zero multiples of <code>PI/2</code> but never close enough
             * for the sine or cosine to be exactly 0.0, 1.0 or -1.0.
             * The implementations of <code>Math.sin()</code> and
             * <code>Math.cos()</code> correspondingly never return 0.0
             * for any case other than <code>Math.sin(0.0)</code>.
             * These same implementations do, however, return exactly 1.0 and
             * -1.0 for some range of numbers around each multiple of 90
             * degrees since the correct answer is so close to 1.0 or -1.0 that
             * the double precision significand cannot represent the difference
             * as accurately as it can for numbers that are near 0.0.
             * <p>
             * The net result of these issues is that if the
             * <code>Math.sin()</code> and <code>Math.cos()</code> methods
             * are used to directly generate the values for the matrix modifications
             * during these radian-based rotation operations then the resulting
             * transform is never strictly classifiable as a quadrant rotation
             * even for a simple case like <code>rotate(Math.PI/2.0)</code>,
             * due to minor variations in the matrix caused by the non-0.0 values
             * obtained for the sine and cosine.
             * If these transforms are not classified as quadrant rotations then
             * subsequent code which attempts to optimize further operations based
             * upon the type of the transform will be relegated to its most general
             * implementation.
             * <p>
             * Because quadrant rotations are fairly common,
             * this class should handle these cases reasonably quickly, both in
             * applying the rotations to the transform and in applying the resulting
             * transform to the coordinates.
             * To facilitate this optimal handling, the methods which take an angle
             * of rotation measured in radians attempt to detect angles that are
             * intended to be quadrant rotations and treat them as such.
             * These methods therefore treat an angle <em>theta</em> as a quadrant
             * rotation if either <code>Math.sin(<em>theta</em>)</code> or
             * <code>Math.cos(<em>theta</em>)</code> returns exactly 1.0 or -1.0.
             * As a rule of thumb, this property holds true for a range of
             * approximately 0.0000000211 radians (or 0.00000121 degrees) around
             * small multiples of <code>Math.PI/2.0</code>.
             *
             * @author Jim Graham
             * @since 1.2
             */
            var AffineTransform = (function () {
                function AffineTransform(m00, m10, m01, m11, m02, m12, state) {
                    var _this = this;
                    if (((typeof m00 === 'number') || m00 === null) && ((typeof m10 === 'number') || m10 === null) && ((typeof m01 === 'number') || m01 === null) && ((typeof m11 === 'number') || m11 === null) && ((typeof m02 === 'number') || m02 === null) && ((typeof m12 === 'number') || m12 === null) && ((typeof state === 'number') || state === null)) {
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.io.Serializable"] });
                        this.m00 = 0;
                        this.m10 = 0;
                        this.m01 = 0;
                        this.m11 = 0;
                        this.m02 = 0;
                        this.m12 = 0;
                        this.state = 0;
                        this.type = 0;
                        (function () {
                            _this.m00 = m00;
                            _this.m10 = m10;
                            _this.m01 = m01;
                            _this.m11 = m11;
                            _this.m02 = m02;
                            _this.m12 = m12;
                            _this.state = state;
                            _this.type = AffineTransform.TYPE_UNKNOWN;
                        })();
                    }
                    else if (((typeof m00 === 'number') || m00 === null) && ((typeof m10 === 'number') || m10 === null) && ((typeof m01 === 'number') || m01 === null) && ((typeof m11 === 'number') || m11 === null) && ((typeof m02 === 'number') || m02 === null) && ((typeof m12 === 'number') || m12 === null) && state === undefined) {
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.io.Serializable"] });
                        this.m00 = 0;
                        this.m10 = 0;
                        this.m01 = 0;
                        this.m11 = 0;
                        this.m02 = 0;
                        this.m12 = 0;
                        this.state = 0;
                        this.type = 0;
                        (function () {
                            _this.m00 = m00;
                            _this.m10 = m10;
                            _this.m01 = m01;
                            _this.m11 = m11;
                            _this.m02 = m02;
                            _this.m12 = m12;
                            _this.updateState();
                        })();
                    }
                    else if (((typeof m00 === 'number') || m00 === null) && ((typeof m10 === 'number') || m10 === null) && ((typeof m01 === 'number') || m01 === null) && ((typeof m11 === 'number') || m11 === null) && ((typeof m02 === 'number') || m02 === null) && ((typeof m12 === 'number') || m12 === null) && state === undefined) {
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.io.Serializable"] });
                        this.m00 = 0;
                        this.m10 = 0;
                        this.m01 = 0;
                        this.m11 = 0;
                        this.m02 = 0;
                        this.m12 = 0;
                        this.state = 0;
                        this.type = 0;
                        (function () {
                            _this.m00 = m00;
                            _this.m10 = m10;
                            _this.m01 = m01;
                            _this.m11 = m11;
                            _this.m02 = m02;
                            _this.m12 = m12;
                            _this.updateState();
                        })();
                    }
                    else if (((m00 != null && m00 instanceof java.awt.geom.AffineTransform) || m00 === null) && m10 === undefined && m01 === undefined && m11 === undefined && m02 === undefined && m12 === undefined && state === undefined) {
                        var Tx = m00;
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.io.Serializable"] });
                        this.m00 = 0;
                        this.m10 = 0;
                        this.m01 = 0;
                        this.m11 = 0;
                        this.m02 = 0;
                        this.m12 = 0;
                        this.state = 0;
                        this.type = 0;
                        (function () {
                            _this.m00 = Tx.m00;
                            _this.m10 = Tx.m10;
                            _this.m01 = Tx.m01;
                            _this.m11 = Tx.m11;
                            _this.m02 = Tx.m02;
                            _this.m12 = Tx.m12;
                            _this.state = Tx.state;
                            _this.type = Tx.type;
                        })();
                    }
                    else if (((m00 != null && m00 instanceof Array) || m00 === null) && m10 === undefined && m01 === undefined && m11 === undefined && m02 === undefined && m12 === undefined && state === undefined) {
                        var flatmatrix = m00;
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.io.Serializable"] });
                        this.m00 = 0;
                        this.m10 = 0;
                        this.m01 = 0;
                        this.m11 = 0;
                        this.m02 = 0;
                        this.m12 = 0;
                        this.state = 0;
                        this.type = 0;
                        (function () {
                            _this.m00 = flatmatrix[0];
                            _this.m10 = flatmatrix[1];
                            _this.m01 = flatmatrix[2];
                            _this.m11 = flatmatrix[3];
                            if (flatmatrix.length > 5) {
                                _this.m02 = flatmatrix[4];
                                _this.m12 = flatmatrix[5];
                            }
                            _this.updateState();
                        })();
                    }
                    else if (((m00 != null && m00 instanceof Array) || m00 === null) && m10 === undefined && m01 === undefined && m11 === undefined && m02 === undefined && m12 === undefined && state === undefined) {
                        var flatmatrix = m00;
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.io.Serializable"] });
                        this.m00 = 0;
                        this.m10 = 0;
                        this.m01 = 0;
                        this.m11 = 0;
                        this.m02 = 0;
                        this.m12 = 0;
                        this.state = 0;
                        this.type = 0;
                        (function () {
                            _this.m00 = flatmatrix[0];
                            _this.m10 = flatmatrix[1];
                            _this.m01 = flatmatrix[2];
                            _this.m11 = flatmatrix[3];
                            if (flatmatrix.length > 5) {
                                _this.m02 = flatmatrix[4];
                                _this.m12 = flatmatrix[5];
                            }
                            _this.updateState();
                        })();
                    }
                    else if (m00 === undefined && m10 === undefined && m01 === undefined && m11 === undefined && m02 === undefined && m12 === undefined && state === undefined) {
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.io.Serializable"] });
                        this.m00 = 0;
                        this.m10 = 0;
                        this.m01 = 0;
                        this.m11 = 0;
                        this.m02 = 0;
                        this.m12 = 0;
                        this.state = 0;
                        this.type = 0;
                        (function () {
                            _this.m00 = _this.m11 = 1.0;
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                }
                AffineTransform.TYPE_MASK_SCALE_$LI$ = function () { if (AffineTransform.TYPE_MASK_SCALE == null)
                    AffineTransform.TYPE_MASK_SCALE = (AffineTransform.TYPE_UNIFORM_SCALE | AffineTransform.TYPE_GENERAL_SCALE); return AffineTransform.TYPE_MASK_SCALE; };
                ;
                AffineTransform.TYPE_MASK_ROTATION_$LI$ = function () { if (AffineTransform.TYPE_MASK_ROTATION == null)
                    AffineTransform.TYPE_MASK_ROTATION = (AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_GENERAL_ROTATION); return AffineTransform.TYPE_MASK_ROTATION; };
                ;
                AffineTransform.HI_IDENTITY_$LI$ = function () { if (AffineTransform.HI_IDENTITY == null)
                    AffineTransform.HI_IDENTITY = AffineTransform.APPLY_IDENTITY << AffineTransform.HI_SHIFT; return AffineTransform.HI_IDENTITY; };
                ;
                AffineTransform.HI_TRANSLATE_$LI$ = function () { if (AffineTransform.HI_TRANSLATE == null)
                    AffineTransform.HI_TRANSLATE = AffineTransform.APPLY_TRANSLATE << AffineTransform.HI_SHIFT; return AffineTransform.HI_TRANSLATE; };
                ;
                AffineTransform.HI_SCALE_$LI$ = function () { if (AffineTransform.HI_SCALE == null)
                    AffineTransform.HI_SCALE = AffineTransform.APPLY_SCALE << AffineTransform.HI_SHIFT; return AffineTransform.HI_SCALE; };
                ;
                AffineTransform.HI_SHEAR_$LI$ = function () { if (AffineTransform.HI_SHEAR == null)
                    AffineTransform.HI_SHEAR = AffineTransform.APPLY_SHEAR << AffineTransform.HI_SHIFT; return AffineTransform.HI_SHEAR; };
                ;
                /**
                 * Returns a transform representing a translation transformation.
                 * The matrix representing the returned transform is:
                 * <pre>
                 * [   1    0    tx  ]
                 * [   0    1    ty  ]
                 * [   0    0    1   ]
                 * </pre>
                 * @param tx the distance by which coordinates are translated in the
                 * X axis direction
                 * @param ty the distance by which coordinates are translated in the
                 * Y axis direction
                 * @return an <code>AffineTransform</code> object that represents a
                 * translation transformation, created with the specified vector.
                 * @since 1.2
                 */
                AffineTransform.getTranslateInstance = function (tx, ty) {
                    var Tx = new AffineTransform();
                    Tx.setToTranslation(tx, ty);
                    return Tx;
                };
                /**
                 * Returns a transform representing a rotation transformation.
                 * The matrix representing the returned transform is:
                 * <pre>
                 * [   cos(theta)    -sin(theta)    0   ]
                 * [   sin(theta)     cos(theta)    0   ]
                 * [       0              0         1   ]
                 * </pre>
                 * Rotating by a positive angle theta rotates points on the positive
                 * X axis toward the positive Y axis.
                 * Note also the discussion of
                 * <a href="#quadrantapproximation">Handling 90-Degree Rotations</a>
                 * above.
                 * @param theta the angle of rotation measured in radians
                 * @return an <code>AffineTransform</code> object that is a rotation
                 * transformation, created with the specified angle of rotation.
                 * @since 1.2
                 */
                AffineTransform.getRotateInstance$double = function (theta) {
                    var Tx = new AffineTransform();
                    Tx.setToRotation(theta);
                    return Tx;
                };
                /**
                 * Returns a transform that rotates coordinates around an anchor point.
                 * This operation is equivalent to translating the coordinates so
                 * that the anchor point is at the origin (S1), then rotating them
                 * about the new origin (S2), and finally translating so that the
                 * intermediate origin is restored to the coordinates of the original
                 * anchor point (S3).
                 * <p>
                 * This operation is equivalent to the following sequence of calls:
                 * <pre>
                 * AffineTransform Tx = new AffineTransform();
                 * Tx.translate(anchorx, anchory);    // S3: final translation
                 * Tx.rotate(theta);                  // S2: rotate around anchor
                 * Tx.translate(-anchorx, -anchory);  // S1: translate anchor to origin
                 * </pre>
                 * The matrix representing the returned transform is:
                 * <pre>
                 * [   cos(theta)    -sin(theta)    x-x*cos+y*sin  ]
                 * [   sin(theta)     cos(theta)    y-x*sin-y*cos  ]
                 * [       0              0               1        ]
                 * </pre>
                 * Rotating by a positive angle theta rotates points on the positive
                 * X axis toward the positive Y axis.
                 * Note also the discussion of
                 * <a href="#quadrantapproximation">Handling 90-Degree Rotations</a>
                 * above.
                 *
                 * @param theta the angle of rotation measured in radians
                 * @param anchorx the X coordinate of the rotation anchor point
                 * @param anchory the Y coordinate of the rotation anchor point
                 * @return an <code>AffineTransform</code> object that rotates
                 * coordinates around the specified point by the specified angle of
                 * rotation.
                 * @since 1.2
                 */
                AffineTransform.getRotateInstance$double$double$double = function (theta, anchorx, anchory) {
                    var Tx = new AffineTransform();
                    Tx.setToRotation(theta, anchorx, anchory);
                    return Tx;
                };
                /**
                 * Returns a transform that rotates coordinates according to
                 * a rotation vector.
                 * All coordinates rotate about the origin by the same amount.
                 * The amount of rotation is such that coordinates along the former
                 * positive X axis will subsequently align with the vector pointing
                 * from the origin to the specified vector coordinates.
                 * If both <code>vecx</code> and <code>vecy</code> are 0.0,
                 * an identity transform is returned.
                 * This operation is equivalent to calling:
                 * <pre>
                 * AffineTransform.getRotateInstance(Math.atan2(vecy, vecx));
                 * </pre>
                 *
                 * @param vecx the X coordinate of the rotation vector
                 * @param vecy the Y coordinate of the rotation vector
                 * @return an <code>AffineTransform</code> object that rotates
                 * coordinates according to the specified rotation vector.
                 * @since 1.6
                 */
                AffineTransform.getRotateInstance$double$double = function (vecx, vecy) {
                    var Tx = new AffineTransform();
                    Tx.setToRotation(vecx, vecy);
                    return Tx;
                };
                /**
                 * Returns a transform that rotates coordinates around an anchor
                 * point according to a rotation vector.
                 * All coordinates rotate about the specified anchor coordinates
                 * by the same amount.
                 * The amount of rotation is such that coordinates along the former
                 * positive X axis will subsequently align with the vector pointing
                 * from the origin to the specified vector coordinates.
                 * If both <code>vecx</code> and <code>vecy</code> are 0.0,
                 * an identity transform is returned.
                 * This operation is equivalent to calling:
                 * <pre>
                 * AffineTransform.getRotateInstance(Math.atan2(vecy, vecx),
                 * anchorx, anchory);
                 * </pre>
                 *
                 * @param vecx the X coordinate of the rotation vector
                 * @param vecy the Y coordinate of the rotation vector
                 * @param anchorx the X coordinate of the rotation anchor point
                 * @param anchory the Y coordinate of the rotation anchor point
                 * @return an <code>AffineTransform</code> object that rotates
                 * coordinates around the specified point according to the
                 * specified rotation vector.
                 * @since 1.6
                 */
                AffineTransform.getRotateInstance = function (vecx, vecy, anchorx, anchory) {
                    if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && ((typeof anchorx === 'number') || anchorx === null) && ((typeof anchory === 'number') || anchory === null)) {
                        return (function () {
                            var Tx = new AffineTransform();
                            Tx.setToRotation(vecx, vecy, anchorx, anchory);
                            return Tx;
                        })();
                    }
                    else if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && ((typeof anchorx === 'number') || anchorx === null) && anchory === undefined) {
                        return java.awt.geom.AffineTransform.getRotateInstance$double$double$double(vecx, vecy, anchorx);
                    }
                    else if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && anchorx === undefined && anchory === undefined) {
                        return java.awt.geom.AffineTransform.getRotateInstance$double$double(vecx, vecy);
                    }
                    else if (((typeof vecx === 'number') || vecx === null) && vecy === undefined && anchorx === undefined && anchory === undefined) {
                        return java.awt.geom.AffineTransform.getRotateInstance$double(vecx);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns a transform that rotates coordinates by the specified
                 * number of quadrants.
                 * This operation is equivalent to calling:
                 * <pre>
                 * AffineTransform.getRotateInstance(numquadrants * Math.PI / 2.0);
                 * </pre>
                 * Rotating by a positive number of quadrants rotates points on
                 * the positive X axis toward the positive Y axis.
                 * @param numquadrants the number of 90 degree arcs to rotate by
                 * @return an <code>AffineTransform</code> object that rotates
                 * coordinates by the specified number of quadrants.
                 * @since 1.6
                 */
                AffineTransform.getQuadrantRotateInstance$int = function (numquadrants) {
                    var Tx = new AffineTransform();
                    Tx.setToQuadrantRotation(numquadrants);
                    return Tx;
                };
                /**
                 * Returns a transform that rotates coordinates by the specified
                 * number of quadrants around the specified anchor point.
                 * This operation is equivalent to calling:
                 * <pre>
                 * AffineTransform.getRotateInstance(numquadrants * Math.PI / 2.0,
                 * anchorx, anchory);
                 * </pre>
                 * Rotating by a positive number of quadrants rotates points on
                 * the positive X axis toward the positive Y axis.
                 *
                 * @param numquadrants the number of 90 degree arcs to rotate by
                 * @param anchorx the X coordinate of the rotation anchor point
                 * @param anchory the Y coordinate of the rotation anchor point
                 * @return an <code>AffineTransform</code> object that rotates
                 * coordinates by the specified number of quadrants around the
                 * specified anchor point.
                 * @since 1.6
                 */
                AffineTransform.getQuadrantRotateInstance = function (numquadrants, anchorx, anchory) {
                    if (((typeof numquadrants === 'number') || numquadrants === null) && ((typeof anchorx === 'number') || anchorx === null) && ((typeof anchory === 'number') || anchory === null)) {
                        return (function () {
                            var Tx = new AffineTransform();
                            Tx.setToQuadrantRotation(numquadrants, anchorx, anchory);
                            return Tx;
                        })();
                    }
                    else if (((typeof numquadrants === 'number') || numquadrants === null) && anchorx === undefined && anchory === undefined) {
                        return java.awt.geom.AffineTransform.getQuadrantRotateInstance$int(numquadrants);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns a transform representing a scaling transformation.
                 * The matrix representing the returned transform is:
                 * <pre>
                 * [   sx   0    0   ]
                 * [   0    sy   0   ]
                 * [   0    0    1   ]
                 * </pre>
                 * @param sx the factor by which coordinates are scaled along the
                 * X axis direction
                 * @param sy the factor by which coordinates are scaled along the
                 * Y axis direction
                 * @return an <code>AffineTransform</code> object that scales
                 * coordinates by the specified factors.
                 * @since 1.2
                 */
                AffineTransform.getScaleInstance = function (sx, sy) {
                    var Tx = new AffineTransform();
                    Tx.setToScale(sx, sy);
                    return Tx;
                };
                /**
                 * Returns a transform representing a shearing transformation.
                 * The matrix representing the returned transform is:
                 * <pre>
                 * [   1   shx   0   ]
                 * [  shy   1    0   ]
                 * [   0    0    1   ]
                 * </pre>
                 * @param shx the multiplier by which coordinates are shifted in the
                 * direction of the positive X axis as a factor of their Y coordinate
                 * @param shy the multiplier by which coordinates are shifted in the
                 * direction of the positive Y axis as a factor of their X coordinate
                 * @return an <code>AffineTransform</code> object that shears
                 * coordinates by the specified multipliers.
                 * @since 1.2
                 */
                AffineTransform.getShearInstance = function (shx, shy) {
                    var Tx = new AffineTransform();
                    Tx.setToShear(shx, shy);
                    return Tx;
                };
                /**
                 * Retrieves the flag bits describing the conversion properties of
                 * this transform.
                 * The return value is either one of the constants TYPE_IDENTITY
                 * or TYPE_GENERAL_TRANSFORM, or a combination of the
                 * appropriate flag bits.
                 * A valid combination of flag bits is an exclusive OR operation
                 * that can combine
                 * the TYPE_TRANSLATION flag bit
                 * in addition to either of the
                 * TYPE_UNIFORM_SCALE or TYPE_GENERAL_SCALE flag bits
                 * as well as either of the
                 * TYPE_QUADRANT_ROTATION or TYPE_GENERAL_ROTATION flag bits.
                 * @return the OR combination of any of the indicated flags that
                 * apply to this transform
                 * @see #TYPE_IDENTITY
                 * @see #TYPE_TRANSLATION
                 * @see #TYPE_UNIFORM_SCALE
                 * @see #TYPE_GENERAL_SCALE
                 * @see #TYPE_QUADRANT_ROTATION
                 * @see #TYPE_GENERAL_ROTATION
                 * @see #TYPE_GENERAL_TRANSFORM
                 * @since 1.2
                 */
                AffineTransform.prototype.getType = function () {
                    if (this.type === AffineTransform.TYPE_UNKNOWN) {
                        this.calculateType();
                    }
                    return this.type;
                };
                /**
                 * This is the utility function to calculate the flag bits when
                 * they have not been cached.
                 * @see #getType
                 */
                AffineTransform.prototype.calculateType = function () {
                    var ret = AffineTransform.TYPE_IDENTITY;
                    var sgn0;
                    var sgn1;
                    var M0;
                    var M1;
                    var M2;
                    var M3;
                    this.updateState();
                    switch ((this.state)) {
                        default:
                            this.stateError();
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            ret = AffineTransform.TYPE_TRANSLATION;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            if ((M0 = this.m00) * (M2 = this.m01) + (M3 = this.m10) * (M1 = this.m11) !== 0) {
                                this.type = AffineTransform.TYPE_GENERAL_TRANSFORM;
                                return;
                            }
                            sgn0 = (M0 >= 0.0);
                            sgn1 = (M1 >= 0.0);
                            if (sgn0 === sgn1) {
                                if (M0 !== M1 || M2 !== -M3) {
                                    ret |= (AffineTransform.TYPE_GENERAL_ROTATION | AffineTransform.TYPE_GENERAL_SCALE);
                                }
                                else if (M0 * M1 - M2 * M3 !== 1.0) {
                                    ret |= (AffineTransform.TYPE_GENERAL_ROTATION | AffineTransform.TYPE_UNIFORM_SCALE);
                                }
                                else {
                                    ret |= AffineTransform.TYPE_GENERAL_ROTATION;
                                }
                            }
                            else {
                                if (M0 !== -M1 || M2 !== M3) {
                                    ret |= (AffineTransform.TYPE_GENERAL_ROTATION | AffineTransform.TYPE_FLIP | AffineTransform.TYPE_GENERAL_SCALE);
                                }
                                else if (M0 * M1 - M2 * M3 !== 1.0) {
                                    ret |= (AffineTransform.TYPE_GENERAL_ROTATION | AffineTransform.TYPE_FLIP | AffineTransform.TYPE_UNIFORM_SCALE);
                                }
                                else {
                                    ret |= (AffineTransform.TYPE_GENERAL_ROTATION | AffineTransform.TYPE_FLIP);
                                }
                            }
                            break;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            ret = AffineTransform.TYPE_TRANSLATION;
                        case (AffineTransform.APPLY_SHEAR):
                            sgn0 = ((M0 = this.m01) >= 0.0);
                            sgn1 = ((M1 = this.m10) >= 0.0);
                            if (sgn0 !== sgn1) {
                                if (M0 !== -M1) {
                                    ret |= (AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_GENERAL_SCALE);
                                }
                                else if (M0 !== 1.0 && M0 !== -1.0) {
                                    ret |= (AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_UNIFORM_SCALE);
                                }
                                else {
                                    ret |= AffineTransform.TYPE_QUADRANT_ROTATION;
                                }
                            }
                            else {
                                if (M0 === M1) {
                                    ret |= (AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_FLIP | AffineTransform.TYPE_UNIFORM_SCALE);
                                }
                                else {
                                    ret |= (AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_FLIP | AffineTransform.TYPE_GENERAL_SCALE);
                                }
                            }
                            break;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            ret = AffineTransform.TYPE_TRANSLATION;
                        case (AffineTransform.APPLY_SCALE):
                            sgn0 = ((M0 = this.m00) >= 0.0);
                            sgn1 = ((M1 = this.m11) >= 0.0);
                            if (sgn0 === sgn1) {
                                if (sgn0) {
                                    if (M0 === M1) {
                                        ret |= AffineTransform.TYPE_UNIFORM_SCALE;
                                    }
                                    else {
                                        ret |= AffineTransform.TYPE_GENERAL_SCALE;
                                    }
                                }
                                else {
                                    if (M0 !== M1) {
                                        ret |= (AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_GENERAL_SCALE);
                                    }
                                    else if (M0 !== -1.0) {
                                        ret |= (AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_UNIFORM_SCALE);
                                    }
                                    else {
                                        ret |= AffineTransform.TYPE_QUADRANT_ROTATION;
                                    }
                                }
                            }
                            else {
                                if (M0 === -M1) {
                                    if (M0 === 1.0 || M0 === -1.0) {
                                        ret |= AffineTransform.TYPE_FLIP;
                                    }
                                    else {
                                        ret |= (AffineTransform.TYPE_FLIP | AffineTransform.TYPE_UNIFORM_SCALE);
                                    }
                                }
                                else {
                                    ret |= (AffineTransform.TYPE_FLIP | AffineTransform.TYPE_GENERAL_SCALE);
                                }
                            }
                            break;
                        case (AffineTransform.APPLY_TRANSLATE):
                            ret = AffineTransform.TYPE_TRANSLATION;
                            break;
                        case (AffineTransform.APPLY_IDENTITY):
                            break;
                    }
                    this.type = ret;
                };
                /**
                 * Returns the determinant of the matrix representation of the transform.
                 * The determinant is useful both to determine if the transform can
                 * be inverted and to get a single value representing the
                 * combined X and Y scaling of the transform.
                 * <p>
                 * If the determinant is non-zero, then this transform is
                 * invertible and the various methods that depend on the inverse
                 * transform do not need to throw a
                 * {@link NoninvertibleTransformException}.
                 * If the determinant is zero then this transform can not be
                 * inverted since the transform maps all input coordinates onto
                 * a line or a point.
                 * If the determinant is near enough to zero then inverse transform
                 * operations might not carry enough precision to produce meaningful
                 * results.
                 * <p>
                 * If this transform represents a uniform scale, as indicated by
                 * the <code>getType</code> method then the determinant also
                 * represents the square of the uniform scale factor by which all of
                 * the points are expanded from or contracted towards the origin.
                 * If this transform represents a non-uniform scale or more general
                 * transform then the determinant is not likely to represent a
                 * value useful for any purpose other than determining if inverse
                 * transforms are possible.
                 * <p>
                 * Mathematically, the determinant is calculated using the formula:
                 * <pre>
                 * |  m00  m01  m02  |
                 * |  m10  m11  m12  |  =  m00 * m11 - m01 * m10
                 * |   0    0    1   |
                 * </pre>
                 *
                 * @return the determinant of the matrix used to transform the
                 * coordinates.
                 * @see #getType
                 * @see #createInverse
                 * @see #inverseTransform
                 * @see #TYPE_UNIFORM_SCALE
                 * @since 1.2
                 */
                AffineTransform.prototype.getDeterminant = function () {
                    switch ((this.state)) {
                        default:
                            this.stateError();
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            return this.m00 * this.m11 - this.m01 * this.m10;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SHEAR):
                            return -(this.m01 * this.m10);
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SCALE):
                            return this.m00 * this.m11;
                        case (AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_IDENTITY):
                            return 1.0;
                    }
                };
                /**
                 * Manually recalculates the state of the transform when the matrix
                 * changes too much to predict the effects on the state.
                 * The following table specifies what the various settings of the
                 * state field say about the values of the corresponding matrix
                 * element fields.
                 * Note that the rules governing the SCALE fields are slightly
                 * different depending on whether the SHEAR flag is also set.
                 * <pre>
                 * SCALE            SHEAR          TRANSLATE
                 * m00/m11          m01/m10          m02/m12
                 *
                 * IDENTITY             1.0              0.0              0.0
                 * TRANSLATE (TR)       1.0              0.0          not both 0.0
                 * SCALE (SC)       not both 1.0         0.0              0.0
                 * TR | SC          not both 1.0         0.0          not both 0.0
                 * SHEAR (SH)           0.0          not both 0.0         0.0
                 * TR | SH              0.0          not both 0.0     not both 0.0
                 * SC | SH          not both 0.0     not both 0.0         0.0
                 * TR | SC | SH     not both 0.0     not both 0.0     not both 0.0
                 * </pre>
                 */
                AffineTransform.prototype.updateState = function () {
                    if (this.m01 === 0.0 && this.m10 === 0.0) {
                        if (this.m00 === 1.0 && this.m11 === 1.0) {
                            if (this.m02 === 0.0 && this.m12 === 0.0) {
                                this.state = AffineTransform.APPLY_IDENTITY;
                                this.type = AffineTransform.TYPE_IDENTITY;
                            }
                            else {
                                this.state = AffineTransform.APPLY_TRANSLATE;
                                this.type = AffineTransform.TYPE_TRANSLATION;
                            }
                        }
                        else {
                            if (this.m02 === 0.0 && this.m12 === 0.0) {
                                this.state = AffineTransform.APPLY_SCALE;
                                this.type = AffineTransform.TYPE_UNKNOWN;
                            }
                            else {
                                this.state = (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE);
                                this.type = AffineTransform.TYPE_UNKNOWN;
                            }
                        }
                    }
                    else {
                        if (this.m00 === 0.0 && this.m11 === 0.0) {
                            if (this.m02 === 0.0 && this.m12 === 0.0) {
                                this.state = AffineTransform.APPLY_SHEAR;
                                this.type = AffineTransform.TYPE_UNKNOWN;
                            }
                            else {
                                this.state = (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE);
                                this.type = AffineTransform.TYPE_UNKNOWN;
                            }
                        }
                        else {
                            if (this.m02 === 0.0 && this.m12 === 0.0) {
                                this.state = (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE);
                                this.type = AffineTransform.TYPE_UNKNOWN;
                            }
                            else {
                                this.state = (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE);
                                this.type = AffineTransform.TYPE_UNKNOWN;
                            }
                        }
                    }
                };
                AffineTransform.prototype.stateError = function () {
                    throw new java.lang.InternalError("missing case in transform state switch");
                };
                /**
                 * Retrieves the 6 specifiable values in the 3x3 affine transformation
                 * matrix and places them into an array of double precisions values.
                 * The values are stored in the array as
                 * {&nbsp;m00&nbsp;m10&nbsp;m01&nbsp;m11&nbsp;m02&nbsp;m12&nbsp;}.
                 * An array of 4 doubles can also be specified, in which case only the
                 * first four elements representing the non-transform
                 * parts of the array are retrieved and the values are stored into
                 * the array as {&nbsp;m00&nbsp;m10&nbsp;m01&nbsp;m11&nbsp;}
                 * @param flatmatrix the double array used to store the returned
                 * values.
                 * @see #getScaleX
                 * @see #getScaleY
                 * @see #getShearX
                 * @see #getShearY
                 * @see #getTranslateX
                 * @see #getTranslateY
                 * @since 1.2
                 */
                AffineTransform.prototype.getMatrix = function (flatmatrix) {
                    flatmatrix[0] = this.m00;
                    flatmatrix[1] = this.m10;
                    flatmatrix[2] = this.m01;
                    flatmatrix[3] = this.m11;
                    if (flatmatrix.length > 5) {
                        flatmatrix[4] = this.m02;
                        flatmatrix[5] = this.m12;
                    }
                };
                /**
                 * Returns the X coordinate scaling element (m00) of the 3x3
                 * affine transformation matrix.
                 * @return a double value that is the X coordinate of the scaling
                 * element of the affine transformation matrix.
                 * @see #getMatrix
                 * @since 1.2
                 */
                AffineTransform.prototype.getScaleX = function () {
                    return this.m00;
                };
                /**
                 * Returns the Y coordinate scaling element (m11) of the 3x3
                 * affine transformation matrix.
                 * @return a double value that is the Y coordinate of the scaling
                 * element of the affine transformation matrix.
                 * @see #getMatrix
                 * @since 1.2
                 */
                AffineTransform.prototype.getScaleY = function () {
                    return this.m11;
                };
                /**
                 * Returns the X coordinate shearing element (m01) of the 3x3
                 * affine transformation matrix.
                 * @return a double value that is the X coordinate of the shearing
                 * element of the affine transformation matrix.
                 * @see #getMatrix
                 * @since 1.2
                 */
                AffineTransform.prototype.getShearX = function () {
                    return this.m01;
                };
                /**
                 * Returns the Y coordinate shearing element (m10) of the 3x3
                 * affine transformation matrix.
                 * @return a double value that is the Y coordinate of the shearing
                 * element of the affine transformation matrix.
                 * @see #getMatrix
                 * @since 1.2
                 */
                AffineTransform.prototype.getShearY = function () {
                    return this.m10;
                };
                /**
                 * Returns the X coordinate of the translation element (m02) of the
                 * 3x3 affine transformation matrix.
                 * @return a double value that is the X coordinate of the translation
                 * element of the affine transformation matrix.
                 * @see #getMatrix
                 * @since 1.2
                 */
                AffineTransform.prototype.getTranslateX = function () {
                    return this.m02;
                };
                /**
                 * Returns the Y coordinate of the translation element (m12) of the
                 * 3x3 affine transformation matrix.
                 * @return a double value that is the Y coordinate of the translation
                 * element of the affine transformation matrix.
                 * @see #getMatrix
                 * @since 1.2
                 */
                AffineTransform.prototype.getTranslateY = function () {
                    return this.m12;
                };
                /**
                 * Concatenates this transform with a translation transformation.
                 * This is equivalent to calling concatenate(T), where T is an
                 * <code>AffineTransform</code> represented by the following matrix:
                 * <pre>
                 * [   1    0    tx  ]
                 * [   0    1    ty  ]
                 * [   0    0    1   ]
                 * </pre>
                 * @param tx the distance by which coordinates are translated in the
                 * X axis direction
                 * @param ty the distance by which coordinates are translated in the
                 * Y axis direction
                 * @since 1.2
                 */
                AffineTransform.prototype.translate = function (tx, ty) {
                    switch ((this.state)) {
                        default:
                            this.stateError();
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            this.m02 = tx * this.m00 + ty * this.m01 + this.m02;
                            this.m12 = tx * this.m10 + ty * this.m11 + this.m12;
                            if (this.m02 === 0.0 && this.m12 === 0.0) {
                                this.state = AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE;
                                if (this.type !== AffineTransform.TYPE_UNKNOWN) {
                                    this.type -= AffineTransform.TYPE_TRANSLATION;
                                }
                            }
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            this.m02 = tx * this.m00 + ty * this.m01;
                            this.m12 = tx * this.m10 + ty * this.m11;
                            if (this.m02 !== 0.0 || this.m12 !== 0.0) {
                                this.state = AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE;
                                this.type |= AffineTransform.TYPE_TRANSLATION;
                            }
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            this.m02 = ty * this.m01 + this.m02;
                            this.m12 = tx * this.m10 + this.m12;
                            if (this.m02 === 0.0 && this.m12 === 0.0) {
                                this.state = AffineTransform.APPLY_SHEAR;
                                if (this.type !== AffineTransform.TYPE_UNKNOWN) {
                                    this.type -= AffineTransform.TYPE_TRANSLATION;
                                }
                            }
                            return;
                        case (AffineTransform.APPLY_SHEAR):
                            this.m02 = ty * this.m01;
                            this.m12 = tx * this.m10;
                            if (this.m02 !== 0.0 || this.m12 !== 0.0) {
                                this.state = AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE;
                                this.type |= AffineTransform.TYPE_TRANSLATION;
                            }
                            return;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            this.m02 = tx * this.m00 + this.m02;
                            this.m12 = ty * this.m11 + this.m12;
                            if (this.m02 === 0.0 && this.m12 === 0.0) {
                                this.state = AffineTransform.APPLY_SCALE;
                                if (this.type !== AffineTransform.TYPE_UNKNOWN) {
                                    this.type -= AffineTransform.TYPE_TRANSLATION;
                                }
                            }
                            return;
                        case (AffineTransform.APPLY_SCALE):
                            this.m02 = tx * this.m00;
                            this.m12 = ty * this.m11;
                            if (this.m02 !== 0.0 || this.m12 !== 0.0) {
                                this.state = AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE;
                                this.type |= AffineTransform.TYPE_TRANSLATION;
                            }
                            return;
                        case (AffineTransform.APPLY_TRANSLATE):
                            this.m02 = tx + this.m02;
                            this.m12 = ty + this.m12;
                            if (this.m02 === 0.0 && this.m12 === 0.0) {
                                this.state = AffineTransform.APPLY_IDENTITY;
                                this.type = AffineTransform.TYPE_IDENTITY;
                            }
                            return;
                        case (AffineTransform.APPLY_IDENTITY):
                            this.m02 = tx;
                            this.m12 = ty;
                            if (tx !== 0.0 || ty !== 0.0) {
                                this.state = AffineTransform.APPLY_TRANSLATE;
                                this.type = AffineTransform.TYPE_TRANSLATION;
                            }
                            return;
                    }
                };
                AffineTransform.rot90conversion_$LI$ = function () { if (AffineTransform.rot90conversion == null)
                    AffineTransform.rot90conversion = [AffineTransform.APPLY_SHEAR, AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE, AffineTransform.APPLY_SHEAR, AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE, AffineTransform.APPLY_SCALE, AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE, AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE, AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE]; return AffineTransform.rot90conversion; };
                ;
                AffineTransform.prototype.rotate90 = function () {
                    var M0 = this.m00;
                    this.m00 = this.m01;
                    this.m01 = -M0;
                    M0 = this.m10;
                    this.m10 = this.m11;
                    this.m11 = -M0;
                    var state = AffineTransform.rot90conversion_$LI$()[this.state];
                    if ((state & (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE)) === AffineTransform.APPLY_SCALE && this.m00 === 1.0 && this.m11 === 1.0) {
                        state -= AffineTransform.APPLY_SCALE;
                    }
                    this.state = state;
                    this.type = AffineTransform.TYPE_UNKNOWN;
                };
                AffineTransform.prototype.rotate180 = function () {
                    this.m00 = -this.m00;
                    this.m11 = -this.m11;
                    var state = this.state;
                    if ((state & (AffineTransform.APPLY_SHEAR)) !== 0) {
                        this.m01 = -this.m01;
                        this.m10 = -this.m10;
                    }
                    else {
                        if (this.m00 === 1.0 && this.m11 === 1.0) {
                            this.state = state & ~AffineTransform.APPLY_SCALE;
                        }
                        else {
                            this.state = state | AffineTransform.APPLY_SCALE;
                        }
                    }
                    this.type = AffineTransform.TYPE_UNKNOWN;
                };
                AffineTransform.prototype.rotate270 = function () {
                    var M0 = this.m00;
                    this.m00 = -this.m01;
                    this.m01 = M0;
                    M0 = this.m10;
                    this.m10 = -this.m11;
                    this.m11 = M0;
                    var state = AffineTransform.rot90conversion_$LI$()[this.state];
                    if ((state & (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE)) === AffineTransform.APPLY_SCALE && this.m00 === 1.0 && this.m11 === 1.0) {
                        state -= AffineTransform.APPLY_SCALE;
                    }
                    this.state = state;
                    this.type = AffineTransform.TYPE_UNKNOWN;
                };
                /**
                 * Concatenates this transform with a rotation transformation.
                 * This is equivalent to calling concatenate(R), where R is an
                 * <code>AffineTransform</code> represented by the following matrix:
                 * <pre>
                 * [   cos(theta)    -sin(theta)    0   ]
                 * [   sin(theta)     cos(theta)    0   ]
                 * [       0              0         1   ]
                 * </pre>
                 * Rotating by a positive angle theta rotates points on the positive
                 * X axis toward the positive Y axis.
                 * Note also the discussion of
                 * <a href="#quadrantapproximation">Handling 90-Degree Rotations</a>
                 * above.
                 * @param theta the angle of rotation measured in radians
                 * @since 1.2
                 */
                AffineTransform.prototype.rotate$double = function (theta) {
                    var sin = Math.sin(theta);
                    if (sin === 1.0) {
                        this.rotate90();
                    }
                    else if (sin === -1.0) {
                        this.rotate270();
                    }
                    else {
                        var cos = Math.cos(theta);
                        if (cos === -1.0) {
                            this.rotate180();
                        }
                        else if (cos !== 1.0) {
                            var M0;
                            var M1;
                            M0 = this.m00;
                            M1 = this.m01;
                            this.m00 = cos * M0 + sin * M1;
                            this.m01 = -sin * M0 + cos * M1;
                            M0 = this.m10;
                            M1 = this.m11;
                            this.m10 = cos * M0 + sin * M1;
                            this.m11 = -sin * M0 + cos * M1;
                            this.updateState();
                        }
                    }
                };
                /**
                 * Concatenates this transform with a transform that rotates
                 * coordinates around an anchor point.
                 * This operation is equivalent to translating the coordinates so
                 * that the anchor point is at the origin (S1), then rotating them
                 * about the new origin (S2), and finally translating so that the
                 * intermediate origin is restored to the coordinates of the original
                 * anchor point (S3).
                 * <p>
                 * This operation is equivalent to the following sequence of calls:
                 * <pre>
                 * translate(anchorx, anchory);      // S3: final translation
                 * rotate(theta);                    // S2: rotate around anchor
                 * translate(-anchorx, -anchory);    // S1: translate anchor to origin
                 * </pre>
                 * Rotating by a positive angle theta rotates points on the positive
                 * X axis toward the positive Y axis.
                 * Note also the discussion of
                 * <a href="#quadrantapproximation">Handling 90-Degree Rotations</a>
                 * above.
                 *
                 * @param theta the angle of rotation measured in radians
                 * @param anchorx the X coordinate of the rotation anchor point
                 * @param anchory the Y coordinate of the rotation anchor point
                 * @since 1.2
                 */
                AffineTransform.prototype.rotate$double$double$double = function (theta, anchorx, anchory) {
                    this.translate(anchorx, anchory);
                    this.rotate(theta);
                    this.translate(-anchorx, -anchory);
                };
                /**
                 * Concatenates this transform with a transform that rotates
                 * coordinates according to a rotation vector.
                 * All coordinates rotate about the origin by the same amount.
                 * The amount of rotation is such that coordinates along the former
                 * positive X axis will subsequently align with the vector pointing
                 * from the origin to the specified vector coordinates.
                 * If both <code>vecx</code> and <code>vecy</code> are 0.0,
                 * no additional rotation is added to this transform.
                 * This operation is equivalent to calling:
                 * <pre>
                 * rotate(Math.atan2(vecy, vecx));
                 * </pre>
                 *
                 * @param vecx the X coordinate of the rotation vector
                 * @param vecy the Y coordinate of the rotation vector
                 * @since 1.6
                 */
                AffineTransform.prototype.rotate$double$double = function (vecx, vecy) {
                    if (vecy === 0.0) {
                        if (vecx < 0.0) {
                            this.rotate180();
                        }
                    }
                    else if (vecx === 0.0) {
                        if (vecy > 0.0) {
                            this.rotate90();
                        }
                        else {
                            this.rotate270();
                        }
                    }
                    else {
                        var len = Math.sqrt(vecx * vecx + vecy * vecy);
                        var sin = vecy / len;
                        var cos = vecx / len;
                        var M0;
                        var M1;
                        M0 = this.m00;
                        M1 = this.m01;
                        this.m00 = cos * M0 + sin * M1;
                        this.m01 = -sin * M0 + cos * M1;
                        M0 = this.m10;
                        M1 = this.m11;
                        this.m10 = cos * M0 + sin * M1;
                        this.m11 = -sin * M0 + cos * M1;
                        this.updateState();
                    }
                };
                /**
                 * Concatenates this transform with a transform that rotates
                 * coordinates around an anchor point according to a rotation
                 * vector.
                 * All coordinates rotate about the specified anchor coordinates
                 * by the same amount.
                 * The amount of rotation is such that coordinates along the former
                 * positive X axis will subsequently align with the vector pointing
                 * from the origin to the specified vector coordinates.
                 * If both <code>vecx</code> and <code>vecy</code> are 0.0,
                 * the transform is not modified in any way.
                 * This method is equivalent to calling:
                 * <pre>
                 * rotate(Math.atan2(vecy, vecx), anchorx, anchory);
                 * </pre>
                 *
                 * @param vecx the X coordinate of the rotation vector
                 * @param vecy the Y coordinate of the rotation vector
                 * @param anchorx the X coordinate of the rotation anchor point
                 * @param anchory the Y coordinate of the rotation anchor point
                 * @since 1.6
                 */
                AffineTransform.prototype.rotate = function (vecx, vecy, anchorx, anchory) {
                    var _this = this;
                    if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && ((typeof anchorx === 'number') || anchorx === null) && ((typeof anchory === 'number') || anchory === null)) {
                        return (function () {
                            _this.translate(anchorx, anchory);
                            _this.rotate(vecx, vecy);
                            _this.translate(-anchorx, -anchory);
                        })();
                    }
                    else if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && ((typeof anchorx === 'number') || anchorx === null) && anchory === undefined) {
                        return this.rotate$double$double$double(vecx, vecy, anchorx);
                    }
                    else if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && anchorx === undefined && anchory === undefined) {
                        return this.rotate$double$double(vecx, vecy);
                    }
                    else if (((typeof vecx === 'number') || vecx === null) && vecy === undefined && anchorx === undefined && anchory === undefined) {
                        return this.rotate$double(vecx);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Concatenates this transform with a transform that rotates
                 * coordinates by the specified number of quadrants.
                 * This is equivalent to calling:
                 * <pre>
                 * rotate(numquadrants * Math.PI / 2.0);
                 * </pre>
                 * Rotating by a positive number of quadrants rotates points on
                 * the positive X axis toward the positive Y axis.
                 * @param numquadrants the number of 90 degree arcs to rotate by
                 * @since 1.6
                 */
                AffineTransform.prototype.quadrantRotate$int = function (numquadrants) {
                    switch ((numquadrants & 3)) {
                        case 0:
                            break;
                        case 1:
                            this.rotate90();
                            break;
                        case 2:
                            this.rotate180();
                            break;
                        case 3:
                            this.rotate270();
                            break;
                    }
                };
                /**
                 * Concatenates this transform with a transform that rotates
                 * coordinates by the specified number of quadrants around
                 * the specified anchor point.
                 * This method is equivalent to calling:
                 * <pre>
                 * rotate(numquadrants * Math.PI / 2.0, anchorx, anchory);
                 * </pre>
                 * Rotating by a positive number of quadrants rotates points on
                 * the positive X axis toward the positive Y axis.
                 *
                 * @param numquadrants the number of 90 degree arcs to rotate by
                 * @param anchorx the X coordinate of the rotation anchor point
                 * @param anchory the Y coordinate of the rotation anchor point
                 * @since 1.6
                 */
                AffineTransform.prototype.quadrantRotate = function (numquadrants, anchorx, anchory) {
                    var _this = this;
                    if (((typeof numquadrants === 'number') || numquadrants === null) && ((typeof anchorx === 'number') || anchorx === null) && ((typeof anchory === 'number') || anchory === null)) {
                        return (function () {
                            switch ((numquadrants & 3)) {
                                case 0:
                                    return;
                                case 1:
                                    _this.m02 += anchorx * (_this.m00 - _this.m01) + anchory * (_this.m01 + _this.m00);
                                    _this.m12 += anchorx * (_this.m10 - _this.m11) + anchory * (_this.m11 + _this.m10);
                                    _this.rotate90();
                                    break;
                                case 2:
                                    _this.m02 += anchorx * (_this.m00 + _this.m00) + anchory * (_this.m01 + _this.m01);
                                    _this.m12 += anchorx * (_this.m10 + _this.m10) + anchory * (_this.m11 + _this.m11);
                                    _this.rotate180();
                                    break;
                                case 3:
                                    _this.m02 += anchorx * (_this.m00 + _this.m01) + anchory * (_this.m01 - _this.m00);
                                    _this.m12 += anchorx * (_this.m10 + _this.m11) + anchory * (_this.m11 - _this.m10);
                                    _this.rotate270();
                                    break;
                            }
                            if (_this.m02 === 0.0 && _this.m12 === 0.0) {
                                _this.state &= ~AffineTransform.APPLY_TRANSLATE;
                            }
                            else {
                                _this.state |= AffineTransform.APPLY_TRANSLATE;
                            }
                        })();
                    }
                    else if (((typeof numquadrants === 'number') || numquadrants === null) && anchorx === undefined && anchory === undefined) {
                        return this.quadrantRotate$int(numquadrants);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Concatenates this transform with a scaling transformation.
                 * This is equivalent to calling concatenate(S), where S is an
                 * <code>AffineTransform</code> represented by the following matrix:
                 * <pre>
                 * [   sx   0    0   ]
                 * [   0    sy   0   ]
                 * [   0    0    1   ]
                 * </pre>
                 * @param sx the factor by which coordinates are scaled along the
                 * X axis direction
                 * @param sy the factor by which coordinates are scaled along the
                 * Y axis direction
                 * @since 1.2
                 */
                AffineTransform.prototype.scale = function (sx, sy) {
                    var state = this.state;
                    switch ((state)) {
                        default:
                            this.stateError();
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            this.m00 *= sx;
                            this.m11 *= sy;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SHEAR):
                            this.m01 *= sy;
                            this.m10 *= sx;
                            if (this.m01 === 0 && this.m10 === 0) {
                                state &= AffineTransform.APPLY_TRANSLATE;
                                if (this.m00 === 1.0 && this.m11 === 1.0) {
                                    this.type = (state === AffineTransform.APPLY_IDENTITY ? AffineTransform.TYPE_IDENTITY : AffineTransform.TYPE_TRANSLATION);
                                }
                                else {
                                    state |= AffineTransform.APPLY_SCALE;
                                    this.type = AffineTransform.TYPE_UNKNOWN;
                                }
                                this.state = state;
                            }
                            return;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SCALE):
                            this.m00 *= sx;
                            this.m11 *= sy;
                            if (this.m00 === 1.0 && this.m11 === 1.0) {
                                this.state = (state &= AffineTransform.APPLY_TRANSLATE);
                                this.type = (state === AffineTransform.APPLY_IDENTITY ? AffineTransform.TYPE_IDENTITY : AffineTransform.TYPE_TRANSLATION);
                            }
                            else {
                                this.type = AffineTransform.TYPE_UNKNOWN;
                            }
                            return;
                        case (AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_IDENTITY):
                            this.m00 = sx;
                            this.m11 = sy;
                            if (sx !== 1.0 || sy !== 1.0) {
                                this.state = state | AffineTransform.APPLY_SCALE;
                                this.type = AffineTransform.TYPE_UNKNOWN;
                            }
                            return;
                    }
                };
                /**
                 * Concatenates this transform with a shearing transformation.
                 * This is equivalent to calling concatenate(SH), where SH is an
                 * <code>AffineTransform</code> represented by the following matrix:
                 * <pre>
                 * [   1   shx   0   ]
                 * [  shy   1    0   ]
                 * [   0    0    1   ]
                 * </pre>
                 * @param shx the multiplier by which coordinates are shifted in the
                 * direction of the positive X axis as a factor of their Y coordinate
                 * @param shy the multiplier by which coordinates are shifted in the
                 * direction of the positive Y axis as a factor of their X coordinate
                 * @since 1.2
                 */
                AffineTransform.prototype.shear = function (shx, shy) {
                    var state = this.state;
                    switch ((state)) {
                        default:
                            this.stateError();
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            var M0;
                            var M1;
                            M0 = this.m00;
                            M1 = this.m01;
                            this.m00 = M0 + M1 * shy;
                            this.m01 = M0 * shx + M1;
                            M0 = this.m10;
                            M1 = this.m11;
                            this.m10 = M0 + M1 * shy;
                            this.m11 = M0 * shx + M1;
                            this.updateState();
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SHEAR):
                            this.m00 = this.m01 * shy;
                            this.m11 = this.m10 * shx;
                            if (this.m00 !== 0.0 || this.m11 !== 0.0) {
                                this.state = state | AffineTransform.APPLY_SCALE;
                            }
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SCALE):
                            this.m01 = this.m00 * shx;
                            this.m10 = this.m11 * shy;
                            if (this.m01 !== 0.0 || this.m10 !== 0.0) {
                                this.state = state | AffineTransform.APPLY_SHEAR;
                            }
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                        case (AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_IDENTITY):
                            this.m01 = shx;
                            this.m10 = shy;
                            if (this.m01 !== 0.0 || this.m10 !== 0.0) {
                                this.state = state | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_SHEAR;
                                this.type = AffineTransform.TYPE_UNKNOWN;
                            }
                            return;
                    }
                };
                /**
                 * Resets this transform to the Identity transform.
                 * @since 1.2
                 */
                AffineTransform.prototype.setToIdentity = function () {
                    this.m00 = this.m11 = 1.0;
                    this.m10 = this.m01 = this.m02 = this.m12 = 0.0;
                    this.state = AffineTransform.APPLY_IDENTITY;
                    this.type = AffineTransform.TYPE_IDENTITY;
                };
                /**
                 * Sets this transform to a translation transformation.
                 * The matrix representing this transform becomes:
                 * <pre>
                 * [   1    0    tx  ]
                 * [   0    1    ty  ]
                 * [   0    0    1   ]
                 * </pre>
                 * @param tx the distance by which coordinates are translated in the
                 * X axis direction
                 * @param ty the distance by which coordinates are translated in the
                 * Y axis direction
                 * @since 1.2
                 */
                AffineTransform.prototype.setToTranslation = function (tx, ty) {
                    this.m00 = 1.0;
                    this.m10 = 0.0;
                    this.m01 = 0.0;
                    this.m11 = 1.0;
                    this.m02 = tx;
                    this.m12 = ty;
                    if (tx !== 0.0 || ty !== 0.0) {
                        this.state = AffineTransform.APPLY_TRANSLATE;
                        this.type = AffineTransform.TYPE_TRANSLATION;
                    }
                    else {
                        this.state = AffineTransform.APPLY_IDENTITY;
                        this.type = AffineTransform.TYPE_IDENTITY;
                    }
                };
                /**
                 * Sets this transform to a rotation transformation.
                 * The matrix representing this transform becomes:
                 * <pre>
                 * [   cos(theta)    -sin(theta)    0   ]
                 * [   sin(theta)     cos(theta)    0   ]
                 * [       0              0         1   ]
                 * </pre>
                 * Rotating by a positive angle theta rotates points on the positive
                 * X axis toward the positive Y axis.
                 * Note also the discussion of
                 * <a href="#quadrantapproximation">Handling 90-Degree Rotations</a>
                 * above.
                 * @param theta the angle of rotation measured in radians
                 * @since 1.2
                 */
                AffineTransform.prototype.setToRotation$double = function (theta) {
                    var sin = Math.sin(theta);
                    var cos;
                    if (sin === 1.0 || sin === -1.0) {
                        cos = 0.0;
                        this.state = AffineTransform.APPLY_SHEAR;
                        this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                    }
                    else {
                        cos = Math.cos(theta);
                        if (cos === -1.0) {
                            sin = 0.0;
                            this.state = AffineTransform.APPLY_SCALE;
                            this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                        }
                        else if (cos === 1.0) {
                            sin = 0.0;
                            this.state = AffineTransform.APPLY_IDENTITY;
                            this.type = AffineTransform.TYPE_IDENTITY;
                        }
                        else {
                            this.state = AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE;
                            this.type = AffineTransform.TYPE_GENERAL_ROTATION;
                        }
                    }
                    this.m00 = cos;
                    this.m10 = sin;
                    this.m01 = -sin;
                    this.m11 = cos;
                    this.m02 = 0.0;
                    this.m12 = 0.0;
                };
                /**
                 * Sets this transform to a translated rotation transformation.
                 * This operation is equivalent to translating the coordinates so
                 * that the anchor point is at the origin (S1), then rotating them
                 * about the new origin (S2), and finally translating so that the
                 * intermediate origin is restored to the coordinates of the original
                 * anchor point (S3).
                 * <p>
                 * This operation is equivalent to the following sequence of calls:
                 * <pre>
                 * setToTranslation(anchorx, anchory); // S3: final translation
                 * rotate(theta);                      // S2: rotate around anchor
                 * translate(-anchorx, -anchory);      // S1: translate anchor to origin
                 * </pre>
                 * The matrix representing this transform becomes:
                 * <pre>
                 * [   cos(theta)    -sin(theta)    x-x*cos+y*sin  ]
                 * [   sin(theta)     cos(theta)    y-x*sin-y*cos  ]
                 * [       0              0               1        ]
                 * </pre>
                 * Rotating by a positive angle theta rotates points on the positive
                 * X axis toward the positive Y axis.
                 * Note also the discussion of
                 * <a href="#quadrantapproximation">Handling 90-Degree Rotations</a>
                 * above.
                 *
                 * @param theta the angle of rotation measured in radians
                 * @param anchorx the X coordinate of the rotation anchor point
                 * @param anchory the Y coordinate of the rotation anchor point
                 * @since 1.2
                 */
                AffineTransform.prototype.setToRotation$double$double$double = function (theta, anchorx, anchory) {
                    this.setToRotation(theta);
                    var sin = this.m10;
                    var oneMinusCos = 1.0 - this.m00;
                    this.m02 = anchorx * oneMinusCos + anchory * sin;
                    this.m12 = anchory * oneMinusCos - anchorx * sin;
                    if (this.m02 !== 0.0 || this.m12 !== 0.0) {
                        this.state |= AffineTransform.APPLY_TRANSLATE;
                        this.type |= AffineTransform.TYPE_TRANSLATION;
                    }
                };
                /**
                 * Sets this transform to a rotation transformation that rotates
                 * coordinates according to a rotation vector.
                 * All coordinates rotate about the origin by the same amount.
                 * The amount of rotation is such that coordinates along the former
                 * positive X axis will subsequently align with the vector pointing
                 * from the origin to the specified vector coordinates.
                 * If both <code>vecx</code> and <code>vecy</code> are 0.0,
                 * the transform is set to an identity transform.
                 * This operation is equivalent to calling:
                 * <pre>
                 * setToRotation(Math.atan2(vecy, vecx));
                 * </pre>
                 *
                 * @param vecx the X coordinate of the rotation vector
                 * @param vecy the Y coordinate of the rotation vector
                 * @since 1.6
                 */
                AffineTransform.prototype.setToRotation$double$double = function (vecx, vecy) {
                    var sin;
                    var cos;
                    if (vecy === 0) {
                        sin = 0.0;
                        if (vecx < 0.0) {
                            cos = -1.0;
                            this.state = AffineTransform.APPLY_SCALE;
                            this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                        }
                        else {
                            cos = 1.0;
                            this.state = AffineTransform.APPLY_IDENTITY;
                            this.type = AffineTransform.TYPE_IDENTITY;
                        }
                    }
                    else if (vecx === 0) {
                        cos = 0.0;
                        sin = (vecy > 0.0) ? 1.0 : -1.0;
                        this.state = AffineTransform.APPLY_SHEAR;
                        this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                    }
                    else {
                        var len = Math.sqrt(vecx * vecx + vecy * vecy);
                        cos = vecx / len;
                        sin = vecy / len;
                        this.state = AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE;
                        this.type = AffineTransform.TYPE_GENERAL_ROTATION;
                    }
                    this.m00 = cos;
                    this.m10 = sin;
                    this.m01 = -sin;
                    this.m11 = cos;
                    this.m02 = 0.0;
                    this.m12 = 0.0;
                };
                /**
                 * Sets this transform to a rotation transformation that rotates
                 * coordinates around an anchor point according to a rotation
                 * vector.
                 * All coordinates rotate about the specified anchor coordinates
                 * by the same amount.
                 * The amount of rotation is such that coordinates along the former
                 * positive X axis will subsequently align with the vector pointing
                 * from the origin to the specified vector coordinates.
                 * If both <code>vecx</code> and <code>vecy</code> are 0.0,
                 * the transform is set to an identity transform.
                 * This operation is equivalent to calling:
                 * <pre>
                 * setToTranslation(Math.atan2(vecy, vecx), anchorx, anchory);
                 * </pre>
                 *
                 * @param vecx the X coordinate of the rotation vector
                 * @param vecy the Y coordinate of the rotation vector
                 * @param anchorx the X coordinate of the rotation anchor point
                 * @param anchory the Y coordinate of the rotation anchor point
                 * @since 1.6
                 */
                AffineTransform.prototype.setToRotation = function (vecx, vecy, anchorx, anchory) {
                    var _this = this;
                    if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && ((typeof anchorx === 'number') || anchorx === null) && ((typeof anchory === 'number') || anchory === null)) {
                        return (function () {
                            _this.setToRotation(vecx, vecy);
                            var sin = _this.m10;
                            var oneMinusCos = 1.0 - _this.m00;
                            _this.m02 = anchorx * oneMinusCos + anchory * sin;
                            _this.m12 = anchory * oneMinusCos - anchorx * sin;
                            if (_this.m02 !== 0.0 || _this.m12 !== 0.0) {
                                _this.state |= AffineTransform.APPLY_TRANSLATE;
                                _this.type |= AffineTransform.TYPE_TRANSLATION;
                            }
                        })();
                    }
                    else if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && ((typeof anchorx === 'number') || anchorx === null) && anchory === undefined) {
                        return this.setToRotation$double$double$double(vecx, vecy, anchorx);
                    }
                    else if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && anchorx === undefined && anchory === undefined) {
                        return this.setToRotation$double$double(vecx, vecy);
                    }
                    else if (((typeof vecx === 'number') || vecx === null) && vecy === undefined && anchorx === undefined && anchory === undefined) {
                        return this.setToRotation$double(vecx);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets this transform to a rotation transformation that rotates
                 * coordinates by the specified number of quadrants.
                 * This operation is equivalent to calling:
                 * <pre>
                 * setToRotation(numquadrants * Math.PI / 2.0);
                 * </pre>
                 * Rotating by a positive number of quadrants rotates points on
                 * the positive X axis toward the positive Y axis.
                 * @param numquadrants the number of 90 degree arcs to rotate by
                 * @since 1.6
                 */
                AffineTransform.prototype.setToQuadrantRotation$int = function (numquadrants) {
                    switch ((numquadrants & 3)) {
                        case 0:
                            this.m00 = 1.0;
                            this.m10 = 0.0;
                            this.m01 = 0.0;
                            this.m11 = 1.0;
                            this.m02 = 0.0;
                            this.m12 = 0.0;
                            this.state = AffineTransform.APPLY_IDENTITY;
                            this.type = AffineTransform.TYPE_IDENTITY;
                            break;
                        case 1:
                            this.m00 = 0.0;
                            this.m10 = 1.0;
                            this.m01 = -1.0;
                            this.m11 = 0.0;
                            this.m02 = 0.0;
                            this.m12 = 0.0;
                            this.state = AffineTransform.APPLY_SHEAR;
                            this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                            break;
                        case 2:
                            this.m00 = -1.0;
                            this.m10 = 0.0;
                            this.m01 = 0.0;
                            this.m11 = -1.0;
                            this.m02 = 0.0;
                            this.m12 = 0.0;
                            this.state = AffineTransform.APPLY_SCALE;
                            this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                            break;
                        case 3:
                            this.m00 = 0.0;
                            this.m10 = -1.0;
                            this.m01 = 1.0;
                            this.m11 = 0.0;
                            this.m02 = 0.0;
                            this.m12 = 0.0;
                            this.state = AffineTransform.APPLY_SHEAR;
                            this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                            break;
                    }
                };
                /**
                 * Sets this transform to a translated rotation transformation
                 * that rotates coordinates by the specified number of quadrants
                 * around the specified anchor point.
                 * This operation is equivalent to calling:
                 * <pre>
                 * setToRotation(numquadrants * Math.PI / 2.0, anchorx, anchory);
                 * </pre>
                 * Rotating by a positive number of quadrants rotates points on
                 * the positive X axis toward the positive Y axis.
                 *
                 * @param numquadrants the number of 90 degree arcs to rotate by
                 * @param anchorx the X coordinate of the rotation anchor point
                 * @param anchory the Y coordinate of the rotation anchor point
                 * @since 1.6
                 */
                AffineTransform.prototype.setToQuadrantRotation = function (numquadrants, anchorx, anchory) {
                    var _this = this;
                    if (((typeof numquadrants === 'number') || numquadrants === null) && ((typeof anchorx === 'number') || anchorx === null) && ((typeof anchory === 'number') || anchory === null)) {
                        return (function () {
                            switch ((numquadrants & 3)) {
                                case 0:
                                    _this.m00 = 1.0;
                                    _this.m10 = 0.0;
                                    _this.m01 = 0.0;
                                    _this.m11 = 1.0;
                                    _this.m02 = 0.0;
                                    _this.m12 = 0.0;
                                    _this.state = AffineTransform.APPLY_IDENTITY;
                                    _this.type = AffineTransform.TYPE_IDENTITY;
                                    break;
                                case 1:
                                    _this.m00 = 0.0;
                                    _this.m10 = 1.0;
                                    _this.m01 = -1.0;
                                    _this.m11 = 0.0;
                                    _this.m02 = anchorx + anchory;
                                    _this.m12 = anchory - anchorx;
                                    if (_this.m02 === 0.0 && _this.m12 === 0.0) {
                                        _this.state = AffineTransform.APPLY_SHEAR;
                                        _this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                                    }
                                    else {
                                        _this.state = AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE;
                                        _this.type = AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_TRANSLATION;
                                    }
                                    break;
                                case 2:
                                    _this.m00 = -1.0;
                                    _this.m10 = 0.0;
                                    _this.m01 = 0.0;
                                    _this.m11 = -1.0;
                                    _this.m02 = anchorx + anchorx;
                                    _this.m12 = anchory + anchory;
                                    if (_this.m02 === 0.0 && _this.m12 === 0.0) {
                                        _this.state = AffineTransform.APPLY_SCALE;
                                        _this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                                    }
                                    else {
                                        _this.state = AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE;
                                        _this.type = AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_TRANSLATION;
                                    }
                                    break;
                                case 3:
                                    _this.m00 = 0.0;
                                    _this.m10 = -1.0;
                                    _this.m01 = 1.0;
                                    _this.m11 = 0.0;
                                    _this.m02 = anchorx - anchory;
                                    _this.m12 = anchory + anchorx;
                                    if (_this.m02 === 0.0 && _this.m12 === 0.0) {
                                        _this.state = AffineTransform.APPLY_SHEAR;
                                        _this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                                    }
                                    else {
                                        _this.state = AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE;
                                        _this.type = AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_TRANSLATION;
                                    }
                                    break;
                            }
                        })();
                    }
                    else if (((typeof numquadrants === 'number') || numquadrants === null) && anchorx === undefined && anchory === undefined) {
                        return this.setToQuadrantRotation$int(numquadrants);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets this transform to a scaling transformation.
                 * The matrix representing this transform becomes:
                 * <pre>
                 * [   sx   0    0   ]
                 * [   0    sy   0   ]
                 * [   0    0    1   ]
                 * </pre>
                 * @param sx the factor by which coordinates are scaled along the
                 * X axis direction
                 * @param sy the factor by which coordinates are scaled along the
                 * Y axis direction
                 * @since 1.2
                 */
                AffineTransform.prototype.setToScale = function (sx, sy) {
                    this.m00 = sx;
                    this.m10 = 0.0;
                    this.m01 = 0.0;
                    this.m11 = sy;
                    this.m02 = 0.0;
                    this.m12 = 0.0;
                    if (sx !== 1.0 || sy !== 1.0) {
                        this.state = AffineTransform.APPLY_SCALE;
                        this.type = AffineTransform.TYPE_UNKNOWN;
                    }
                    else {
                        this.state = AffineTransform.APPLY_IDENTITY;
                        this.type = AffineTransform.TYPE_IDENTITY;
                    }
                };
                /**
                 * Sets this transform to a shearing transformation.
                 * The matrix representing this transform becomes:
                 * <pre>
                 * [   1   shx   0   ]
                 * [  shy   1    0   ]
                 * [   0    0    1   ]
                 * </pre>
                 * @param shx the multiplier by which coordinates are shifted in the
                 * direction of the positive X axis as a factor of their Y coordinate
                 * @param shy the multiplier by which coordinates are shifted in the
                 * direction of the positive Y axis as a factor of their X coordinate
                 * @since 1.2
                 */
                AffineTransform.prototype.setToShear = function (shx, shy) {
                    this.m00 = 1.0;
                    this.m01 = shx;
                    this.m10 = shy;
                    this.m11 = 1.0;
                    this.m02 = 0.0;
                    this.m12 = 0.0;
                    if (shx !== 0.0 || shy !== 0.0) {
                        this.state = (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE);
                        this.type = AffineTransform.TYPE_UNKNOWN;
                    }
                    else {
                        this.state = AffineTransform.APPLY_IDENTITY;
                        this.type = AffineTransform.TYPE_IDENTITY;
                    }
                };
                /**
                 * Sets this transform to a copy of the transform in the specified
                 * <code>AffineTransform</code> object.
                 * @param Tx the <code>AffineTransform</code> object from which to
                 * copy the transform
                 * @since 1.2
                 */
                AffineTransform.prototype.setTransform$java_awt_geom_AffineTransform = function (Tx) {
                    this.m00 = Tx.m00;
                    this.m10 = Tx.m10;
                    this.m01 = Tx.m01;
                    this.m11 = Tx.m11;
                    this.m02 = Tx.m02;
                    this.m12 = Tx.m12;
                    this.state = Tx.state;
                    this.type = Tx.type;
                };
                /**
                 * Sets this transform to the matrix specified by the 6
                 * double precision values.
                 *
                 * @param m00 the X coordinate scaling element of the 3x3 matrix
                 * @param m10 the Y coordinate shearing element of the 3x3 matrix
                 * @param m01 the X coordinate shearing element of the 3x3 matrix
                 * @param m11 the Y coordinate scaling element of the 3x3 matrix
                 * @param m02 the X coordinate translation element of the 3x3 matrix
                 * @param m12 the Y coordinate translation element of the 3x3 matrix
                 * @since 1.2
                 */
                AffineTransform.prototype.setTransform = function (m00, m10, m01, m11, m02, m12) {
                    var _this = this;
                    if (((typeof m00 === 'number') || m00 === null) && ((typeof m10 === 'number') || m10 === null) && ((typeof m01 === 'number') || m01 === null) && ((typeof m11 === 'number') || m11 === null) && ((typeof m02 === 'number') || m02 === null) && ((typeof m12 === 'number') || m12 === null)) {
                        return (function () {
                            _this.m00 = m00;
                            _this.m10 = m10;
                            _this.m01 = m01;
                            _this.m11 = m11;
                            _this.m02 = m02;
                            _this.m12 = m12;
                            _this.updateState();
                        })();
                    }
                    else if (((m00 != null && m00 instanceof java.awt.geom.AffineTransform) || m00 === null) && m10 === undefined && m01 === undefined && m11 === undefined && m02 === undefined && m12 === undefined) {
                        return this.setTransform$java_awt_geom_AffineTransform(m00);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Concatenates an <code>AffineTransform</code> <code>Tx</code> to
                 * this <code>AffineTransform</code> Cx in the most commonly useful
                 * way to provide a new user space
                 * that is mapped to the former user space by <code>Tx</code>.
                 * Cx is updated to perform the combined transformation.
                 * Transforming a point p by the updated transform Cx' is
                 * equivalent to first transforming p by <code>Tx</code> and then
                 * transforming the result by the original transform Cx like this:
                 * Cx'(p) = Cx(Tx(p))
                 * In matrix notation, if this transform Cx is
                 * represented by the matrix [this] and <code>Tx</code> is represented
                 * by the matrix [Tx] then this method does the following:
                 * <pre>
                 * [this] = [this] x [Tx]
                 * </pre>
                 * @param Tx the <code>AffineTransform</code> object to be
                 * concatenated with this <code>AffineTransform</code> object.
                 * @see #preConcatenate
                 * @since 1.2
                 */
                AffineTransform.prototype.concatenate = function (Tx) {
                    var M0;
                    var M1;
                    var T00;
                    var T01;
                    var T10;
                    var T11;
                    var T02;
                    var T12;
                    var mystate = this.state;
                    var txstate = Tx.state;
                    switch (((txstate << AffineTransform.HI_SHIFT) | mystate)) {
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_IDENTITY):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SCALE):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SHEAR):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            return;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.HI_SCALE_$LI$() | AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_IDENTITY):
                            this.m01 = Tx.m01;
                            this.m10 = Tx.m10;
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_IDENTITY):
                            this.m00 = Tx.m00;
                            this.m11 = Tx.m11;
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_IDENTITY):
                            this.m02 = Tx.m02;
                            this.m12 = Tx.m12;
                            this.state = txstate;
                            this.type = Tx.type;
                            return;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_IDENTITY):
                            this.m01 = Tx.m01;
                            this.m10 = Tx.m10;
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_IDENTITY):
                            this.m00 = Tx.m00;
                            this.m11 = Tx.m11;
                            this.state = txstate;
                            this.type = Tx.type;
                            return;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_IDENTITY):
                            this.m02 = Tx.m02;
                            this.m12 = Tx.m12;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_IDENTITY):
                            this.m01 = Tx.m01;
                            this.m10 = Tx.m10;
                            this.m00 = this.m11 = 0.0;
                            this.state = txstate;
                            this.type = Tx.type;
                            return;
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SHEAR):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SCALE):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_TRANSLATE):
                            this.translate(Tx.m02, Tx.m12);
                            return;
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SHEAR):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SCALE):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_TRANSLATE):
                            this.scale(Tx.m00, Tx.m11);
                            return;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            T01 = Tx.m01;
                            T10 = Tx.m10;
                            M0 = this.m00;
                            this.m00 = this.m01 * T10;
                            this.m01 = M0 * T01;
                            M0 = this.m10;
                            this.m10 = this.m11 * T10;
                            this.m11 = M0 * T01;
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SHEAR):
                            this.m00 = this.m01 * Tx.m10;
                            this.m01 = 0.0;
                            this.m11 = this.m10 * Tx.m01;
                            this.m10 = 0.0;
                            this.state = mystate ^ (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE);
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SCALE):
                            this.m01 = this.m00 * Tx.m01;
                            this.m00 = 0.0;
                            this.m10 = this.m11 * Tx.m10;
                            this.m11 = 0.0;
                            this.state = mystate ^ (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE);
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_TRANSLATE):
                            this.m00 = 0.0;
                            this.m01 = Tx.m01;
                            this.m10 = Tx.m10;
                            this.m11 = 0.0;
                            this.state = AffineTransform.APPLY_TRANSLATE | AffineTransform.APPLY_SHEAR;
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                    }
                    T00 = Tx.m00;
                    T01 = Tx.m01;
                    T02 = Tx.m02;
                    T10 = Tx.m10;
                    T11 = Tx.m11;
                    T12 = Tx.m12;
                    switch ((mystate)) {
                        default:
                            this.stateError();
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            this.state = mystate | txstate;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M0 = this.m00;
                            M1 = this.m01;
                            this.m00 = T00 * M0 + T10 * M1;
                            this.m01 = T01 * M0 + T11 * M1;
                            this.m02 += T02 * M0 + T12 * M1;
                            M0 = this.m10;
                            M1 = this.m11;
                            this.m10 = T00 * M0 + T10 * M1;
                            this.m11 = T01 * M0 + T11 * M1;
                            this.m12 += T02 * M0 + T12 * M1;
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SHEAR):
                            M0 = this.m01;
                            this.m00 = T10 * M0;
                            this.m01 = T11 * M0;
                            this.m02 += T12 * M0;
                            M0 = this.m10;
                            this.m10 = T00 * M0;
                            this.m11 = T01 * M0;
                            this.m12 += T02 * M0;
                            break;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SCALE):
                            M0 = this.m00;
                            this.m00 = T00 * M0;
                            this.m01 = T01 * M0;
                            this.m02 += T02 * M0;
                            M0 = this.m11;
                            this.m10 = T10 * M0;
                            this.m11 = T11 * M0;
                            this.m12 += T12 * M0;
                            break;
                        case (AffineTransform.APPLY_TRANSLATE):
                            this.m00 = T00;
                            this.m01 = T01;
                            this.m02 += T02;
                            this.m10 = T10;
                            this.m11 = T11;
                            this.m12 += T12;
                            this.state = txstate | AffineTransform.APPLY_TRANSLATE;
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                    }
                    this.updateState();
                };
                /**
                 * Concatenates an <code>AffineTransform</code> <code>Tx</code> to
                 * this <code>AffineTransform</code> Cx
                 * in a less commonly used way such that <code>Tx</code> modifies the
                 * coordinate transformation relative to the absolute pixel
                 * space rather than relative to the existing user space.
                 * Cx is updated to perform the combined transformation.
                 * Transforming a point p by the updated transform Cx' is
                 * equivalent to first transforming p by the original transform
                 * Cx and then transforming the result by
                 * <code>Tx</code> like this:
                 * Cx'(p) = Tx(Cx(p))
                 * In matrix notation, if this transform Cx
                 * is represented by the matrix [this] and <code>Tx</code> is
                 * represented by the matrix [Tx] then this method does the
                 * following:
                 * <pre>
                 * [this] = [Tx] x [this]
                 * </pre>
                 * @param Tx the <code>AffineTransform</code> object to be
                 * concatenated with this <code>AffineTransform</code> object.
                 * @see #concatenate
                 * @since 1.2
                 */
                AffineTransform.prototype.preConcatenate = function (Tx) {
                    var M0;
                    var M1;
                    var T00;
                    var T01;
                    var T10;
                    var T11;
                    var T02;
                    var T12;
                    var mystate = this.state;
                    var txstate = Tx.state;
                    switch (((txstate << AffineTransform.HI_SHIFT) | mystate)) {
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_IDENTITY):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SCALE):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SHEAR):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            return;
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_IDENTITY):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SCALE):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SHEAR):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            this.m02 = Tx.m02;
                            this.m12 = Tx.m12;
                            this.state = mystate | AffineTransform.APPLY_TRANSLATE;
                            this.type |= AffineTransform.TYPE_TRANSLATION;
                            return;
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            this.m02 = this.m02 + Tx.m02;
                            this.m12 = this.m12 + Tx.m12;
                            return;
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_IDENTITY):
                            this.state = mystate | AffineTransform.APPLY_SCALE;
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SHEAR):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SCALE):
                            T00 = Tx.m00;
                            T11 = Tx.m11;
                            if ((mystate & AffineTransform.APPLY_SHEAR) !== 0) {
                                this.m01 = this.m01 * T00;
                                this.m10 = this.m10 * T11;
                                if ((mystate & AffineTransform.APPLY_SCALE) !== 0) {
                                    this.m00 = this.m00 * T00;
                                    this.m11 = this.m11 * T11;
                                }
                            }
                            else {
                                this.m00 = this.m00 * T00;
                                this.m11 = this.m11 * T11;
                            }
                            if ((mystate & AffineTransform.APPLY_TRANSLATE) !== 0) {
                                this.m02 = this.m02 * T00;
                                this.m12 = this.m12 * T11;
                            }
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SHEAR):
                            mystate = mystate | AffineTransform.APPLY_SCALE;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_IDENTITY):
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SCALE):
                            this.state = mystate ^ AffineTransform.APPLY_SHEAR;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            T01 = Tx.m01;
                            T10 = Tx.m10;
                            M0 = this.m00;
                            this.m00 = this.m10 * T01;
                            this.m10 = M0 * T10;
                            M0 = this.m01;
                            this.m01 = this.m11 * T01;
                            this.m11 = M0 * T10;
                            M0 = this.m02;
                            this.m02 = this.m12 * T01;
                            this.m12 = M0 * T10;
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                    }
                    T00 = Tx.m00;
                    T01 = Tx.m01;
                    T02 = Tx.m02;
                    T10 = Tx.m10;
                    T11 = Tx.m11;
                    T12 = Tx.m12;
                    switch ((mystate)) {
                        default:
                            this.stateError();
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M0 = this.m02;
                            M1 = this.m12;
                            T02 += M0 * T00 + M1 * T01;
                            T12 += M0 * T10 + M1 * T11;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            this.m02 = T02;
                            this.m12 = T12;
                            M0 = this.m00;
                            M1 = this.m10;
                            this.m00 = M0 * T00 + M1 * T01;
                            this.m10 = M0 * T10 + M1 * T11;
                            M0 = this.m01;
                            M1 = this.m11;
                            this.m01 = M0 * T00 + M1 * T01;
                            this.m11 = M0 * T10 + M1 * T11;
                            break;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            M0 = this.m02;
                            M1 = this.m12;
                            T02 += M0 * T00 + M1 * T01;
                            T12 += M0 * T10 + M1 * T11;
                        case (AffineTransform.APPLY_SHEAR):
                            this.m02 = T02;
                            this.m12 = T12;
                            M0 = this.m10;
                            this.m00 = M0 * T01;
                            this.m10 = M0 * T11;
                            M0 = this.m01;
                            this.m01 = M0 * T00;
                            this.m11 = M0 * T10;
                            break;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M0 = this.m02;
                            M1 = this.m12;
                            T02 += M0 * T00 + M1 * T01;
                            T12 += M0 * T10 + M1 * T11;
                        case (AffineTransform.APPLY_SCALE):
                            this.m02 = T02;
                            this.m12 = T12;
                            M0 = this.m00;
                            this.m00 = M0 * T00;
                            this.m10 = M0 * T10;
                            M0 = this.m11;
                            this.m01 = M0 * T01;
                            this.m11 = M0 * T11;
                            break;
                        case (AffineTransform.APPLY_TRANSLATE):
                            M0 = this.m02;
                            M1 = this.m12;
                            T02 += M0 * T00 + M1 * T01;
                            T12 += M0 * T10 + M1 * T11;
                        case (AffineTransform.APPLY_IDENTITY):
                            this.m02 = T02;
                            this.m12 = T12;
                            this.m00 = T00;
                            this.m10 = T10;
                            this.m01 = T01;
                            this.m11 = T11;
                            this.state = mystate | txstate;
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                    }
                    this.updateState();
                };
                /**
                 * Returns an <code>AffineTransform</code> object representing the
                 * inverse transformation.
                 * The inverse transform Tx' of this transform Tx
                 * maps coordinates transformed by Tx back
                 * to their original coordinates.
                 * In other words, Tx'(Tx(p)) = p = Tx(Tx'(p)).
                 * <p>
                 * If this transform maps all coordinates onto a point or a line
                 * then it will not have an inverse, since coordinates that do
                 * not lie on the destination point or line will not have an inverse
                 * mapping.
                 * The <code>getDeterminant</code> method can be used to determine if this
                 * transform has no inverse, in which case an exception will be
                 * thrown if the <code>createInverse</code> method is called.
                 * @return a new <code>AffineTransform</code> object representing the
                 * inverse transformation.
                 * @see #getDeterminant
                 * @exception NoninvertibleTransformException
                 * if the matrix cannot be inverted.
                 * @since 1.2
                 */
                AffineTransform.prototype.createInverse = function () {
                    var det;
                    switch ((this.state)) {
                        default:
                            this.stateError();
                            return null;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            det = this.m00 * this.m11 - this.m01 * this.m10;
                            if (Math.abs(det) <= javaemul.internal.DoubleHelper.MIN_VALUE) {
                                throw new java.awt.geom.NoninvertibleTransformException("Determinant is " + det);
                            }
                            return new AffineTransform(this.m11 / det, -this.m10 / det, -this.m01 / det, this.m00 / det, (this.m01 * this.m12 - this.m11 * this.m02) / det, (this.m10 * this.m02 - this.m00 * this.m12) / det, (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE));
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            det = this.m00 * this.m11 - this.m01 * this.m10;
                            if (Math.abs(det) <= javaemul.internal.DoubleHelper.MIN_VALUE) {
                                throw new java.awt.geom.NoninvertibleTransformException("Determinant is " + det);
                            }
                            return new AffineTransform(this.m11 / det, -this.m10 / det, -this.m01 / det, this.m00 / det, 0.0, 0.0, (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE));
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            if (this.m01 === 0.0 || this.m10 === 0.0) {
                                throw new java.awt.geom.NoninvertibleTransformException("Determinant is 0");
                            }
                            return new AffineTransform(0.0, 1.0 / this.m01, 1.0 / this.m10, 0.0, -this.m12 / this.m10, -this.m02 / this.m01, (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE));
                        case (AffineTransform.APPLY_SHEAR):
                            if (this.m01 === 0.0 || this.m10 === 0.0) {
                                throw new java.awt.geom.NoninvertibleTransformException("Determinant is 0");
                            }
                            return new AffineTransform(0.0, 1.0 / this.m01, 1.0 / this.m10, 0.0, 0.0, 0.0, (AffineTransform.APPLY_SHEAR));
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            if (this.m00 === 0.0 || this.m11 === 0.0) {
                                throw new java.awt.geom.NoninvertibleTransformException("Determinant is 0");
                            }
                            return new AffineTransform(1.0 / this.m00, 0.0, 0.0, 1.0 / this.m11, -this.m02 / this.m00, -this.m12 / this.m11, (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE));
                        case (AffineTransform.APPLY_SCALE):
                            if (this.m00 === 0.0 || this.m11 === 0.0) {
                                throw new java.awt.geom.NoninvertibleTransformException("Determinant is 0");
                            }
                            return new AffineTransform(1.0 / this.m00, 0.0, 0.0, 1.0 / this.m11, 0.0, 0.0, (AffineTransform.APPLY_SCALE));
                        case (AffineTransform.APPLY_TRANSLATE):
                            return new AffineTransform(1.0, 0.0, 0.0, 1.0, -this.m02, -this.m12, (AffineTransform.APPLY_TRANSLATE));
                        case (AffineTransform.APPLY_IDENTITY):
                            return new AffineTransform();
                    }
                };
                /**
                 * Sets this transform to the inverse of itself.
                 * The inverse transform Tx' of this transform Tx
                 * maps coordinates transformed by Tx back
                 * to their original coordinates.
                 * In other words, Tx'(Tx(p)) = p = Tx(Tx'(p)).
                 * <p>
                 * If this transform maps all coordinates onto a point or a line
                 * then it will not have an inverse, since coordinates that do
                 * not lie on the destination point or line will not have an inverse
                 * mapping.
                 * The <code>getDeterminant</code> method can be used to determine if this
                 * transform has no inverse, in which case an exception will be
                 * thrown if the <code>invert</code> method is called.
                 * @see #getDeterminant
                 * @exception NoninvertibleTransformException
                 * if the matrix cannot be inverted.
                 * @since 1.6
                 */
                AffineTransform.prototype.invert = function () {
                    var M00;
                    var M01;
                    var M02;
                    var M10;
                    var M11;
                    var M12;
                    var det;
                    switch ((this.state)) {
                        default:
                            this.stateError();
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M02 = this.m02;
                            M10 = this.m10;
                            M11 = this.m11;
                            M12 = this.m12;
                            det = M00 * M11 - M01 * M10;
                            if (Math.abs(det) <= javaemul.internal.DoubleHelper.MIN_VALUE) {
                                throw new java.awt.geom.NoninvertibleTransformException("Determinant is " + det);
                            }
                            this.m00 = M11 / det;
                            this.m10 = -M10 / det;
                            this.m01 = -M01 / det;
                            this.m11 = M00 / det;
                            this.m02 = (M01 * M12 - M11 * M02) / det;
                            this.m12 = (M10 * M02 - M00 * M12) / det;
                            break;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M10 = this.m10;
                            M11 = this.m11;
                            det = M00 * M11 - M01 * M10;
                            if (Math.abs(det) <= javaemul.internal.DoubleHelper.MIN_VALUE) {
                                throw new java.awt.geom.NoninvertibleTransformException("Determinant is " + det);
                            }
                            this.m00 = M11 / det;
                            this.m10 = -M10 / det;
                            this.m01 = -M01 / det;
                            this.m11 = M00 / det;
                            break;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            M01 = this.m01;
                            M02 = this.m02;
                            M10 = this.m10;
                            M12 = this.m12;
                            if (M01 === 0.0 || M10 === 0.0) {
                                throw new java.awt.geom.NoninvertibleTransformException("Determinant is 0");
                            }
                            this.m10 = 1.0 / M01;
                            this.m01 = 1.0 / M10;
                            this.m02 = -M12 / M10;
                            this.m12 = -M02 / M01;
                            break;
                        case (AffineTransform.APPLY_SHEAR):
                            M01 = this.m01;
                            M10 = this.m10;
                            if (M01 === 0.0 || M10 === 0.0) {
                                throw new java.awt.geom.NoninvertibleTransformException("Determinant is 0");
                            }
                            this.m10 = 1.0 / M01;
                            this.m01 = 1.0 / M10;
                            break;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M00 = this.m00;
                            M02 = this.m02;
                            M11 = this.m11;
                            M12 = this.m12;
                            if (M00 === 0.0 || M11 === 0.0) {
                                throw new java.awt.geom.NoninvertibleTransformException("Determinant is 0");
                            }
                            this.m00 = 1.0 / M00;
                            this.m11 = 1.0 / M11;
                            this.m02 = -M02 / M00;
                            this.m12 = -M12 / M11;
                            break;
                        case (AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M11 = this.m11;
                            if (M00 === 0.0 || M11 === 0.0) {
                                throw new java.awt.geom.NoninvertibleTransformException("Determinant is 0");
                            }
                            this.m00 = 1.0 / M00;
                            this.m11 = 1.0 / M11;
                            break;
                        case (AffineTransform.APPLY_TRANSLATE):
                            this.m02 = -this.m02;
                            this.m12 = -this.m12;
                            break;
                        case (AffineTransform.APPLY_IDENTITY):
                            break;
                    }
                };
                /**
                 * Transforms the specified <code>ptSrc</code> and stores the result
                 * in <code>ptDst</code>.
                 * If <code>ptDst</code> is <code>null</code>, a new {@link Point2D}
                 * object is allocated and then the result of the transformation is
                 * stored in this object.
                 * In either case, <code>ptDst</code>, which contains the
                 * transformed point, is returned for convenience.
                 * If <code>ptSrc</code> and <code>ptDst</code> are the same
                 * object, the input point is correctly overwritten with
                 * the transformed point.
                 * @param ptSrc the specified <code>Point2D</code> to be transformed
                 * @param ptDst the specified <code>Point2D</code> that stores the
                 * result of transforming <code>ptSrc</code>
                 * @return the <code>ptDst</code> after transforming
                 * <code>ptSrc</code> and storing the result in <code>ptDst</code>.
                 * @since 1.2
                 */
                AffineTransform.prototype.transform$java_awt_geom_Point2D$java_awt_geom_Point2D = function (ptSrc, ptDst) {
                    if (ptDst == null) {
                        if (ptSrc != null && ptSrc instanceof java.awt.geom.Point2D.Double) {
                            ptDst = new java.awt.geom.Point2D.Double();
                        }
                        else {
                            ptDst = new java.awt.geom.Point2D.Float();
                        }
                    }
                    var x = ptSrc.getX();
                    var y = ptSrc.getY();
                    switch ((this.state)) {
                        default:
                            this.stateError();
                            return null;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            ptDst.setLocation(x * this.m00 + y * this.m01 + this.m02, x * this.m10 + y * this.m11 + this.m12);
                            return ptDst;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            ptDst.setLocation(x * this.m00 + y * this.m01, x * this.m10 + y * this.m11);
                            return ptDst;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            ptDst.setLocation(y * this.m01 + this.m02, x * this.m10 + this.m12);
                            return ptDst;
                        case (AffineTransform.APPLY_SHEAR):
                            ptDst.setLocation(y * this.m01, x * this.m10);
                            return ptDst;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            ptDst.setLocation(x * this.m00 + this.m02, y * this.m11 + this.m12);
                            return ptDst;
                        case (AffineTransform.APPLY_SCALE):
                            ptDst.setLocation(x * this.m00, y * this.m11);
                            return ptDst;
                        case (AffineTransform.APPLY_TRANSLATE):
                            ptDst.setLocation(x + this.m02, y + this.m12);
                            return ptDst;
                        case (AffineTransform.APPLY_IDENTITY):
                            ptDst.setLocation(x, y);
                            return ptDst;
                    }
                };
                /**
                 * Transforms an array of point objects by this transform.
                 * If any element of the <code>ptDst</code> array is
                 * <code>null</code>, a new <code>Point2D</code> object is allocated
                 * and stored into that element before storing the results of the
                 * transformation.
                 * <p>
                 * Note that this method does not take any precautions to
                 * avoid problems caused by storing results into <code>Point2D</code>
                 * objects that will be used as the source for calculations
                 * further down the source array.
                 * This method does guarantee that if a specified <code>Point2D</code>
                 * object is both the source and destination for the same single point
                 * transform operation then the results will not be stored until
                 * the calculations are complete to avoid storing the results on
                 * top of the operands.
                 * If, however, the destination <code>Point2D</code> object for one
                 * operation is the same object as the source <code>Point2D</code>
                 * object for another operation further down the source array then
                 * the original coordinates in that point are overwritten before
                 * they can be converted.
                 * @param ptSrc the array containing the source point objects
                 * @param ptDst the array into which the transform point objects are
                 * returned
                 * @param srcOff the offset to the first point object to be
                 * transformed in the source array
                 * @param dstOff the offset to the location of the first
                 * transformed point object that is stored in the destination array
                 * @param numPts the number of point objects to be transformed
                 * @since 1.2
                 */
                AffineTransform.prototype.transform = function (ptSrc, srcOff, ptDst, dstOff, numPts) {
                    var _this = this;
                    if (((ptSrc != null && ptSrc instanceof Array) || ptSrc === null) && ((typeof srcOff === 'number') || srcOff === null) && ((ptDst != null && ptDst instanceof Array) || ptDst === null) && ((typeof dstOff === 'number') || dstOff === null) && ((typeof numPts === 'number') || numPts === null)) {
                        return (function () {
                            var state = _this.state;
                            while ((--numPts >= 0)) {
                                var src = ptSrc[srcOff++];
                                var x = src.getX();
                                var y = src.getY();
                                var dst = ptDst[dstOff++];
                                if (dst == null) {
                                    if (src != null && src instanceof java.awt.geom.Point2D.Double) {
                                        dst = new java.awt.geom.Point2D.Double();
                                    }
                                    else {
                                        dst = new java.awt.geom.Point2D.Float();
                                    }
                                    ptDst[dstOff - 1] = dst;
                                }
                                switch ((state)) {
                                    default:
                                        _this.stateError();
                                        return;
                                    case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                                        dst.setLocation(x * _this.m00 + y * _this.m01 + _this.m02, x * _this.m10 + y * _this.m11 + _this.m12);
                                        break;
                                    case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                                        dst.setLocation(x * _this.m00 + y * _this.m01, x * _this.m10 + y * _this.m11);
                                        break;
                                    case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                                        dst.setLocation(y * _this.m01 + _this.m02, x * _this.m10 + _this.m12);
                                        break;
                                    case (AffineTransform.APPLY_SHEAR):
                                        dst.setLocation(y * _this.m01, x * _this.m10);
                                        break;
                                    case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                                        dst.setLocation(x * _this.m00 + _this.m02, y * _this.m11 + _this.m12);
                                        break;
                                    case (AffineTransform.APPLY_SCALE):
                                        dst.setLocation(x * _this.m00, y * _this.m11);
                                        break;
                                    case (AffineTransform.APPLY_TRANSLATE):
                                        dst.setLocation(x + _this.m02, y + _this.m12);
                                        break;
                                    case (AffineTransform.APPLY_IDENTITY):
                                        dst.setLocation(x, y);
                                        break;
                                }
                            }
                            ;
                        })();
                    }
                    else if (((ptSrc != null && ptSrc instanceof Array) || ptSrc === null) && ((typeof srcOff === 'number') || srcOff === null) && ((ptDst != null && ptDst instanceof Array) || ptDst === null) && ((typeof dstOff === 'number') || dstOff === null) && ((typeof numPts === 'number') || numPts === null)) {
                        return this.transform$float_A$int$float_A$int$int(ptSrc, srcOff, ptDst, dstOff, numPts);
                    }
                    else if (((ptSrc != null && ptSrc instanceof Array) || ptSrc === null) && ((typeof srcOff === 'number') || srcOff === null) && ((ptDst != null && ptDst instanceof Array) || ptDst === null) && ((typeof dstOff === 'number') || dstOff === null) && ((typeof numPts === 'number') || numPts === null)) {
                        return this.transform$double_A$int$double_A$int$int(ptSrc, srcOff, ptDst, dstOff, numPts);
                    }
                    else if (((ptSrc != null && ptSrc instanceof Array) || ptSrc === null) && ((typeof srcOff === 'number') || srcOff === null) && ((ptDst != null && ptDst instanceof Array) || ptDst === null) && ((typeof dstOff === 'number') || dstOff === null) && ((typeof numPts === 'number') || numPts === null)) {
                        return this.transform$float_A$int$double_A$int$int(ptSrc, srcOff, ptDst, dstOff, numPts);
                    }
                    else if (((ptSrc != null && ptSrc instanceof Array) || ptSrc === null) && ((typeof srcOff === 'number') || srcOff === null) && ((ptDst != null && ptDst instanceof Array) || ptDst === null) && ((typeof dstOff === 'number') || dstOff === null) && ((typeof numPts === 'number') || numPts === null)) {
                        return this.transform$double_A$int$float_A$int$int(ptSrc, srcOff, ptDst, dstOff, numPts);
                    }
                    else if (((ptSrc != null && ptSrc instanceof java.awt.geom.Point2D) || ptSrc === null) && ((srcOff != null && srcOff instanceof java.awt.geom.Point2D) || srcOff === null) && ptDst === undefined && dstOff === undefined && numPts === undefined) {
                        return this.transform$java_awt_geom_Point2D$java_awt_geom_Point2D(ptSrc, srcOff);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Transforms an array of floating point coordinates by this transform.
                 * The two coordinate array sections can be exactly the same or
                 * can be overlapping sections of the same array without affecting the
                 * validity of the results.
                 * This method ensures that no source coordinates are overwritten by a
                 * previous operation before they can be transformed.
                 * The coordinates are stored in the arrays starting at the specified
                 * offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]</code>.
                 * @param srcPts the array containing the source point coordinates.
                 * Each point is stored as a pair of x,&nbsp;y coordinates.
                 * @param dstPts the array into which the transformed point coordinates
                 * are returned.  Each point is stored as a pair of x,&nbsp;y
                 * coordinates.
                 * @param srcOff the offset to the first point to be transformed
                 * in the source array
                 * @param dstOff the offset to the location of the first
                 * transformed point that is stored in the destination array
                 * @param numPts the number of points to be transformed
                 * @since 1.2
                 */
                AffineTransform.prototype.transform$float_A$int$float_A$int$int = function (srcPts, srcOff, dstPts, dstOff, numPts) {
                    var M00;
                    var M01;
                    var M02;
                    var M10;
                    var M11;
                    var M12;
                    if (dstPts === srcPts && dstOff > srcOff && dstOff < srcOff + numPts * 2) {
                        java.lang.System.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
                        srcOff = dstOff;
                    }
                    switch ((this.state)) {
                        default:
                            this.stateError();
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M02 = this.m02;
                            M10 = this.m10;
                            M11 = this.m11;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                var x = srcPts[srcOff++];
                                var y = srcPts[srcOff++];
                                dstPts[dstOff++] = (M00 * x + M01 * y + M02);
                                dstPts[dstOff++] = (M10 * x + M11 * y + M12);
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M10 = this.m10;
                            M11 = this.m11;
                            while ((--numPts >= 0)) {
                                var x = srcPts[srcOff++];
                                var y = srcPts[srcOff++];
                                dstPts[dstOff++] = (M00 * x + M01 * y);
                                dstPts[dstOff++] = (M10 * x + M11 * y);
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            M01 = this.m01;
                            M02 = this.m02;
                            M10 = this.m10;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                var x = srcPts[srcOff++];
                                dstPts[dstOff++] = (M01 * srcPts[srcOff++] + M02);
                                dstPts[dstOff++] = (M10 * x + M12);
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR):
                            M01 = this.m01;
                            M10 = this.m10;
                            while ((--numPts >= 0)) {
                                var x = srcPts[srcOff++];
                                dstPts[dstOff++] = (M01 * srcPts[srcOff++]);
                                dstPts[dstOff++] = (M10 * x);
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M00 = this.m00;
                            M02 = this.m02;
                            M11 = this.m11;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                dstPts[dstOff++] = (M00 * srcPts[srcOff++] + M02);
                                dstPts[dstOff++] = (M11 * srcPts[srcOff++] + M12);
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M11 = this.m11;
                            while ((--numPts >= 0)) {
                                dstPts[dstOff++] = (M00 * srcPts[srcOff++]);
                                dstPts[dstOff++] = (M11 * srcPts[srcOff++]);
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_TRANSLATE):
                            M02 = this.m02;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                dstPts[dstOff++] = (srcPts[srcOff++] + M02);
                                dstPts[dstOff++] = (srcPts[srcOff++] + M12);
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_IDENTITY):
                            if (srcPts !== dstPts || srcOff !== dstOff) {
                                java.lang.System.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
                            }
                            return;
                    }
                };
                /**
                 * Transforms an array of double precision coordinates by this transform.
                 * The two coordinate array sections can be exactly the same or
                 * can be overlapping sections of the same array without affecting the
                 * validity of the results.
                 * This method ensures that no source coordinates are
                 * overwritten by a previous operation before they can be transformed.
                 * The coordinates are stored in the arrays starting at the indicated
                 * offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]</code>.
                 * @param srcPts the array containing the source point coordinates.
                 * Each point is stored as a pair of x,&nbsp;y coordinates.
                 * @param dstPts the array into which the transformed point
                 * coordinates are returned.  Each point is stored as a pair of
                 * x,&nbsp;y coordinates.
                 * @param srcOff the offset to the first point to be transformed
                 * in the source array
                 * @param dstOff the offset to the location of the first
                 * transformed point that is stored in the destination array
                 * @param numPts the number of point objects to be transformed
                 * @since 1.2
                 */
                AffineTransform.prototype.transform$double_A$int$double_A$int$int = function (srcPts, srcOff, dstPts, dstOff, numPts) {
                    var M00;
                    var M01;
                    var M02;
                    var M10;
                    var M11;
                    var M12;
                    if (dstPts === srcPts && dstOff > srcOff && dstOff < srcOff + numPts * 2) {
                        java.lang.System.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
                        srcOff = dstOff;
                    }
                    switch ((this.state)) {
                        default:
                            this.stateError();
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M02 = this.m02;
                            M10 = this.m10;
                            M11 = this.m11;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                var x = srcPts[srcOff++];
                                var y = srcPts[srcOff++];
                                dstPts[dstOff++] = M00 * x + M01 * y + M02;
                                dstPts[dstOff++] = M10 * x + M11 * y + M12;
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M10 = this.m10;
                            M11 = this.m11;
                            while ((--numPts >= 0)) {
                                var x = srcPts[srcOff++];
                                var y = srcPts[srcOff++];
                                dstPts[dstOff++] = M00 * x + M01 * y;
                                dstPts[dstOff++] = M10 * x + M11 * y;
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            M01 = this.m01;
                            M02 = this.m02;
                            M10 = this.m10;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                var x = srcPts[srcOff++];
                                dstPts[dstOff++] = M01 * srcPts[srcOff++] + M02;
                                dstPts[dstOff++] = M10 * x + M12;
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR):
                            M01 = this.m01;
                            M10 = this.m10;
                            while ((--numPts >= 0)) {
                                var x = srcPts[srcOff++];
                                dstPts[dstOff++] = M01 * srcPts[srcOff++];
                                dstPts[dstOff++] = M10 * x;
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M00 = this.m00;
                            M02 = this.m02;
                            M11 = this.m11;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                dstPts[dstOff++] = M00 * srcPts[srcOff++] + M02;
                                dstPts[dstOff++] = M11 * srcPts[srcOff++] + M12;
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M11 = this.m11;
                            while ((--numPts >= 0)) {
                                dstPts[dstOff++] = M00 * srcPts[srcOff++];
                                dstPts[dstOff++] = M11 * srcPts[srcOff++];
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_TRANSLATE):
                            M02 = this.m02;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                dstPts[dstOff++] = srcPts[srcOff++] + M02;
                                dstPts[dstOff++] = srcPts[srcOff++] + M12;
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_IDENTITY):
                            if (srcPts !== dstPts || srcOff !== dstOff) {
                                java.lang.System.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
                            }
                            return;
                    }
                };
                /**
                 * Transforms an array of floating point coordinates by this transform
                 * and stores the results into an array of doubles.
                 * The coordinates are stored in the arrays starting at the specified
                 * offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]</code>.
                 * @param srcPts the array containing the source point coordinates.
                 * Each point is stored as a pair of x,&nbsp;y coordinates.
                 * @param dstPts the array into which the transformed point coordinates
                 * are returned.  Each point is stored as a pair of x,&nbsp;y
                 * coordinates.
                 * @param srcOff the offset to the first point to be transformed
                 * in the source array
                 * @param dstOff the offset to the location of the first
                 * transformed point that is stored in the destination array
                 * @param numPts the number of points to be transformed
                 * @since 1.2
                 */
                AffineTransform.prototype.transform$float_A$int$double_A$int$int = function (srcPts, srcOff, dstPts, dstOff, numPts) {
                    var M00;
                    var M01;
                    var M02;
                    var M10;
                    var M11;
                    var M12;
                    switch ((this.state)) {
                        default:
                            this.stateError();
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M02 = this.m02;
                            M10 = this.m10;
                            M11 = this.m11;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                var x = srcPts[srcOff++];
                                var y = srcPts[srcOff++];
                                dstPts[dstOff++] = M00 * x + M01 * y + M02;
                                dstPts[dstOff++] = M10 * x + M11 * y + M12;
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M10 = this.m10;
                            M11 = this.m11;
                            while ((--numPts >= 0)) {
                                var x = srcPts[srcOff++];
                                var y = srcPts[srcOff++];
                                dstPts[dstOff++] = M00 * x + M01 * y;
                                dstPts[dstOff++] = M10 * x + M11 * y;
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            M01 = this.m01;
                            M02 = this.m02;
                            M10 = this.m10;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                var x = srcPts[srcOff++];
                                dstPts[dstOff++] = M01 * srcPts[srcOff++] + M02;
                                dstPts[dstOff++] = M10 * x + M12;
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR):
                            M01 = this.m01;
                            M10 = this.m10;
                            while ((--numPts >= 0)) {
                                var x = srcPts[srcOff++];
                                dstPts[dstOff++] = M01 * srcPts[srcOff++];
                                dstPts[dstOff++] = M10 * x;
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M00 = this.m00;
                            M02 = this.m02;
                            M11 = this.m11;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                dstPts[dstOff++] = M00 * srcPts[srcOff++] + M02;
                                dstPts[dstOff++] = M11 * srcPts[srcOff++] + M12;
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M11 = this.m11;
                            while ((--numPts >= 0)) {
                                dstPts[dstOff++] = M00 * srcPts[srcOff++];
                                dstPts[dstOff++] = M11 * srcPts[srcOff++];
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_TRANSLATE):
                            M02 = this.m02;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                dstPts[dstOff++] = srcPts[srcOff++] + M02;
                                dstPts[dstOff++] = srcPts[srcOff++] + M12;
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_IDENTITY):
                            while ((--numPts >= 0)) {
                                dstPts[dstOff++] = srcPts[srcOff++];
                                dstPts[dstOff++] = srcPts[srcOff++];
                            }
                            ;
                            return;
                    }
                };
                /**
                 * Transforms an array of double precision coordinates by this transform
                 * and stores the results into an array of floats.
                 * The coordinates are stored in the arrays starting at the specified
                 * offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]</code>.
                 * @param srcPts the array containing the source point coordinates.
                 * Each point is stored as a pair of x,&nbsp;y coordinates.
                 * @param dstPts the array into which the transformed point
                 * coordinates are returned.  Each point is stored as a pair of
                 * x,&nbsp;y coordinates.
                 * @param srcOff the offset to the first point to be transformed
                 * in the source array
                 * @param dstOff the offset to the location of the first
                 * transformed point that is stored in the destination array
                 * @param numPts the number of point objects to be transformed
                 * @since 1.2
                 */
                AffineTransform.prototype.transform$double_A$int$float_A$int$int = function (srcPts, srcOff, dstPts, dstOff, numPts) {
                    var M00;
                    var M01;
                    var M02;
                    var M10;
                    var M11;
                    var M12;
                    switch ((this.state)) {
                        default:
                            this.stateError();
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M02 = this.m02;
                            M10 = this.m10;
                            M11 = this.m11;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                var x = srcPts[srcOff++];
                                var y = srcPts[srcOff++];
                                dstPts[dstOff++] = (M00 * x + M01 * y + M02);
                                dstPts[dstOff++] = (M10 * x + M11 * y + M12);
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M10 = this.m10;
                            M11 = this.m11;
                            while ((--numPts >= 0)) {
                                var x = srcPts[srcOff++];
                                var y = srcPts[srcOff++];
                                dstPts[dstOff++] = (M00 * x + M01 * y);
                                dstPts[dstOff++] = (M10 * x + M11 * y);
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            M01 = this.m01;
                            M02 = this.m02;
                            M10 = this.m10;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                var x = srcPts[srcOff++];
                                dstPts[dstOff++] = (M01 * srcPts[srcOff++] + M02);
                                dstPts[dstOff++] = (M10 * x + M12);
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR):
                            M01 = this.m01;
                            M10 = this.m10;
                            while ((--numPts >= 0)) {
                                var x = srcPts[srcOff++];
                                dstPts[dstOff++] = (M01 * srcPts[srcOff++]);
                                dstPts[dstOff++] = (M10 * x);
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M00 = this.m00;
                            M02 = this.m02;
                            M11 = this.m11;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                dstPts[dstOff++] = (M00 * srcPts[srcOff++] + M02);
                                dstPts[dstOff++] = (M11 * srcPts[srcOff++] + M12);
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M11 = this.m11;
                            while ((--numPts >= 0)) {
                                dstPts[dstOff++] = (M00 * srcPts[srcOff++]);
                                dstPts[dstOff++] = (M11 * srcPts[srcOff++]);
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_TRANSLATE):
                            M02 = this.m02;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                dstPts[dstOff++] = (srcPts[srcOff++] + M02);
                                dstPts[dstOff++] = (srcPts[srcOff++] + M12);
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_IDENTITY):
                            while ((--numPts >= 0)) {
                                dstPts[dstOff++] = (srcPts[srcOff++]);
                                dstPts[dstOff++] = (srcPts[srcOff++]);
                            }
                            ;
                            return;
                    }
                };
                /**
                 * Inverse transforms the specified <code>ptSrc</code> and stores the
                 * result in <code>ptDst</code>.
                 * If <code>ptDst</code> is <code>null</code>, a new
                 * <code>Point2D</code> object is allocated and then the result of the
                 * transform is stored in this object.
                 * In either case, <code>ptDst</code>, which contains the transformed
                 * point, is returned for convenience.
                 * If <code>ptSrc</code> and <code>ptDst</code> are the same
                 * object, the input point is correctly overwritten with the
                 * transformed point.
                 * @param ptSrc the point to be inverse transformed
                 * @param ptDst the resulting transformed point
                 * @return <code>ptDst</code>, which contains the result of the
                 * inverse transform.
                 * @exception NoninvertibleTransformException  if the matrix cannot be
                 * inverted.
                 * @since 1.2
                 */
                AffineTransform.prototype.inverseTransform$java_awt_geom_Point2D$java_awt_geom_Point2D = function (ptSrc, ptDst) {
                    if (ptDst == null) {
                        if (ptSrc != null && ptSrc instanceof java.awt.geom.Point2D.Double) {
                            ptDst = new java.awt.geom.Point2D.Double();
                        }
                        else {
                            ptDst = new java.awt.geom.Point2D.Float();
                        }
                    }
                    var x = ptSrc.getX();
                    var y = ptSrc.getY();
                    switch ((this.state)) {
                        default:
                            this.stateError();
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            x -= this.m02;
                            y -= this.m12;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            var det = this.m00 * this.m11 - this.m01 * this.m10;
                            if (Math.abs(det) <= javaemul.internal.DoubleHelper.MIN_VALUE) {
                                throw new java.awt.geom.NoninvertibleTransformException("Determinant is " + det);
                            }
                            ptDst.setLocation((x * this.m11 - y * this.m01) / det, (y * this.m00 - x * this.m10) / det);
                            return ptDst;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            x -= this.m02;
                            y -= this.m12;
                        case (AffineTransform.APPLY_SHEAR):
                            if (this.m01 === 0.0 || this.m10 === 0.0) {
                                throw new java.awt.geom.NoninvertibleTransformException("Determinant is 0");
                            }
                            ptDst.setLocation(y / this.m10, x / this.m01);
                            return ptDst;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            x -= this.m02;
                            y -= this.m12;
                        case (AffineTransform.APPLY_SCALE):
                            if (this.m00 === 0.0 || this.m11 === 0.0) {
                                throw new java.awt.geom.NoninvertibleTransformException("Determinant is 0");
                            }
                            ptDst.setLocation(x / this.m00, y / this.m11);
                            return ptDst;
                        case (AffineTransform.APPLY_TRANSLATE):
                            ptDst.setLocation(x - this.m02, y - this.m12);
                            return ptDst;
                        case (AffineTransform.APPLY_IDENTITY):
                            ptDst.setLocation(x, y);
                            return ptDst;
                    }
                };
                /**
                 * Inverse transforms an array of double precision coordinates by
                 * this transform.
                 * The two coordinate array sections can be exactly the same or
                 * can be overlapping sections of the same array without affecting the
                 * validity of the results.
                 * This method ensures that no source coordinates are
                 * overwritten by a previous operation before they can be transformed.
                 * The coordinates are stored in the arrays starting at the specified
                 * offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]</code>.
                 * @param srcPts the array containing the source point coordinates.
                 * Each point is stored as a pair of x,&nbsp;y coordinates.
                 * @param dstPts the array into which the transformed point
                 * coordinates are returned.  Each point is stored as a pair of
                 * x,&nbsp;y coordinates.
                 * @param srcOff the offset to the first point to be transformed
                 * in the source array
                 * @param dstOff the offset to the location of the first
                 * transformed point that is stored in the destination array
                 * @param numPts the number of point objects to be transformed
                 * @exception NoninvertibleTransformException  if the matrix cannot be
                 * inverted.
                 * @since 1.2
                 */
                AffineTransform.prototype.inverseTransform = function (srcPts, srcOff, dstPts, dstOff, numPts) {
                    var _this = this;
                    if (((srcPts != null && srcPts instanceof Array) || srcPts === null) && ((typeof srcOff === 'number') || srcOff === null) && ((dstPts != null && dstPts instanceof Array) || dstPts === null) && ((typeof dstOff === 'number') || dstOff === null) && ((typeof numPts === 'number') || numPts === null)) {
                        return (function () {
                            var M00;
                            var M01;
                            var M02;
                            var M10;
                            var M11;
                            var M12;
                            var det;
                            if (dstPts === srcPts && dstOff > srcOff && dstOff < srcOff + numPts * 2) {
                                java.lang.System.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
                                srcOff = dstOff;
                            }
                            switch ((_this.state)) {
                                default:
                                    _this.stateError();
                                    return;
                                case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                                    M00 = _this.m00;
                                    M01 = _this.m01;
                                    M02 = _this.m02;
                                    M10 = _this.m10;
                                    M11 = _this.m11;
                                    M12 = _this.m12;
                                    det = M00 * M11 - M01 * M10;
                                    if (Math.abs(det) <= javaemul.internal.DoubleHelper.MIN_VALUE) {
                                        throw new java.awt.geom.NoninvertibleTransformException("Determinant is " + det);
                                    }
                                    while ((--numPts >= 0)) {
                                        var x = srcPts[srcOff++] - M02;
                                        var y = srcPts[srcOff++] - M12;
                                        dstPts[dstOff++] = (x * M11 - y * M01) / det;
                                        dstPts[dstOff++] = (y * M00 - x * M10) / det;
                                    }
                                    ;
                                    return;
                                case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                                    M00 = _this.m00;
                                    M01 = _this.m01;
                                    M10 = _this.m10;
                                    M11 = _this.m11;
                                    det = M00 * M11 - M01 * M10;
                                    if (Math.abs(det) <= javaemul.internal.DoubleHelper.MIN_VALUE) {
                                        throw new java.awt.geom.NoninvertibleTransformException("Determinant is " + det);
                                    }
                                    while ((--numPts >= 0)) {
                                        var x = srcPts[srcOff++];
                                        var y = srcPts[srcOff++];
                                        dstPts[dstOff++] = (x * M11 - y * M01) / det;
                                        dstPts[dstOff++] = (y * M00 - x * M10) / det;
                                    }
                                    ;
                                    return;
                                case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                                    M01 = _this.m01;
                                    M02 = _this.m02;
                                    M10 = _this.m10;
                                    M12 = _this.m12;
                                    if (M01 === 0.0 || M10 === 0.0) {
                                        throw new java.awt.geom.NoninvertibleTransformException("Determinant is 0");
                                    }
                                    while ((--numPts >= 0)) {
                                        var x = srcPts[srcOff++] - M02;
                                        dstPts[dstOff++] = (srcPts[srcOff++] - M12) / M10;
                                        dstPts[dstOff++] = x / M01;
                                    }
                                    ;
                                    return;
                                case (AffineTransform.APPLY_SHEAR):
                                    M01 = _this.m01;
                                    M10 = _this.m10;
                                    if (M01 === 0.0 || M10 === 0.0) {
                                        throw new java.awt.geom.NoninvertibleTransformException("Determinant is 0");
                                    }
                                    while ((--numPts >= 0)) {
                                        var x = srcPts[srcOff++];
                                        dstPts[dstOff++] = srcPts[srcOff++] / M10;
                                        dstPts[dstOff++] = x / M01;
                                    }
                                    ;
                                    return;
                                case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                                    M00 = _this.m00;
                                    M02 = _this.m02;
                                    M11 = _this.m11;
                                    M12 = _this.m12;
                                    if (M00 === 0.0 || M11 === 0.0) {
                                        throw new java.awt.geom.NoninvertibleTransformException("Determinant is 0");
                                    }
                                    while ((--numPts >= 0)) {
                                        dstPts[dstOff++] = (srcPts[srcOff++] - M02) / M00;
                                        dstPts[dstOff++] = (srcPts[srcOff++] - M12) / M11;
                                    }
                                    ;
                                    return;
                                case (AffineTransform.APPLY_SCALE):
                                    M00 = _this.m00;
                                    M11 = _this.m11;
                                    if (M00 === 0.0 || M11 === 0.0) {
                                        throw new java.awt.geom.NoninvertibleTransformException("Determinant is 0");
                                    }
                                    while ((--numPts >= 0)) {
                                        dstPts[dstOff++] = srcPts[srcOff++] / M00;
                                        dstPts[dstOff++] = srcPts[srcOff++] / M11;
                                    }
                                    ;
                                    return;
                                case (AffineTransform.APPLY_TRANSLATE):
                                    M02 = _this.m02;
                                    M12 = _this.m12;
                                    while ((--numPts >= 0)) {
                                        dstPts[dstOff++] = srcPts[srcOff++] - M02;
                                        dstPts[dstOff++] = srcPts[srcOff++] - M12;
                                    }
                                    ;
                                    return;
                                case (AffineTransform.APPLY_IDENTITY):
                                    if (srcPts !== dstPts || srcOff !== dstOff) {
                                        java.lang.System.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
                                    }
                                    return;
                            }
                        })();
                    }
                    else if (((srcPts != null && srcPts instanceof java.awt.geom.Point2D) || srcPts === null) && ((srcOff != null && srcOff instanceof java.awt.geom.Point2D) || srcOff === null) && dstPts === undefined && dstOff === undefined && numPts === undefined) {
                        return this.inverseTransform$java_awt_geom_Point2D$java_awt_geom_Point2D(srcPts, srcOff);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Transforms the relative distance vector specified by
                 * <code>ptSrc</code> and stores the result in <code>ptDst</code>.
                 * A relative distance vector is transformed without applying the
                 * translation components of the affine transformation matrix
                 * using the following equations:
                 * <pre>
                 * [  x' ]   [  m00  m01 (m02) ] [  x  ]   [ m00x + m01y ]
                 * [  y' ] = [  m10  m11 (m12) ] [  y  ] = [ m10x + m11y ]
                 * [ (1) ]   [  (0)  (0) ( 1 ) ] [ (1) ]   [     (1)     ]
                 * </pre>
                 * If <code>ptDst</code> is <code>null</code>, a new
                 * <code>Point2D</code> object is allocated and then the result of the
                 * transform is stored in this object.
                 * In either case, <code>ptDst</code>, which contains the
                 * transformed point, is returned for convenience.
                 * If <code>ptSrc</code> and <code>ptDst</code> are the same object,
                 * the input point is correctly overwritten with the transformed
                 * point.
                 * @param ptSrc the distance vector to be delta transformed
                 * @param ptDst the resulting transformed distance vector
                 * @return <code>ptDst</code>, which contains the result of the
                 * transformation.
                 * @since 1.2
                 */
                AffineTransform.prototype.deltaTransform$java_awt_geom_Point2D$java_awt_geom_Point2D = function (ptSrc, ptDst) {
                    if (ptDst == null) {
                        if (ptSrc != null && ptSrc instanceof java.awt.geom.Point2D.Double) {
                            ptDst = new java.awt.geom.Point2D.Double();
                        }
                        else {
                            ptDst = new java.awt.geom.Point2D.Float();
                        }
                    }
                    var x = ptSrc.getX();
                    var y = ptSrc.getY();
                    switch ((this.state)) {
                        default:
                            this.stateError();
                            return null;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            ptDst.setLocation(x * this.m00 + y * this.m01, x * this.m10 + y * this.m11);
                            return ptDst;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SHEAR):
                            ptDst.setLocation(y * this.m01, x * this.m10);
                            return ptDst;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SCALE):
                            ptDst.setLocation(x * this.m00, y * this.m11);
                            return ptDst;
                        case (AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_IDENTITY):
                            ptDst.setLocation(x, y);
                            return ptDst;
                    }
                };
                /**
                 * Transforms an array of relative distance vectors by this
                 * transform.
                 * A relative distance vector is transformed without applying the
                 * translation components of the affine transformation matrix
                 * using the following equations:
                 * <pre>
                 * [  x' ]   [  m00  m01 (m02) ] [  x  ]   [ m00x + m01y ]
                 * [  y' ] = [  m10  m11 (m12) ] [  y  ] = [ m10x + m11y ]
                 * [ (1) ]   [  (0)  (0) ( 1 ) ] [ (1) ]   [     (1)     ]
                 * </pre>
                 * The two coordinate array sections can be exactly the same or
                 * can be overlapping sections of the same array without affecting the
                 * validity of the results.
                 * This method ensures that no source coordinates are
                 * overwritten by a previous operation before they can be transformed.
                 * The coordinates are stored in the arrays starting at the indicated
                 * offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]</code>.
                 * @param srcPts the array containing the source distance vectors.
                 * Each vector is stored as a pair of relative x,&nbsp;y coordinates.
                 * @param dstPts the array into which the transformed distance vectors
                 * are returned.  Each vector is stored as a pair of relative
                 * x,&nbsp;y coordinates.
                 * @param srcOff the offset to the first vector to be transformed
                 * in the source array
                 * @param dstOff the offset to the location of the first
                 * transformed vector that is stored in the destination array
                 * @param numPts the number of vector coordinate pairs to be
                 * transformed
                 * @since 1.2
                 */
                AffineTransform.prototype.deltaTransform = function (srcPts, srcOff, dstPts, dstOff, numPts) {
                    var _this = this;
                    if (((srcPts != null && srcPts instanceof Array) || srcPts === null) && ((typeof srcOff === 'number') || srcOff === null) && ((dstPts != null && dstPts instanceof Array) || dstPts === null) && ((typeof dstOff === 'number') || dstOff === null) && ((typeof numPts === 'number') || numPts === null)) {
                        return (function () {
                            var M00;
                            var M01;
                            var M10;
                            var M11;
                            if (dstPts === srcPts && dstOff > srcOff && dstOff < srcOff + numPts * 2) {
                                java.lang.System.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
                                srcOff = dstOff;
                            }
                            switch ((_this.state)) {
                                default:
                                    _this.stateError();
                                    return;
                                case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                                case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                                    M00 = _this.m00;
                                    M01 = _this.m01;
                                    M10 = _this.m10;
                                    M11 = _this.m11;
                                    while ((--numPts >= 0)) {
                                        var x = srcPts[srcOff++];
                                        var y = srcPts[srcOff++];
                                        dstPts[dstOff++] = x * M00 + y * M01;
                                        dstPts[dstOff++] = x * M10 + y * M11;
                                    }
                                    ;
                                    return;
                                case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                                case (AffineTransform.APPLY_SHEAR):
                                    M01 = _this.m01;
                                    M10 = _this.m10;
                                    while ((--numPts >= 0)) {
                                        var x = srcPts[srcOff++];
                                        dstPts[dstOff++] = srcPts[srcOff++] * M01;
                                        dstPts[dstOff++] = x * M10;
                                    }
                                    ;
                                    return;
                                case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                                case (AffineTransform.APPLY_SCALE):
                                    M00 = _this.m00;
                                    M11 = _this.m11;
                                    while ((--numPts >= 0)) {
                                        dstPts[dstOff++] = srcPts[srcOff++] * M00;
                                        dstPts[dstOff++] = srcPts[srcOff++] * M11;
                                    }
                                    ;
                                    return;
                                case (AffineTransform.APPLY_TRANSLATE):
                                case (AffineTransform.APPLY_IDENTITY):
                                    if (srcPts !== dstPts || srcOff !== dstOff) {
                                        java.lang.System.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
                                    }
                                    return;
                            }
                        })();
                    }
                    else if (((srcPts != null && srcPts instanceof java.awt.geom.Point2D) || srcPts === null) && ((srcOff != null && srcOff instanceof java.awt.geom.Point2D) || srcOff === null) && dstPts === undefined && dstOff === undefined && numPts === undefined) {
                        return this.deltaTransform$java_awt_geom_Point2D$java_awt_geom_Point2D(srcPts, srcOff);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns a new {@link Shape} object defined by the geometry of the
                 * specified <code>Shape</code> after it has been transformed by
                 * this transform.
                 * @param pSrc the specified <code>Shape</code> object to be
                 * transformed by this transform.
                 * @return a new <code>Shape</code> object that defines the geometry
                 * of the transformed <code>Shape</code>, or null if {@code pSrc} is null.
                 * @since 1.2
                 */
                AffineTransform.prototype.createTransformedShape = function (pSrc) {
                    if (pSrc == null) {
                        return null;
                    }
                    return new java.awt.geom.Path2D.Double(pSrc, this);
                };
                AffineTransform._matround = function (matval) {
                    return (function (d) { if (d === Number.NaN) {
                        return d;
                    }
                    else if (Number.POSITIVE_INFINITY === d || Number.NEGATIVE_INFINITY === d) {
                        return d;
                    }
                    else if (d == 0) {
                        return d;
                    }
                    else {
                        return Math.round(d);
                    } })(matval * 1.0E15) / 1.0E15;
                };
                /**
                 * Returns a <code>String</code> that represents the value of this
                 * {@link Object}.
                 * @return a <code>String</code> representing the value of this
                 * <code>Object</code>.
                 * @since 1.2
                 */
                AffineTransform.prototype.toString = function () {
                    return ("AffineTransform[[" + AffineTransform._matround(this.m00) + ", " + AffineTransform._matround(this.m01) + ", " + AffineTransform._matround(this.m02) + "], [" + AffineTransform._matround(this.m10) + ", " + AffineTransform._matround(this.m11) + ", " + AffineTransform._matround(this.m12) + "]]");
                };
                /**
                 * Returns <code>true</code> if this <code>AffineTransform</code> is
                 * an identity transform.
                 * @return <code>true</code> if this <code>AffineTransform</code> is
                 * an identity transform; <code>false</code> otherwise.
                 * @since 1.2
                 */
                AffineTransform.prototype.isIdentity = function () {
                    return (this.state === AffineTransform.APPLY_IDENTITY || (this.getType() === AffineTransform.TYPE_IDENTITY));
                };
                /**
                 * Returns a copy of this <code>AffineTransform</code> object.
                 * @return an <code>Object</code> that is a copy of this
                 * <code>AffineTransform</code> object.
                 * @since 1.2
                 */
                AffineTransform.prototype.clone = function () {
                    try {
                        return javaemul.internal.ObjectHelper.clone(this);
                    }
                    catch (e) {
                        throw new java.lang.InternalError(e);
                    }
                    ;
                };
                /**
                 * Returns the hashcode for this transform.
                 * @return      a hash code for this transform.
                 * @since 1.2
                 */
                AffineTransform.prototype.hashCode = function () {
                    var bits = javaemul.internal.DoubleHelper.doubleToLongBits(this.m00);
                    bits = bits * 31 + javaemul.internal.DoubleHelper.doubleToLongBits(this.m01);
                    bits = bits * 31 + javaemul.internal.DoubleHelper.doubleToLongBits(this.m02);
                    bits = bits * 31 + javaemul.internal.DoubleHelper.doubleToLongBits(this.m10);
                    bits = bits * 31 + javaemul.internal.DoubleHelper.doubleToLongBits(this.m11);
                    bits = bits * 31 + javaemul.internal.DoubleHelper.doubleToLongBits(this.m12);
                    return (((bits | 0)) ^ (((bits >> 32) | 0)));
                };
                /**
                 * Returns <code>true</code> if this <code>AffineTransform</code>
                 * represents the same affine coordinate transform as the specified
                 * argument.
                 * @param obj the <code>Object</code> to test for equality with this
                 * <code>AffineTransform</code>
                 * @return <code>true</code> if <code>obj</code> equals this
                 * <code>AffineTransform</code> object; <code>false</code> otherwise.
                 * @since 1.2
                 */
                AffineTransform.prototype.equals = function (obj) {
                    if (!(obj != null && obj instanceof java.awt.geom.AffineTransform)) {
                        return false;
                    }
                    var a = obj;
                    return ((this.m00 === a.m00) && (this.m01 === a.m01) && (this.m02 === a.m02) && (this.m10 === a.m10) && (this.m11 === a.m11) && (this.m12 === a.m12));
                };
                AffineTransform.TYPE_UNKNOWN = -1;
                /**
                 * This constant indicates that the transform defined by this object
                 * is an identity transform.
                 * An identity transform is one in which the output coordinates are
                 * always the same as the input coordinates.
                 * If this transform is anything other than the identity transform,
                 * the type will either be the constant GENERAL_TRANSFORM or a
                 * combination of the appropriate flag bits for the various coordinate
                 * conversions that this transform performs.
                 * @see #TYPE_TRANSLATION
                 * @see #TYPE_UNIFORM_SCALE
                 * @see #TYPE_GENERAL_SCALE
                 * @see #TYPE_FLIP
                 * @see #TYPE_QUADRANT_ROTATION
                 * @see #TYPE_GENERAL_ROTATION
                 * @see #TYPE_GENERAL_TRANSFORM
                 * @see #getType
                 * @since 1.2
                 */
                AffineTransform.TYPE_IDENTITY = 0;
                /**
                 * This flag bit indicates that the transform defined by this object
                 * performs a translation in addition to the conversions indicated
                 * by other flag bits.
                 * A translation moves the coordinates by a constant amount in x
                 * and y without changing the length or angle of vectors.
                 * @see #TYPE_IDENTITY
                 * @see #TYPE_UNIFORM_SCALE
                 * @see #TYPE_GENERAL_SCALE
                 * @see #TYPE_FLIP
                 * @see #TYPE_QUADRANT_ROTATION
                 * @see #TYPE_GENERAL_ROTATION
                 * @see #TYPE_GENERAL_TRANSFORM
                 * @see #getType
                 * @since 1.2
                 */
                AffineTransform.TYPE_TRANSLATION = 1;
                /**
                 * This flag bit indicates that the transform defined by this object
                 * performs a uniform scale in addition to the conversions indicated
                 * by other flag bits.
                 * A uniform scale multiplies the length of vectors by the same amount
                 * in both the x and y directions without changing the angle between
                 * vectors.
                 * This flag bit is mutually exclusive with the TYPE_GENERAL_SCALE flag.
                 * @see #TYPE_IDENTITY
                 * @see #TYPE_TRANSLATION
                 * @see #TYPE_GENERAL_SCALE
                 * @see #TYPE_FLIP
                 * @see #TYPE_QUADRANT_ROTATION
                 * @see #TYPE_GENERAL_ROTATION
                 * @see #TYPE_GENERAL_TRANSFORM
                 * @see #getType
                 * @since 1.2
                 */
                AffineTransform.TYPE_UNIFORM_SCALE = 2;
                /**
                 * This flag bit indicates that the transform defined by this object
                 * performs a general scale in addition to the conversions indicated
                 * by other flag bits.
                 * A general scale multiplies the length of vectors by different
                 * amounts in the x and y directions without changing the angle
                 * between perpendicular vectors.
                 * This flag bit is mutually exclusive with the TYPE_UNIFORM_SCALE flag.
                 * @see #TYPE_IDENTITY
                 * @see #TYPE_TRANSLATION
                 * @see #TYPE_UNIFORM_SCALE
                 * @see #TYPE_FLIP
                 * @see #TYPE_QUADRANT_ROTATION
                 * @see #TYPE_GENERAL_ROTATION
                 * @see #TYPE_GENERAL_TRANSFORM
                 * @see #getType
                 * @since 1.2
                 */
                AffineTransform.TYPE_GENERAL_SCALE = 4;
                /**
                 * This flag bit indicates that the transform defined by this object
                 * performs a mirror image flip about some axis which changes the
                 * normally right handed coordinate system into a left handed
                 * system in addition to the conversions indicated by other flag bits.
                 * A right handed coordinate system is one where the positive X
                 * axis rotates counterclockwise to overlay the positive Y axis
                 * similar to the direction that the fingers on your right hand
                 * curl when you stare end on at your thumb.
                 * A left handed coordinate system is one where the positive X
                 * axis rotates clockwise to overlay the positive Y axis similar
                 * to the direction that the fingers on your left hand curl.
                 * There is no mathematical way to determine the angle of the
                 * original flipping or mirroring transformation since all angles
                 * of flip are identical given an appropriate adjusting rotation.
                 * @see #TYPE_IDENTITY
                 * @see #TYPE_TRANSLATION
                 * @see #TYPE_UNIFORM_SCALE
                 * @see #TYPE_GENERAL_SCALE
                 * @see #TYPE_QUADRANT_ROTATION
                 * @see #TYPE_GENERAL_ROTATION
                 * @see #TYPE_GENERAL_TRANSFORM
                 * @see #getType
                 * @since 1.2
                 */
                AffineTransform.TYPE_FLIP = 64;
                /**
                 * This flag bit indicates that the transform defined by this object
                 * performs a quadrant rotation by some multiple of 90 degrees in
                 * addition to the conversions indicated by other flag bits.
                 * A rotation changes the angles of vectors by the same amount
                 * regardless of the original direction of the vector and without
                 * changing the length of the vector.
                 * This flag bit is mutually exclusive with the TYPE_GENERAL_ROTATION flag.
                 * @see #TYPE_IDENTITY
                 * @see #TYPE_TRANSLATION
                 * @see #TYPE_UNIFORM_SCALE
                 * @see #TYPE_GENERAL_SCALE
                 * @see #TYPE_FLIP
                 * @see #TYPE_GENERAL_ROTATION
                 * @see #TYPE_GENERAL_TRANSFORM
                 * @see #getType
                 * @since 1.2
                 */
                AffineTransform.TYPE_QUADRANT_ROTATION = 8;
                /**
                 * This flag bit indicates that the transform defined by this object
                 * performs a rotation by an arbitrary angle in addition to the
                 * conversions indicated by other flag bits.
                 * A rotation changes the angles of vectors by the same amount
                 * regardless of the original direction of the vector and without
                 * changing the length of the vector.
                 * This flag bit is mutually exclusive with the
                 * TYPE_QUADRANT_ROTATION flag.
                 * @see #TYPE_IDENTITY
                 * @see #TYPE_TRANSLATION
                 * @see #TYPE_UNIFORM_SCALE
                 * @see #TYPE_GENERAL_SCALE
                 * @see #TYPE_FLIP
                 * @see #TYPE_QUADRANT_ROTATION
                 * @see #TYPE_GENERAL_TRANSFORM
                 * @see #getType
                 * @since 1.2
                 */
                AffineTransform.TYPE_GENERAL_ROTATION = 16;
                /**
                 * This constant indicates that the transform defined by this object
                 * performs an arbitrary conversion of the input coordinates.
                 * If this transform can be classified by any of the above constants,
                 * the type will either be the constant TYPE_IDENTITY or a
                 * combination of the appropriate flag bits for the various coordinate
                 * conversions that this transform performs.
                 * @see #TYPE_IDENTITY
                 * @see #TYPE_TRANSLATION
                 * @see #TYPE_UNIFORM_SCALE
                 * @see #TYPE_GENERAL_SCALE
                 * @see #TYPE_FLIP
                 * @see #TYPE_QUADRANT_ROTATION
                 * @see #TYPE_GENERAL_ROTATION
                 * @see #getType
                 * @since 1.2
                 */
                AffineTransform.TYPE_GENERAL_TRANSFORM = 32;
                /**
                 * This constant is used for the internal state variable to indicate
                 * that no calculations need to be performed and that the source
                 * coordinates only need to be copied to their destinations to
                 * complete the transformation equation of this transform.
                 * @see #APPLY_TRANSLATE
                 * @see #APPLY_SCALE
                 * @see #APPLY_SHEAR
                 * @see #state
                 */
                AffineTransform.APPLY_IDENTITY = 0;
                /**
                 * This constant is used for the internal state variable to indicate
                 * that the translation components of the matrix (m02 and m12) need
                 * to be added to complete the transformation equation of this transform.
                 * @see #APPLY_IDENTITY
                 * @see #APPLY_SCALE
                 * @see #APPLY_SHEAR
                 * @see #state
                 */
                AffineTransform.APPLY_TRANSLATE = 1;
                /**
                 * This constant is used for the internal state variable to indicate
                 * that the scaling components of the matrix (m00 and m11) need
                 * to be factored in to complete the transformation equation of
                 * this transform.  If the APPLY_SHEAR bit is also set then it
                 * indicates that the scaling components are not both 0.0.  If the
                 * APPLY_SHEAR bit is not also set then it indicates that the
                 * scaling components are not both 1.0.  If neither the APPLY_SHEAR
                 * nor the APPLY_SCALE bits are set then the scaling components
                 * are both 1.0, which means that the x and y components contribute
                 * to the transformed coordinate, but they are not multiplied by
                 * any scaling factor.
                 * @see #APPLY_IDENTITY
                 * @see #APPLY_TRANSLATE
                 * @see #APPLY_SHEAR
                 * @see #state
                 */
                AffineTransform.APPLY_SCALE = 2;
                /**
                 * This constant is used for the internal state variable to indicate
                 * that the shearing components of the matrix (m01 and m10) need
                 * to be factored in to complete the transformation equation of this
                 * transform.  The presence of this bit in the state variable changes
                 * the interpretation of the APPLY_SCALE bit as indicated in its
                 * documentation.
                 * @see #APPLY_IDENTITY
                 * @see #APPLY_TRANSLATE
                 * @see #APPLY_SCALE
                 * @see #state
                 */
                AffineTransform.APPLY_SHEAR = 4;
                AffineTransform.HI_SHIFT = 3;
                AffineTransform.serialVersionUID = 1330973210523860834;
                return AffineTransform;
            }());
            geom.AffineTransform = AffineTransform;
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * A utility class to iterate over the path segments of an arc through the
             * PathIterator interface.
             *
             * @author Jim Graham
             */
            var ArcIterator = (function () {
                function ArcIterator(a, at) {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.geom.PathIterator"] });
                    this.x = 0;
                    this.y = 0;
                    this.w = 0;
                    this.h = 0;
                    this.angStRad = 0;
                    this.increment = 0;
                    this.cv = 0;
                    this.index = 0;
                    this.arcSegs = 0;
                    this.lineSegs = 0;
                    this.w = a.getWidth() / 2;
                    this.h = a.getHeight() / 2;
                    this.x = a.getX() + this.w;
                    this.y = a.getY() + this.h;
                    this.angStRad = -(function (x) { return x * Math.PI / 180; })(a.getAngleStart());
                    this.affine = at;
                    var ext = -a.getAngleExtent();
                    if (ext >= 360.0 || ext <= -360) {
                        this.arcSegs = 4;
                        this.increment = Math.PI / 2;
                        this.cv = 0.5522847498307933;
                        if (ext < 0) {
                            this.increment = -this.increment;
                            this.cv = -this.cv;
                        }
                    }
                    else {
                        this.arcSegs = (Math.ceil(Math.abs(ext) / 90.0) | 0);
                        this.increment = (function (x) { return x * Math.PI / 180; })(ext / this.arcSegs);
                        this.cv = ArcIterator.btan(this.increment);
                        if (this.cv === 0) {
                            this.arcSegs = 0;
                        }
                    }
                    switch ((a.getArcType())) {
                        case java.awt.geom.Arc2D.OPEN:
                            this.lineSegs = 0;
                            break;
                        case java.awt.geom.Arc2D.CHORD:
                            this.lineSegs = 1;
                            break;
                        case java.awt.geom.Arc2D.PIE:
                            this.lineSegs = 2;
                            break;
                    }
                    if (this.w < 0 || this.h < 0) {
                        this.arcSegs = this.lineSegs = -1;
                    }
                }
                /**
                 * Return the winding rule for determining the insideness of the path.
                 *
                 * @see #WIND_EVEN_ODD
                 * @see #WIND_NON_ZERO
                 */
                ArcIterator.prototype.getWindingRule = function () {
                    return java.awt.geom.PathIterator.WIND_NON_ZERO;
                };
                /**
                 * Tests if there are more points to read.
                 *
                 * @return true if there are more points to read
                 */
                ArcIterator.prototype.isDone = function () {
                    return this.index > this.arcSegs + this.lineSegs;
                };
                /**
                 * Moves the iterator to the next segment of the path forwards along the
                 * primary direction of traversal as long as there are more points in that
                 * direction.
                 */
                ArcIterator.prototype.next = function () {
                    this.index++;
                };
                ArcIterator.btan = function (increment) {
                    increment /= 2.0;
                    return 4.0 / 3.0 * Math.sin(increment) / (1.0 + Math.cos(increment));
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of float x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 */
                ArcIterator.prototype.currentSegment = function (coords) {
                    var _this = this;
                    if (((coords != null && coords instanceof Array) || coords === null)) {
                        return (function () {
                            if (_this.isDone()) {
                                throw new java.util.NoSuchElementException("arc iterator out of bounds");
                            }
                            var angle = _this.angStRad;
                            if (_this.index === 0) {
                                coords[0] = (_this.x + Math.cos(angle) * _this.w);
                                coords[1] = (_this.y + Math.sin(angle) * _this.h);
                                if (_this.affine != null) {
                                    _this.affine.transform(coords, 0, coords, 0, 1);
                                }
                                return java.awt.geom.PathIterator.SEG_MOVETO;
                            }
                            if (_this.index > _this.arcSegs) {
                                if (_this.index === _this.arcSegs + _this.lineSegs) {
                                    return java.awt.geom.PathIterator.SEG_CLOSE;
                                }
                                coords[0] = _this.x;
                                coords[1] = _this.y;
                                if (_this.affine != null) {
                                    _this.affine.transform(coords, 0, coords, 0, 1);
                                }
                                return java.awt.geom.PathIterator.SEG_LINETO;
                            }
                            angle += _this.increment * (_this.index - 1);
                            var relx = Math.cos(angle);
                            var rely = Math.sin(angle);
                            coords[0] = (_this.x + (relx - _this.cv * rely) * _this.w);
                            coords[1] = (_this.y + (rely + _this.cv * relx) * _this.h);
                            angle += _this.increment;
                            relx = Math.cos(angle);
                            rely = Math.sin(angle);
                            coords[2] = (_this.x + (relx + _this.cv * rely) * _this.w);
                            coords[3] = (_this.y + (rely - _this.cv * relx) * _this.h);
                            coords[4] = (_this.x + relx * _this.w);
                            coords[5] = (_this.y + rely * _this.h);
                            if (_this.affine != null) {
                                _this.affine.transform(coords, 0, coords, 0, 3);
                            }
                            return java.awt.geom.PathIterator.SEG_CUBICTO;
                        })();
                    }
                    else if (((coords != null && coords instanceof Array) || coords === null)) {
                        return this.currentSegment$double_A(coords);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A double array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of double x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 */
                ArcIterator.prototype.currentSegment$double_A = function (coords) {
                    if (this.isDone()) {
                        throw new java.util.NoSuchElementException("arc iterator out of bounds");
                    }
                    var angle = this.angStRad;
                    if (this.index === 0) {
                        coords[0] = this.x + Math.cos(angle) * this.w;
                        coords[1] = this.y + Math.sin(angle) * this.h;
                        if (this.affine != null) {
                            this.affine.transform(coords, 0, coords, 0, 1);
                        }
                        return java.awt.geom.PathIterator.SEG_MOVETO;
                    }
                    if (this.index > this.arcSegs) {
                        if (this.index === this.arcSegs + this.lineSegs) {
                            return java.awt.geom.PathIterator.SEG_CLOSE;
                        }
                        coords[0] = this.x;
                        coords[1] = this.y;
                        if (this.affine != null) {
                            this.affine.transform(coords, 0, coords, 0, 1);
                        }
                        return java.awt.geom.PathIterator.SEG_LINETO;
                    }
                    angle += this.increment * (this.index - 1);
                    var relx = Math.cos(angle);
                    var rely = Math.sin(angle);
                    coords[0] = this.x + (relx - this.cv * rely) * this.w;
                    coords[1] = this.y + (rely + this.cv * relx) * this.h;
                    angle += this.increment;
                    relx = Math.cos(angle);
                    rely = Math.sin(angle);
                    coords[2] = this.x + (relx + this.cv * rely) * this.w;
                    coords[3] = this.y + (rely - this.cv * relx) * this.h;
                    coords[4] = this.x + relx * this.w;
                    coords[5] = this.y + rely * this.h;
                    if (this.affine != null) {
                        this.affine.transform(coords, 0, coords, 0, 3);
                    }
                    return java.awt.geom.PathIterator.SEG_CUBICTO;
                };
                return ArcIterator;
            }());
            geom.ArcIterator = ArcIterator;
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The <code>CubicCurve2D</code> class defines a cubic parametric curve segment
             * in {@code (x,y)} coordinate space.
             * <p>
             * This class is only the abstract superclass for all objects which store a 2D
             * cubic curve segment. The actual storage representation of the coordinates is
             * left to the subclass.
             *
             * @author Jim Graham
             * @since 1.2
             */
            var CubicCurve2D = (function () {
                /**
                 * This is an abstract class that cannot be instantiated directly.
                 * Type-specific implementation subclasses are available for instantiation
                 * and provide a number of formats for storing the information necessary to
                 * satisfy the various accessor methods below.
                 *
                 * @see java.awt.geom.CubicCurve2D.Float
                 * @see java.awt.geom.CubicCurve2D.Double
                 * @since 1.2
                 */
                function CubicCurve2D() {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable"] });
                }
                /**
                 * Sets the location of the end points and control points of this curve
                 * to the specified {@code float} coordinates.
                 *
                 * @param x1
                 * the X coordinate used to set the start point of this
                 * {@code CubicCurve2D}
                 * @param y1
                 * the Y coordinate used to set the start point of this
                 * {@code CubicCurve2D}
                 * @param ctrlx1
                 * the X coordinate used to set the first control point of
                 * this {@code CubicCurve2D}
                 * @param ctrly1
                 * the Y coordinate used to set the first control point of
                 * this {@code CubicCurve2D}
                 * @param ctrlx2
                 * the X coordinate used to set the second control point of
                 * this {@code CubicCurve2D}
                 * @param ctrly2
                 * the Y coordinate used to set the second control point of
                 * this {@code CubicCurve2D}
                 * @param x2
                 * the X coordinate used to set the end point of this
                 * {@code CubicCurve2D}
                 * @param y2
                 * the Y coordinate used to set the end point of this
                 * {@code CubicCurve2D}
                 * @since 1.2
                 */
                CubicCurve2D.prototype.setCurve = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx1 === 'number') || ctrlx1 === null) && ((typeof ctrly1 === 'number') || ctrly1 === null) && ((typeof ctrlx2 === 'number') || ctrlx2 === null) && ((typeof ctrly2 === 'number') || ctrly2 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        return this.setCurve$double$double$double$double$double$double$double$double(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2);
                    }
                    else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && ((ctrlx1 != null && ctrlx1 instanceof java.awt.geom.Point2D) || ctrlx1 === null) && ((ctrly1 != null && ctrly1 instanceof java.awt.geom.Point2D) || ctrly1 === null) && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                        return this.setCurve$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1, ctrlx1, ctrly1);
                    }
                    else if (((x1 != null && x1 instanceof Array) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                        return this.setCurve$double_A$int(x1, y1);
                    }
                    else if (((x1 != null && x1 instanceof Array) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                        return this.setCurve$java_awt_geom_Point2D_A$int(x1, y1);
                    }
                    else if (((x1 != null && x1 instanceof java.awt.geom.CubicCurve2D) || x1 === null) && y1 === undefined && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                        return this.setCurve$java_awt_geom_CubicCurve2D(x1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets the location of the end points and control points of this curve to
                 * the specified double coordinates.
                 *
                 * @param x1
                 * the X coordinate used to set the start point of this
                 * {@code CubicCurve2D}
                 * @param y1
                 * the Y coordinate used to set the start point of this
                 * {@code CubicCurve2D}
                 * @param ctrlx1
                 * the X coordinate used to set the first control point of this
                 * {@code CubicCurve2D}
                 * @param ctrly1
                 * the Y coordinate used to set the first control point of this
                 * {@code CubicCurve2D}
                 * @param ctrlx2
                 * the X coordinate used to set the second control point of this
                 * {@code CubicCurve2D}
                 * @param ctrly2
                 * the Y coordinate used to set the second control point of this
                 * {@code CubicCurve2D}
                 * @param x2
                 * the X coordinate used to set the end point of this
                 * {@code CubicCurve2D}
                 * @param y2
                 * the Y coordinate used to set the end point of this
                 * {@code CubicCurve2D}
                 * @since 1.2
                 */
                CubicCurve2D.prototype.setCurve$double$double$double$double$double$double$double$double = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Sets the location of the end points and control points of this curve to
                 * the double coordinates at the specified offset in the specified array.
                 *
                 * @param coords
                 * a double array containing coordinates
                 * @param offset
                 * the index of <code>coords</code> from which to begin setting
                 * the end points and control points of this curve to the
                 * coordinates contained in <code>coords</code>
                 * @since 1.2
                 */
                CubicCurve2D.prototype.setCurve$double_A$int = function (coords, offset) {
                    this.setCurve(coords[offset + 0], coords[offset + 1], coords[offset + 2], coords[offset + 3], coords[offset + 4], coords[offset + 5], coords[offset + 6], coords[offset + 7]);
                };
                /**
                 * Sets the location of the end points and control points of this curve to
                 * the specified <code>Point2D</code> coordinates.
                 *
                 * @param p1
                 * the first specified <code>Point2D</code> used to set the start
                 * point of this curve
                 * @param cp1
                 * the second specified <code>Point2D</code> used to set the
                 * first control point of this curve
                 * @param cp2
                 * the third specified <code>Point2D</code> used to set the
                 * second control point of this curve
                 * @param p2
                 * the fourth specified <code>Point2D</code> used to set the end
                 * point of this curve
                 * @since 1.2
                 */
                CubicCurve2D.prototype.setCurve$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D = function (p1, cp1, cp2, p2) {
                    this.setCurve(p1.getX(), p1.getY(), cp1.getX(), cp1.getY(), cp2.getX(), cp2.getY(), p2.getX(), p2.getY());
                };
                /**
                 * Sets the location of the end points and control points of this curve to
                 * the coordinates of the <code>Point2D</code> objects at the specified
                 * offset in the specified array.
                 *
                 * @param pts
                 * an array of <code>Point2D</code> objects
                 * @param offset
                 * the index of <code>pts</code> from which to begin setting the
                 * end points and control points of this curve to the points
                 * contained in <code>pts</code>
                 * @since 1.2
                 */
                CubicCurve2D.prototype.setCurve$java_awt_geom_Point2D_A$int = function (pts, offset) {
                    this.setCurve(pts[offset + 0].getX(), pts[offset + 0].getY(), pts[offset + 1].getX(), pts[offset + 1].getY(), pts[offset + 2].getX(), pts[offset + 2].getY(), pts[offset + 3].getX(), pts[offset + 3].getY());
                };
                /**
                 * Sets the location of the end points and control points of this curve to
                 * the same as those in the specified <code>CubicCurve2D</code>.
                 *
                 * @param c
                 * the specified <code>CubicCurve2D</code>
                 * @since 1.2
                 */
                CubicCurve2D.prototype.setCurve$java_awt_geom_CubicCurve2D = function (c) {
                    this.setCurve(c.getX1(), c.getY1(), c.getCtrlX1(), c.getCtrlY1(), c.getCtrlX2(), c.getCtrlY2(), c.getX2(), c.getY2());
                };
                /**
                 * Returns the square of the flatness of the cubic curve specified by the
                 * indicated control points. The flatness is the maximum distance of a
                 * control point from the line connecting the end points.
                 *
                 * @param x1
                 * the X coordinate that specifies the start point of a
                 * {@code CubicCurve2D}
                 * @param y1
                 * the Y coordinate that specifies the start point of a
                 * {@code CubicCurve2D}
                 * @param ctrlx1
                 * the X coordinate that specifies the first control point of a
                 * {@code CubicCurve2D}
                 * @param ctrly1
                 * the Y coordinate that specifies the first control point of a
                 * {@code CubicCurve2D}
                 * @param ctrlx2
                 * the X coordinate that specifies the second control point of a
                 * {@code CubicCurve2D}
                 * @param ctrly2
                 * the Y coordinate that specifies the second control point of a
                 * {@code CubicCurve2D}
                 * @param x2
                 * the X coordinate that specifies the end point of a
                 * {@code CubicCurve2D}
                 * @param y2
                 * the Y coordinate that specifies the end point of a
                 * {@code CubicCurve2D}
                 * @return the square of the flatness of the {@code CubicCurve2D}
                 * represented by the specified coordinates.
                 * @since 1.2
                 */
                CubicCurve2D.getFlatnessSq = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx1 === 'number') || ctrlx1 === null) && ((typeof ctrly1 === 'number') || ctrly1 === null) && ((typeof ctrlx2 === 'number') || ctrlx2 === null) && ((typeof ctrly2 === 'number') || ctrly2 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        return (function () {
                            return Math.max(java.awt.geom.Line2D.ptSegDistSq(x1, y1, x2, y2, ctrlx1, ctrly1), java.awt.geom.Line2D.ptSegDistSq(x1, y1, x2, y2, ctrlx2, ctrly2));
                        })();
                    }
                    else if (((x1 != null && x1 instanceof Array) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                        return java.awt.geom.CubicCurve2D.getFlatnessSq$double_A$int(x1, y1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the flatness of the cubic curve specified by the indicated
                 * control points. The flatness is the maximum distance of a control point
                 * from the line connecting the end points.
                 *
                 * @param x1
                 * the X coordinate that specifies the start point of a
                 * {@code CubicCurve2D}
                 * @param y1
                 * the Y coordinate that specifies the start point of a
                 * {@code CubicCurve2D}
                 * @param ctrlx1
                 * the X coordinate that specifies the first control point of a
                 * {@code CubicCurve2D}
                 * @param ctrly1
                 * the Y coordinate that specifies the first control point of a
                 * {@code CubicCurve2D}
                 * @param ctrlx2
                 * the X coordinate that specifies the second control point of a
                 * {@code CubicCurve2D}
                 * @param ctrly2
                 * the Y coordinate that specifies the second control point of a
                 * {@code CubicCurve2D}
                 * @param x2
                 * the X coordinate that specifies the end point of a
                 * {@code CubicCurve2D}
                 * @param y2
                 * the Y coordinate that specifies the end point of a
                 * {@code CubicCurve2D}
                 * @return the flatness of the {@code CubicCurve2D} represented by the
                 * specified coordinates.
                 * @since 1.2
                 */
                CubicCurve2D.getFlatness = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx1 === 'number') || ctrlx1 === null) && ((typeof ctrly1 === 'number') || ctrly1 === null) && ((typeof ctrlx2 === 'number') || ctrlx2 === null) && ((typeof ctrly2 === 'number') || ctrly2 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        return (function () {
                            return Math.sqrt(CubicCurve2D.getFlatnessSq(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2));
                        })();
                    }
                    else if (((x1 != null && x1 instanceof Array) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                        return java.awt.geom.CubicCurve2D.getFlatness$double_A$int(x1, y1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the square of the flatness of the cubic curve specified by the
                 * control points stored in the indicated array at the indicated index. The
                 * flatness is the maximum distance of a control point from the line
                 * connecting the end points.
                 *
                 * @param coords
                 * an array containing coordinates
                 * @param offset
                 * the index of <code>coords</code> from which to begin getting
                 * the end points and control points of the curve
                 * @return the square of the flatness of the <code>CubicCurve2D</code>
                 * specified by the coordinates in <code>coords</code> at the
                 * specified offset.
                 * @since 1.2
                 */
                CubicCurve2D.getFlatnessSq$double_A$int = function (coords, offset) {
                    return CubicCurve2D.getFlatnessSq(coords[offset + 0], coords[offset + 1], coords[offset + 2], coords[offset + 3], coords[offset + 4], coords[offset + 5], coords[offset + 6], coords[offset + 7]);
                };
                /**
                 * Returns the flatness of the cubic curve specified by the control points
                 * stored in the indicated array at the indicated index. The flatness is the
                 * maximum distance of a control point from the line connecting the end
                 * points.
                 *
                 * @param coords
                 * an array containing coordinates
                 * @param offset
                 * the index of <code>coords</code> from which to begin getting
                 * the end points and control points of the curve
                 * @return the flatness of the <code>CubicCurve2D</code> specified by the
                 * coordinates in <code>coords</code> at the specified offset.
                 * @since 1.2
                 */
                CubicCurve2D.getFlatness$double_A$int = function (coords, offset) {
                    return CubicCurve2D.getFlatness(coords[offset + 0], coords[offset + 1], coords[offset + 2], coords[offset + 3], coords[offset + 4], coords[offset + 5], coords[offset + 6], coords[offset + 7]);
                };
                /**
                 * Returns the square of the flatness of this curve. The flatness is the
                 * maximum distance of a control point from the line connecting the end
                 * points.
                 *
                 * @return the square of the flatness of this curve.
                 * @since 1.2
                 */
                CubicCurve2D.prototype.getFlatnessSq = function () {
                    return CubicCurve2D.getFlatnessSq(this.getX1(), this.getY1(), this.getCtrlX1(), this.getCtrlY1(), this.getCtrlX2(), this.getCtrlY2(), this.getX2(), this.getY2());
                };
                /**
                 * Returns the flatness of this curve. The flatness is the maximum distance
                 * of a control point from the line connecting the end points.
                 *
                 * @return the flatness of this curve.
                 * @since 1.2
                 */
                CubicCurve2D.prototype.getFlatness = function () {
                    return CubicCurve2D.getFlatness(this.getX1(), this.getY1(), this.getCtrlX1(), this.getCtrlY1(), this.getCtrlX2(), this.getCtrlY2(), this.getX2(), this.getY2());
                };
                /**
                 * Subdivides this cubic curve and stores the resulting two subdivided
                 * curves into the left and right curve parameters. Either or both of the
                 * left and right objects may be the same as this object or null.
                 *
                 * @param left
                 * the cubic curve object for storing for the left or first half
                 * of the subdivided curve
                 * @param right
                 * the cubic curve object for storing for the right or second
                 * half of the subdivided curve
                 * @since 1.2
                 */
                CubicCurve2D.prototype.subdivide = function (left, right) {
                    CubicCurve2D.subdivide(this, left, right);
                };
                /**
                 * Subdivides the cubic curve specified by the <code>src</code> parameter
                 * and stores the resulting two subdivided curves into the <code>left</code>
                 * and <code>right</code> curve parameters. Either or both of the
                 * <code>left</code> and <code>right</code> objects may be the same as the
                 * <code>src</code> object or <code>null</code>.
                 *
                 * @param src
                 * the cubic curve to be subdivided
                 * @param left
                 * the cubic curve object for storing the left or first half of
                 * the subdivided curve
                 * @param right
                 * the cubic curve object for storing the right or second half of
                 * the subdivided curve
                 * @since 1.2
                 */
                CubicCurve2D.subdivide$java_awt_geom_CubicCurve2D$java_awt_geom_CubicCurve2D$java_awt_geom_CubicCurve2D = function (src, left, right) {
                    var x1 = src.getX1();
                    var y1 = src.getY1();
                    var ctrlx1 = src.getCtrlX1();
                    var ctrly1 = src.getCtrlY1();
                    var ctrlx2 = src.getCtrlX2();
                    var ctrly2 = src.getCtrlY2();
                    var x2 = src.getX2();
                    var y2 = src.getY2();
                    var centerx = (ctrlx1 + ctrlx2) / 2.0;
                    var centery = (ctrly1 + ctrly2) / 2.0;
                    ctrlx1 = (x1 + ctrlx1) / 2.0;
                    ctrly1 = (y1 + ctrly1) / 2.0;
                    ctrlx2 = (x2 + ctrlx2) / 2.0;
                    ctrly2 = (y2 + ctrly2) / 2.0;
                    var ctrlx12 = (ctrlx1 + centerx) / 2.0;
                    var ctrly12 = (ctrly1 + centery) / 2.0;
                    var ctrlx21 = (ctrlx2 + centerx) / 2.0;
                    var ctrly21 = (ctrly2 + centery) / 2.0;
                    centerx = (ctrlx12 + ctrlx21) / 2.0;
                    centery = (ctrly12 + ctrly21) / 2.0;
                    if (left != null) {
                        left.setCurve(x1, y1, ctrlx1, ctrly1, ctrlx12, ctrly12, centerx, centery);
                    }
                    if (right != null) {
                        right.setCurve(centerx, centery, ctrlx21, ctrly21, ctrlx2, ctrly2, x2, y2);
                    }
                };
                /**
                 * Subdivides the cubic curve specified by the coordinates stored in the
                 * <code>src</code> array at indices <code>srcoff</code> through (
                 * <code>srcoff</code>&nbsp;+&nbsp;7) and stores the resulting two
                 * subdivided curves into the two result arrays at the corresponding
                 * indices. Either or both of the <code>left</code> and <code>right</code>
                 * arrays may be <code>null</code> or a reference to the same array as the
                 * <code>src</code> array. Note that the last point in the first subdivided
                 * curve is the same as the first point in the second subdivided curve.
                 * Thus, it is possible to pass the same array for <code>left</code> and
                 * <code>right</code> and to use offsets, such as <code>rightoff</code>
                 * equals (<code>leftoff</code> + 6), in order to avoid allocating extra
                 * storage for this common point.
                 *
                 * @param src
                 * the array holding the coordinates for the source curve
                 * @param srcoff
                 * the offset into the array of the beginning of the the 6 source
                 * coordinates
                 * @param left
                 * the array for storing the coordinates for the first half of
                 * the subdivided curve
                 * @param leftoff
                 * the offset into the array of the beginning of the the 6 left
                 * coordinates
                 * @param right
                 * the array for storing the coordinates for the second half of
                 * the subdivided curve
                 * @param rightoff
                 * the offset into the array of the beginning of the the 6 right
                 * coordinates
                 * @since 1.2
                 */
                CubicCurve2D.subdivide = function (src, srcoff, left, leftoff, right, rightoff) {
                    if (((src != null && src instanceof Array) || src === null) && ((typeof srcoff === 'number') || srcoff === null) && ((left != null && left instanceof Array) || left === null) && ((typeof leftoff === 'number') || leftoff === null) && ((right != null && right instanceof Array) || right === null) && ((typeof rightoff === 'number') || rightoff === null)) {
                        return (function () {
                            var x1 = src[srcoff + 0];
                            var y1 = src[srcoff + 1];
                            var ctrlx1 = src[srcoff + 2];
                            var ctrly1 = src[srcoff + 3];
                            var ctrlx2 = src[srcoff + 4];
                            var ctrly2 = src[srcoff + 5];
                            var x2 = src[srcoff + 6];
                            var y2 = src[srcoff + 7];
                            if (left != null) {
                                left[leftoff + 0] = x1;
                                left[leftoff + 1] = y1;
                            }
                            if (right != null) {
                                right[rightoff + 6] = x2;
                                right[rightoff + 7] = y2;
                            }
                            x1 = (x1 + ctrlx1) / 2.0;
                            y1 = (y1 + ctrly1) / 2.0;
                            x2 = (x2 + ctrlx2) / 2.0;
                            y2 = (y2 + ctrly2) / 2.0;
                            var centerx = (ctrlx1 + ctrlx2) / 2.0;
                            var centery = (ctrly1 + ctrly2) / 2.0;
                            ctrlx1 = (x1 + centerx) / 2.0;
                            ctrly1 = (y1 + centery) / 2.0;
                            ctrlx2 = (x2 + centerx) / 2.0;
                            ctrly2 = (y2 + centery) / 2.0;
                            centerx = (ctrlx1 + ctrlx2) / 2.0;
                            centery = (ctrly1 + ctrly2) / 2.0;
                            if (left != null) {
                                left[leftoff + 2] = x1;
                                left[leftoff + 3] = y1;
                                left[leftoff + 4] = ctrlx1;
                                left[leftoff + 5] = ctrly1;
                                left[leftoff + 6] = centerx;
                                left[leftoff + 7] = centery;
                            }
                            if (right != null) {
                                right[rightoff + 0] = centerx;
                                right[rightoff + 1] = centery;
                                right[rightoff + 2] = ctrlx2;
                                right[rightoff + 3] = ctrly2;
                                right[rightoff + 4] = x2;
                                right[rightoff + 5] = y2;
                            }
                        })();
                    }
                    else if (((src != null && src instanceof java.awt.geom.CubicCurve2D) || src === null) && ((srcoff != null && srcoff instanceof java.awt.geom.CubicCurve2D) || srcoff === null) && ((left != null && left instanceof java.awt.geom.CubicCurve2D) || left === null) && leftoff === undefined && right === undefined && rightoff === undefined) {
                        return java.awt.geom.CubicCurve2D.subdivide$java_awt_geom_CubicCurve2D$java_awt_geom_CubicCurve2D$java_awt_geom_CubicCurve2D(src, srcoff, left);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Solves the cubic whose coefficients are in the <code>eqn</code> array and
                 * places the non-complex roots back into the same array, returning the
                 * number of roots. The solved cubic is represented by the equation:
                 *
                 * <pre>
                 * eqn = {c, b, a, d}
                 * dx^3 + ax^2 + bx + c = 0
                 * </pre>
                 *
                 * A return value of -1 is used to distinguish a constant equation that
                 * might be always 0 or never 0 from an equation that has no zeroes.
                 *
                 * @param eqn
                 * an array containing coefficients for a cubic
                 * @return the number of roots, or -1 if the equation is a constant.
                 * @since 1.2
                 */
                CubicCurve2D.solveCubic$double_A = function (eqn) {
                    return CubicCurve2D.solveCubic(eqn, eqn);
                };
                /**
                 * Solve the cubic whose coefficients are in the <code>eqn</code> array and
                 * place the non-complex roots into the <code>res</code> array, returning
                 * the number of roots. The cubic solved is represented by the equation: eqn
                 * = {c, b, a, d} dx^3 + ax^2 + bx + c = 0 A return value of -1 is used to
                 * distinguish a constant equation, which may be always 0 or never 0, from
                 * an equation which has no zeroes.
                 *
                 * @param eqn
                 * the specified array of coefficients to use to solve the cubic
                 * equation
                 * @param res
                 * the array that contains the non-complex roots resulting from
                 * the solution of the cubic equation
                 * @return the number of roots, or -1 if the equation is a constant
                 * @since 1.3
                 */
                CubicCurve2D.solveCubic = function (eqn, res) {
                    if (((eqn != null && eqn instanceof Array) || eqn === null) && ((res != null && res instanceof Array) || res === null)) {
                        return (function () {
                            var d = eqn[3];
                            if (d === 0) {
                                return java.awt.geom.QuadCurve2D.solveQuadratic(eqn, res);
                            }
                            var A = eqn[2] / d;
                            var B = eqn[1] / d;
                            var C = eqn[0] / d;
                            var sq_A = A * A;
                            var p = 1.0 / 3 * (-1.0 / 3 * sq_A + B);
                            var q = 1.0 / 2 * (2.0 / 27 * A * sq_A - 1.0 / 3 * A * B + C);
                            var cb_p = p * p * p;
                            var D = q * q + cb_p;
                            var sub = 1.0 / 3 * A;
                            var num;
                            if (D < 0) {
                                var phi = 1.0 / 3 * Math.acos(-q / Math.sqrt(-cb_p));
                                var t = 2 * Math.sqrt(-p);
                                if (res === eqn) {
                                    eqn = java.util.Arrays.copyOf(eqn, 4);
                                }
                                res[0] = (t * Math.cos(phi));
                                res[1] = (-t * Math.cos(phi + Math.PI / 3));
                                res[2] = (-t * Math.cos(phi - Math.PI / 3));
                                num = 3;
                                for (var i = 0; i < num; ++i) {
                                    res[i] -= sub;
                                }
                            }
                            else {
                                var sqrt_D = Math.sqrt(D);
                                var u = Math.pow(sqrt_D - q, 1 / 3);
                                var v = -Math.pow(sqrt_D + q, 1 / 3);
                                var uv = u + v;
                                num = 1;
                                var err = 1200000000 * javaemul.internal.MathHelper.ulp(Math.abs(uv) + Math.abs(sub));
                                if (CubicCurve2D.iszero(D, err) || CubicCurve2D.within(u, v, err)) {
                                    if (res === eqn) {
                                        eqn = java.util.Arrays.copyOf(eqn, 4);
                                    }
                                    res[1] = -(uv / 2) - sub;
                                    num = 2;
                                }
                                res[0] = uv - sub;
                            }
                            if (num > 1) {
                                num = CubicCurve2D.fixRoots(eqn, res, num);
                            }
                            if (num > 2 && (res[2] === res[1] || res[2] === res[0])) {
                                num--;
                            }
                            if (num > 1 && res[1] === res[0]) {
                                res[1] = res[--num];
                            }
                            return num;
                        })();
                    }
                    else if (((eqn != null && eqn instanceof Array) || eqn === null) && res === undefined) {
                        return java.awt.geom.CubicCurve2D.solveCubic$double_A(eqn);
                    }
                    else
                        throw new Error('invalid overload');
                };
                CubicCurve2D.fixRoots = function (eqn, res, num) {
                    var intervals = [eqn[1], 2 * eqn[2], 3 * eqn[3]];
                    var critCount = java.awt.geom.QuadCurve2D.solveQuadratic(intervals, intervals);
                    if (critCount === 2 && intervals[0] === intervals[1]) {
                        critCount--;
                    }
                    if (critCount === 2 && intervals[0] > intervals[1]) {
                        var tmp = intervals[0];
                        intervals[0] = intervals[1];
                        intervals[1] = tmp;
                    }
                    if (num === 3) {
                        var xe = CubicCurve2D.getRootUpperBound(eqn);
                        var x0 = -xe;
                        java.util.Arrays.sort(res, 0, num);
                        if (critCount === 2) {
                            res[0] = CubicCurve2D.refineRootWithHint(eqn, x0, intervals[0], res[0]);
                            res[1] = CubicCurve2D.refineRootWithHint(eqn, intervals[0], intervals[1], res[1]);
                            res[2] = CubicCurve2D.refineRootWithHint(eqn, intervals[1], xe, res[2]);
                            return 3;
                        }
                        else if (critCount === 1) {
                            var fxe = eqn[3];
                            var fx0 = -fxe;
                            var x1 = intervals[0];
                            var fx1 = CubicCurve2D.solveEqn(eqn, 3, x1);
                            if (CubicCurve2D.oppositeSigns(fx0, fx1)) {
                                res[0] = CubicCurve2D.bisectRootWithHint(eqn, x0, x1, res[0]);
                            }
                            else if (CubicCurve2D.oppositeSigns(fx1, fxe)) {
                                res[0] = CubicCurve2D.bisectRootWithHint(eqn, x1, xe, res[2]);
                            }
                            else {
                                res[0] = x1;
                            }
                        }
                        else if (critCount === 0) {
                            res[0] = CubicCurve2D.bisectRootWithHint(eqn, x0, xe, res[1]);
                        }
                    }
                    else if (num === 2 && critCount === 2) {
                        var goodRoot = res[0];
                        var badRoot = res[1];
                        var x1 = intervals[0];
                        var x2 = intervals[1];
                        var x = Math.abs(x1 - goodRoot) > Math.abs(x2 - goodRoot) ? x1 : x2;
                        var fx = CubicCurve2D.solveEqn(eqn, 3, x);
                        if (CubicCurve2D.iszero(fx, 10000000 * javaemul.internal.MathHelper.ulp(x))) {
                            var badRootVal = CubicCurve2D.solveEqn(eqn, 3, badRoot);
                            res[1] = Math.abs(badRootVal) < Math.abs(fx) ? badRoot : x;
                            return 2;
                        }
                    }
                    return 1;
                };
                CubicCurve2D.refineRootWithHint = function (eqn, min, max, t) {
                    if (!CubicCurve2D.inInterval(t, min, max)) {
                        return t;
                    }
                    var deriv = [eqn[1], 2 * eqn[2], 3 * eqn[3]];
                    var origt = t;
                    for (var i = 0; i < 3; i++) {
                        var slope = CubicCurve2D.solveEqn(deriv, 2, t);
                        var y = CubicCurve2D.solveEqn(eqn, 3, t);
                        var delta = -(y / slope);
                        var newt = t + delta;
                        if (slope === 0 || y === 0 || t === newt) {
                            break;
                        }
                        t = newt;
                    }
                    if (CubicCurve2D.within(t, origt, 1000 * javaemul.internal.MathHelper.ulp(origt)) && CubicCurve2D.inInterval(t, min, max)) {
                        return t;
                    }
                    return origt;
                };
                CubicCurve2D.bisectRootWithHint = function (eqn, x0, xe, hint) {
                    var delta1 = Math.min(Math.abs(hint - x0) / 64, 0.0625);
                    var delta2 = Math.min(Math.abs(hint - xe) / 64, 0.0625);
                    var x02 = hint - delta1;
                    var xe2 = hint + delta2;
                    var fx02 = CubicCurve2D.solveEqn(eqn, 3, x02);
                    var fxe2 = CubicCurve2D.solveEqn(eqn, 3, xe2);
                    while ((CubicCurve2D.oppositeSigns(fx02, fxe2))) {
                        if (x02 >= xe2) {
                            return x02;
                        }
                        x0 = x02;
                        xe = xe2;
                        delta1 /= 64;
                        delta2 /= 64;
                        x02 = hint - delta1;
                        xe2 = hint + delta2;
                        fx02 = CubicCurve2D.solveEqn(eqn, 3, x02);
                        fxe2 = CubicCurve2D.solveEqn(eqn, 3, xe2);
                    }
                    ;
                    if (fx02 === 0) {
                        return x02;
                    }
                    if (fxe2 === 0) {
                        return xe2;
                    }
                    return CubicCurve2D.bisectRoot(eqn, x0, xe);
                };
                CubicCurve2D.bisectRoot = function (eqn, x0, xe) {
                    var fx0 = CubicCurve2D.solveEqn(eqn, 3, x0);
                    var m = x0 + (xe - x0) / 2;
                    while ((m !== x0 && m !== xe)) {
                        var fm = CubicCurve2D.solveEqn(eqn, 3, m);
                        if (fm === 0) {
                            return m;
                        }
                        if (CubicCurve2D.oppositeSigns(fx0, fm)) {
                            xe = m;
                        }
                        else {
                            fx0 = fm;
                            x0 = m;
                        }
                        m = x0 + (xe - x0) / 2;
                    }
                    ;
                    return m;
                };
                CubicCurve2D.inInterval = function (t, min, max) {
                    return min <= t && t <= max;
                };
                CubicCurve2D.within = function (x, y, err) {
                    var d = y - x;
                    return (d <= err && d >= -err);
                };
                CubicCurve2D.iszero = function (x, err) {
                    return CubicCurve2D.within(x, 0, err);
                };
                CubicCurve2D.oppositeSigns = function (x1, x2) {
                    return (x1 < 0 && x2 > 0) || (x1 > 0 && x2 < 0);
                };
                CubicCurve2D.solveEqn = function (eqn, order, t) {
                    var v = eqn[order];
                    while ((--order >= 0)) {
                        v = v * t + eqn[order];
                    }
                    ;
                    return v;
                };
                CubicCurve2D.getRootUpperBound = function (eqn) {
                    var d = eqn[3];
                    var a = eqn[2];
                    var b = eqn[1];
                    var c = eqn[0];
                    var M = 1 + Math.max(Math.max(Math.abs(a), Math.abs(b)), Math.abs(c)) / Math.abs(d);
                    M += javaemul.internal.MathHelper.ulp(M) + 1;
                    return M;
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                CubicCurve2D.prototype.contains$double$double = function (x, y) {
                    if (!(x * 0.0 + y * 0.0 === 0.0)) {
                        return false;
                    }
                    var x1 = this.getX1();
                    var y1 = this.getY1();
                    var x2 = this.getX2();
                    var y2 = this.getY2();
                    var crossings = (sun.awt.geom.Curve.pointCrossingsForLine(x, y, x1, y1, x2, y2) + sun.awt.geom.Curve.pointCrossingsForCubic(x, y, x1, y1, this.getCtrlX1(), this.getCtrlY1(), this.getCtrlX2(), this.getCtrlY2(), x2, y2, 0));
                    return ((crossings & 1) === 1);
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                CubicCurve2D.prototype.contains$java_awt_geom_Point2D = function (p) {
                    return this.contains(p.getX(), p.getY());
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                CubicCurve2D.prototype.intersects = function (x, y, w, h) {
                    var _this = this;
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return (function () {
                            if (w <= 0 || h <= 0) {
                                return false;
                            }
                            var numCrossings = _this.rectCrossings(x, y, w, h);
                            return numCrossings !== 0;
                        })();
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.intersects$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                CubicCurve2D.prototype.intersects$java_awt_geom_Rectangle2D = function (r) {
                    return this.intersects(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                CubicCurve2D.prototype.contains = function (x, y, w, h) {
                    var _this = this;
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return (function () {
                            if (w <= 0 || h <= 0) {
                                return false;
                            }
                            var numCrossings = _this.rectCrossings(x, y, w, h);
                            return !(numCrossings === 0 || numCrossings === sun.awt.geom.Curve.RECT_INTERSECTS);
                        })();
                    }
                    else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined) {
                        return this.contains$double$double(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Point2D(x);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                CubicCurve2D.prototype.rectCrossings = function (x, y, w, h) {
                    var crossings = 0;
                    if (!(this.getX1() === this.getX2() && this.getY1() === this.getY2())) {
                        crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, x, y, x + w, y + h, this.getX1(), this.getY1(), this.getX2(), this.getY2());
                        if (crossings === sun.awt.geom.Curve.RECT_INTERSECTS) {
                            return crossings;
                        }
                    }
                    return sun.awt.geom.Curve.rectCrossingsForCubic(crossings, x, y, x + w, y + h, this.getX2(), this.getY2(), this.getCtrlX2(), this.getCtrlY2(), this.getCtrlX1(), this.getCtrlY1(), this.getX1(), this.getY1(), 0);
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                CubicCurve2D.prototype.contains$java_awt_geom_Rectangle2D = function (r) {
                    return this.contains(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                CubicCurve2D.prototype.getBounds = function () {
                    return this.getBounds2D().getBounds();
                };
                /**
                 * Returns an iteration object that defines the boundary of the shape. The
                 * iterator for this class is not multi-threaded safe, which means that this
                 * <code>CubicCurve2D</code> class does not guarantee that modifications to
                 * the geometry of this <code>CubicCurve2D</code> object do not affect any
                 * iterations of that geometry that are already in process.
                 *
                 * @param at
                 * an optional <code>AffineTransform</code> to be applied to the
                 * coordinates as they are returned in the iteration, or
                 * <code>null</code> if untransformed coordinates are desired
                 * @return the <code>PathIterator</code> object that returns the geometry of
                 * the outline of this <code>CubicCurve2D</code>, one segment at a
                 * time.
                 * @since 1.2
                 */
                CubicCurve2D.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
                    return new java.awt.geom.CubicIterator(this, at);
                };
                /**
                 * Return an iteration object that defines the boundary of the flattened
                 * shape. The iterator for this class is not multi-threaded safe, which
                 * means that this <code>CubicCurve2D</code> class does not guarantee that
                 * modifications to the geometry of this <code>CubicCurve2D</code> object do
                 * not affect any iterations of that geometry that are already in process.
                 *
                 * @param at
                 * an optional <code>AffineTransform</code> to be applied to the
                 * coordinates as they are returned in the iteration, or
                 * <code>null</code> if untransformed coordinates are desired
                 * @param flatness
                 * the maximum amount that the control points for a given curve
                 * can vary from colinear before a subdivided curve is replaced
                 * by a straight line connecting the end points
                 * @return the <code>PathIterator</code> object that returns the geometry of
                 * the outline of this <code>CubicCurve2D</code>, one segment at a
                 * time.
                 * @since 1.2
                 */
                CubicCurve2D.prototype.getPathIterator = function (at, flatness) {
                    var _this = this;
                    if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
                        return (function () {
                            return new java.awt.geom.FlatteningPathIterator(_this.getPathIterator(at), flatness);
                        })();
                    }
                    else if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && flatness === undefined) {
                        return this.getPathIterator$java_awt_geom_AffineTransform(at);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Creates a new object of the same class as this object.
                 *
                 * @return a clone of this instance.
                 * @exception OutOfMemoryError
                 * if there is not enough memory.
                 * @see java.lang.Cloneable
                 * @since 1.2
                 */
                CubicCurve2D.prototype.clone = function () {
                    try {
                        return javaemul.internal.ObjectHelper.clone(this);
                    }
                    catch (e) {
                        throw new java.lang.InternalError(e);
                    }
                    ;
                };
                return CubicCurve2D;
            }());
            geom.CubicCurve2D = CubicCurve2D;
            var CubicCurve2D;
            (function (CubicCurve2D) {
                /**
                 * A cubic parametric curve segment specified with {@code float}
                 * coordinates.
                 *
                 * @since 1.2
                 */
                var Float = (function (_super) {
                    __extends(Float, _super);
                    /**
                     * Constructs and initializes a {@code CubicCurve2D} from the specified
                     * {@code float} coordinates.
                     *
                     * @param x1
                     * the X coordinate for the start point of the resulting
                     * {@code CubicCurve2D}
                     * @param y1
                     * the Y coordinate for the start point of the resulting
                     * {@code CubicCurve2D}
                     * @param ctrlx1
                     * the X coordinate for the first control point of the
                     * resulting {@code CubicCurve2D}
                     * @param ctrly1
                     * the Y coordinate for the first control point of the
                     * resulting {@code CubicCurve2D}
                     * @param ctrlx2
                     * the X coordinate for the second control point of the
                     * resulting {@code CubicCurve2D}
                     * @param ctrly2
                     * the Y coordinate for the second control point of the
                     * resulting {@code CubicCurve2D}
                     * @param x2
                     * the X coordinate for the end point of the resulting
                     * {@code CubicCurve2D}
                     * @param y2
                     * the Y coordinate for the end point of the resulting
                     * {@code CubicCurve2D}
                     * @since 1.2
                     */
                    function Float(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
                        var _this = this;
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx1 === 'number') || ctrlx1 === null) && ((typeof ctrly1 === 'number') || ctrly1 === null) && ((typeof ctrlx2 === 'number') || ctrlx2 === null) && ((typeof ctrly2 === 'number') || ctrly2 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x1 = 0;
                            this.y1 = 0;
                            this.ctrlx1 = 0;
                            this.ctrly1 = 0;
                            this.ctrlx2 = 0;
                            this.ctrly2 = 0;
                            this.x2 = 0;
                            this.y2 = 0;
                            (function () {
                                _this.setCurve(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2);
                            })();
                        }
                        else if (x1 === undefined && y1 === undefined && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x1 = 0;
                            this.y1 = 0;
                            this.ctrlx1 = 0;
                            this.ctrly1 = 0;
                            this.ctrlx2 = 0;
                            this.ctrly2 = 0;
                            this.x2 = 0;
                            this.y2 = 0;
                            (function () {
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getX1 = function () {
                        return this.x1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getY1 = function () {
                        return this.y1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getP1 = function () {
                        return new java.awt.geom.Point2D.Float(this.x1, this.y1);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getCtrlX1 = function () {
                        return this.ctrlx1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getCtrlY1 = function () {
                        return this.ctrly1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getCtrlP1 = function () {
                        return new java.awt.geom.Point2D.Float(this.ctrlx1, this.ctrly1);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getCtrlX2 = function () {
                        return this.ctrlx2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getCtrlY2 = function () {
                        return this.ctrly2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getCtrlP2 = function () {
                        return new java.awt.geom.Point2D.Float(this.ctrlx2, this.ctrly2);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getX2 = function () {
                        return this.x2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getY2 = function () {
                        return this.y2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getP2 = function () {
                        return new java.awt.geom.Point2D.Float(this.x2, this.y2);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.setCurve$double$double$double$double$double$double$double$double = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
                        this.x1 = x1;
                        this.y1 = y1;
                        this.ctrlx1 = ctrlx1;
                        this.ctrly1 = ctrly1;
                        this.ctrlx2 = ctrlx2;
                        this.ctrly2 = ctrly2;
                        this.x2 = x2;
                        this.y2 = y2;
                    };
                    /**
                     * Sets the location of the end points and control points of this curve
                     * to the specified {@code float} coordinates.
                     *
                     * @param x1
                     * the X coordinate used to set the start point of this
                     * {@code CubicCurve2D}
                     * @param y1
                     * the Y coordinate used to set the start point of this
                     * {@code CubicCurve2D}
                     * @param ctrlx1
                     * the X coordinate used to set the first control point of
                     * this {@code CubicCurve2D}
                     * @param ctrly1
                     * the Y coordinate used to set the first control point of
                     * this {@code CubicCurve2D}
                     * @param ctrlx2
                     * the X coordinate used to set the second control point of
                     * this {@code CubicCurve2D}
                     * @param ctrly2
                     * the Y coordinate used to set the second control point of
                     * this {@code CubicCurve2D}
                     * @param x2
                     * the X coordinate used to set the end point of this
                     * {@code CubicCurve2D}
                     * @param y2
                     * the Y coordinate used to set the end point of this
                     * {@code CubicCurve2D}
                     * @since 1.2
                     */
                    Float.prototype.setCurve = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
                        var _this = this;
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx1 === 'number') || ctrlx1 === null) && ((typeof ctrly1 === 'number') || ctrly1 === null) && ((typeof ctrlx2 === 'number') || ctrlx2 === null) && ((typeof ctrly2 === 'number') || ctrly2 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            return (function () {
                                _this.x1 = x1;
                                _this.y1 = y1;
                                _this.ctrlx1 = ctrlx1;
                                _this.ctrly1 = ctrly1;
                                _this.ctrlx2 = ctrlx2;
                                _this.ctrly2 = ctrly2;
                                _this.x2 = x2;
                                _this.y2 = y2;
                            })();
                        }
                        else if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx1 === 'number') || ctrlx1 === null) && ((typeof ctrly1 === 'number') || ctrly1 === null) && ((typeof ctrlx2 === 'number') || ctrlx2 === null) && ((typeof ctrly2 === 'number') || ctrly2 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            return this.setCurve$double$double$double$double$double$double$double$double(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && ((ctrlx1 != null && ctrlx1 instanceof java.awt.geom.Point2D) || ctrlx1 === null) && ((ctrly1 != null && ctrly1 instanceof java.awt.geom.Point2D) || ctrly1 === null) && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1, ctrlx1, ctrly1);
                        }
                        else if (((x1 != null && x1 instanceof Array) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$double_A$int(x1, y1);
                        }
                        else if (((x1 != null && x1 instanceof Array) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_Point2D_A$int(x1, y1);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.CubicCurve2D) || x1 === null) && y1 === undefined && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_CubicCurve2D(x1);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getBounds2D = function () {
                        var left = Math.min(Math.min(this.x1, this.x2), Math.min(this.ctrlx1, this.ctrlx2));
                        var top = Math.min(Math.min(this.y1, this.y2), Math.min(this.ctrly1, this.ctrly2));
                        var right = Math.max(Math.max(this.x1, this.x2), Math.max(this.ctrlx1, this.ctrlx2));
                        var bottom = Math.max(Math.max(this.y1, this.y2), Math.max(this.ctrly1, this.ctrly2));
                        return new java.awt.geom.Rectangle2D.Float(left, top, right - left, bottom - top);
                    };
                    Float.serialVersionUID = -1272015596714244385;
                    return Float;
                }(java.awt.geom.CubicCurve2D));
                CubicCurve2D.Float = Float;
                /**
                 * A cubic parametric curve segment specified with {@code double}
                 * coordinates.
                 *
                 * @since 1.2
                 */
                var Double = (function (_super) {
                    __extends(Double, _super);
                    /**
                     * Constructs and initializes a {@code CubicCurve2D} from the specified
                     * {@code double} coordinates.
                     *
                     * @param x1
                     * the X coordinate for the start point of the resulting
                     * {@code CubicCurve2D}
                     * @param y1
                     * the Y coordinate for the start point of the resulting
                     * {@code CubicCurve2D}
                     * @param ctrlx1
                     * the X coordinate for the first control point of the
                     * resulting {@code CubicCurve2D}
                     * @param ctrly1
                     * the Y coordinate for the first control point of the
                     * resulting {@code CubicCurve2D}
                     * @param ctrlx2
                     * the X coordinate for the second control point of the
                     * resulting {@code CubicCurve2D}
                     * @param ctrly2
                     * the Y coordinate for the second control point of the
                     * resulting {@code CubicCurve2D}
                     * @param x2
                     * the X coordinate for the end point of the resulting
                     * {@code CubicCurve2D}
                     * @param y2
                     * the Y coordinate for the end point of the resulting
                     * {@code CubicCurve2D}
                     * @since 1.2
                     */
                    function Double(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
                        var _this = this;
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx1 === 'number') || ctrlx1 === null) && ((typeof ctrly1 === 'number') || ctrly1 === null) && ((typeof ctrlx2 === 'number') || ctrlx2 === null) && ((typeof ctrly2 === 'number') || ctrly2 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x1 = 0;
                            this.y1 = 0;
                            this.ctrlx1 = 0;
                            this.ctrly1 = 0;
                            this.ctrlx2 = 0;
                            this.ctrly2 = 0;
                            this.x2 = 0;
                            this.y2 = 0;
                            (function () {
                                _this.setCurve(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2);
                            })();
                        }
                        else if (x1 === undefined && y1 === undefined && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x1 = 0;
                            this.y1 = 0;
                            this.ctrlx1 = 0;
                            this.ctrly1 = 0;
                            this.ctrlx2 = 0;
                            this.ctrly2 = 0;
                            this.x2 = 0;
                            this.y2 = 0;
                            (function () {
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getX1 = function () {
                        return this.x1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getY1 = function () {
                        return this.y1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getP1 = function () {
                        return new java.awt.geom.Point2D.Double(this.x1, this.y1);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getCtrlX1 = function () {
                        return this.ctrlx1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getCtrlY1 = function () {
                        return this.ctrly1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getCtrlP1 = function () {
                        return new java.awt.geom.Point2D.Double(this.ctrlx1, this.ctrly1);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getCtrlX2 = function () {
                        return this.ctrlx2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getCtrlY2 = function () {
                        return this.ctrly2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getCtrlP2 = function () {
                        return new java.awt.geom.Point2D.Double(this.ctrlx2, this.ctrly2);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getX2 = function () {
                        return this.x2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getY2 = function () {
                        return this.y2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getP2 = function () {
                        return new java.awt.geom.Point2D.Double(this.x2, this.y2);
                    };
                    /**
                     * Sets the location of the end points and control points of this curve
                     * to the specified {@code float} coordinates.
                     *
                     * @param x1
                     * the X coordinate used to set the start point of this
                     * {@code CubicCurve2D}
                     * @param y1
                     * the Y coordinate used to set the start point of this
                     * {@code CubicCurve2D}
                     * @param ctrlx1
                     * the X coordinate used to set the first control point of
                     * this {@code CubicCurve2D}
                     * @param ctrly1
                     * the Y coordinate used to set the first control point of
                     * this {@code CubicCurve2D}
                     * @param ctrlx2
                     * the X coordinate used to set the second control point of
                     * this {@code CubicCurve2D}
                     * @param ctrly2
                     * the Y coordinate used to set the second control point of
                     * this {@code CubicCurve2D}
                     * @param x2
                     * the X coordinate used to set the end point of this
                     * {@code CubicCurve2D}
                     * @param y2
                     * the Y coordinate used to set the end point of this
                     * {@code CubicCurve2D}
                     * @since 1.2
                     */
                    Double.prototype.setCurve = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx1 === 'number') || ctrlx1 === null) && ((typeof ctrly1 === 'number') || ctrly1 === null) && ((typeof ctrlx2 === 'number') || ctrlx2 === null) && ((typeof ctrly2 === 'number') || ctrly2 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            return this.setCurve$double$double$double$double$double$double$double$double(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && ((ctrlx1 != null && ctrlx1 instanceof java.awt.geom.Point2D) || ctrlx1 === null) && ((ctrly1 != null && ctrly1 instanceof java.awt.geom.Point2D) || ctrly1 === null) && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1, ctrlx1, ctrly1);
                        }
                        else if (((x1 != null && x1 instanceof Array) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$double_A$int(x1, y1);
                        }
                        else if (((x1 != null && x1 instanceof Array) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_Point2D_A$int(x1, y1);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.CubicCurve2D) || x1 === null) && y1 === undefined && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_CubicCurve2D(x1);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.setCurve$double$double$double$double$double$double$double$double = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
                        this.x1 = x1;
                        this.y1 = y1;
                        this.ctrlx1 = ctrlx1;
                        this.ctrly1 = ctrly1;
                        this.ctrlx2 = ctrlx2;
                        this.ctrly2 = ctrly2;
                        this.x2 = x2;
                        this.y2 = y2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getBounds2D = function () {
                        var left = Math.min(Math.min(this.x1, this.x2), Math.min(this.ctrlx1, this.ctrlx2));
                        var top = Math.min(Math.min(this.y1, this.y2), Math.min(this.ctrly1, this.ctrly2));
                        var right = Math.max(Math.max(this.x1, this.x2), Math.max(this.ctrlx1, this.ctrlx2));
                        var bottom = Math.max(Math.max(this.y1, this.y2), Math.max(this.ctrly1, this.ctrly2));
                        return new java.awt.geom.Rectangle2D.Double(left, top, right - left, bottom - top);
                    };
                    Double.serialVersionUID = -4202960122839707295;
                    return Double;
                }(java.awt.geom.CubicCurve2D));
                CubicCurve2D.Double = Double;
            })(CubicCurve2D = geom.CubicCurve2D || (geom.CubicCurve2D = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * A utility class to iterate over the path segments of a cubic curve segment
             * through the PathIterator interface.
             *
             * @author Jim Graham
             */
            var CubicIterator = (function () {
                function CubicIterator(q, at) {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.geom.PathIterator"] });
                    this.index = 0;
                    this.cubic = q;
                    this.affine = at;
                }
                /**
                 * Return the winding rule for determining the insideness of the path.
                 *
                 * @see #WIND_EVEN_ODD
                 * @see #WIND_NON_ZERO
                 */
                CubicIterator.prototype.getWindingRule = function () {
                    return java.awt.geom.PathIterator.WIND_NON_ZERO;
                };
                /**
                 * Tests if there are more points to read.
                 *
                 * @return true if there are more points to read
                 */
                CubicIterator.prototype.isDone = function () {
                    return (this.index > 1);
                };
                /**
                 * Moves the iterator to the next segment of the path forwards along the
                 * primary direction of traversal as long as there are more points in that
                 * direction.
                 */
                CubicIterator.prototype.next = function () {
                    this.index++;
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of float x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 */
                CubicIterator.prototype.currentSegment = function (coords) {
                    var _this = this;
                    if (((coords != null && coords instanceof Array) || coords === null)) {
                        return (function () {
                            if (_this.isDone()) {
                                throw new java.util.NoSuchElementException("cubic iterator iterator out of bounds");
                            }
                            var type;
                            if (_this.index === 0) {
                                coords[0] = _this.cubic.getX1();
                                coords[1] = _this.cubic.getY1();
                                type = java.awt.geom.PathIterator.SEG_MOVETO;
                            }
                            else {
                                coords[0] = _this.cubic.getCtrlX1();
                                coords[1] = _this.cubic.getCtrlY1();
                                coords[2] = _this.cubic.getCtrlX2();
                                coords[3] = _this.cubic.getCtrlY2();
                                coords[4] = _this.cubic.getX2();
                                coords[5] = _this.cubic.getY2();
                                type = java.awt.geom.PathIterator.SEG_CUBICTO;
                            }
                            if (_this.affine != null) {
                                _this.affine.transform(coords, 0, coords, 0, _this.index === 0 ? 1 : 3);
                            }
                            return type;
                        })();
                    }
                    else if (((coords != null && coords instanceof Array) || coords === null)) {
                        return this.currentSegment$double_A(coords);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A double array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of double x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 */
                CubicIterator.prototype.currentSegment$double_A = function (coords) {
                    if (this.isDone()) {
                        throw new java.util.NoSuchElementException("cubic iterator iterator out of bounds");
                    }
                    var type;
                    if (this.index === 0) {
                        coords[0] = this.cubic.getX1();
                        coords[1] = this.cubic.getY1();
                        type = java.awt.geom.PathIterator.SEG_MOVETO;
                    }
                    else {
                        coords[0] = this.cubic.getCtrlX1();
                        coords[1] = this.cubic.getCtrlY1();
                        coords[2] = this.cubic.getCtrlX2();
                        coords[3] = this.cubic.getCtrlY2();
                        coords[4] = this.cubic.getX2();
                        coords[5] = this.cubic.getY2();
                        type = java.awt.geom.PathIterator.SEG_CUBICTO;
                    }
                    if (this.affine != null) {
                        this.affine.transform(coords, 0, coords, 0, this.index === 0 ? 1 : 3);
                    }
                    return type;
                };
                return CubicIterator;
            }());
            geom.CubicIterator = CubicIterator;
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The <code>Dimension2D</code> class is to encapsulate a width and a height
             * dimension.
             * <p>
             * This class is only the abstract superclass for all objects that store a 2D
             * dimension. The actual storage representation of the sizes is left to the
             * subclass.
             *
             * @author Jim Graham
             * @since 1.2
             */
            var Dimension2D = (function () {
                /**
                 * This is an abstract class that cannot be instantiated directly.
                 * Type-specific implementation subclasses are available for instantiation
                 * and provide a number of formats for storing the information necessary to
                 * satisfy the various accessor methods below.
                 *
                 * @see java.awt.Dimension
                 * @since 1.2
                 */
                function Dimension2D() {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable"] });
                }
                Dimension2D.prototype.setSize = function (width, height) {
                    if (((typeof width === 'number') || width === null) && ((typeof height === 'number') || height === null)) {
                        return this.setSize$double$double(width, height);
                    }
                    else if (((width != null && width instanceof java.awt.geom.Dimension2D) || width === null) && height === undefined) {
                        return this.setSize$java_awt_geom_Dimension2D(width);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets the size of this <code>Dimension</code> object to the specified
                 * width and height. This method is included for completeness, to parallel
                 * the {@link java.awt.Component#getSize getSize} method of
                 * {@link java.awt.Component}.
                 *
                 * @param width
                 * the new width for the <code>Dimension</code> object
                 * @param height
                 * the new height for the <code>Dimension</code> object
                 * @since 1.2
                 */
                Dimension2D.prototype.setSize$double$double = function (width, height) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Sets the size of this <code>Dimension2D</code> object to match the
                 * specified size. This method is included for completeness, to parallel the
                 * <code>getSize</code> method of <code>Component</code>.
                 *
                 * @param d
                 * the new size for the <code>Dimension2D</code> object
                 * @since 1.2
                 */
                Dimension2D.prototype.setSize$java_awt_geom_Dimension2D = function (d) {
                    this.setSize(d.getWidth(), d.getHeight());
                };
                /**
                 * Creates a new object of the same class as this object.
                 *
                 * @return a clone of this instance.
                 * @exception OutOfMemoryError
                 * if there is not enough memory.
                 * @see java.lang.Cloneable
                 * @since 1.2
                 */
                Dimension2D.prototype.clone = function () {
                    try {
                        return javaemul.internal.ObjectHelper.clone(this);
                    }
                    catch (e) {
                        throw new java.lang.InternalError(e);
                    }
                    ;
                };
                return Dimension2D;
            }());
            geom.Dimension2D = Dimension2D;
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * A utility class to iterate over the path segments of an ellipse through the
             * PathIterator interface.
             *
             * @author Jim Graham
             */
            var EllipseIterator = (function () {
                function EllipseIterator(e, at) {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.geom.PathIterator"] });
                    this.x = 0;
                    this.y = 0;
                    this.w = 0;
                    this.h = 0;
                    this.index = 0;
                    this.x = e.getX();
                    this.y = e.getY();
                    this.w = e.getWidth();
                    this.h = e.getHeight();
                    this.affine = at;
                    if (this.w < 0 || this.h < 0) {
                        this.index = 6;
                    }
                }
                /**
                 * Return the winding rule for determining the insideness of the path.
                 *
                 * @see #WIND_EVEN_ODD
                 * @see #WIND_NON_ZERO
                 */
                EllipseIterator.prototype.getWindingRule = function () {
                    return java.awt.geom.PathIterator.WIND_NON_ZERO;
                };
                /**
                 * Tests if there are more points to read.
                 *
                 * @return true if there are more points to read
                 */
                EllipseIterator.prototype.isDone = function () {
                    return this.index > 5;
                };
                /**
                 * Moves the iterator to the next segment of the path forwards along the
                 * primary direction of traversal as long as there are more points in that
                 * direction.
                 */
                EllipseIterator.prototype.next = function () {
                    this.index++;
                };
                EllipseIterator.pcv_$LI$ = function () { if (EllipseIterator.pcv == null)
                    EllipseIterator.pcv = 0.5 + EllipseIterator.CtrlVal * 0.5; return EllipseIterator.pcv; };
                ;
                EllipseIterator.ncv_$LI$ = function () { if (EllipseIterator.ncv == null)
                    EllipseIterator.ncv = 0.5 - EllipseIterator.CtrlVal * 0.5; return EllipseIterator.ncv; };
                ;
                EllipseIterator.ctrlpts_$LI$ = function () { if (EllipseIterator.ctrlpts == null)
                    EllipseIterator.ctrlpts = [[1.0, EllipseIterator.pcv_$LI$(), EllipseIterator.pcv_$LI$(), 1.0, 0.5, 1.0], [EllipseIterator.ncv_$LI$(), 1.0, 0.0, EllipseIterator.pcv_$LI$(), 0.0, 0.5], [0.0, EllipseIterator.ncv_$LI$(), EllipseIterator.ncv_$LI$(), 0.0, 0.5, 0.0], [EllipseIterator.pcv_$LI$(), 0.0, 1.0, EllipseIterator.ncv_$LI$(), 1.0, 0.5]]; return EllipseIterator.ctrlpts; };
                ;
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of float x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 */
                EllipseIterator.prototype.currentSegment = function (coords) {
                    var _this = this;
                    if (((coords != null && coords instanceof Array) || coords === null)) {
                        return (function () {
                            if (_this.isDone()) {
                                throw new java.util.NoSuchElementException("ellipse iterator out of bounds");
                            }
                            if (_this.index === 5) {
                                return java.awt.geom.PathIterator.SEG_CLOSE;
                            }
                            if (_this.index === 0) {
                                var ctrls = EllipseIterator.ctrlpts_$LI$()[3];
                                coords[0] = (_this.x + ctrls[4] * _this.w);
                                coords[1] = (_this.y + ctrls[5] * _this.h);
                                if (_this.affine != null) {
                                    _this.affine.transform(coords, 0, coords, 0, 1);
                                }
                                return java.awt.geom.PathIterator.SEG_MOVETO;
                            }
                            var ctrls = EllipseIterator.ctrlpts_$LI$()[_this.index - 1];
                            coords[0] = (_this.x + ctrls[0] * _this.w);
                            coords[1] = (_this.y + ctrls[1] * _this.h);
                            coords[2] = (_this.x + ctrls[2] * _this.w);
                            coords[3] = (_this.y + ctrls[3] * _this.h);
                            coords[4] = (_this.x + ctrls[4] * _this.w);
                            coords[5] = (_this.y + ctrls[5] * _this.h);
                            if (_this.affine != null) {
                                _this.affine.transform(coords, 0, coords, 0, 3);
                            }
                            return java.awt.geom.PathIterator.SEG_CUBICTO;
                        })();
                    }
                    else if (((coords != null && coords instanceof Array) || coords === null)) {
                        return this.currentSegment$double_A(coords);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A double array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of double x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 */
                EllipseIterator.prototype.currentSegment$double_A = function (coords) {
                    if (this.isDone()) {
                        throw new java.util.NoSuchElementException("ellipse iterator out of bounds");
                    }
                    if (this.index === 5) {
                        return java.awt.geom.PathIterator.SEG_CLOSE;
                    }
                    if (this.index === 0) {
                        var ctrls = EllipseIterator.ctrlpts_$LI$()[3];
                        coords[0] = this.x + ctrls[4] * this.w;
                        coords[1] = this.y + ctrls[5] * this.h;
                        if (this.affine != null) {
                            this.affine.transform(coords, 0, coords, 0, 1);
                        }
                        return java.awt.geom.PathIterator.SEG_MOVETO;
                    }
                    var ctrls = EllipseIterator.ctrlpts_$LI$()[this.index - 1];
                    coords[0] = this.x + ctrls[0] * this.w;
                    coords[1] = this.y + ctrls[1] * this.h;
                    coords[2] = this.x + ctrls[2] * this.w;
                    coords[3] = this.y + ctrls[3] * this.h;
                    coords[4] = this.x + ctrls[4] * this.w;
                    coords[5] = this.y + ctrls[5] * this.h;
                    if (this.affine != null) {
                        this.affine.transform(coords, 0, coords, 0, 3);
                    }
                    return java.awt.geom.PathIterator.SEG_CUBICTO;
                };
                EllipseIterator.CtrlVal = 0.5522847498307933;
                return EllipseIterator;
            }());
            geom.EllipseIterator = EllipseIterator;
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The <code>FlatteningPathIterator</code> class returns a flattened view of
             * another {@link PathIterator} object. Other {@link java.awt.Shape Shape}
             * classes can use this class to provide flattening behavior for their paths
             * without having to perform the interpolation calculations themselves.
             *
             * @author Jim Graham
             */
            var FlatteningPathIterator = (function () {
                /**
                 * Constructs a new <code>FlatteningPathIterator</code> object that flattens
                 * a path as it iterates over it. The <code>limit</code> parameter allows
                 * you to control the maximum number of recursive subdivisions that the
                 * iterator can make before it assumes that the curve is flat enough without
                 * measuring against the <code>flatness</code> parameter. The flattened
                 * iteration therefore never generates more than a maximum of
                 * <code>(2^limit)</code> line segments per curve.
                 *
                 * @param src
                 * the original unflattened path being iterated over
                 * @param flatness
                 * the maximum allowable distance between the control points and
                 * the flattened curve
                 * @param limit
                 * the maximum number of recursive subdivisions allowed for any
                 * curved segment
                 * @exception IllegalArgumentException
                 * if <code>flatness</code> or <code>limit</code> is less
                 * than zero
                 */
                function FlatteningPathIterator(src, flatness, limit) {
                    if (limit === void 0) { limit = 10; }
                    this.hold = new Array(14);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.geom.PathIterator"] });
                    this.squareflat = 0;
                    this.limit = 0;
                    this.curx = 0;
                    this.cury = 0;
                    this.movx = 0;
                    this.movy = 0;
                    this.holdType = 0;
                    this.holdEnd = 0;
                    this.holdIndex = 0;
                    this.levelIndex = 0;
                    this.done = false;
                    if (flatness < 0.0) {
                        throw new java.lang.IllegalArgumentException("flatness must be >= 0");
                    }
                    if (limit < 0) {
                        throw new java.lang.IllegalArgumentException("limit must be >= 0");
                    }
                    this.src = src;
                    this.squareflat = flatness * flatness;
                    this.limit = limit;
                    this.levels = new Array(limit + 1);
                    this.next(false);
                }
                /**
                 * Returns the flatness of this iterator.
                 *
                 * @return the flatness of this <code>FlatteningPathIterator</code>.
                 */
                FlatteningPathIterator.prototype.getFlatness = function () {
                    return Math.sqrt(this.squareflat);
                };
                /**
                 * Returns the recursion limit of this iterator.
                 *
                 * @return the recursion limit of this <code>FlatteningPathIterator</code>.
                 */
                FlatteningPathIterator.prototype.getRecursionLimit = function () {
                    return this.limit;
                };
                /**
                 * Returns the winding rule for determining the interior of the path.
                 *
                 * @return the winding rule of the original unflattened path being iterated
                 * over.
                 * @see PathIterator#WIND_EVEN_ODD
                 * @see PathIterator#WIND_NON_ZERO
                 */
                FlatteningPathIterator.prototype.getWindingRule = function () {
                    return this.src.getWindingRule();
                };
                /**
                 * Tests if the iteration is complete.
                 *
                 * @return <code>true</code> if all the segments have been read;
                 * <code>false</code> otherwise.
                 */
                FlatteningPathIterator.prototype.isDone = function () {
                    return this.done;
                };
                FlatteningPathIterator.prototype.ensureHoldCapacity = function (want) {
                    if (this.holdIndex - want < 0) {
                        var have = this.hold.length - this.holdIndex;
                        var newsize = this.hold.length + FlatteningPathIterator.GROW_SIZE;
                        var newhold = new Array(newsize);
                        java.lang.System.arraycopy(this.hold, this.holdIndex, newhold, this.holdIndex + FlatteningPathIterator.GROW_SIZE, have);
                        this.hold = newhold;
                        this.holdIndex += FlatteningPathIterator.GROW_SIZE;
                        this.holdEnd += FlatteningPathIterator.GROW_SIZE;
                    }
                };
                /**
                 * Moves the iterator to the next segment of the path forwards along the
                 * primary direction of traversal as long as there are more points in that
                 * direction.
                 */
                FlatteningPathIterator.prototype.next$ = function () {
                    this.next(true);
                };
                FlatteningPathIterator.prototype.next = function (doNext) {
                    var _this = this;
                    if (((typeof doNext === 'boolean') || doNext === null)) {
                        return (function () {
                            var level;
                            if (_this.holdIndex >= _this.holdEnd) {
                                if (doNext) {
                                    _this.src.next();
                                }
                                if (_this.src.isDone()) {
                                    _this.done = true;
                                    return;
                                }
                                _this.holdType = _this.src.currentSegment(_this.hold);
                                _this.levelIndex = 0;
                                _this.levels[0] = 0;
                            }
                            switch ((_this.holdType)) {
                                case java.awt.geom.PathIterator.SEG_MOVETO:
                                case java.awt.geom.PathIterator.SEG_LINETO:
                                    _this.curx = _this.hold[0];
                                    _this.cury = _this.hold[1];
                                    if (_this.holdType === java.awt.geom.PathIterator.SEG_MOVETO) {
                                        _this.movx = _this.curx;
                                        _this.movy = _this.cury;
                                    }
                                    _this.holdIndex = 0;
                                    _this.holdEnd = 0;
                                    break;
                                case java.awt.geom.PathIterator.SEG_CLOSE:
                                    _this.curx = _this.movx;
                                    _this.cury = _this.movy;
                                    _this.holdIndex = 0;
                                    _this.holdEnd = 0;
                                    break;
                                case java.awt.geom.PathIterator.SEG_QUADTO:
                                    if (_this.holdIndex >= _this.holdEnd) {
                                        _this.holdIndex = _this.hold.length - 6;
                                        _this.holdEnd = _this.hold.length - 2;
                                        _this.hold[_this.holdIndex + 0] = _this.curx;
                                        _this.hold[_this.holdIndex + 1] = _this.cury;
                                        _this.hold[_this.holdIndex + 2] = _this.hold[0];
                                        _this.hold[_this.holdIndex + 3] = _this.hold[1];
                                        _this.hold[_this.holdIndex + 4] = _this.curx = _this.hold[2];
                                        _this.hold[_this.holdIndex + 5] = _this.cury = _this.hold[3];
                                    }
                                    level = _this.levels[_this.levelIndex];
                                    while ((level < _this.limit)) {
                                        if (java.awt.geom.QuadCurve2D.getFlatnessSq(_this.hold, _this.holdIndex) < _this.squareflat) {
                                            break;
                                        }
                                        _this.ensureHoldCapacity(4);
                                        java.awt.geom.QuadCurve2D.subdivide(_this.hold, _this.holdIndex, _this.hold, _this.holdIndex - 4, _this.hold, _this.holdIndex);
                                        _this.holdIndex -= 4;
                                        level++;
                                        _this.levels[_this.levelIndex] = level;
                                        _this.levelIndex++;
                                        _this.levels[_this.levelIndex] = level;
                                    }
                                    ;
                                    _this.holdIndex += 4;
                                    _this.levelIndex--;
                                    break;
                                case java.awt.geom.PathIterator.SEG_CUBICTO:
                                    if (_this.holdIndex >= _this.holdEnd) {
                                        _this.holdIndex = _this.hold.length - 8;
                                        _this.holdEnd = _this.hold.length - 2;
                                        _this.hold[_this.holdIndex + 0] = _this.curx;
                                        _this.hold[_this.holdIndex + 1] = _this.cury;
                                        _this.hold[_this.holdIndex + 2] = _this.hold[0];
                                        _this.hold[_this.holdIndex + 3] = _this.hold[1];
                                        _this.hold[_this.holdIndex + 4] = _this.hold[2];
                                        _this.hold[_this.holdIndex + 5] = _this.hold[3];
                                        _this.hold[_this.holdIndex + 6] = _this.curx = _this.hold[4];
                                        _this.hold[_this.holdIndex + 7] = _this.cury = _this.hold[5];
                                    }
                                    level = _this.levels[_this.levelIndex];
                                    while ((level < _this.limit)) {
                                        if (java.awt.geom.CubicCurve2D.getFlatnessSq(_this.hold, _this.holdIndex) < _this.squareflat) {
                                            break;
                                        }
                                        _this.ensureHoldCapacity(6);
                                        java.awt.geom.CubicCurve2D.subdivide(_this.hold, _this.holdIndex, _this.hold, _this.holdIndex - 6, _this.hold, _this.holdIndex);
                                        _this.holdIndex -= 6;
                                        level++;
                                        _this.levels[_this.levelIndex] = level;
                                        _this.levelIndex++;
                                        _this.levels[_this.levelIndex] = level;
                                    }
                                    ;
                                    _this.holdIndex += 6;
                                    _this.levelIndex--;
                                    break;
                            }
                        })();
                    }
                    else if (doNext === undefined) {
                        return this.next$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, or SEG_CLOSE. A float array of length 6 must be passed in and
                 * can be used to store the coordinates of the point(s). Each point is
                 * stored as a pair of float x,y coordinates. SEG_MOVETO and SEG_LINETO
                 * types return one point, and SEG_CLOSE does not return any points.
                 *
                 * @param coords
                 * an array that holds the data returned from this method
                 * @return the path segment type of the current path segment.
                 * @exception NoSuchElementException
                 * if there are no more elements in the flattening path to be
                 * returned.
                 * @see PathIterator#SEG_MOVETO
                 * @see PathIterator#SEG_LINETO
                 * @see PathIterator#SEG_CLOSE
                 */
                FlatteningPathIterator.prototype.currentSegment = function (coords) {
                    var _this = this;
                    if (((coords != null && coords instanceof Array) || coords === null)) {
                        return (function () {
                            if (_this.isDone()) {
                                throw new java.util.NoSuchElementException("flattening iterator out of bounds");
                            }
                            var type = _this.holdType;
                            if (type !== java.awt.geom.PathIterator.SEG_CLOSE) {
                                coords[0] = _this.hold[_this.holdIndex + 0];
                                coords[1] = _this.hold[_this.holdIndex + 1];
                                if (type !== java.awt.geom.PathIterator.SEG_MOVETO) {
                                    type = java.awt.geom.PathIterator.SEG_LINETO;
                                }
                            }
                            return type;
                        })();
                    }
                    else if (((coords != null && coords instanceof Array) || coords === null)) {
                        return this.currentSegment$double_A(coords);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, or SEG_CLOSE. A double array of length 6 must be passed in
                 * and can be used to store the coordinates of the point(s). Each point is
                 * stored as a pair of double x,y coordinates. SEG_MOVETO and SEG_LINETO
                 * types return one point, and SEG_CLOSE does not return any points.
                 *
                 * @param coords
                 * an array that holds the data returned from this method
                 * @return the path segment type of the current path segment.
                 * @exception NoSuchElementException
                 * if there are no more elements in the flattening path to be
                 * returned.
                 * @see PathIterator#SEG_MOVETO
                 * @see PathIterator#SEG_LINETO
                 * @see PathIterator#SEG_CLOSE
                 */
                FlatteningPathIterator.prototype.currentSegment$double_A = function (coords) {
                    if (this.isDone()) {
                        throw new java.util.NoSuchElementException("flattening iterator out of bounds");
                    }
                    var type = this.holdType;
                    if (type !== java.awt.geom.PathIterator.SEG_CLOSE) {
                        coords[0] = this.hold[this.holdIndex + 0];
                        coords[1] = this.hold[this.holdIndex + 1];
                        if (type !== java.awt.geom.PathIterator.SEG_MOVETO) {
                            type = java.awt.geom.PathIterator.SEG_LINETO;
                        }
                    }
                    return type;
                };
                FlatteningPathIterator.GROW_SIZE = 24;
                return FlatteningPathIterator;
            }());
            geom.FlatteningPathIterator = FlatteningPathIterator;
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * This <code>Line2D</code> represents a line segment in {@code (x,y)}
             * coordinate space. This class, like all of the Java 2D API, uses a default
             * coordinate system called <i>user space</i> in which the y-axis values
             * increase downward and x-axis values increase to the right. For more
             * information on the user space coordinate system, see the <a href=
             * "http://docs.oracle.com/javase/1.3/docs/guide/2d/spec/j2d-intro.fm2.html#61857">
             * Coordinate Systems</a> section of the Java 2D Programmer's Guide.
             * <p>
             * This class is only the abstract superclass for all objects that store a 2D
             * line segment. The actual storage representation of the coordinates is left to
             * the subclass.
             *
             * @author Jim Graham
             * @since 1.2
             */
            var Line2D = (function () {
                /**
                 * This is an abstract class that cannot be instantiated directly.
                 * Type-specific implementation subclasses are available for instantiation
                 * and provide a number of formats for storing the information necessary to
                 * satisfy the various accessory methods below.
                 *
                 * @see java.awt.geom.Line2D.Float
                 * @see java.awt.geom.Line2D.Double
                 * @since 1.2
                 */
                function Line2D() {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable"] });
                }
                /**
                 * Sets the location of the end points of this <code>Line2D</code> to
                 * the specified float coordinates.
                 *
                 * @param x1
                 * the X coordinate of the start point
                 * @param y1
                 * the Y coordinate of the start point
                 * @param x2
                 * the X coordinate of the end point
                 * @param y2
                 * the Y coordinate of the end point
                 * @since 1.2
                 */
                Line2D.prototype.setLine = function (x1, y1, x2, y2) {
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        return this.setLine$double$double$double$double(x1, y1, x2, y2);
                    }
                    else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && x2 === undefined && y2 === undefined) {
                        return this.setLine$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1);
                    }
                    else if (((x1 != null && x1 instanceof java.awt.geom.Line2D) || x1 === null) && y1 === undefined && x2 === undefined && y2 === undefined) {
                        return this.setLine$java_awt_geom_Line2D(x1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets the location of the end points of this <code>Line2D</code> to the
                 * specified double coordinates.
                 *
                 * @param x1
                 * the X coordinate of the start point
                 * @param y1
                 * the Y coordinate of the start point
                 * @param x2
                 * the X coordinate of the end point
                 * @param y2
                 * the Y coordinate of the end point
                 * @since 1.2
                 */
                Line2D.prototype.setLine$double$double$double$double = function (x1, y1, x2, y2) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Sets the location of the end points of this <code>Line2D</code> to the
                 * specified <code>Point2D</code> coordinates.
                 *
                 * @param p1
                 * the start <code>Point2D</code> of the line segment
                 * @param p2
                 * the end <code>Point2D</code> of the line segment
                 * @since 1.2
                 */
                Line2D.prototype.setLine$java_awt_geom_Point2D$java_awt_geom_Point2D = function (p1, p2) {
                    this.setLine(p1.getX(), p1.getY(), p2.getX(), p2.getY());
                };
                /**
                 * Sets the location of the end points of this <code>Line2D</code> to the
                 * same as those end points of the specified <code>Line2D</code>.
                 *
                 * @param l
                 * the specified <code>Line2D</code>
                 * @since 1.2
                 */
                Line2D.prototype.setLine$java_awt_geom_Line2D = function (l) {
                    this.setLine(l.getX1(), l.getY1(), l.getX2(), l.getY2());
                };
                /**
                 * Returns an indicator of where the specified point {@code (px,py)} lies
                 * with respect to the line segment from {@code (x1,y1)} to {@code (x2,y2)}.
                 * The return value can be either 1, -1, or 0 and indicates in which
                 * direction the specified line must pivot around its first end point,
                 * {@code (x1,y1)}, in order to point at the specified point {@code (px,py)}
                 * .
                 * <p>
                 * A return value of 1 indicates that the line segment must turn in the
                 * direction that takes the positive X axis towards the negative Y axis. In
                 * the default coordinate system used by Java 2D, this direction is
                 * counterclockwise.
                 * <p>
                 * A return value of -1 indicates that the line segment must turn in the
                 * direction that takes the positive X axis towards the positive Y axis. In
                 * the default coordinate system, this direction is clockwise.
                 * <p>
                 * A return value of 0 indicates that the point lies exactly on the line
                 * segment. Note that an indicator value of 0 is rare and not useful for
                 * determining collinearity because of floating point rounding issues.
                 * <p>
                 * If the point is colinear with the line segment, but not between the end
                 * points, then the value will be -1 if the point lies
                 * "beyond {@code (x1,y1)}" or 1 if the point lies "beyond {@code (x2,y2)}".
                 *
                 * @param x1
                 * the X coordinate of the start point of the specified line
                 * segment
                 * @param y1
                 * the Y coordinate of the start point of the specified line
                 * segment
                 * @param x2
                 * the X coordinate of the end point of the specified line
                 * segment
                 * @param y2
                 * the Y coordinate of the end point of the specified line
                 * segment
                 * @param px
                 * the X coordinate of the specified point to be compared with
                 * the specified line segment
                 * @param py
                 * the Y coordinate of the specified point to be compared with
                 * the specified line segment
                 * @return an integer that indicates the position of the third specified
                 * coordinates with respect to the line segment formed by the first
                 * two specified coordinates.
                 * @since 1.2
                 */
                Line2D.relativeCCW = function (x1, y1, x2, y2, px, py) {
                    x2 -= x1;
                    y2 -= y1;
                    px -= x1;
                    py -= y1;
                    var ccw = px * y2 - py * x2;
                    if (ccw === 0.0) {
                        ccw = px * x2 + py * y2;
                        if (ccw > 0.0) {
                            px -= x2;
                            py -= y2;
                            ccw = px * x2 + py * y2;
                            if (ccw < 0.0) {
                                ccw = 0.0;
                            }
                        }
                    }
                    return (ccw < 0.0) ? -1 : ((ccw > 0.0) ? 1 : 0);
                };
                /**
                 * Returns an indicator of where the specified point {@code (px,py)} lies
                 * with respect to this line segment. See the method comments of
                 * {@link #relativeCCW(double, double, double, double, double, double)} to
                 * interpret the return value.
                 *
                 * @param px
                 * the X coordinate of the specified point to be compared with
                 * this <code>Line2D</code>
                 * @param py
                 * the Y coordinate of the specified point to be compared with
                 * this <code>Line2D</code>
                 * @return an integer that indicates the position of the specified
                 * coordinates with respect to this <code>Line2D</code>
                 * @see #relativeCCW(double, double, double, double, double, double)
                 * @since 1.2
                 */
                Line2D.prototype.relativeCCW = function (px, py) {
                    var _this = this;
                    if (((typeof px === 'number') || px === null) && ((typeof py === 'number') || py === null)) {
                        return (function () {
                            return Line2D.relativeCCW(_this.getX1(), _this.getY1(), _this.getX2(), _this.getY2(), px, py);
                        })();
                    }
                    else if (((px != null && px instanceof java.awt.geom.Point2D) || px === null) && py === undefined) {
                        return this.relativeCCW$java_awt_geom_Point2D(px);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns an indicator of where the specified <code>Point2D</code> lies
                 * with respect to this line segment. See the method comments of
                 * {@link #relativeCCW(double, double, double, double, double, double)} to
                 * interpret the return value.
                 *
                 * @param p
                 * the specified <code>Point2D</code> to be compared with this
                 * <code>Line2D</code>
                 * @return an integer that indicates the position of the specified
                 * <code>Point2D</code> with respect to this <code>Line2D</code>
                 * @see #relativeCCW(double, double, double, double, double, double)
                 * @since 1.2
                 */
                Line2D.prototype.relativeCCW$java_awt_geom_Point2D = function (p) {
                    return Line2D.relativeCCW(this.getX1(), this.getY1(), this.getX2(), this.getY2(), p.getX(), p.getY());
                };
                /**
                 * Tests if the line segment from {@code (x1,y1)} to {@code (x2,y2)}
                 * intersects the line segment from {@code (x3,y3)} to {@code (x4,y4)}.
                 *
                 * @param x1
                 * the X coordinate of the start point of the first specified
                 * line segment
                 * @param y1
                 * the Y coordinate of the start point of the first specified
                 * line segment
                 * @param x2
                 * the X coordinate of the end point of the first specified line
                 * segment
                 * @param y2
                 * the Y coordinate of the end point of the first specified line
                 * segment
                 * @param x3
                 * the X coordinate of the start point of the second specified
                 * line segment
                 * @param y3
                 * the Y coordinate of the start point of the second specified
                 * line segment
                 * @param x4
                 * the X coordinate of the end point of the second specified line
                 * segment
                 * @param y4
                 * the Y coordinate of the end point of the second specified line
                 * segment
                 * @return <code>true</code> if the first specified line segment and the
                 * second specified line segment intersect each other;
                 * <code>false</code> otherwise.
                 * @since 1.2
                 */
                Line2D.linesIntersect = function (x1, y1, x2, y2, x3, y3, x4, y4) {
                    return ((Line2D.relativeCCW(x1, y1, x2, y2, x3, y3) * Line2D.relativeCCW(x1, y1, x2, y2, x4, y4) <= 0) && (Line2D.relativeCCW(x3, y3, x4, y4, x1, y1) * Line2D.relativeCCW(x3, y3, x4, y4, x2, y2) <= 0));
                };
                /**
                 * Tests if the line segment from {@code (x1,y1)} to {@code (x2,y2)}
                 * intersects this line segment.
                 *
                 * @param x1
                 * the X coordinate of the start point of the specified line
                 * segment
                 * @param y1
                 * the Y coordinate of the start point of the specified line
                 * segment
                 * @param x2
                 * the X coordinate of the end point of the specified line
                 * segment
                 * @param y2
                 * the Y coordinate of the end point of the specified line
                 * segment
                 * @return {@code <true>} if this line segment and the specified line
                 * segment intersect each other; <code>false</code> otherwise.
                 * @since 1.2
                 */
                Line2D.prototype.intersectsLine = function (x1, y1, x2, y2) {
                    var _this = this;
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        return (function () {
                            return Line2D.linesIntersect(x1, y1, x2, y2, _this.getX1(), _this.getY1(), _this.getX2(), _this.getY2());
                        })();
                    }
                    else if (((x1 != null && x1 instanceof java.awt.geom.Line2D) || x1 === null) && y1 === undefined && x2 === undefined && y2 === undefined) {
                        return this.intersectsLine$java_awt_geom_Line2D(x1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Tests if the specified line segment intersects this line segment.
                 *
                 * @param l
                 * the specified <code>Line2D</code>
                 * @return <code>true</code> if this line segment and the specified line
                 * segment intersect each other; <code>false</code> otherwise.
                 * @since 1.2
                 */
                Line2D.prototype.intersectsLine$java_awt_geom_Line2D = function (l) {
                    return Line2D.linesIntersect(l.getX1(), l.getY1(), l.getX2(), l.getY2(), this.getX1(), this.getY1(), this.getX2(), this.getY2());
                };
                /**
                 * Returns the square of the distance from a point to a line segment. The
                 * distance measured is the distance between the specified point and the
                 * closest point between the specified end points. If the specified point
                 * intersects the line segment in between the end points, this method
                 * returns 0.0.
                 *
                 * @param x1
                 * the X coordinate of the start point of the specified line
                 * segment
                 * @param y1
                 * the Y coordinate of the start point of the specified line
                 * segment
                 * @param x2
                 * the X coordinate of the end point of the specified line
                 * segment
                 * @param y2
                 * the Y coordinate of the end point of the specified line
                 * segment
                 * @param px
                 * the X coordinate of the specified point being measured against
                 * the specified line segment
                 * @param py
                 * the Y coordinate of the specified point being measured against
                 * the specified line segment
                 * @return a double value that is the square of the distance from the
                 * specified point to the specified line segment.
                 * @see #ptLineDistSq(double, double, double, double, double, double)
                 * @since 1.2
                 */
                Line2D.ptSegDistSq = function (x1, y1, x2, y2, px, py) {
                    x2 -= x1;
                    y2 -= y1;
                    px -= x1;
                    py -= y1;
                    var dotprod = px * x2 + py * y2;
                    var projlenSq;
                    if (dotprod <= 0.0) {
                        projlenSq = 0.0;
                    }
                    else {
                        px = x2 - px;
                        py = y2 - py;
                        dotprod = px * x2 + py * y2;
                        if (dotprod <= 0.0) {
                            projlenSq = 0.0;
                        }
                        else {
                            projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);
                        }
                    }
                    var lenSq = px * px + py * py - projlenSq;
                    if (lenSq < 0) {
                        lenSq = 0;
                    }
                    return lenSq;
                };
                /**
                 * Returns the distance from a point to a line segment. The distance
                 * measured is the distance between the specified point and the closest
                 * point between the specified end points. If the specified point intersects
                 * the line segment in between the end points, this method returns 0.0.
                 *
                 * @param x1
                 * the X coordinate of the start point of the specified line
                 * segment
                 * @param y1
                 * the Y coordinate of the start point of the specified line
                 * segment
                 * @param x2
                 * the X coordinate of the end point of the specified line
                 * segment
                 * @param y2
                 * the Y coordinate of the end point of the specified line
                 * segment
                 * @param px
                 * the X coordinate of the specified point being measured against
                 * the specified line segment
                 * @param py
                 * the Y coordinate of the specified point being measured against
                 * the specified line segment
                 * @return a double value that is the distance from the specified point to
                 * the specified line segment.
                 * @see #ptLineDist(double, double, double, double, double, double)
                 * @since 1.2
                 */
                Line2D.ptSegDist = function (x1, y1, x2, y2, px, py) {
                    return Math.sqrt(Line2D.ptSegDistSq(x1, y1, x2, y2, px, py));
                };
                /**
                 * Returns the square of the distance from a point to this line segment. The
                 * distance measured is the distance between the specified point and the
                 * closest point between the current line's end points. If the specified
                 * point intersects the line segment in between the end points, this method
                 * returns 0.0.
                 *
                 * @param px
                 * the X coordinate of the specified point being measured against
                 * this line segment
                 * @param py
                 * the Y coordinate of the specified point being measured against
                 * this line segment
                 * @return a double value that is the square of the distance from the
                 * specified point to the current line segment.
                 * @see #ptLineDistSq(double, double)
                 * @since 1.2
                 */
                Line2D.prototype.ptSegDistSq = function (px, py) {
                    var _this = this;
                    if (((typeof px === 'number') || px === null) && ((typeof py === 'number') || py === null)) {
                        return (function () {
                            return Line2D.ptSegDistSq(_this.getX1(), _this.getY1(), _this.getX2(), _this.getY2(), px, py);
                        })();
                    }
                    else if (((px != null && px instanceof java.awt.geom.Point2D) || px === null) && py === undefined) {
                        return this.ptSegDistSq$java_awt_geom_Point2D(px);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the square of the distance from a <code>Point2D</code> to this
                 * line segment. The distance measured is the distance between the specified
                 * point and the closest point between the current line's end points. If the
                 * specified point intersects the line segment in between the end points,
                 * this method returns 0.0.
                 *
                 * @param pt
                 * the specified <code>Point2D</code> being measured against this
                 * line segment.
                 * @return a double value that is the square of the distance from the
                 * specified <code>Point2D</code> to the current line segment.
                 * @see #ptLineDistSq(Point2D)
                 * @since 1.2
                 */
                Line2D.prototype.ptSegDistSq$java_awt_geom_Point2D = function (pt) {
                    return Line2D.ptSegDistSq(this.getX1(), this.getY1(), this.getX2(), this.getY2(), pt.getX(), pt.getY());
                };
                /**
                 * Returns the distance from a point to this line segment. The distance
                 * measured is the distance between the specified point and the closest
                 * point between the current line's end points. If the specified point
                 * intersects the line segment in between the end points, this method
                 * returns 0.0.
                 *
                 * @param px
                 * the X coordinate of the specified point being measured against
                 * this line segment
                 * @param py
                 * the Y coordinate of the specified point being measured against
                 * this line segment
                 * @return a double value that is the distance from the specified point to
                 * the current line segment.
                 * @see #ptLineDist(double, double)
                 * @since 1.2
                 */
                Line2D.prototype.ptSegDist = function (px, py) {
                    var _this = this;
                    if (((typeof px === 'number') || px === null) && ((typeof py === 'number') || py === null)) {
                        return (function () {
                            return Line2D.ptSegDist(_this.getX1(), _this.getY1(), _this.getX2(), _this.getY2(), px, py);
                        })();
                    }
                    else if (((px != null && px instanceof java.awt.geom.Point2D) || px === null) && py === undefined) {
                        return this.ptSegDist$java_awt_geom_Point2D(px);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the distance from a <code>Point2D</code> to this line segment.
                 * The distance measured is the distance between the specified point and the
                 * closest point between the current line's end points. If the specified
                 * point intersects the line segment in between the end points, this method
                 * returns 0.0.
                 *
                 * @param pt
                 * the specified <code>Point2D</code> being measured against this
                 * line segment
                 * @return a double value that is the distance from the specified
                 * <code>Point2D</code> to the current line segment.
                 * @see #ptLineDist(Point2D)
                 * @since 1.2
                 */
                Line2D.prototype.ptSegDist$java_awt_geom_Point2D = function (pt) {
                    return Line2D.ptSegDist(this.getX1(), this.getY1(), this.getX2(), this.getY2(), pt.getX(), pt.getY());
                };
                /**
                 * Returns the square of the distance from a point to a line. The distance
                 * measured is the distance between the specified point and the closest
                 * point on the infinitely-extended line defined by the specified
                 * coordinates. If the specified point intersects the line, this method
                 * returns 0.0.
                 *
                 * @param x1
                 * the X coordinate of the start point of the specified line
                 * @param y1
                 * the Y coordinate of the start point of the specified line
                 * @param x2
                 * the X coordinate of the end point of the specified line
                 * @param y2
                 * the Y coordinate of the end point of the specified line
                 * @param px
                 * the X coordinate of the specified point being measured against
                 * the specified line
                 * @param py
                 * the Y coordinate of the specified point being measured against
                 * the specified line
                 * @return a double value that is the square of the distance from the
                 * specified point to the specified line.
                 * @see #ptSegDistSq(double, double, double, double, double, double)
                 * @since 1.2
                 */
                Line2D.ptLineDistSq = function (x1, y1, x2, y2, px, py) {
                    x2 -= x1;
                    y2 -= y1;
                    px -= x1;
                    py -= y1;
                    var dotprod = px * x2 + py * y2;
                    var projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);
                    var lenSq = px * px + py * py - projlenSq;
                    if (lenSq < 0) {
                        lenSq = 0;
                    }
                    return lenSq;
                };
                /**
                 * Returns the distance from a point to a line. The distance measured is the
                 * distance between the specified point and the closest point on the
                 * infinitely-extended line defined by the specified coordinates. If the
                 * specified point intersects the line, this method returns 0.0.
                 *
                 * @param x1
                 * the X coordinate of the start point of the specified line
                 * @param y1
                 * the Y coordinate of the start point of the specified line
                 * @param x2
                 * the X coordinate of the end point of the specified line
                 * @param y2
                 * the Y coordinate of the end point of the specified line
                 * @param px
                 * the X coordinate of the specified point being measured against
                 * the specified line
                 * @param py
                 * the Y coordinate of the specified point being measured against
                 * the specified line
                 * @return a double value that is the distance from the specified point to
                 * the specified line.
                 * @see #ptSegDist(double, double, double, double, double, double)
                 * @since 1.2
                 */
                Line2D.ptLineDist = function (x1, y1, x2, y2, px, py) {
                    return Math.sqrt(Line2D.ptLineDistSq(x1, y1, x2, y2, px, py));
                };
                /**
                 * Returns the square of the distance from a point to this line. The
                 * distance measured is the distance between the specified point and the
                 * closest point on the infinitely-extended line defined by this
                 * <code>Line2D</code>. If the specified point intersects the line, this
                 * method returns 0.0.
                 *
                 * @param px
                 * the X coordinate of the specified point being measured against
                 * this line
                 * @param py
                 * the Y coordinate of the specified point being measured against
                 * this line
                 * @return a double value that is the square of the distance from a
                 * specified point to the current line.
                 * @see #ptSegDistSq(double, double)
                 * @since 1.2
                 */
                Line2D.prototype.ptLineDistSq = function (px, py) {
                    var _this = this;
                    if (((typeof px === 'number') || px === null) && ((typeof py === 'number') || py === null)) {
                        return (function () {
                            return Line2D.ptLineDistSq(_this.getX1(), _this.getY1(), _this.getX2(), _this.getY2(), px, py);
                        })();
                    }
                    else if (((px != null && px instanceof java.awt.geom.Point2D) || px === null) && py === undefined) {
                        return this.ptLineDistSq$java_awt_geom_Point2D(px);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the square of the distance from a specified <code>Point2D</code>
                 * to this line. The distance measured is the distance between the specified
                 * point and the closest point on the infinitely-extended line defined by
                 * this <code>Line2D</code>. If the specified point intersects the line,
                 * this method returns 0.0.
                 *
                 * @param pt
                 * the specified <code>Point2D</code> being measured against this
                 * line
                 * @return a double value that is the square of the distance from a
                 * specified <code>Point2D</code> to the current line.
                 * @see #ptSegDistSq(Point2D)
                 * @since 1.2
                 */
                Line2D.prototype.ptLineDistSq$java_awt_geom_Point2D = function (pt) {
                    return Line2D.ptLineDistSq(this.getX1(), this.getY1(), this.getX2(), this.getY2(), pt.getX(), pt.getY());
                };
                /**
                 * Returns the distance from a point to this line. The distance measured is
                 * the distance between the specified point and the closest point on the
                 * infinitely-extended line defined by this <code>Line2D</code>. If the
                 * specified point intersects the line, this method returns 0.0.
                 *
                 * @param px
                 * the X coordinate of the specified point being measured against
                 * this line
                 * @param py
                 * the Y coordinate of the specified point being measured against
                 * this line
                 * @return a double value that is the distance from a specified point to the
                 * current line.
                 * @see #ptSegDist(double, double)
                 * @since 1.2
                 */
                Line2D.prototype.ptLineDist = function (px, py) {
                    var _this = this;
                    if (((typeof px === 'number') || px === null) && ((typeof py === 'number') || py === null)) {
                        return (function () {
                            return Line2D.ptLineDist(_this.getX1(), _this.getY1(), _this.getX2(), _this.getY2(), px, py);
                        })();
                    }
                    else if (((px != null && px instanceof java.awt.geom.Point2D) || px === null) && py === undefined) {
                        return this.ptLineDist$java_awt_geom_Point2D(px);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the distance from a <code>Point2D</code> to this line. The
                 * distance measured is the distance between the specified point and the
                 * closest point on the infinitely-extended line defined by this
                 * <code>Line2D</code>. If the specified point intersects the line, this
                 * method returns 0.0.
                 *
                 * @param pt
                 * the specified <code>Point2D</code> being measured
                 * @return a double value that is the distance from a specified
                 * <code>Point2D</code> to the current line.
                 * @see #ptSegDist(Point2D)
                 * @since 1.2
                 */
                Line2D.prototype.ptLineDist$java_awt_geom_Point2D = function (pt) {
                    return Line2D.ptLineDist(this.getX1(), this.getY1(), this.getX2(), this.getY2(), pt.getX(), pt.getY());
                };
                /**
                 * Tests if a specified coordinate is inside the boundary of this
                 * <code>Line2D</code>. This method is required to implement the
                 * {@link Shape} interface, but in the case of <code>Line2D</code> objects
                 * it always returns <code>false</code> since a line contains no area.
                 *
                 * @param x
                 * the X coordinate of the specified point to be tested
                 * @param y
                 * the Y coordinate of the specified point to be tested
                 * @return <code>false</code> because a <code>Line2D</code> contains no
                 * area.
                 * @since 1.2
                 */
                Line2D.prototype.contains$double$double = function (x, y) {
                    return false;
                };
                /**
                 * Tests if a given <code>Point2D</code> is inside the boundary of this
                 * <code>Line2D</code>. This method is required to implement the
                 * {@link Shape} interface, but in the case of <code>Line2D</code> objects
                 * it always returns <code>false</code> since a line contains no area.
                 *
                 * @param p
                 * the specified <code>Point2D</code> to be tested
                 * @return <code>false</code> because a <code>Line2D</code> contains no
                 * area.
                 * @since 1.2
                 */
                Line2D.prototype.contains$java_awt_geom_Point2D = function (p) {
                    return false;
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                Line2D.prototype.intersects = function (x, y, w, h) {
                    var _this = this;
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return (function () {
                            return _this.intersects(new java.awt.geom.Rectangle2D.Double(x, y, w, h));
                        })();
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.intersects$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                Line2D.prototype.intersects$java_awt_geom_Rectangle2D = function (r) {
                    return r.intersectsLine(this.getX1(), this.getY1(), this.getX2(), this.getY2());
                };
                /**
                 * Tests if the interior of this <code>Line2D</code> entirely contains the
                 * specified set of rectangular coordinates. This method is required to
                 * implement the <code>Shape</code> interface, but in the case of
                 * <code>Line2D</code> objects it always returns false since a line contains
                 * no area.
                 *
                 * @param x
                 * the X coordinate of the upper-left corner of the specified
                 * rectangular area
                 * @param y
                 * the Y coordinate of the upper-left corner of the specified
                 * rectangular area
                 * @param w
                 * the width of the specified rectangular area
                 * @param h
                 * the height of the specified rectangular area
                 * @return <code>false</code> because a <code>Line2D</code> contains no
                 * area.
                 * @since 1.2
                 */
                Line2D.prototype.contains = function (x, y, w, h) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return (function () {
                            return false;
                        })();
                    }
                    else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined) {
                        return this.contains$double$double(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Point2D(x);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Tests if the interior of this <code>Line2D</code> entirely contains the
                 * specified <code>Rectangle2D</code>. This method is required to implement
                 * the <code>Shape</code> interface, but in the case of <code>Line2D</code>
                 * objects it always returns <code>false</code> since a line contains no
                 * area.
                 *
                 * @param r
                 * the specified <code>Rectangle2D</code> to be tested
                 * @return <code>false</code> because a <code>Line2D</code> contains no
                 * area.
                 * @since 1.2
                 */
                Line2D.prototype.contains$java_awt_geom_Rectangle2D = function (r) {
                    return false;
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                Line2D.prototype.getBounds = function () {
                    return this.getBounds2D().getBounds();
                };
                /**
                 * Returns an iteration object that defines the boundary of this
                 * <code>Line2D</code>. The iterator for this class is not multi-threaded
                 * safe, which means that this <code>Line2D</code> class does not guarantee
                 * that modifications to the geometry of this <code>Line2D</code> object do
                 * not affect any iterations of that geometry that are already in process.
                 *
                 * @param at
                 * the specified {@link AffineTransform}
                 * @return a {@link PathIterator} that defines the boundary of this
                 * <code>Line2D</code>.
                 * @since 1.2
                 */
                Line2D.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
                    return new java.awt.geom.LineIterator(this, at);
                };
                /**
                 * Returns an iteration object that defines the boundary of this flattened
                 * <code>Line2D</code>. The iterator for this class is not multi-threaded
                 * safe, which means that this <code>Line2D</code> class does not guarantee
                 * that modifications to the geometry of this <code>Line2D</code> object do
                 * not affect any iterations of that geometry that are already in process.
                 *
                 * @param at
                 * the specified <code>AffineTransform</code>
                 * @param flatness
                 * the maximum amount that the control points for a given curve
                 * can vary from colinear before a subdivided curve is replaced
                 * by a straight line connecting the end points. Since a
                 * <code>Line2D</code> object is always flat, this parameter is
                 * ignored.
                 * @return a <code>PathIterator</code> that defines the boundary of the
                 * flattened <code>Line2D</code>
                 * @since 1.2
                 */
                Line2D.prototype.getPathIterator = function (at, flatness) {
                    var _this = this;
                    if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
                        return (function () {
                            return new java.awt.geom.LineIterator(_this, at);
                        })();
                    }
                    else if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && flatness === undefined) {
                        return this.getPathIterator$java_awt_geom_AffineTransform(at);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Creates a new object of the same class as this object.
                 *
                 * @return a clone of this instance.
                 * @exception OutOfMemoryError
                 * if there is not enough memory.
                 * @see java.lang.Cloneable
                 * @since 1.2
                 */
                Line2D.prototype.clone = function () {
                    try {
                        return javaemul.internal.ObjectHelper.clone(this);
                    }
                    catch (e) {
                        throw new java.lang.InternalError(e);
                    }
                    ;
                };
                return Line2D;
            }());
            geom.Line2D = Line2D;
            var Line2D;
            (function (Line2D) {
                /**
                 * A line segment specified with float coordinates.
                 *
                 * @since 1.2
                 */
                var Float = (function (_super) {
                    __extends(Float, _super);
                    /**
                     * Constructs and initializes a Line from the specified coordinates.
                     *
                     * @param x1
                     * the X coordinate of the start point
                     * @param y1
                     * the Y coordinate of the start point
                     * @param x2
                     * the X coordinate of the end point
                     * @param y2
                     * the Y coordinate of the end point
                     * @since 1.2
                     */
                    function Float(x1, y1, x2, y2) {
                        var _this = this;
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x1 = 0;
                            this.y1 = 0;
                            this.x2 = 0;
                            this.y2 = 0;
                            (function () {
                                _this.setLine(x1, y1, x2, y2);
                            })();
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && x2 === undefined && y2 === undefined) {
                            var p1 = x1;
                            var p2 = y1;
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x1 = 0;
                            this.y1 = 0;
                            this.x2 = 0;
                            this.y2 = 0;
                            (function () {
                                _this.setLine(p1, p2);
                            })();
                        }
                        else if (x1 === undefined && y1 === undefined && x2 === undefined && y2 === undefined) {
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x1 = 0;
                            this.y1 = 0;
                            this.x2 = 0;
                            this.y2 = 0;
                            (function () {
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getX1 = function () {
                        return this.x1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getY1 = function () {
                        return this.y1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getP1 = function () {
                        return new java.awt.geom.Point2D.Float(this.x1, this.y1);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getX2 = function () {
                        return this.x2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getY2 = function () {
                        return this.y2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getP2 = function () {
                        return new java.awt.geom.Point2D.Float(this.x2, this.y2);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.setLine$double$double$double$double = function (x1, y1, x2, y2) {
                        this.x1 = x1;
                        this.y1 = y1;
                        this.x2 = x2;
                        this.y2 = y2;
                    };
                    /**
                     * Sets the location of the end points of this <code>Line2D</code> to
                     * the specified float coordinates.
                     *
                     * @param x1
                     * the X coordinate of the start point
                     * @param y1
                     * the Y coordinate of the start point
                     * @param x2
                     * the X coordinate of the end point
                     * @param y2
                     * the Y coordinate of the end point
                     * @since 1.2
                     */
                    Float.prototype.setLine = function (x1, y1, x2, y2) {
                        var _this = this;
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            return (function () {
                                _this.x1 = x1;
                                _this.y1 = y1;
                                _this.x2 = x2;
                                _this.y2 = y2;
                            })();
                        }
                        else if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            return this.setLine$double$double$double$double(x1, y1, x2, y2);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && x2 === undefined && y2 === undefined) {
                            return this.setLine$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.Line2D) || x1 === null) && y1 === undefined && x2 === undefined && y2 === undefined) {
                            return this.setLine$java_awt_geom_Line2D(x1);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getBounds2D = function () {
                        var x;
                        var y;
                        var w;
                        var h;
                        if (this.x1 < this.x2) {
                            x = this.x1;
                            w = this.x2 - this.x1;
                        }
                        else {
                            x = this.x2;
                            w = this.x1 - this.x2;
                        }
                        if (this.y1 < this.y2) {
                            y = this.y1;
                            h = this.y2 - this.y1;
                        }
                        else {
                            y = this.y2;
                            h = this.y1 - this.y2;
                        }
                        return new java.awt.geom.Rectangle2D.Float(x, y, w, h);
                    };
                    Float.serialVersionUID = 6161772511649436349;
                    return Float;
                }(java.awt.geom.Line2D));
                Line2D.Float = Float;
                /**
                 * A line segment specified with double coordinates.
                 *
                 * @since 1.2
                 */
                var Double = (function (_super) {
                    __extends(Double, _super);
                    /**
                     * Constructs and initializes a <code>Line2D</code> from the specified
                     * coordinates.
                     *
                     * @param x1
                     * the X coordinate of the start point
                     * @param y1
                     * the Y coordinate of the start point
                     * @param x2
                     * the X coordinate of the end point
                     * @param y2
                     * the Y coordinate of the end point
                     * @since 1.2
                     */
                    function Double(x1, y1, x2, y2) {
                        var _this = this;
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x1 = 0;
                            this.y1 = 0;
                            this.x2 = 0;
                            this.y2 = 0;
                            (function () {
                                _this.setLine(x1, y1, x2, y2);
                            })();
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && x2 === undefined && y2 === undefined) {
                            var p1 = x1;
                            var p2 = y1;
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x1 = 0;
                            this.y1 = 0;
                            this.x2 = 0;
                            this.y2 = 0;
                            (function () {
                                _this.setLine(p1, p2);
                            })();
                        }
                        else if (x1 === undefined && y1 === undefined && x2 === undefined && y2 === undefined) {
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x1 = 0;
                            this.y1 = 0;
                            this.x2 = 0;
                            this.y2 = 0;
                            (function () {
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getX1 = function () {
                        return this.x1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getY1 = function () {
                        return this.y1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getP1 = function () {
                        return new java.awt.geom.Point2D.Double(this.x1, this.y1);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getX2 = function () {
                        return this.x2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getY2 = function () {
                        return this.y2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getP2 = function () {
                        return new java.awt.geom.Point2D.Double(this.x2, this.y2);
                    };
                    /**
                     * Sets the location of the end points of this <code>Line2D</code> to
                     * the specified float coordinates.
                     *
                     * @param x1
                     * the X coordinate of the start point
                     * @param y1
                     * the Y coordinate of the start point
                     * @param x2
                     * the X coordinate of the end point
                     * @param y2
                     * the Y coordinate of the end point
                     * @since 1.2
                     */
                    Double.prototype.setLine = function (x1, y1, x2, y2) {
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            return this.setLine$double$double$double$double(x1, y1, x2, y2);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && x2 === undefined && y2 === undefined) {
                            return this.setLine$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.Line2D) || x1 === null) && y1 === undefined && x2 === undefined && y2 === undefined) {
                            return this.setLine$java_awt_geom_Line2D(x1);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.setLine$double$double$double$double = function (x1, y1, x2, y2) {
                        this.x1 = x1;
                        this.y1 = y1;
                        this.x2 = x2;
                        this.y2 = y2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getBounds2D = function () {
                        var x;
                        var y;
                        var w;
                        var h;
                        if (this.x1 < this.x2) {
                            x = this.x1;
                            w = this.x2 - this.x1;
                        }
                        else {
                            x = this.x2;
                            w = this.x1 - this.x2;
                        }
                        if (this.y1 < this.y2) {
                            y = this.y1;
                            h = this.y2 - this.y1;
                        }
                        else {
                            y = this.y2;
                            h = this.y1 - this.y2;
                        }
                        return new java.awt.geom.Rectangle2D.Double(x, y, w, h);
                    };
                    Double.serialVersionUID = 7979627399746467499;
                    return Double;
                }(java.awt.geom.Line2D));
                Line2D.Double = Double;
            })(Line2D = geom.Line2D || (geom.Line2D = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * A utility class to iterate over the path segments of a line segment through
             * the PathIterator interface.
             *
             * @author Jim Graham
             */
            var LineIterator = (function () {
                function LineIterator(l, at) {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.geom.PathIterator"] });
                    this.index = 0;
                    this.line = l;
                    this.affine = at;
                }
                /**
                 * Return the winding rule for determining the insideness of the path.
                 *
                 * @see #WIND_EVEN_ODD
                 * @see #WIND_NON_ZERO
                 */
                LineIterator.prototype.getWindingRule = function () {
                    return java.awt.geom.PathIterator.WIND_NON_ZERO;
                };
                /**
                 * Tests if there are more points to read.
                 *
                 * @return true if there are more points to read
                 */
                LineIterator.prototype.isDone = function () {
                    return (this.index > 1);
                };
                LineIterator.prototype.next = function (doNext) {
                    if (doNext === undefined) {
                        return this.next$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Moves the iterator to the next segment of the path forwards along the
                 * primary direction of traversal as long as there are more points in that
                 * direction.
                 */
                LineIterator.prototype.next$ = function () {
                    this.index++;
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of float x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 */
                LineIterator.prototype.currentSegment = function (coords) {
                    var _this = this;
                    if (((coords != null && coords instanceof Array) || coords === null)) {
                        return (function () {
                            if (_this.isDone()) {
                                throw new java.util.NoSuchElementException("line iterator out of bounds");
                            }
                            var type;
                            if (_this.index === 0) {
                                coords[0] = _this.line.getX1();
                                coords[1] = _this.line.getY1();
                                type = java.awt.geom.PathIterator.SEG_MOVETO;
                            }
                            else {
                                coords[0] = _this.line.getX2();
                                coords[1] = _this.line.getY2();
                                type = java.awt.geom.PathIterator.SEG_LINETO;
                            }
                            if (_this.affine != null) {
                                _this.affine.transform(coords, 0, coords, 0, 1);
                            }
                            return type;
                        })();
                    }
                    else if (((coords != null && coords instanceof Array) || coords === null)) {
                        return this.currentSegment$double_A(coords);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A double array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of double x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 */
                LineIterator.prototype.currentSegment$double_A = function (coords) {
                    if (this.isDone()) {
                        throw new java.util.NoSuchElementException("line iterator out of bounds");
                    }
                    var type;
                    if (this.index === 0) {
                        coords[0] = this.line.getX1();
                        coords[1] = this.line.getY1();
                        type = java.awt.geom.PathIterator.SEG_MOVETO;
                    }
                    else {
                        coords[0] = this.line.getX2();
                        coords[1] = this.line.getY2();
                        type = java.awt.geom.PathIterator.SEG_LINETO;
                    }
                    if (this.affine != null) {
                        this.affine.transform(coords, 0, coords, 0, 1);
                    }
                    return type;
                };
                return LineIterator;
            }());
            geom.LineIterator = LineIterator;
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var PathIterator;
            (function (PathIterator) {
                /**
                 * The winding rule constant for specifying an even-odd rule for determining
                 * the interior of a path. The even-odd rule specifies that a point lies
                 * inside the path if a ray drawn in any direction from that point to
                 * infinity is crossed by path segments an odd number of times.
                 */
                PathIterator.WIND_EVEN_ODD = 0;
                /**
                 * The winding rule constant for specifying a non-zero rule for determining
                 * the interior of a path. The non-zero rule specifies that a point lies
                 * inside the path if a ray drawn in any direction from that point to
                 * infinity is crossed by path segments a different number of times in the
                 * counter-clockwise direction than the clockwise direction.
                 */
                PathIterator.WIND_NON_ZERO = 1;
                /**
                 * The segment type constant for a point that specifies the starting
                 * location for a new subpath.
                 */
                PathIterator.SEG_MOVETO = 0;
                /**
                 * The segment type constant for a point that specifies the end point of a
                 * line to be drawn from the most recently specified point.
                 */
                PathIterator.SEG_LINETO = 1;
                /**
                 * The segment type constant for the pair of points that specify a quadratic
                 * parametric curve to be drawn from the most recently specified point. The
                 * curve is interpolated by solving the parametric control equation in the
                 * range <code>(t=[0..1])</code> using the most recently specified (current)
                 * point (CP), the first control point (P1), and the final interpolated
                 * control point (P2). The parametric control equation for this curve is:
                 *
                 * <pre>
                 * P(t) = B(2,0)*CP + B(2,1)*P1 + B(2,2)*P2
                 * 0 &lt;= t &lt;= 1
                 *
                 * B(n,m) = mth coefficient of nth degree Bernstein polynomial
                 * = C(n,m) * t^(m) * (1 - t)^(n-m)
                 * C(n,m) = Combinations of n things, taken m at a time
                 * = n! / (m! * (n-m)!)
                 * </pre>
                 */
                PathIterator.SEG_QUADTO = 2;
                /**
                 * The segment type constant for the set of 3 points that specify a cubic
                 * parametric curve to be drawn from the most recently specified point. The
                 * curve is interpolated by solving the parametric control equation in the
                 * range <code>(t=[0..1])</code> using the most recently specified (current)
                 * point (CP), the first control point (P1), the second control point (P2),
                 * and the final interpolated control point (P3). The parametric control
                 * equation for this curve is:
                 *
                 * <pre>
                 * P(t) = B(3,0)*CP + B(3,1)*P1 + B(3,2)*P2 + B(3,3)*P3
                 * 0 &lt;= t &lt;= 1
                 *
                 * B(n,m) = mth coefficient of nth degree Bernstein polynomial
                 * = C(n,m) * t^(m) * (1 - t)^(n-m)
                 * C(n,m) = Combinations of n things, taken m at a time
                 * = n! / (m! * (n-m)!)
                 * </pre>
                 *
                 * This form of curve is commonly known as a B&eacute;zier curve.
                 */
                PathIterator.SEG_CUBICTO = 3;
                /**
                 * The segment type constant that specifies that the preceding subpath
                 * should be closed by appending a line segment back to the point
                 * corresponding to the most recent SEG_MOVETO.
                 */
                PathIterator.SEG_CLOSE = 4;
            })(PathIterator = geom.PathIterator || (geom.PathIterator = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The <code>Point2D</code> class defines a point representing a location in
             * {@code (x,y)} coordinate space.
             * <p>
             * This class is only the abstract superclass for all objects that store a 2D
             * coordinate. The actual storage representation of the coordinates is left to
             * the subclass.
             *
             * @author Jim Graham
             * @since 1.2
             */
            var Point2D = (function () {
                /**
                 * This is an abstract class that cannot be instantiated directly.
                 * Type-specific implementation subclasses are available for instantiation
                 * and provide a number of formats for storing the information necessary to
                 * satisfy the various accessor methods below.
                 *
                 * @see java.awt.geom.Point2D.Float
                 * @see java.awt.geom.Point2D.Double
                 * @see java.awt.Point
                 * @since 1.2
                 */
                function Point2D() {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable"] });
                }
                Point2D.prototype.setLocation = function (x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.setLocation$double$double(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined) {
                        return this.setLocation$java_awt_geom_Point2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets the location of this <code>Point2D</code> to the specified
                 * <code>double</code> coordinates.
                 *
                 * @param x
                 * the new X coordinate of this {@code Point2D}
                 * @param y
                 * the new Y coordinate of this {@code Point2D}
                 * @since 1.2
                 */
                Point2D.prototype.setLocation$double$double = function (x, y) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Sets the location of this <code>Point2D</code> to the same coordinates as
                 * the specified <code>Point2D</code> object.
                 *
                 * @param p
                 * the specified <code>Point2D</code> to which to set this
                 * <code>Point2D</code>
                 * @since 1.2
                 */
                Point2D.prototype.setLocation$java_awt_geom_Point2D = function (p) {
                    this.setLocation(p.getX(), p.getY());
                };
                /**
                 * Returns the square of the distance between two points.
                 *
                 * @param x1
                 * the X coordinate of the first specified point
                 * @param y1
                 * the Y coordinate of the first specified point
                 * @param x2
                 * the X coordinate of the second specified point
                 * @param y2
                 * the Y coordinate of the second specified point
                 * @return the square of the distance between the two sets of specified
                 * coordinates.
                 * @since 1.2
                 */
                Point2D.distanceSq = function (x1, y1, x2, y2) {
                    x1 -= x2;
                    y1 -= y2;
                    return (x1 * x1 + y1 * y1);
                };
                /**
                 * Returns the distance between two points.
                 *
                 * @param x1
                 * the X coordinate of the first specified point
                 * @param y1
                 * the Y coordinate of the first specified point
                 * @param x2
                 * the X coordinate of the second specified point
                 * @param y2
                 * the Y coordinate of the second specified point
                 * @return the distance between the two sets of specified coordinates.
                 * @since 1.2
                 */
                Point2D.distance = function (x1, y1, x2, y2) {
                    x1 -= x2;
                    y1 -= y2;
                    return Math.sqrt(x1 * x1 + y1 * y1);
                };
                /**
                 * Returns the square of the distance from this <code>Point2D</code> to a
                 * specified point.
                 *
                 * @param px
                 * the X coordinate of the specified point to be measured against
                 * this <code>Point2D</code>
                 * @param py
                 * the Y coordinate of the specified point to be measured against
                 * this <code>Point2D</code>
                 * @return the square of the distance between this <code>Point2D</code> and
                 * the specified point.
                 * @since 1.2
                 */
                Point2D.prototype.distanceSq = function (px, py) {
                    var _this = this;
                    if (((typeof px === 'number') || px === null) && ((typeof py === 'number') || py === null)) {
                        return (function () {
                            px -= _this.getX();
                            py -= _this.getY();
                            return (px * px + py * py);
                        })();
                    }
                    else if (((px != null && px instanceof java.awt.geom.Point2D) || px === null) && py === undefined) {
                        return this.distanceSq$java_awt_geom_Point2D(px);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the square of the distance from this <code>Point2D</code> to a
                 * specified <code>Point2D</code>.
                 *
                 * @param pt
                 * the specified point to be measured against this
                 * <code>Point2D</code>
                 * @return the square of the distance between this <code>Point2D</code> to a
                 * specified <code>Point2D</code>.
                 * @since 1.2
                 */
                Point2D.prototype.distanceSq$java_awt_geom_Point2D = function (pt) {
                    var px = pt.getX() - this.getX();
                    var py = pt.getY() - this.getY();
                    return (px * px + py * py);
                };
                /**
                 * Returns the distance from this <code>Point2D</code> to a specified point.
                 *
                 * @param px
                 * the X coordinate of the specified point to be measured against
                 * this <code>Point2D</code>
                 * @param py
                 * the Y coordinate of the specified point to be measured against
                 * this <code>Point2D</code>
                 * @return the distance between this <code>Point2D</code> and a specified
                 * point.
                 * @since 1.2
                 */
                Point2D.prototype.distance = function (px, py) {
                    var _this = this;
                    if (((typeof px === 'number') || px === null) && ((typeof py === 'number') || py === null)) {
                        return (function () {
                            px -= _this.getX();
                            py -= _this.getY();
                            return Math.sqrt(px * px + py * py);
                        })();
                    }
                    else if (((px != null && px instanceof java.awt.geom.Point2D) || px === null) && py === undefined) {
                        return this.distance$java_awt_geom_Point2D(px);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the distance from this <code>Point2D</code> to a specified
                 * <code>Point2D</code>.
                 *
                 * @param pt
                 * the specified point to be measured against this
                 * <code>Point2D</code>
                 * @return the distance between this <code>Point2D</code> and the specified
                 * <code>Point2D</code>.
                 * @since 1.2
                 */
                Point2D.prototype.distance$java_awt_geom_Point2D = function (pt) {
                    var px = pt.getX() - this.getX();
                    var py = pt.getY() - this.getY();
                    return Math.sqrt(px * px + py * py);
                };
                /**
                 * Creates a new object of the same class and with the same contents as this
                 * object.
                 *
                 * @return a clone of this instance.
                 * @exception OutOfMemoryError
                 * if there is not enough memory.
                 * @see java.lang.Cloneable
                 * @since 1.2
                 */
                Point2D.prototype.clone = function () {
                    try {
                        return javaemul.internal.ObjectHelper.clone(this);
                    }
                    catch (e) {
                        throw new java.lang.InternalError(e);
                    }
                    ;
                };
                /**
                 * Returns the hashcode for this <code>Point2D</code>.
                 *
                 * @return a hash code for this <code>Point2D</code>.
                 */
                Point2D.prototype.hashCode = function () {
                    var bits = javaemul.internal.DoubleHelper.doubleToLongBits(this.getX());
                    bits ^= javaemul.internal.DoubleHelper.doubleToLongBits(this.getY()) * 31;
                    return (((bits | 0)) ^ (((bits >> 32) | 0)));
                };
                /**
                 * Determines whether or not two points are equal. Two instances of
                 * <code>Point2D</code> are equal if the values of their <code>x</code> and
                 * <code>y</code> member fields, representing their position in the
                 * coordinate space, are the same.
                 *
                 * @param obj
                 * an object to be compared with this <code>Point2D</code>
                 * @return <code>true</code> if the object to be compared is an instance of
                 * <code>Point2D</code> and has the same values; <code>false</code>
                 * otherwise.
                 * @since 1.2
                 */
                Point2D.prototype.equals = function (obj) {
                    if (obj != null && obj instanceof java.awt.geom.Point2D) {
                        var p2d = obj;
                        return (this.getX() === p2d.getX()) && (this.getY() === p2d.getY());
                    }
                    return (this === obj);
                };
                return Point2D;
            }());
            geom.Point2D = Point2D;
            var Point2D;
            (function (Point2D) {
                /**
                 * The <code>Float</code> class defines a point specified in float
                 * precision.
                 *
                 * @since 1.2
                 */
                var Float = (function (_super) {
                    __extends(Float, _super);
                    /**
                     * Constructs and initializes a <code>Point2D</code> with the specified
                     * coordinates.
                     *
                     * @param x
                     * the X coordinate of the newly constructed
                     * <code>Point2D</code>
                     * @param y
                     * the Y coordinate of the newly constructed
                     * <code>Point2D</code>
                     * @since 1.2
                     */
                    function Float(x, y) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.io.Serializable"] });
                            this.x = 0;
                            this.y = 0;
                            (function () {
                                _this.x = x;
                                _this.y = y;
                            })();
                        }
                        else if (x === undefined && y === undefined) {
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.io.Serializable"] });
                            this.x = 0;
                            this.y = 0;
                            (function () {
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getX = function () {
                        return this.x;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getY = function () {
                        return this.y;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.setLocation$double$double = function (x, y) {
                        this.x = x;
                        this.y = y;
                    };
                    /**
                     * Sets the location of this <code>Point2D</code> to the specified
                     * <code>float</code> coordinates.
                     *
                     * @param x
                     * the new X coordinate of this {@code Point2D}
                     * @param y
                     * the new Y coordinate of this {@code Point2D}
                     * @since 1.2
                     */
                    Float.prototype.setLocation = function (x, y) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            return (function () {
                                _this.x = x;
                                _this.y = y;
                            })();
                        }
                        else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            return this.setLocation$double$double(x, y);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined) {
                            return this.setLocation$java_awt_geom_Point2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * Returns a <code>String</code> that represents the value of this
                     * <code>Point2D</code>.
                     *
                     * @return a string representation of this <code>Point2D</code>.
                     * @since 1.2
                     */
                    Float.prototype.toString = function () {
                        return "Point2D.Float[" + this.x + ", " + this.y + "]";
                    };
                    Float.serialVersionUID = -2870572449815403710;
                    return Float;
                }(java.awt.geom.Point2D));
                Point2D.Float = Float;
                /**
                 * The <code>Double</code> class defines a point specified in
                 * <code>double</code> precision.
                 *
                 * @since 1.2
                 */
                var Double = (function (_super) {
                    __extends(Double, _super);
                    /**
                     * Constructs and initializes a <code>Point2D</code> with the specified
                     * coordinates.
                     *
                     * @param x
                     * the X coordinate of the newly constructed
                     * <code>Point2D</code>
                     * @param y
                     * the Y coordinate of the newly constructed
                     * <code>Point2D</code>
                     * @since 1.2
                     */
                    function Double(x, y) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.io.Serializable"] });
                            this.x = 0;
                            this.y = 0;
                            (function () {
                                _this.x = x;
                                _this.y = y;
                            })();
                        }
                        else if (x === undefined && y === undefined) {
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.io.Serializable"] });
                            this.x = 0;
                            this.y = 0;
                            (function () {
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getX = function () {
                        return this.x;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getY = function () {
                        return this.y;
                    };
                    /**
                     * Sets the location of this <code>Point2D</code> to the specified
                     * <code>float</code> coordinates.
                     *
                     * @param x
                     * the new X coordinate of this {@code Point2D}
                     * @param y
                     * the new Y coordinate of this {@code Point2D}
                     * @since 1.2
                     */
                    Double.prototype.setLocation = function (x, y) {
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            return this.setLocation$double$double(x, y);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined) {
                            return this.setLocation$java_awt_geom_Point2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.setLocation$double$double = function (x, y) {
                        this.x = x;
                        this.y = y;
                    };
                    /**
                     * Returns a <code>String</code> that represents the value of this
                     * <code>Point2D</code>.
                     *
                     * @return a string representation of this <code>Point2D</code>.
                     * @since 1.2
                     */
                    Double.prototype.toString = function () {
                        return "Point2D.Double[" + this.x + ", " + this.y + "]";
                    };
                    Double.serialVersionUID = 6150783262733311327;
                    return Double;
                }(java.awt.geom.Point2D));
                Point2D.Double = Double;
            })(Point2D = geom.Point2D || (geom.Point2D = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The <code>QuadCurve2D</code> class defines a quadratic parametric curve
             * segment in {@code (x,y)} coordinate space.
             * <p>
             * This class is only the abstract superclass for all objects that store a 2D
             * quadratic curve segment. The actual storage representation of the coordinates
             * is left to the subclass.
             *
             * @author Jim Graham
             * @since 1.2
             */
            var QuadCurve2D = (function () {
                /**
                 * This is an abstract class that cannot be instantiated directly.
                 * Type-specific implementation subclasses are available for instantiation
                 * and provide a number of formats for storing the information necessary to
                 * satisfy the various accessor methods below.
                 *
                 * @see java.awt.geom.QuadCurve2D.Float
                 * @see java.awt.geom.QuadCurve2D.Double
                 * @since 1.2
                 */
                function QuadCurve2D() {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable"] });
                }
                /**
                 * Sets the location of the end points and control point of this curve
                 * to the specified {@code float} coordinates.
                 *
                 * @param x1
                 * the X coordinate of the start point
                 * @param y1
                 * the Y coordinate of the start point
                 * @param ctrlx
                 * the X coordinate of the control point
                 * @param ctrly
                 * the Y coordinate of the control point
                 * @param x2
                 * the X coordinate of the end point
                 * @param y2
                 * the Y coordinate of the end point
                 * @since 1.2
                 */
                QuadCurve2D.prototype.setCurve = function (x1, y1, ctrlx, ctrly, x2, y2) {
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx === 'number') || ctrlx === null) && ((typeof ctrly === 'number') || ctrly === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        return this.setCurve$double$double$double$double$double$double(x1, y1, ctrlx, ctrly, x2, y2);
                    }
                    else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && ((ctrlx != null && ctrlx instanceof java.awt.geom.Point2D) || ctrlx === null) && ctrly === undefined && x2 === undefined && y2 === undefined) {
                        return this.setCurve$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1, ctrlx);
                    }
                    else if (((x1 != null && x1 instanceof Array) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                        return this.setCurve$double_A$int(x1, y1);
                    }
                    else if (((x1 != null && x1 instanceof Array) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                        return this.setCurve$java_awt_geom_Point2D_A$int(x1, y1);
                    }
                    else if (((x1 != null && x1 instanceof java.awt.geom.QuadCurve2D) || x1 === null) && y1 === undefined && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                        return this.setCurve$java_awt_geom_QuadCurve2D(x1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets the location of the end points and control point of this curve to
                 * the specified <code>double</code> coordinates.
                 *
                 * @param x1
                 * the X coordinate of the start point
                 * @param y1
                 * the Y coordinate of the start point
                 * @param ctrlx
                 * the X coordinate of the control point
                 * @param ctrly
                 * the Y coordinate of the control point
                 * @param x2
                 * the X coordinate of the end point
                 * @param y2
                 * the Y coordinate of the end point
                 * @since 1.2
                 */
                QuadCurve2D.prototype.setCurve$double$double$double$double$double$double = function (x1, y1, ctrlx, ctrly, x2, y2) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Sets the location of the end points and control points of this
                 * <code>QuadCurve2D</code> to the <code>double</code> coordinates at the
                 * specified offset in the specified array.
                 *
                 * @param coords
                 * the array containing coordinate values
                 * @param offset
                 * the index into the array from which to start getting the
                 * coordinate values and assigning them to this
                 * <code>QuadCurve2D</code>
                 * @since 1.2
                 */
                QuadCurve2D.prototype.setCurve$double_A$int = function (coords, offset) {
                    this.setCurve(coords[offset + 0], coords[offset + 1], coords[offset + 2], coords[offset + 3], coords[offset + 4], coords[offset + 5]);
                };
                /**
                 * Sets the location of the end points and control point of this
                 * <code>QuadCurve2D</code> to the specified <code>Point2D</code>
                 * coordinates.
                 *
                 * @param p1
                 * the start point
                 * @param cp
                 * the control point
                 * @param p2
                 * the end point
                 * @since 1.2
                 */
                QuadCurve2D.prototype.setCurve$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D = function (p1, cp, p2) {
                    this.setCurve(p1.getX(), p1.getY(), cp.getX(), cp.getY(), p2.getX(), p2.getY());
                };
                /**
                 * Sets the location of the end points and control points of this
                 * <code>QuadCurve2D</code> to the coordinates of the <code>Point2D</code>
                 * objects at the specified offset in the specified array.
                 *
                 * @param pts
                 * an array containing <code>Point2D</code> that define
                 * coordinate values
                 * @param offset
                 * the index into <code>pts</code> from which to start getting
                 * the coordinate values and assigning them to this
                 * <code>QuadCurve2D</code>
                 * @since 1.2
                 */
                QuadCurve2D.prototype.setCurve$java_awt_geom_Point2D_A$int = function (pts, offset) {
                    this.setCurve(pts[offset + 0].getX(), pts[offset + 0].getY(), pts[offset + 1].getX(), pts[offset + 1].getY(), pts[offset + 2].getX(), pts[offset + 2].getY());
                };
                /**
                 * Sets the location of the end points and control point of this
                 * <code>QuadCurve2D</code> to the same as those in the specified
                 * <code>QuadCurve2D</code>.
                 *
                 * @param c
                 * the specified <code>QuadCurve2D</code>
                 * @since 1.2
                 */
                QuadCurve2D.prototype.setCurve$java_awt_geom_QuadCurve2D = function (c) {
                    this.setCurve(c.getX1(), c.getY1(), c.getCtrlX(), c.getCtrlY(), c.getX2(), c.getY2());
                };
                /**
                 * Returns the square of the flatness, or maximum distance of a control
                 * point from the line connecting the end points, of the quadratic curve
                 * specified by the indicated control points.
                 *
                 * @param x1
                 * the X coordinate of the start point
                 * @param y1
                 * the Y coordinate of the start point
                 * @param ctrlx
                 * the X coordinate of the control point
                 * @param ctrly
                 * the Y coordinate of the control point
                 * @param x2
                 * the X coordinate of the end point
                 * @param y2
                 * the Y coordinate of the end point
                 * @return the square of the flatness of the quadratic curve defined by the
                 * specified coordinates.
                 * @since 1.2
                 */
                QuadCurve2D.getFlatnessSq = function (x1, y1, ctrlx, ctrly, x2, y2) {
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx === 'number') || ctrlx === null) && ((typeof ctrly === 'number') || ctrly === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        return (function () {
                            return java.awt.geom.Line2D.ptSegDistSq(x1, y1, x2, y2, ctrlx, ctrly);
                        })();
                    }
                    else if (((x1 != null && x1 instanceof Array) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                        return java.awt.geom.QuadCurve2D.getFlatnessSq$double_A$int(x1, y1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the flatness, or maximum distance of a control point from the
                 * line connecting the end points, of the quadratic curve specified by the
                 * indicated control points.
                 *
                 * @param x1
                 * the X coordinate of the start point
                 * @param y1
                 * the Y coordinate of the start point
                 * @param ctrlx
                 * the X coordinate of the control point
                 * @param ctrly
                 * the Y coordinate of the control point
                 * @param x2
                 * the X coordinate of the end point
                 * @param y2
                 * the Y coordinate of the end point
                 * @return the flatness of the quadratic curve defined by the specified
                 * coordinates.
                 * @since 1.2
                 */
                QuadCurve2D.getFlatness = function (x1, y1, ctrlx, ctrly, x2, y2) {
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx === 'number') || ctrlx === null) && ((typeof ctrly === 'number') || ctrly === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        return (function () {
                            return java.awt.geom.Line2D.ptSegDist(x1, y1, x2, y2, ctrlx, ctrly);
                        })();
                    }
                    else if (((x1 != null && x1 instanceof Array) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                        return java.awt.geom.QuadCurve2D.getFlatness$double_A$int(x1, y1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the square of the flatness, or maximum distance of a control
                 * point from the line connecting the end points, of the quadratic curve
                 * specified by the control points stored in the indicated array at the
                 * indicated index.
                 *
                 * @param coords
                 * an array containing coordinate values
                 * @param offset
                 * the index into <code>coords</code> from which to to start
                 * getting the values from the array
                 * @return the flatness of the quadratic curve that is defined by the values
                 * in the specified array at the specified index.
                 * @since 1.2
                 */
                QuadCurve2D.getFlatnessSq$double_A$int = function (coords, offset) {
                    return java.awt.geom.Line2D.ptSegDistSq(coords[offset + 0], coords[offset + 1], coords[offset + 4], coords[offset + 5], coords[offset + 2], coords[offset + 3]);
                };
                /**
                 * Returns the flatness, or maximum distance of a control point from the
                 * line connecting the end points, of the quadratic curve specified by the
                 * control points stored in the indicated array at the indicated index.
                 *
                 * @param coords
                 * an array containing coordinate values
                 * @param offset
                 * the index into <code>coords</code> from which to start getting
                 * the coordinate values
                 * @return the flatness of a quadratic curve defined by the specified array
                 * at the specified offset.
                 * @since 1.2
                 */
                QuadCurve2D.getFlatness$double_A$int = function (coords, offset) {
                    return java.awt.geom.Line2D.ptSegDist(coords[offset + 0], coords[offset + 1], coords[offset + 4], coords[offset + 5], coords[offset + 2], coords[offset + 3]);
                };
                /**
                 * Returns the square of the flatness, or maximum distance of a control
                 * point from the line connecting the end points, of this
                 * <code>QuadCurve2D</code>.
                 *
                 * @return the square of the flatness of this <code>QuadCurve2D</code>.
                 * @since 1.2
                 */
                QuadCurve2D.prototype.getFlatnessSq = function () {
                    return java.awt.geom.Line2D.ptSegDistSq(this.getX1(), this.getY1(), this.getX2(), this.getY2(), this.getCtrlX(), this.getCtrlY());
                };
                /**
                 * Returns the flatness, or maximum distance of a control point from the
                 * line connecting the end points, of this <code>QuadCurve2D</code>.
                 *
                 * @return the flatness of this <code>QuadCurve2D</code>.
                 * @since 1.2
                 */
                QuadCurve2D.prototype.getFlatness = function () {
                    return java.awt.geom.Line2D.ptSegDist(this.getX1(), this.getY1(), this.getX2(), this.getY2(), this.getCtrlX(), this.getCtrlY());
                };
                /**
                 * Subdivides this <code>QuadCurve2D</code> and stores the resulting two
                 * subdivided curves into the <code>left</code> and <code>right</code> curve
                 * parameters. Either or both of the <code>left</code> and
                 * <code>right</code> objects can be the same as this
                 * <code>QuadCurve2D</code> or <code>null</code>.
                 *
                 * @param left
                 * the <code>QuadCurve2D</code> object for storing the left or
                 * first half of the subdivided curve
                 * @param right
                 * the <code>QuadCurve2D</code> object for storing the right or
                 * second half of the subdivided curve
                 * @since 1.2
                 */
                QuadCurve2D.prototype.subdivide = function (left, right) {
                    QuadCurve2D.subdivide(this, left, right);
                };
                /**
                 * Subdivides the quadratic curve specified by the <code>src</code>
                 * parameter and stores the resulting two subdivided curves into the
                 * <code>left</code> and <code>right</code> curve parameters. Either or both
                 * of the <code>left</code> and <code>right</code> objects can be the same
                 * as the <code>src</code> object or <code>null</code>.
                 *
                 * @param src
                 * the quadratic curve to be subdivided
                 * @param left
                 * the <code>QuadCurve2D</code> object for storing the left or
                 * first half of the subdivided curve
                 * @param right
                 * the <code>QuadCurve2D</code> object for storing the right or
                 * second half of the subdivided curve
                 * @since 1.2
                 */
                QuadCurve2D.subdivide$java_awt_geom_QuadCurve2D$java_awt_geom_QuadCurve2D$java_awt_geom_QuadCurve2D = function (src, left, right) {
                    var x1 = src.getX1();
                    var y1 = src.getY1();
                    var ctrlx = src.getCtrlX();
                    var ctrly = src.getCtrlY();
                    var x2 = src.getX2();
                    var y2 = src.getY2();
                    var ctrlx1 = (x1 + ctrlx) / 2.0;
                    var ctrly1 = (y1 + ctrly) / 2.0;
                    var ctrlx2 = (x2 + ctrlx) / 2.0;
                    var ctrly2 = (y2 + ctrly) / 2.0;
                    ctrlx = (ctrlx1 + ctrlx2) / 2.0;
                    ctrly = (ctrly1 + ctrly2) / 2.0;
                    if (left != null) {
                        left.setCurve(x1, y1, ctrlx1, ctrly1, ctrlx, ctrly);
                    }
                    if (right != null) {
                        right.setCurve(ctrlx, ctrly, ctrlx2, ctrly2, x2, y2);
                    }
                };
                /**
                 * Subdivides the quadratic curve specified by the coordinates stored in the
                 * <code>src</code> array at indices <code>srcoff</code> through
                 * <code>srcoff</code>&nbsp;+&nbsp;5 and stores the resulting two subdivided
                 * curves into the two result arrays at the corresponding indices. Either or
                 * both of the <code>left</code> and <code>right</code> arrays can be
                 * <code>null</code> or a reference to the same array and offset as the
                 * <code>src</code> array. Note that the last point in the first subdivided
                 * curve is the same as the first point in the second subdivided curve.
                 * Thus, it is possible to pass the same array for <code>left</code> and
                 * <code>right</code> and to use offsets such that <code>rightoff</code>
                 * equals <code>leftoff</code> + 4 in order to avoid allocating extra
                 * storage for this common point.
                 *
                 * @param src
                 * the array holding the coordinates for the source curve
                 * @param srcoff
                 * the offset into the array of the beginning of the the 6 source
                 * coordinates
                 * @param left
                 * the array for storing the coordinates for the first half of
                 * the subdivided curve
                 * @param leftoff
                 * the offset into the array of the beginning of the the 6 left
                 * coordinates
                 * @param right
                 * the array for storing the coordinates for the second half of
                 * the subdivided curve
                 * @param rightoff
                 * the offset into the array of the beginning of the the 6 right
                 * coordinates
                 * @since 1.2
                 */
                QuadCurve2D.subdivide = function (src, srcoff, left, leftoff, right, rightoff) {
                    if (((src != null && src instanceof Array) || src === null) && ((typeof srcoff === 'number') || srcoff === null) && ((left != null && left instanceof Array) || left === null) && ((typeof leftoff === 'number') || leftoff === null) && ((right != null && right instanceof Array) || right === null) && ((typeof rightoff === 'number') || rightoff === null)) {
                        return (function () {
                            var x1 = src[srcoff + 0];
                            var y1 = src[srcoff + 1];
                            var ctrlx = src[srcoff + 2];
                            var ctrly = src[srcoff + 3];
                            var x2 = src[srcoff + 4];
                            var y2 = src[srcoff + 5];
                            if (left != null) {
                                left[leftoff + 0] = x1;
                                left[leftoff + 1] = y1;
                            }
                            if (right != null) {
                                right[rightoff + 4] = x2;
                                right[rightoff + 5] = y2;
                            }
                            x1 = (x1 + ctrlx) / 2.0;
                            y1 = (y1 + ctrly) / 2.0;
                            x2 = (x2 + ctrlx) / 2.0;
                            y2 = (y2 + ctrly) / 2.0;
                            ctrlx = (x1 + x2) / 2.0;
                            ctrly = (y1 + y2) / 2.0;
                            if (left != null) {
                                left[leftoff + 2] = x1;
                                left[leftoff + 3] = y1;
                                left[leftoff + 4] = ctrlx;
                                left[leftoff + 5] = ctrly;
                            }
                            if (right != null) {
                                right[rightoff + 0] = ctrlx;
                                right[rightoff + 1] = ctrly;
                                right[rightoff + 2] = x2;
                                right[rightoff + 3] = y2;
                            }
                        })();
                    }
                    else if (((src != null && src instanceof java.awt.geom.QuadCurve2D) || src === null) && ((srcoff != null && srcoff instanceof java.awt.geom.QuadCurve2D) || srcoff === null) && ((left != null && left instanceof java.awt.geom.QuadCurve2D) || left === null) && leftoff === undefined && right === undefined && rightoff === undefined) {
                        return java.awt.geom.QuadCurve2D.subdivide$java_awt_geom_QuadCurve2D$java_awt_geom_QuadCurve2D$java_awt_geom_QuadCurve2D(src, srcoff, left);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Solves the quadratic whose coefficients are in the <code>eqn</code> array
                 * and places the non-complex roots back into the same array, returning the
                 * number of roots. The quadratic solved is represented by the equation:
                 *
                 * <pre>
                 * eqn = {C, B, A};
                 * ax^2 + bx + c = 0
                 * </pre>
                 *
                 * A return value of <code>-1</code> is used to distinguish a constant
                 * equation, which might be always 0 or never 0, from an equation that has
                 * no zeroes.
                 *
                 * @param eqn
                 * the array that contains the quadratic coefficients
                 * @return the number of roots, or <code>-1</code> if the equation is a
                 * constant
                 * @since 1.2
                 */
                QuadCurve2D.solveQuadratic$double_A = function (eqn) {
                    return QuadCurve2D.solveQuadratic(eqn, eqn);
                };
                /**
                 * Solves the quadratic whose coefficients are in the <code>eqn</code> array
                 * and places the non-complex roots into the <code>res</code> array,
                 * returning the number of roots. The quadratic solved is represented by the
                 * equation:
                 *
                 * <pre>
                 * eqn = {C, B, A};
                 * ax^2 + bx + c = 0
                 * </pre>
                 *
                 * A return value of <code>-1</code> is used to distinguish a constant
                 * equation, which might be always 0 or never 0, from an equation that has
                 * no zeroes.
                 *
                 * @param eqn
                 * the specified array of coefficients to use to solve the
                 * quadratic equation
                 * @param res
                 * the array that contains the non-complex roots resulting from
                 * the solution of the quadratic equation
                 * @return the number of roots, or <code>-1</code> if the equation is a
                 * constant.
                 * @since 1.3
                 */
                QuadCurve2D.solveQuadratic = function (eqn, res) {
                    if (((eqn != null && eqn instanceof Array) || eqn === null) && ((res != null && res instanceof Array) || res === null)) {
                        return (function () {
                            var a = eqn[2];
                            var b = eqn[1];
                            var c = eqn[0];
                            var roots = 0;
                            if (a === 0.0) {
                                if (b === 0.0) {
                                    return -1;
                                }
                                res[roots++] = -c / b;
                            }
                            else {
                                var d = b * b - 4.0 * a * c;
                                if (d < 0.0) {
                                    return 0;
                                }
                                d = Math.sqrt(d);
                                if (b < 0.0) {
                                    d = -d;
                                }
                                var q = (b + d) / -2.0;
                                res[roots++] = q / a;
                                if (q !== 0.0) {
                                    res[roots++] = c / q;
                                }
                            }
                            return roots;
                        })();
                    }
                    else if (((eqn != null && eqn instanceof Array) || eqn === null) && res === undefined) {
                        return java.awt.geom.QuadCurve2D.solveQuadratic$double_A(eqn);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                QuadCurve2D.prototype.contains$double$double = function (x, y) {
                    var x1 = this.getX1();
                    var y1 = this.getY1();
                    var xc = this.getCtrlX();
                    var yc = this.getCtrlY();
                    var x2 = this.getX2();
                    var y2 = this.getY2();
                    var kx = x1 - 2 * xc + x2;
                    var ky = y1 - 2 * yc + y2;
                    var dx = x - x1;
                    var dy = y - y1;
                    var dxl = x2 - x1;
                    var dyl = y2 - y1;
                    var t0 = (dx * ky - dy * kx) / (dxl * ky - dyl * kx);
                    if (t0 < 0 || t0 > 1 || t0 !== t0) {
                        return false;
                    }
                    var xb = kx * t0 * t0 + 2 * (xc - x1) * t0 + x1;
                    var yb = ky * t0 * t0 + 2 * (yc - y1) * t0 + y1;
                    var xl = dxl * t0 + x1;
                    var yl = dyl * t0 + y1;
                    return (x >= xb && x < xl) || (x >= xl && x < xb) || (y >= yb && y < yl) || (y >= yl && y < yb);
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                QuadCurve2D.prototype.contains$java_awt_geom_Point2D = function (p) {
                    return this.contains(p.getX(), p.getY());
                };
                /**
                 * Fill an array with the coefficients of the parametric equation in t,
                 * ready for solving against val with solveQuadratic. We currently have: val
                 * = Py(t) = C1*(1-t)^2 + 2*CP*t*(1-t) + C2*t^2 = C1 - 2*C1*t + C1*t^2 +
                 * 2*CP*t - 2*CP*t^2 + C2*t^2 = C1 + (2*CP - 2*C1)*t + (C1 - 2*CP + C2)*t^2
                 * 0 = (C1 - val) + (2*CP - 2*C1)*t + (C1 - 2*CP + C2)*t^2 0 = C + Bt + At^2
                 * C = C1 - val B = 2*CP - 2*C1 A = C1 - 2*CP + C2
                 */
                QuadCurve2D.fillEqn = function (eqn, val, c1, cp, c2) {
                    eqn[0] = c1 - val;
                    eqn[1] = cp + cp - c1 - c1;
                    eqn[2] = c1 - cp - cp + c2;
                    return;
                };
                /**
                 * Evaluate the t values in the first num slots of the vals[] array and
                 * place the evaluated values back into the same array. Only evaluate t
                 * values that are within the range &lt;0, 1&gt;, including the 0 and 1 ends
                 * of the range iff the include0 or include1 booleans are true. If an
                 * "inflection" equation is handed in, then any points which represent a
                 * point of inflection for that quadratic equation are also ignored.
                 */
                QuadCurve2D.evalQuadratic = function (vals, num, include0, include1, inflect, c1, ctrl, c2) {
                    var j = 0;
                    for (var i = 0; i < num; i++) {
                        var t = vals[i];
                        if ((include0 ? t >= 0 : t > 0) && (include1 ? t <= 1 : t < 1) && (inflect == null || inflect[1] + 2 * inflect[2] * t !== 0)) {
                            var u = 1 - t;
                            vals[j++] = c1 * u * u + 2 * ctrl * t * u + c2 * t * t;
                        }
                    }
                    return j;
                };
                /**
                 * Determine where coord lies with respect to the range from low to high. It
                 * is assumed that low &lt;= high. The return value is one of the 5 values
                 * BELOW, LOWEDGE, INSIDE, HIGHEDGE, or ABOVE.
                 */
                QuadCurve2D.getTag = function (coord, low, high) {
                    if (coord <= low) {
                        return (coord < low ? QuadCurve2D.BELOW : QuadCurve2D.LOWEDGE);
                    }
                    if (coord >= high) {
                        return (coord > high ? QuadCurve2D.ABOVE : QuadCurve2D.HIGHEDGE);
                    }
                    return QuadCurve2D.INSIDE;
                };
                /**
                 * Determine if the pttag represents a coordinate that is already in its
                 * test range, or is on the border with either of the two opttags
                 * representing another coordinate that is "towards the inside" of that test
                 * range. In other words, are either of the two "opt" points
                 * "drawing the pt inward"?
                 */
                QuadCurve2D.inwards = function (pttag, opt1tag, opt2tag) {
                    switch ((pttag)) {
                        case QuadCurve2D.BELOW:
                        case QuadCurve2D.ABOVE:
                        default:
                            return false;
                        case QuadCurve2D.LOWEDGE:
                            return (opt1tag >= QuadCurve2D.INSIDE || opt2tag >= QuadCurve2D.INSIDE);
                        case QuadCurve2D.INSIDE:
                            return true;
                        case QuadCurve2D.HIGHEDGE:
                            return (opt1tag <= QuadCurve2D.INSIDE || opt2tag <= QuadCurve2D.INSIDE);
                    }
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                QuadCurve2D.prototype.intersects = function (x, y, w, h) {
                    var _this = this;
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return (function () {
                            if (w <= 0 || h <= 0) {
                                return false;
                            }
                            var x1 = _this.getX1();
                            var y1 = _this.getY1();
                            var x1tag = QuadCurve2D.getTag(x1, x, x + w);
                            var y1tag = QuadCurve2D.getTag(y1, y, y + h);
                            if (x1tag === QuadCurve2D.INSIDE && y1tag === QuadCurve2D.INSIDE) {
                                return true;
                            }
                            var x2 = _this.getX2();
                            var y2 = _this.getY2();
                            var x2tag = QuadCurve2D.getTag(x2, x, x + w);
                            var y2tag = QuadCurve2D.getTag(y2, y, y + h);
                            if (x2tag === QuadCurve2D.INSIDE && y2tag === QuadCurve2D.INSIDE) {
                                return true;
                            }
                            var ctrlx = _this.getCtrlX();
                            var ctrly = _this.getCtrlY();
                            var ctrlxtag = QuadCurve2D.getTag(ctrlx, x, x + w);
                            var ctrlytag = QuadCurve2D.getTag(ctrly, y, y + h);
                            if (x1tag < QuadCurve2D.INSIDE && x2tag < QuadCurve2D.INSIDE && ctrlxtag < QuadCurve2D.INSIDE) {
                                return false;
                            }
                            if (y1tag < QuadCurve2D.INSIDE && y2tag < QuadCurve2D.INSIDE && ctrlytag < QuadCurve2D.INSIDE) {
                                return false;
                            }
                            if (x1tag > QuadCurve2D.INSIDE && x2tag > QuadCurve2D.INSIDE && ctrlxtag > QuadCurve2D.INSIDE) {
                                return false;
                            }
                            if (y1tag > QuadCurve2D.INSIDE && y2tag > QuadCurve2D.INSIDE && ctrlytag > QuadCurve2D.INSIDE) {
                                return false;
                            }
                            if (QuadCurve2D.inwards(x1tag, x2tag, ctrlxtag) && QuadCurve2D.inwards(y1tag, y2tag, ctrlytag)) {
                                return true;
                            }
                            if (QuadCurve2D.inwards(x2tag, x1tag, ctrlxtag) && QuadCurve2D.inwards(y2tag, y1tag, ctrlytag)) {
                                return true;
                            }
                            var xoverlap = (x1tag * x2tag <= 0);
                            var yoverlap = (y1tag * y2tag <= 0);
                            if (x1tag === QuadCurve2D.INSIDE && x2tag === QuadCurve2D.INSIDE && yoverlap) {
                                return true;
                            }
                            if (y1tag === QuadCurve2D.INSIDE && y2tag === QuadCurve2D.INSIDE && xoverlap) {
                                return true;
                            }
                            var eqn = new Array(3);
                            var res = new Array(3);
                            if (!yoverlap) {
                                QuadCurve2D.fillEqn(eqn, (y1tag < QuadCurve2D.INSIDE ? y : y + h), y1, ctrly, y2);
                                return (QuadCurve2D.solveQuadratic(eqn, res) === 2 && QuadCurve2D.evalQuadratic(res, 2, true, true, null, x1, ctrlx, x2) === 2 && QuadCurve2D.getTag(res[0], x, x + w) * QuadCurve2D.getTag(res[1], x, x + w) <= 0);
                            }
                            if (!xoverlap) {
                                QuadCurve2D.fillEqn(eqn, (x1tag < QuadCurve2D.INSIDE ? x : x + w), x1, ctrlx, x2);
                                return (QuadCurve2D.solveQuadratic(eqn, res) === 2 && QuadCurve2D.evalQuadratic(res, 2, true, true, null, y1, ctrly, y2) === 2 && QuadCurve2D.getTag(res[0], y, y + h) * QuadCurve2D.getTag(res[1], y, y + h) <= 0);
                            }
                            var dx = x2 - x1;
                            var dy = y2 - y1;
                            var k = y2 * x1 - x2 * y1;
                            var c1tag;
                            var c2tag;
                            if (y1tag === QuadCurve2D.INSIDE) {
                                c1tag = x1tag;
                            }
                            else {
                                c1tag = QuadCurve2D.getTag((k + dx * (y1tag < QuadCurve2D.INSIDE ? y : y + h)) / dy, x, x + w);
                            }
                            if (y2tag === QuadCurve2D.INSIDE) {
                                c2tag = x2tag;
                            }
                            else {
                                c2tag = QuadCurve2D.getTag((k + dx * (y2tag < QuadCurve2D.INSIDE ? y : y + h)) / dy, x, x + w);
                            }
                            if (c1tag * c2tag <= 0) {
                                return true;
                            }
                            c1tag = ((c1tag * x1tag <= 0) ? y1tag : y2tag);
                            QuadCurve2D.fillEqn(eqn, (c2tag < QuadCurve2D.INSIDE ? x : x + w), x1, ctrlx, x2);
                            var num = QuadCurve2D.solveQuadratic(eqn, res);
                            QuadCurve2D.evalQuadratic(res, num, true, true, null, y1, ctrly, y2);
                            c2tag = QuadCurve2D.getTag(res[0], y, y + h);
                            return (c1tag * c2tag <= 0);
                        })();
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.intersects$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                QuadCurve2D.prototype.intersects$java_awt_geom_Rectangle2D = function (r) {
                    return this.intersects(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                QuadCurve2D.prototype.contains = function (x, y, w, h) {
                    var _this = this;
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return (function () {
                            if (w <= 0 || h <= 0) {
                                return false;
                            }
                            return (_this.contains(x, y) && _this.contains(x + w, y) && _this.contains(x + w, y + h) && _this.contains(x, y + h));
                        })();
                    }
                    else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined) {
                        return this.contains$double$double(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Point2D(x);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                QuadCurve2D.prototype.contains$java_awt_geom_Rectangle2D = function (r) {
                    return this.contains(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                QuadCurve2D.prototype.getBounds = function () {
                    return this.getBounds2D().getBounds();
                };
                /**
                 * Returns an iteration object that defines the boundary of the shape of
                 * this <code>QuadCurve2D</code>. The iterator for this class is not
                 * multi-threaded safe, which means that this <code>QuadCurve2D</code> class
                 * does not guarantee that modifications to the geometry of this
                 * <code>QuadCurve2D</code> object do not affect any iterations of that
                 * geometry that are already in process.
                 *
                 * @param at
                 * an optional {@link AffineTransform} to apply to the shape
                 * boundary
                 * @return a {@link PathIterator} object that defines the boundary of the
                 * shape.
                 * @since 1.2
                 */
                QuadCurve2D.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
                    return new java.awt.geom.QuadIterator(this, at);
                };
                /**
                 * Returns an iteration object that defines the boundary of the flattened
                 * shape of this <code>QuadCurve2D</code>. The iterator for this class is
                 * not multi-threaded safe, which means that this <code>QuadCurve2D</code>
                 * class does not guarantee that modifications to the geometry of this
                 * <code>QuadCurve2D</code> object do not affect any iterations of that
                 * geometry that are already in process.
                 *
                 * @param at
                 * an optional <code>AffineTransform</code> to apply to the
                 * boundary of the shape
                 * @param flatness
                 * the maximum distance that the control points for a subdivided
                 * curve can be with respect to a line connecting the end points
                 * of this curve before this curve is replaced by a straight line
                 * connecting the end points.
                 * @return a <code>PathIterator</code> object that defines the flattened
                 * boundary of the shape.
                 * @since 1.2
                 */
                QuadCurve2D.prototype.getPathIterator = function (at, flatness) {
                    var _this = this;
                    if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
                        return (function () {
                            return new java.awt.geom.FlatteningPathIterator(_this.getPathIterator(at), flatness);
                        })();
                    }
                    else if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && flatness === undefined) {
                        return this.getPathIterator$java_awt_geom_AffineTransform(at);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Creates a new object of the same class and with the same contents as this
                 * object.
                 *
                 * @return a clone of this instance.
                 * @exception OutOfMemoryError
                 * if there is not enough memory.
                 * @see java.lang.Cloneable
                 * @since 1.2
                 */
                QuadCurve2D.prototype.clone = function () {
                    try {
                        return javaemul.internal.ObjectHelper.clone(this);
                    }
                    catch (e) {
                        throw new java.lang.InternalError(e);
                    }
                    ;
                };
                QuadCurve2D.BELOW = -2;
                QuadCurve2D.LOWEDGE = -1;
                QuadCurve2D.INSIDE = 0;
                QuadCurve2D.HIGHEDGE = 1;
                QuadCurve2D.ABOVE = 2;
                return QuadCurve2D;
            }());
            geom.QuadCurve2D = QuadCurve2D;
            var QuadCurve2D;
            (function (QuadCurve2D) {
                /**
                 * A quadratic parametric curve segment specified with {@code float}
                 * coordinates.
                 *
                 * @since 1.2
                 */
                var Float = (function (_super) {
                    __extends(Float, _super);
                    /**
                     * Constructs and initializes a <code>QuadCurve2D</code> from the
                     * specified {@code float} coordinates.
                     *
                     * @param x1
                     * the X coordinate of the start point
                     * @param y1
                     * the Y coordinate of the start point
                     * @param ctrlx
                     * the X coordinate of the control point
                     * @param ctrly
                     * the Y coordinate of the control point
                     * @param x2
                     * the X coordinate of the end point
                     * @param y2
                     * the Y coordinate of the end point
                     * @since 1.2
                     */
                    function Float(x1, y1, ctrlx, ctrly, x2, y2) {
                        var _this = this;
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx === 'number') || ctrlx === null) && ((typeof ctrly === 'number') || ctrly === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x1 = 0;
                            this.y1 = 0;
                            this.ctrlx = 0;
                            this.ctrly = 0;
                            this.x2 = 0;
                            this.y2 = 0;
                            (function () {
                                _this.setCurve(x1, y1, ctrlx, ctrly, x2, y2);
                            })();
                        }
                        else if (x1 === undefined && y1 === undefined && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x1 = 0;
                            this.y1 = 0;
                            this.ctrlx = 0;
                            this.ctrly = 0;
                            this.x2 = 0;
                            this.y2 = 0;
                            (function () {
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getX1 = function () {
                        return this.x1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getY1 = function () {
                        return this.y1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getP1 = function () {
                        return new java.awt.geom.Point2D.Float(this.x1, this.y1);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getCtrlX = function () {
                        return this.ctrlx;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getCtrlY = function () {
                        return this.ctrly;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getCtrlPt = function () {
                        return new java.awt.geom.Point2D.Float(this.ctrlx, this.ctrly);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getX2 = function () {
                        return this.x2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getY2 = function () {
                        return this.y2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getP2 = function () {
                        return new java.awt.geom.Point2D.Float(this.x2, this.y2);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.setCurve$double$double$double$double$double$double = function (x1, y1, ctrlx, ctrly, x2, y2) {
                        this.x1 = x1;
                        this.y1 = y1;
                        this.ctrlx = ctrlx;
                        this.ctrly = ctrly;
                        this.x2 = x2;
                        this.y2 = y2;
                    };
                    /**
                     * Sets the location of the end points and control point of this curve
                     * to the specified {@code float} coordinates.
                     *
                     * @param x1
                     * the X coordinate of the start point
                     * @param y1
                     * the Y coordinate of the start point
                     * @param ctrlx
                     * the X coordinate of the control point
                     * @param ctrly
                     * the Y coordinate of the control point
                     * @param x2
                     * the X coordinate of the end point
                     * @param y2
                     * the Y coordinate of the end point
                     * @since 1.2
                     */
                    Float.prototype.setCurve = function (x1, y1, ctrlx, ctrly, x2, y2) {
                        var _this = this;
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx === 'number') || ctrlx === null) && ((typeof ctrly === 'number') || ctrly === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            return (function () {
                                _this.x1 = x1;
                                _this.y1 = y1;
                                _this.ctrlx = ctrlx;
                                _this.ctrly = ctrly;
                                _this.x2 = x2;
                                _this.y2 = y2;
                            })();
                        }
                        else if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx === 'number') || ctrlx === null) && ((typeof ctrly === 'number') || ctrly === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            return this.setCurve$double$double$double$double$double$double(x1, y1, ctrlx, ctrly, x2, y2);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && ((ctrlx != null && ctrlx instanceof java.awt.geom.Point2D) || ctrlx === null) && ctrly === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1, ctrlx);
                        }
                        else if (((x1 != null && x1 instanceof Array) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$double_A$int(x1, y1);
                        }
                        else if (((x1 != null && x1 instanceof Array) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_Point2D_A$int(x1, y1);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.QuadCurve2D) || x1 === null) && y1 === undefined && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_QuadCurve2D(x1);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getBounds2D = function () {
                        var left = Math.min(Math.min(this.x1, this.x2), this.ctrlx);
                        var top = Math.min(Math.min(this.y1, this.y2), this.ctrly);
                        var right = Math.max(Math.max(this.x1, this.x2), this.ctrlx);
                        var bottom = Math.max(Math.max(this.y1, this.y2), this.ctrly);
                        return new java.awt.geom.Rectangle2D.Float(left, top, right - left, bottom - top);
                    };
                    Float.serialVersionUID = -8511188402130719609;
                    return Float;
                }(java.awt.geom.QuadCurve2D));
                QuadCurve2D.Float = Float;
                /**
                 * A quadratic parametric curve segment specified with {@code double}
                 * coordinates.
                 *
                 * @since 1.2
                 */
                var Double = (function (_super) {
                    __extends(Double, _super);
                    /**
                     * Constructs and initializes a <code>QuadCurve2D</code> from the
                     * specified {@code double} coordinates.
                     *
                     * @param x1
                     * the X coordinate of the start point
                     * @param y1
                     * the Y coordinate of the start point
                     * @param ctrlx
                     * the X coordinate of the control point
                     * @param ctrly
                     * the Y coordinate of the control point
                     * @param x2
                     * the X coordinate of the end point
                     * @param y2
                     * the Y coordinate of the end point
                     * @since 1.2
                     */
                    function Double(x1, y1, ctrlx, ctrly, x2, y2) {
                        var _this = this;
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx === 'number') || ctrlx === null) && ((typeof ctrly === 'number') || ctrly === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x1 = 0;
                            this.y1 = 0;
                            this.ctrlx = 0;
                            this.ctrly = 0;
                            this.x2 = 0;
                            this.y2 = 0;
                            (function () {
                                _this.setCurve(x1, y1, ctrlx, ctrly, x2, y2);
                            })();
                        }
                        else if (x1 === undefined && y1 === undefined && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x1 = 0;
                            this.y1 = 0;
                            this.ctrlx = 0;
                            this.ctrly = 0;
                            this.x2 = 0;
                            this.y2 = 0;
                            (function () {
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getX1 = function () {
                        return this.x1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getY1 = function () {
                        return this.y1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getP1 = function () {
                        return new java.awt.geom.Point2D.Double(this.x1, this.y1);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getCtrlX = function () {
                        return this.ctrlx;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getCtrlY = function () {
                        return this.ctrly;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getCtrlPt = function () {
                        return new java.awt.geom.Point2D.Double(this.ctrlx, this.ctrly);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getX2 = function () {
                        return this.x2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getY2 = function () {
                        return this.y2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getP2 = function () {
                        return new java.awt.geom.Point2D.Double(this.x2, this.y2);
                    };
                    /**
                     * Sets the location of the end points and control point of this curve
                     * to the specified {@code float} coordinates.
                     *
                     * @param x1
                     * the X coordinate of the start point
                     * @param y1
                     * the Y coordinate of the start point
                     * @param ctrlx
                     * the X coordinate of the control point
                     * @param ctrly
                     * the Y coordinate of the control point
                     * @param x2
                     * the X coordinate of the end point
                     * @param y2
                     * the Y coordinate of the end point
                     * @since 1.2
                     */
                    Double.prototype.setCurve = function (x1, y1, ctrlx, ctrly, x2, y2) {
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx === 'number') || ctrlx === null) && ((typeof ctrly === 'number') || ctrly === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            return this.setCurve$double$double$double$double$double$double(x1, y1, ctrlx, ctrly, x2, y2);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && ((ctrlx != null && ctrlx instanceof java.awt.geom.Point2D) || ctrlx === null) && ctrly === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1, ctrlx);
                        }
                        else if (((x1 != null && x1 instanceof Array) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$double_A$int(x1, y1);
                        }
                        else if (((x1 != null && x1 instanceof Array) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_Point2D_A$int(x1, y1);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.QuadCurve2D) || x1 === null) && y1 === undefined && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_QuadCurve2D(x1);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.setCurve$double$double$double$double$double$double = function (x1, y1, ctrlx, ctrly, x2, y2) {
                        this.x1 = x1;
                        this.y1 = y1;
                        this.ctrlx = ctrlx;
                        this.ctrly = ctrly;
                        this.x2 = x2;
                        this.y2 = y2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getBounds2D = function () {
                        var left = Math.min(Math.min(this.x1, this.x2), this.ctrlx);
                        var top = Math.min(Math.min(this.y1, this.y2), this.ctrly);
                        var right = Math.max(Math.max(this.x1, this.x2), this.ctrlx);
                        var bottom = Math.max(Math.max(this.y1, this.y2), this.ctrly);
                        return new java.awt.geom.Rectangle2D.Double(left, top, right - left, bottom - top);
                    };
                    Double.serialVersionUID = 4217149928428559721;
                    return Double;
                }(java.awt.geom.QuadCurve2D));
                QuadCurve2D.Double = Double;
            })(QuadCurve2D = geom.QuadCurve2D || (geom.QuadCurve2D = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * A utility class to iterate over the path segments of a quadratic curve
             * segment through the PathIterator interface.
             *
             * @author Jim Graham
             */
            var QuadIterator = (function () {
                function QuadIterator(q, at) {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.geom.PathIterator"] });
                    this.index = 0;
                    this.quad = q;
                    this.affine = at;
                }
                /**
                 * Return the winding rule for determining the insideness of the path.
                 *
                 * @see #WIND_EVEN_ODD
                 * @see #WIND_NON_ZERO
                 */
                QuadIterator.prototype.getWindingRule = function () {
                    return java.awt.geom.PathIterator.WIND_NON_ZERO;
                };
                /**
                 * Tests if there are more points to read.
                 *
                 * @return true if there are more points to read
                 */
                QuadIterator.prototype.isDone = function () {
                    return (this.index > 1);
                };
                QuadIterator.prototype.next = function (doNext) {
                    if (doNext === undefined) {
                        return this.next$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Moves the iterator to the next segment of the path forwards along the
                 * primary direction of traversal as long as there are more points in that
                 * direction.
                 */
                QuadIterator.prototype.next$ = function () {
                    this.index++;
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of float x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 */
                QuadIterator.prototype.currentSegment = function (coords) {
                    var _this = this;
                    if (((coords != null && coords instanceof Array) || coords === null)) {
                        return (function () {
                            if (_this.isDone()) {
                                throw new java.util.NoSuchElementException("quad iterator iterator out of bounds");
                            }
                            var type;
                            if (_this.index === 0) {
                                coords[0] = _this.quad.getX1();
                                coords[1] = _this.quad.getY1();
                                type = java.awt.geom.PathIterator.SEG_MOVETO;
                            }
                            else {
                                coords[0] = _this.quad.getCtrlX();
                                coords[1] = _this.quad.getCtrlY();
                                coords[2] = _this.quad.getX2();
                                coords[3] = _this.quad.getY2();
                                type = java.awt.geom.PathIterator.SEG_QUADTO;
                            }
                            if (_this.affine != null) {
                                _this.affine.transform(coords, 0, coords, 0, _this.index === 0 ? 1 : 2);
                            }
                            return type;
                        })();
                    }
                    else if (((coords != null && coords instanceof Array) || coords === null)) {
                        return this.currentSegment$double_A(coords);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A double array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of double x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 */
                QuadIterator.prototype.currentSegment$double_A = function (coords) {
                    if (this.isDone()) {
                        throw new java.util.NoSuchElementException("quad iterator iterator out of bounds");
                    }
                    var type;
                    if (this.index === 0) {
                        coords[0] = this.quad.getX1();
                        coords[1] = this.quad.getY1();
                        type = java.awt.geom.PathIterator.SEG_MOVETO;
                    }
                    else {
                        coords[0] = this.quad.getCtrlX();
                        coords[1] = this.quad.getCtrlY();
                        coords[2] = this.quad.getX2();
                        coords[3] = this.quad.getY2();
                        type = java.awt.geom.PathIterator.SEG_QUADTO;
                    }
                    if (this.affine != null) {
                        this.affine.transform(coords, 0, coords, 0, this.index === 0 ? 1 : 2);
                    }
                    return type;
                };
                return QuadIterator;
            }());
            geom.QuadIterator = QuadIterator;
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * <code>RectangularShape</code> is the base class for a number of {@link Shape}
             * objects whose geometry is defined by a rectangular frame. This class does not
             * directly specify any specific geometry by itself, but merely provides
             * manipulation methods inherited by a whole category of <code>Shape</code>
             * objects. The manipulation methods provided by this class can be used to query
             * and modify the rectangular frame, which provides a reference for the
             * subclasses to define their geometry.
             *
             * @author Jim Graham
             * @since 1.2
             */
            var RectangularShape = (function () {
                /**
                 * This is an abstract class that cannot be instantiated directly.
                 *
                 * @see Arc2D
                 * @see Ellipse2D
                 * @see Rectangle2D
                 * @see RoundRectangle2D
                 * @since 1.2
                 */
                function RectangularShape() {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable"] });
                }
                /**
                 * Returns the smallest X coordinate of the framing rectangle of the
                 * <code>Shape</code> in <code>double</code> precision.
                 *
                 * @return the smallest X coordinate of the framing rectangle of the
                 * <code>Shape</code>.
                 * @since 1.2
                 */
                RectangularShape.prototype.getMinX = function () {
                    return this.getX();
                };
                /**
                 * Returns the smallest Y coordinate of the framing rectangle of the
                 * <code>Shape</code> in <code>double</code> precision.
                 *
                 * @return the smallest Y coordinate of the framing rectangle of the
                 * <code>Shape</code>.
                 * @since 1.2
                 */
                RectangularShape.prototype.getMinY = function () {
                    return this.getY();
                };
                /**
                 * Returns the largest X coordinate of the framing rectangle of the
                 * <code>Shape</code> in <code>double</code> precision.
                 *
                 * @return the largest X coordinate of the framing rectangle of the
                 * <code>Shape</code>.
                 * @since 1.2
                 */
                RectangularShape.prototype.getMaxX = function () {
                    return this.getX() + this.getWidth();
                };
                /**
                 * Returns the largest Y coordinate of the framing rectangle of the
                 * <code>Shape</code> in <code>double</code> precision.
                 *
                 * @return the largest Y coordinate of the framing rectangle of the
                 * <code>Shape</code>.
                 * @since 1.2
                 */
                RectangularShape.prototype.getMaxY = function () {
                    return this.getY() + this.getHeight();
                };
                /**
                 * Returns the X coordinate of the center of the framing rectangle of the
                 * <code>Shape</code> in <code>double</code> precision.
                 *
                 * @return the X coordinate of the center of the framing rectangle of the
                 * <code>Shape</code>.
                 * @since 1.2
                 */
                RectangularShape.prototype.getCenterX = function () {
                    return this.getX() + this.getWidth() / 2.0;
                };
                /**
                 * Returns the Y coordinate of the center of the framing rectangle of the
                 * <code>Shape</code> in <code>double</code> precision.
                 *
                 * @return the Y coordinate of the center of the framing rectangle of the
                 * <code>Shape</code>.
                 * @since 1.2
                 */
                RectangularShape.prototype.getCenterY = function () {
                    return this.getY() + this.getHeight() / 2.0;
                };
                /**
                 * Returns the framing {@link Rectangle2D} that defines the overall shape of
                 * this object.
                 *
                 * @return a <code>Rectangle2D</code>, specified in <code>double</code>
                 * coordinates.
                 * @see #setFrame(double, double, double, double)
                 * @see #setFrame(Point2D, Dimension2D)
                 * @see #setFrame(Rectangle2D)
                 * @since 1.2
                 */
                RectangularShape.prototype.getFrame = function () {
                    return new java.awt.geom.Rectangle2D.Double(this.getX(), this.getY(), this.getWidth(), this.getHeight());
                };
                RectangularShape.prototype.setFrame = function (x, y, w, h) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return this.setFrame$double$double$double$double(x, y, w, h);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && ((y != null && y instanceof java.awt.geom.Dimension2D) || y === null) && w === undefined && h === undefined) {
                        return this.setFrame$java_awt_geom_Point2D$java_awt_geom_Dimension2D(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.setFrame$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets the location and size of the framing rectangle of this
                 * <code>Shape</code> to the specified rectangular values.
                 *
                 * @param x
                 * the X coordinate of the upper-left corner of the specified
                 * rectangular shape
                 * @param y
                 * the Y coordinate of the upper-left corner of the specified
                 * rectangular shape
                 * @param w
                 * the width of the specified rectangular shape
                 * @param h
                 * the height of the specified rectangular shape
                 * @see #getFrame
                 * @since 1.2
                 */
                RectangularShape.prototype.setFrame$double$double$double$double = function (x, y, w, h) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Sets the location and size of the framing rectangle of this
                 * <code>Shape</code> to the specified {@link Point2D} and
                 * {@link Dimension2D}, respectively. The framing rectangle is used by the
                 * subclasses of <code>RectangularShape</code> to define their geometry.
                 *
                 * @param loc
                 * the specified <code>Point2D</code>
                 * @param size
                 * the specified <code>Dimension2D</code>
                 * @see #getFrame
                 * @since 1.2
                 */
                RectangularShape.prototype.setFrame$java_awt_geom_Point2D$java_awt_geom_Dimension2D = function (loc, size) {
                    this.setFrame(loc.getX(), loc.getY(), size.getWidth(), size.getHeight());
                };
                /**
                 * Sets the framing rectangle of this <code>Shape</code> to be the specified
                 * <code>Rectangle2D</code>. The framing rectangle is used by the subclasses
                 * of <code>RectangularShape</code> to define their geometry.
                 *
                 * @param r
                 * the specified <code>Rectangle2D</code>
                 * @see #getFrame
                 * @since 1.2
                 */
                RectangularShape.prototype.setFrame$java_awt_geom_Rectangle2D = function (r) {
                    this.setFrame(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                /**
                 * Sets the diagonal of the framing rectangle of this <code>Shape</code>
                 * based on the two specified coordinates. The framing rectangle is used by
                 * the subclasses of <code>RectangularShape</code> to define their geometry.
                 *
                 * @param x1
                 * the X coordinate of the start point of the specified diagonal
                 * @param y1
                 * the Y coordinate of the start point of the specified diagonal
                 * @param x2
                 * the X coordinate of the end point of the specified diagonal
                 * @param y2
                 * the Y coordinate of the end point of the specified diagonal
                 * @since 1.2
                 */
                RectangularShape.prototype.setFrameFromDiagonal = function (x1, y1, x2, y2) {
                    var _this = this;
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        return (function () {
                            if (x2 < x1) {
                                var t = x1;
                                x1 = x2;
                                x2 = t;
                            }
                            if (y2 < y1) {
                                var t = y1;
                                y1 = y2;
                                y2 = t;
                            }
                            _this.setFrame(x1, y1, x2 - x1, y2 - y1);
                        })();
                    }
                    else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && x2 === undefined && y2 === undefined) {
                        return this.setFrameFromDiagonal$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets the diagonal of the framing rectangle of this <code>Shape</code>
                 * based on two specified <code>Point2D</code> objects. The framing
                 * rectangle is used by the subclasses of <code>RectangularShape</code> to
                 * define their geometry.
                 *
                 * @param p1
                 * the start <code>Point2D</code> of the specified diagonal
                 * @param p2
                 * the end <code>Point2D</code> of the specified diagonal
                 * @since 1.2
                 */
                RectangularShape.prototype.setFrameFromDiagonal$java_awt_geom_Point2D$java_awt_geom_Point2D = function (p1, p2) {
                    this.setFrameFromDiagonal(p1.getX(), p1.getY(), p2.getX(), p2.getY());
                };
                /**
                 * Sets the framing rectangle of this <code>Shape</code> based on the
                 * specified center point coordinates and corner point coordinates. The
                 * framing rectangle is used by the subclasses of
                 * <code>RectangularShape</code> to define their geometry.
                 *
                 * @param centerX
                 * the X coordinate of the specified center point
                 * @param centerY
                 * the Y coordinate of the specified center point
                 * @param cornerX
                 * the X coordinate of the specified corner point
                 * @param cornerY
                 * the Y coordinate of the specified corner point
                 * @since 1.2
                 */
                RectangularShape.prototype.setFrameFromCenter = function (centerX, centerY, cornerX, cornerY) {
                    var _this = this;
                    if (((typeof centerX === 'number') || centerX === null) && ((typeof centerY === 'number') || centerY === null) && ((typeof cornerX === 'number') || cornerX === null) && ((typeof cornerY === 'number') || cornerY === null)) {
                        return (function () {
                            var halfW = Math.abs(cornerX - centerX);
                            var halfH = Math.abs(cornerY - centerY);
                            _this.setFrame(centerX - halfW, centerY - halfH, halfW * 2.0, halfH * 2.0);
                        })();
                    }
                    else if (((centerX != null && centerX instanceof java.awt.geom.Point2D) || centerX === null) && ((centerY != null && centerY instanceof java.awt.geom.Point2D) || centerY === null) && cornerX === undefined && cornerY === undefined) {
                        return this.setFrameFromCenter$java_awt_geom_Point2D$java_awt_geom_Point2D(centerX, centerY);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets the framing rectangle of this <code>Shape</code> based on a
                 * specified center <code>Point2D</code> and corner <code>Point2D</code>.
                 * The framing rectangle is used by the subclasses of
                 * <code>RectangularShape</code> to define their geometry.
                 *
                 * @param center
                 * the specified center <code>Point2D</code>
                 * @param corner
                 * the specified corner <code>Point2D</code>
                 * @since 1.2
                 */
                RectangularShape.prototype.setFrameFromCenter$java_awt_geom_Point2D$java_awt_geom_Point2D = function (center, corner) {
                    this.setFrameFromCenter(center.getX(), center.getY(), corner.getX(), corner.getY());
                };
                RectangularShape.prototype.contains = function (x, y, w, h, origrect) {
                    if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$java_awt_geom_Point2D(x);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                RectangularShape.prototype.contains$java_awt_geom_Point2D = function (p) {
                    return this.contains(p.getX(), p.getY());
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                RectangularShape.prototype.intersects$java_awt_geom_Rectangle2D = function (r) {
                    return this.intersects(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                RectangularShape.prototype.contains$java_awt_geom_Rectangle2D = function (r) {
                    return this.contains(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                RectangularShape.prototype.getBounds = function () {
                    var width = this.getWidth();
                    var height = this.getHeight();
                    if (width < 0 || height < 0) {
                        return new java.awt.Rectangle();
                    }
                    var x = this.getX();
                    var y = this.getY();
                    var x1 = Math.floor(x);
                    var y1 = Math.floor(y);
                    var x2 = Math.ceil(x + width);
                    var y2 = Math.ceil(y + height);
                    return new java.awt.Rectangle((x1 | 0), (y1 | 0), ((x2 - x1) | 0), ((y2 - y1) | 0));
                };
                /**
                 * Returns an iterator object that iterates along the <code>Shape</code>
                 * object's boundary and provides access to a flattened view of the outline
                 * of the <code>Shape</code> object's geometry.
                 * <p>
                 * Only SEG_MOVETO, SEG_LINETO, and SEG_CLOSE point types will be returned
                 * by the iterator.
                 * <p>
                 * The amount of subdivision of the curved segments is controlled by the
                 * <code>flatness</code> parameter, which specifies the maximum distance
                 * that any point on the unflattened transformed curve can deviate from the
                 * returned flattened path segments. An optional {@link AffineTransform} can
                 * be specified so that the coordinates returned in the iteration are
                 * transformed accordingly.
                 *
                 * @param at
                 * an optional <code>AffineTransform</code> to be applied to the
                 * coordinates as they are returned in the iteration, or
                 * <code>null</code> if untransformed coordinates are desired.
                 * @param flatness
                 * the maximum distance that the line segments used to
                 * approximate the curved segments are allowed to deviate from
                 * any point on the original curve
                 * @return a <code>PathIterator</code> object that provides access to the
                 * <code>Shape</code> object's flattened geometry.
                 * @since 1.2
                 */
                RectangularShape.prototype.getPathIterator = function (at, flatness) {
                    var _this = this;
                    if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
                        return (function () {
                            return new java.awt.geom.FlatteningPathIterator(_this.getPathIterator(at), flatness);
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Creates a new object of the same class and with the same contents as this
                 * object.
                 *
                 * @return a clone of this instance.
                 * @exception OutOfMemoryError
                 * if there is not enough memory.
                 * @see java.lang.Cloneable
                 * @since 1.2
                 */
                RectangularShape.prototype.clone = function () {
                    try {
                        return javaemul.internal.ObjectHelper.clone(this);
                    }
                    catch (e) {
                        throw new java.lang.InternalError(e);
                    }
                    ;
                };
                return RectangularShape;
            }());
            geom.RectangularShape = RectangularShape;
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * A utility class to iterate over the path segments of a rectangle through the
             * PathIterator interface.
             *
             * @author Jim Graham
             */
            var RectIterator = (function () {
                function RectIterator(r, at) {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.geom.PathIterator"] });
                    this.x = 0;
                    this.y = 0;
                    this.w = 0;
                    this.h = 0;
                    this.index = 0;
                    this.x = r.getX();
                    this.y = r.getY();
                    this.w = r.getWidth();
                    this.h = r.getHeight();
                    this.affine = at;
                    if (this.w < 0 || this.h < 0) {
                        this.index = 6;
                    }
                }
                /**
                 * Return the winding rule for determining the insideness of the path.
                 *
                 * @see #WIND_EVEN_ODD
                 * @see #WIND_NON_ZERO
                 */
                RectIterator.prototype.getWindingRule = function () {
                    return java.awt.geom.PathIterator.WIND_NON_ZERO;
                };
                /**
                 * Tests if there are more points to read.
                 *
                 * @return true if there are more points to read
                 */
                RectIterator.prototype.isDone = function () {
                    return this.index > 5;
                };
                RectIterator.prototype.next = function (doNext) {
                    if (doNext === undefined) {
                        return this.next$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Moves the iterator to the next segment of the path forwards along the
                 * primary direction of traversal as long as there are more points in that
                 * direction.
                 */
                RectIterator.prototype.next$ = function () {
                    this.index++;
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of float x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 */
                RectIterator.prototype.currentSegment = function (coords) {
                    var _this = this;
                    if (((coords != null && coords instanceof Array) || coords === null)) {
                        return (function () {
                            if (_this.isDone()) {
                                throw new java.util.NoSuchElementException("rect iterator out of bounds");
                            }
                            if (_this.index === 5) {
                                return java.awt.geom.PathIterator.SEG_CLOSE;
                            }
                            coords[0] = _this.x;
                            coords[1] = _this.y;
                            if (_this.index === 1 || _this.index === 2) {
                                coords[0] += _this.w;
                            }
                            if (_this.index === 2 || _this.index === 3) {
                                coords[1] += _this.h;
                            }
                            if (_this.affine != null) {
                                _this.affine.transform(coords, 0, coords, 0, 1);
                            }
                            return (_this.index === 0 ? java.awt.geom.PathIterator.SEG_MOVETO : java.awt.geom.PathIterator.SEG_LINETO);
                        })();
                    }
                    else if (((coords != null && coords instanceof Array) || coords === null)) {
                        return this.currentSegment$double_A(coords);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A double array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of double x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 */
                RectIterator.prototype.currentSegment$double_A = function (coords) {
                    if (this.isDone()) {
                        throw new java.util.NoSuchElementException("rect iterator out of bounds");
                    }
                    if (this.index === 5) {
                        return java.awt.geom.PathIterator.SEG_CLOSE;
                    }
                    coords[0] = this.x;
                    coords[1] = this.y;
                    if (this.index === 1 || this.index === 2) {
                        coords[0] += this.w;
                    }
                    if (this.index === 2 || this.index === 3) {
                        coords[1] += this.h;
                    }
                    if (this.affine != null) {
                        this.affine.transform(coords, 0, coords, 0, 1);
                    }
                    return (this.index === 0 ? java.awt.geom.PathIterator.SEG_MOVETO : java.awt.geom.PathIterator.SEG_LINETO);
                };
                return RectIterator;
            }());
            geom.RectIterator = RectIterator;
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * A utility class to iterate over the path segments of an rounded rectangle
             * through the PathIterator interface.
             *
             * @author Jim Graham
             */
            var RoundRectIterator = (function () {
                function RoundRectIterator(rr, at) {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.geom.PathIterator"] });
                    this.x = 0;
                    this.y = 0;
                    this.w = 0;
                    this.h = 0;
                    this.aw = 0;
                    this.ah = 0;
                    this.index = 0;
                    this.x = rr.getX();
                    this.y = rr.getY();
                    this.w = rr.getWidth();
                    this.h = rr.getHeight();
                    this.aw = Math.min(this.w, Math.abs(rr.getArcWidth()));
                    this.ah = Math.min(this.h, Math.abs(rr.getArcHeight()));
                    this.affine = at;
                    if (this.aw < 0 || this.ah < 0) {
                        this.index = RoundRectIterator.ctrlpts_$LI$().length;
                    }
                }
                /**
                 * Return the winding rule for determining the insideness of the path.
                 *
                 * @see #WIND_EVEN_ODD
                 * @see #WIND_NON_ZERO
                 */
                RoundRectIterator.prototype.getWindingRule = function () {
                    return java.awt.geom.PathIterator.WIND_NON_ZERO;
                };
                /**
                 * Tests if there are more points to read.
                 *
                 * @return true if there are more points to read
                 */
                RoundRectIterator.prototype.isDone = function () {
                    return this.index >= RoundRectIterator.ctrlpts_$LI$().length;
                };
                RoundRectIterator.prototype.next = function (doNext) {
                    if (doNext === undefined) {
                        return this.next$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Moves the iterator to the next segment of the path forwards along the
                 * primary direction of traversal as long as there are more points in that
                 * direction.
                 */
                RoundRectIterator.prototype.next$ = function () {
                    this.index++;
                };
                RoundRectIterator.angle_$LI$ = function () { if (RoundRectIterator.angle == null)
                    RoundRectIterator.angle = Math.PI / 4.0; return RoundRectIterator.angle; };
                ;
                RoundRectIterator.a_$LI$ = function () { if (RoundRectIterator.a == null)
                    RoundRectIterator.a = 1.0 - Math.cos(RoundRectIterator.angle_$LI$()); return RoundRectIterator.a; };
                ;
                RoundRectIterator.b_$LI$ = function () { if (RoundRectIterator.b == null)
                    RoundRectIterator.b = Math.tan(RoundRectIterator.angle_$LI$()); return RoundRectIterator.b; };
                ;
                RoundRectIterator.c_$LI$ = function () { if (RoundRectIterator.c == null)
                    RoundRectIterator.c = Math.sqrt(1.0 + RoundRectIterator.b_$LI$() * RoundRectIterator.b_$LI$()) - 1 + RoundRectIterator.a_$LI$(); return RoundRectIterator.c; };
                ;
                RoundRectIterator.cv_$LI$ = function () { if (RoundRectIterator.cv == null)
                    RoundRectIterator.cv = 4.0 / 3.0 * RoundRectIterator.a_$LI$() * RoundRectIterator.b_$LI$() / RoundRectIterator.c_$LI$(); return RoundRectIterator.cv; };
                ;
                RoundRectIterator.acv_$LI$ = function () { if (RoundRectIterator.acv == null)
                    RoundRectIterator.acv = (1.0 - RoundRectIterator.cv_$LI$()) / 2.0; return RoundRectIterator.acv; };
                ;
                RoundRectIterator.ctrlpts_$LI$ = function () { if (RoundRectIterator.ctrlpts == null)
                    RoundRectIterator.ctrlpts = [[0.0, 0.0, 0.0, 0.5], [0.0, 0.0, 1.0, -0.5], [0.0, 0.0, 1.0, -RoundRectIterator.acv_$LI$(), 0.0, RoundRectIterator.acv_$LI$(), 1.0, 0.0, 0.0, 0.5, 1.0, 0.0], [1.0, -0.5, 1.0, 0.0], [1.0, -RoundRectIterator.acv_$LI$(), 1.0, 0.0, 1.0, 0.0, 1.0, -RoundRectIterator.acv_$LI$(), 1.0, 0.0, 1.0, -0.5], [1.0, 0.0, 0.0, 0.5], [1.0, 0.0, 0.0, RoundRectIterator.acv_$LI$(), 1.0, -RoundRectIterator.acv_$LI$(), 0.0, 0.0, 1.0, -0.5, 0.0, 0.0], [0.0, 0.5, 0.0, 0.0], [0.0, RoundRectIterator.acv_$LI$(), 0.0, 0.0, 0.0, 0.0, 0.0, RoundRectIterator.acv_$LI$(), 0.0, 0.0, 0.0, 0.5], []]; return RoundRectIterator.ctrlpts; };
                ;
                RoundRectIterator.types_$LI$ = function () { if (RoundRectIterator.types == null)
                    RoundRectIterator.types = [java.awt.geom.PathIterator.SEG_MOVETO, java.awt.geom.PathIterator.SEG_LINETO, java.awt.geom.PathIterator.SEG_CUBICTO, java.awt.geom.PathIterator.SEG_LINETO, java.awt.geom.PathIterator.SEG_CUBICTO, java.awt.geom.PathIterator.SEG_LINETO, java.awt.geom.PathIterator.SEG_CUBICTO, java.awt.geom.PathIterator.SEG_LINETO, java.awt.geom.PathIterator.SEG_CUBICTO, java.awt.geom.PathIterator.SEG_CLOSE]; return RoundRectIterator.types; };
                ;
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of float x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 */
                RoundRectIterator.prototype.currentSegment = function (coords) {
                    var _this = this;
                    if (((coords != null && coords instanceof Array) || coords === null)) {
                        return (function () {
                            if (_this.isDone()) {
                                throw new java.util.NoSuchElementException("roundrect iterator out of bounds");
                            }
                            var ctrls = RoundRectIterator.ctrlpts_$LI$()[_this.index];
                            var nc = 0;
                            for (var i = 0; i < ctrls.length; i += 4) {
                                coords[nc++] = (_this.x + ctrls[i + 0] * _this.w + ctrls[i + 1] * _this.aw);
                                coords[nc++] = (_this.y + ctrls[i + 2] * _this.h + ctrls[i + 3] * _this.ah);
                            }
                            if (_this.affine != null) {
                                _this.affine.transform(coords, 0, coords, 0, (nc / 2 | 0));
                            }
                            return RoundRectIterator.types_$LI$()[_this.index];
                        })();
                    }
                    else if (((coords != null && coords instanceof Array) || coords === null)) {
                        return this.currentSegment$double_A(coords);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A double array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of double x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 */
                RoundRectIterator.prototype.currentSegment$double_A = function (coords) {
                    if (this.isDone()) {
                        throw new java.util.NoSuchElementException("roundrect iterator out of bounds");
                    }
                    var ctrls = RoundRectIterator.ctrlpts_$LI$()[this.index];
                    var nc = 0;
                    for (var i = 0; i < ctrls.length; i += 4) {
                        coords[nc++] = (this.x + ctrls[i + 0] * this.w + ctrls[i + 1] * this.aw);
                        coords[nc++] = (this.y + ctrls[i + 2] * this.h + ctrls[i + 3] * this.ah);
                    }
                    if (this.affine != null) {
                        this.affine.transform(coords, 0, coords, 0, (nc / 2 | 0));
                    }
                    return RoundRectIterator.types_$LI$()[this.index];
                };
                return RoundRectIterator;
            }());
            geom.RoundRectIterator = RoundRectIterator;
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        var Graphics = (function () {
            function Graphics() {
            }
            return Graphics;
        }());
        awt.Graphics = Graphics;
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        var GridLayout = (function () {
            function GridLayout(rows, cols) {
                this.currentPosition = 0;
                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.HTMLComponent", "java.awt.Layout"] });
                this.cols = 0;
                this.rows = 0;
                this.rows = rows;
                this.cols = cols;
            }
            GridLayout.prototype.add = function (component) {
                if (this.table == null) {
                    this.init();
                }
                var pos = 0;
                for (var j = 0; j < this.rows; j++) {
                    var row = this.table.childNodes[j];
                    for (var i = 0; i < this.cols; i++) {
                        var col = row.childNodes[i];
                        if (pos++ === this.currentPosition) {
                            col.appendChild(component.getHTMLElement());
                            component.getHTMLElement().style.width = "100%";
                            component.getHTMLElement().style.height = "100%";
                            this.currentPosition++;
                            return;
                        }
                    }
                }
            };
            GridLayout.prototype.getHTMLElement = function () {
                if (this.table == null) {
                    this.init();
                }
                return this.table;
            };
            GridLayout.prototype.bind = function (id) {
            };
            GridLayout.prototype.init = function () {
                this.table = document.createElement("table");
                this.table.style.width = "100%";
                this.table.style.height = "100%";
                this.table.style.position = "absolute";
                this.table.style.left = "0px";
                this.table.style.right = "0px";
                this.table.style.zIndex = "0";
                for (var j = 0; j < this.rows; j++) {
                    var row = document.createElement("tr");
                    this.table.appendChild(row);
                    for (var i = 0; i < this.cols; i++) {
                        var col = document.createElement("td");
                        row.appendChild(col);
                        col.style.width = "" + (((100 | 0) / this.cols | 0)) + "%";
                    }
                }
            };
            return GridLayout;
        }());
        awt.GridLayout = GridLayout;
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var beans;
    (function (beans) {
        /**
         * General-purpose beans control methods. GWT only supports a limited subset of these methods. Only
         * the documented methods are available.
         */
        var Beans = (function () {
            function Beans() {
            }
            /**
             * @return <code>true</code> if we are running in the design time mode.
             */
            Beans.isDesignTime = function () {
                return false;
            };
            return Beans;
        }());
        beans.Beans = Beans;
    })(beans = java.beans || (java.beans = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var io;
    (function (io) {
        /**
         * Package-private abstract class for the local filesystem abstraction.
         */
        var FileSystem = (function () {
            function FileSystem() {
            }
            FileSystem.__static_initialize = function () { if (!FileSystem.__static_initialized) {
                FileSystem.__static_initialized = true;
                FileSystem.__static_initializer_0();
            } };
            FileSystem.prototype.normalize = function (pathname, len, off) {
                if (((typeof pathname === 'string') || pathname === null) && len === undefined && off === undefined) {
                    return this.normalize$java_lang_String(pathname);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Convert the given pathname string to normal form.  If the string is
             * already in normal form then it is simply returned.
             */
            FileSystem.prototype.normalize$java_lang_String = function (path) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
            /**
             * Resolve the child pathname string against the parent.
             * Both strings must be in normal form, and the result
             * will be in normal form.
             */
            FileSystem.prototype.resolve = function (parent, child) {
                if (((typeof parent === 'string') || parent === null) && ((typeof child === 'string') || child === null)) {
                    return null;
                }
                else if (((parent != null && parent instanceof java.io.File) || parent === null) && child === undefined) {
                    return this.resolve$java_io_File(parent);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Resolve the given abstract pathname into absolute form.  Invoked by the
             * getAbsolutePath and getCanonicalPath methods in the File class.
             */
            FileSystem.prototype.resolve$java_io_File = function (f) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
            FileSystem.getBooleanProperty = function (prop, defaultVal) {
                var val = java.lang.System.getProperty(prop);
                if (val == null)
                    return defaultVal;
                if ((function (o1, o2) { return o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()); })(val, "true")) {
                    return true;
                }
                else {
                    return false;
                }
            };
            FileSystem.__static_initializer_0 = function () {
                FileSystem.useCanonCaches = FileSystem.getBooleanProperty("sun.io.useCanonCaches", FileSystem.useCanonCaches);
                FileSystem.useCanonPrefixCache = FileSystem.getBooleanProperty("sun.io.useCanonPrefixCache", FileSystem.useCanonPrefixCache);
            };
            FileSystem.__static_initialized = false;
            FileSystem.BA_EXISTS = 1;
            FileSystem.BA_REGULAR = 2;
            FileSystem.BA_DIRECTORY = 4;
            FileSystem.BA_HIDDEN = 8;
            FileSystem.ACCESS_READ = 4;
            FileSystem.ACCESS_WRITE = 2;
            FileSystem.ACCESS_EXECUTE = 1;
            FileSystem.SPACE_TOTAL = 0;
            FileSystem.SPACE_FREE = 1;
            FileSystem.SPACE_USABLE = 2;
            FileSystem.useCanonCaches = true;
            FileSystem.useCanonPrefixCache = true;
            return FileSystem;
        }());
        io.FileSystem = FileSystem;
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var io;
    (function (io) {
        /**
         * A readable source of bytes.
         *
         * <p>Most clients will use input streams that read data from the file system
         * ({@link FileInputStream}), the network ({@link java.net.Socket#getInputStream()}/{@link
         * java.net.HttpURLConnection#getInputStream()}), or from an in-memory byte
         * array ({@link ByteArrayInputStream}).
         *
         * <p>Use {@link InputStreamReader} to adapt a byte stream like this one into a
         * character stream.
         *
         * <p>Most clients should wrap their input stream with {@link
         * BufferedInputStream}. Callers that do only bulk reads may omit buffering.
         *
         * <p>Some implementations support marking a position in the input stream and
         * resetting back to this position later. Implementations that don't return
         * false from {@link #markSupported()} and throw an {@link IOException} when
         * {@link #reset()} is called.
         *
         * <h3>Subclassing InputStream</h3>
         * Subclasses that decorate another input stream should consider subclassing
         * {@link FilterInputStream}, which delegates all calls to the source input
         * stream.
         *
         * <p>All input stream subclasses should override <strong>both</strong> {@link
         * #read() read()} and {@link #read(byte[],int,int) read(byte[],int,int)}. The
         * three argument overload is necessary for bulk access to the data. This is
         * much more efficient than byte-by-byte access.
         *
         * @see OutputStream
         */
        var InputStream = (function () {
            /**
             * This constructor does nothing. It is provided for signature
             * compatibility.
             */
            function InputStream() {
                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Closeable", "java.lang.AutoCloseable"] });
            }
            /**
             * Returns an estimated number of bytes that can be read or skipped without blocking for more
             * input.
             *
             * <p>Note that this method provides such a weak guarantee that it is not very useful in
             * practice.
             *
             * <p>Firstly, the guarantee is "without blocking for more input" rather than "without
             * blocking": a read may still block waiting for I/O to complete&nbsp;&mdash; the guarantee is
             * merely that it won't have to wait indefinitely for data to be written. The result of this
             * method should not be used as a license to do I/O on a thread that shouldn't be blocked.
             *
             * <p>Secondly, the result is a
             * conservative estimate and may be significantly smaller than the actual number of bytes
             * available. In particular, an implementation that always returns 0 would be correct.
             * In general, callers should only use this method if they'd be satisfied with
             * treating the result as a boolean yes or no answer to the question "is there definitely
             * data ready?".
             *
             * <p>Thirdly, the fact that a given number of bytes is "available" does not guarantee that a
             * read or skip will actually read or skip that many bytes: they may read or skip fewer.
             *
             * <p>It is particularly important to realize that you <i>must not</i> use this method to
             * size a container and assume that you can read the entirety of the stream without needing
             * to resize the container. Such callers should probably write everything they read to a
             * {@link ByteArrayOutputStream} and convert that to a byte array. Alternatively, if you're
             * reading from a file, {@link File#length} returns the current length of the file (though
             * assuming the file's length can't change may be incorrect, reading a file is inherently
             * racy).
             *
             * <p>The default implementation of this method in {@code InputStream} always returns 0.
             * Subclasses should override this method if they are able to indicate the number of bytes
             * available.
             *
             * @return the estimated number of bytes available
             * @throws IOException if this stream is closed or an error occurs
             */
            InputStream.prototype.available = function () {
                return 0;
            };
            /**
             * Closes this stream. Concrete implementations of this class should free
             * any resources during close. This implementation does nothing.
             *
             * @throws IOException
             * if an error occurs while closing this stream.
             */
            InputStream.prototype.close = function () {
            };
            /**
             * Sets a mark position in this InputStream. The parameter {@code readlimit}
             * indicates how many bytes can be read before the mark is invalidated.
             * Sending {@code reset()} will reposition the stream back to the marked
             * position provided {@code readLimit} has not been surpassed.
             * <p>
             * This default implementation does nothing and concrete subclasses must
             * provide their own implementation.
             *
             * @param readlimit
             * the number of bytes that can be read from this stream before
             * the mark is invalidated.
             * @see #markSupported()
             * @see #reset()
             */
            InputStream.prototype.mark = function (readlimit) {
            };
            /**
             * Indicates whether this stream supports the {@code mark()} and
             * {@code reset()} methods. The default implementation returns {@code false}.
             *
             * @return always {@code false}.
             * @see #mark(int)
             * @see #reset()
             */
            InputStream.prototype.markSupported = function () {
                return false;
            };
            /**
             * Reads a single byte from this stream and returns it as an integer in the
             * range from 0 to 255. Returns -1 if the end of the stream has been
             * reached. Blocks until one byte has been read, the end of the source
             * stream is detected or an exception is thrown.
             *
             * @throws IOException
             * if the stream is closed or another IOException occurs.
             */
            InputStream.prototype.read$ = function () { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
            /**
             * Equivalent to {@code read(buffer, 0, buffer.length)}.
             */
            InputStream.prototype.read$byte_A = function (buffer) {
                javaemul.internal.InternalPreconditions.checkNotNull(buffer);
                return this.read(buffer, 0, buffer.length);
            };
            /**
             * Reads up to {@code byteCount} bytes from this stream and stores them in
             * the byte array {@code buffer} starting at {@code byteOffset}.
             * Returns the number of bytes actually read or -1 if the end of the stream
             * has been reached.
             *
             * @throws IndexOutOfBoundsException
             * if {@code byteOffset < 0 || byteCount < 0 || byteOffset + byteCount > buffer.length}.
             * @throws IOException
             * if the stream is closed or another IOException occurs.
             */
            InputStream.prototype.read = function (buffer, byteOffset, byteCount) {
                var _this = this;
                if (((buffer != null && buffer instanceof Array) || buffer === null) && ((typeof byteOffset === 'number') || byteOffset === null) && ((typeof byteCount === 'number') || byteCount === null)) {
                    return (function () {
                        java.io.IOUtils.checkOffsetAndCount(buffer, byteOffset, byteCount);
                        for (var i = 0; i < byteCount; ++i) {
                            var c;
                            try {
                                if ((c = _this.read()) === -1) {
                                    return i === 0 ? -1 : i;
                                }
                            }
                            catch (e) {
                                if (i !== 0) {
                                    return i;
                                }
                                throw e;
                            }
                            ;
                            buffer[byteOffset + i] = (c | 0);
                        }
                        return byteCount;
                    })();
                }
                else if (((buffer != null && buffer instanceof Array) || buffer === null) && byteOffset === undefined && byteCount === undefined) {
                    return this.read$byte_A(buffer);
                }
                else if (buffer === undefined && byteOffset === undefined && byteCount === undefined) {
                    return this.read$();
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Resets this stream to the last marked location. Throws an
             * {@code IOException} if the number of bytes read since the mark has been
             * set is greater than the limit provided to {@code mark}, or if no mark
             * has been set.
             * <p>
             * This implementation always throws an {@code IOException} and concrete
             * subclasses should provide the proper implementation.
             *
             * @throws IOException
             * if this stream is closed or another IOException occurs.
             */
            InputStream.prototype.reset = function () {
                throw new java.io.IOException();
            };
            /**
             * Skips at most {@code byteCount} bytes in this stream. The number of actual
             * bytes skipped may be anywhere between 0 and {@code byteCount}. If
             * {@code byteCount} is negative, this method does nothing and returns 0, but
             * some subclasses may throw.
             *
             * <p>Note the "at most" in the description of this method: this method may
             * choose to skip fewer bytes than requested. Callers should <i>always</i>
             * check the return value.
             *
             * <p>This default implementation reads bytes into a temporary buffer. Concrete
             * subclasses should provide their own implementation.
             *
             * @return the number of bytes actually skipped.
             * @throws IOException if this stream is closed or another IOException
             * occurs.
             */
            InputStream.prototype.skip = function (byteCount) {
                if (byteCount <= 0) {
                    return 0;
                }
                var bSize = (Math.min(InputStream.MAX_SKIP_BUFFER_SIZE, byteCount) | 0);
                var b = new Array(bSize);
                var skipped = 0;
                while ((skipped < byteCount)) {
                    var toRead = (Math.min(byteCount - skipped, b.length) | 0);
                    var readCount = this.read(b, 0, toRead);
                    if (readCount === -1) {
                        break;
                    }
                    skipped += readCount;
                    if (readCount < toRead) {
                        break;
                    }
                }
                ;
                return skipped;
            };
            /**
             * Size of the temporary buffer used when skipping bytes with {@link skip(long)}.
             */
            InputStream.MAX_SKIP_BUFFER_SIZE = 4096;
            return InputStream;
        }());
        io.InputStream = InputStream;
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var io;
    (function (io) {
        /**
         * Provides a series of utilities to be reused between IO classes.
         *
         * TODO(chehayeb): move these checks to InternalPreconditions.
         */
        var IOUtils = (function () {
            function IOUtils() {
            }
            /**
             * Validates the offset and the byte count for the given array of bytes.
             *
             * @param buffer Array of bytes to be checked.
             * @param byteOffset Starting offset in the array.
             * @param byteCount Total number of bytes to be accessed.
             * @throws NullPointerException if the given reference to the buffer is null.
             * @throws IndexOutOfBoundsException if {@code byteOffset} is negative, {@code byteCount} is
             * negative or their sum exceeds the buffer length.
             */
            IOUtils.checkOffsetAndCount = function (buffer, byteOffset, byteCount) {
                if (((buffer != null && buffer instanceof Array) || buffer === null) && ((typeof byteOffset === 'number') || byteOffset === null) && ((typeof byteCount === 'number') || byteCount === null)) {
                    return (function () {
                        javaemul.internal.InternalPreconditions.checkNotNull(buffer);
                        IOUtils.checkOffsetAndCount(buffer.length, byteOffset, byteCount);
                    })();
                }
                else if (((buffer != null && buffer instanceof Array) || buffer === null) && ((typeof byteOffset === 'number') || byteOffset === null) && ((typeof byteCount === 'number') || byteCount === null)) {
                    return java.io.IOUtils.checkOffsetAndCount$char_A$int$int(buffer, byteOffset, byteCount);
                }
                else if (((typeof buffer === 'number') || buffer === null) && ((typeof byteOffset === 'number') || byteOffset === null) && ((typeof byteCount === 'number') || byteCount === null)) {
                    return java.io.IOUtils.checkOffsetAndCount$int$int$int(buffer, byteOffset, byteCount);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Validates the offset and the byte count for the given array of characters.
             *
             * @param buffer Array of characters to be checked.
             * @param charOffset Starting offset in the array.
             * @param charCount Total number of characters to be accessed.
             * @throws NullPointerException if the given reference to the buffer is null.
             * @throws IndexOutOfBoundsException if {@code charOffset} is negative, {@code charCount} is
             * negative or their sum exceeds the buffer length.
             */
            IOUtils.checkOffsetAndCount$char_A$int$int = function (buffer, charOffset, charCount) {
                javaemul.internal.InternalPreconditions.checkNotNull(buffer);
                IOUtils.checkOffsetAndCount(buffer.length, charOffset, charCount);
            };
            /**
             * Validates the offset and the byte count for the given array length.
             *
             * @param length Length of the array to be checked.
             * @param offset Starting offset in the array.
             * @param count Total number of elements to be accessed.
             * @throws IndexOutOfBoundsException if {@code offset} is negative, {@code count} is negative or
             * their sum exceeds the given {@code length}.
             */
            IOUtils.checkOffsetAndCount$int$int$int = function (length, offset, count) {
                if ((offset < 0) || (count < 0) || ((offset + count) > length)) {
                    throw new java.lang.IndexOutOfBoundsException();
                }
            };
            return IOUtils;
        }());
        io.IOUtils = IOUtils;
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var io;
    (function (io) {
        /**
         * A writable sink for bytes.
         *
         * <p>Most clients will use output streams that write data to the file system
         * ({@link FileOutputStream}), the network ({@link java.net.Socket#getOutputStream()}/{@link
         * java.net.HttpURLConnection#getOutputStream()}), or to an in-memory byte array
         * ({@link ByteArrayOutputStream}).
         *
         * <p>Use {@link OutputStreamWriter} to adapt a byte stream like this one into a
         * character stream.
         *
         * <p>Most clients should wrap their output stream with {@link
         * BufferedOutputStream}. Callers that do only bulk writes may omit buffering.
         *
         * <h3>Subclassing OutputStream</h3>
         * Subclasses that decorate another output stream should consider subclassing
         * {@link FilterOutputStream}, which delegates all calls to the target output
         * stream.
         *
         * <p>All output stream subclasses should override <strong>both</strong> {@link
         * #write(int)} and {@link #write(byte[],int,int) write(byte[],int,int)}. The
         * three argument overload is necessary for bulk access to the data. This is
         * much more efficient than byte-by-byte access.
         *
         * @see InputStream
         *
         * <p>The implementation provided by this class behaves as described in the Java
         * API documentation except for {@link write(int)} which throws an exception of
         * type {@link java.lang.UnsupportedOperationException} instead of being
         * abstract.
         */
        var OutputStream = (function () {
            /**
             * Default constructor.
             */
            function OutputStream() {
                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Closeable", "java.lang.AutoCloseable", "java.io.Flushable"] });
            }
            /**
             * Closes this stream. Implementations of this method should free any
             * resources used by the stream. This implementation does nothing.
             *
             * @throws IOException
             * if an error occurs while closing this stream.
             */
            OutputStream.prototype.close = function () {
            };
            /**
             * Flushes this stream. Implementations of this method should ensure that
             * any buffered data is written out. This implementation does nothing.
             *
             * @throws IOException
             * if an error occurs while flushing this stream.
             */
            OutputStream.prototype.flush = function () {
            };
            /**
             * Equivalent to {@code write(buffer, 0, buffer.length)}.
             */
            OutputStream.prototype.write$byte_A = function (buffer) {
                javaemul.internal.InternalPreconditions.checkNotNull(buffer);
                this.write(buffer, 0, buffer.length);
            };
            /**
             * Writes {@code count} bytes from the byte array {@code buffer} starting at
             * position {@code offset} to this stream.
             *
             * @param buffer
             * the buffer to be written.
             * @param offset
             * the start position in {@code buffer} from where to get bytes.
             * @param count
             * the number of bytes from {@code buffer} to write to this
             * stream.
             * @throws IOException
             * if an error occurs while writing to this stream.
             * @throws IndexOutOfBoundsException
             * if {@code offset < 0} or {@code count < 0}, or if
             * {@code offset + count} is bigger than the length of
             * {@code buffer}.
             */
            OutputStream.prototype.write = function (buffer, offset, count) {
                var _this = this;
                if (((buffer != null && buffer instanceof Array) || buffer === null) && ((typeof offset === 'number') || offset === null) && ((typeof count === 'number') || count === null)) {
                    return (function () {
                        java.io.IOUtils.checkOffsetAndCount(buffer, offset, count);
                        for (var i = offset; i < offset + count; i++) {
                            _this.write(buffer[i]);
                        }
                    })();
                }
                else if (((buffer != null && buffer instanceof Array) || buffer === null) && offset === undefined && count === undefined) {
                    return this.write$byte_A(buffer);
                }
                else if (((typeof buffer === 'number') || buffer === null) && offset === undefined && count === undefined) {
                    return this.write$int(buffer);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Writes a single byte to this stream. Only the least significant byte of
             * the integer {@code oneByte} is written to the stream.
             *
             * @param oneByte
             * the byte to be written.
             * @throws IOException
             * if an error occurs while writing to this stream.
             */
            OutputStream.prototype.write$int = function (oneByte) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
            return OutputStream;
        }());
        io.OutputStream = OutputStream;
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var io;
    (function (io) {
        /**
         * JSweet implementation.
         */
        var Reader = (function () {
            function Reader(lock) {
                var _this = this;
                /**
                 * Skip buffer, null until allocated
                 */
                this.skipBuffer = null;
                if (((lock != null) || lock === null)) {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Closeable", "java.lang.AutoCloseable"] });
                    (function () {
                        if (lock == null) {
                            throw new java.lang.NullPointerException();
                        }
                        _this.lock = lock;
                    })();
                }
                else if (lock === undefined) {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Closeable", "java.lang.AutoCloseable"] });
                    (function () {
                        _this.lock = _this;
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            Reader.prototype.read$ = function () {
                var cb = new Array(1);
                if (this.read(cb, 0, 1) === -1)
                    return -1;
                else
                    return (cb[0]).charCodeAt(0);
            };
            Reader.prototype.read$char_A = function (cbuf) {
                return this.read(cbuf, 0, cbuf.length);
            };
            Reader.prototype.read = function (cbuf, off, len) {
                if (((cbuf != null && cbuf instanceof Array) || cbuf === null) && ((typeof off === 'number') || off === null) && ((typeof len === 'number') || len === null)) {
                    return 0;
                }
                else if (((cbuf != null && cbuf instanceof Array) || cbuf === null) && off === undefined && len === undefined) {
                    return this.read$char_A(cbuf);
                }
                else if (cbuf === undefined && off === undefined && len === undefined) {
                    return this.read$();
                }
                else
                    throw new Error('invalid overload');
            };
            Reader.prototype.skip = function (n) {
                if (n < 0)
                    throw new java.lang.IllegalArgumentException("skip value is negative");
                var nn = (Math.min(n, Reader.maxSkipBufferSize) | 0);
                if ((this.skipBuffer == null) || (this.skipBuffer.length < nn))
                    this.skipBuffer = new Array(nn);
                var r = n;
                while ((r > 0)) {
                    var nc = this.read(this.skipBuffer, 0, (Math.min(r, nn) | 0));
                    if (nc === -1)
                        break;
                    r -= nc;
                }
                ;
                return n - r;
            };
            Reader.prototype.ready = function () {
                return false;
            };
            Reader.prototype.markSupported = function () {
                return false;
            };
            Reader.prototype.mark = function (readAheadLimit) {
                throw new java.io.IOException("mark() not supported");
            };
            Reader.prototype.reset = function () {
                throw new java.io.IOException("reset() not supported");
            };
            /**
             * Maximum skip-buffer size
             */
            Reader.maxSkipBufferSize = 8192;
            return Reader;
        }());
        io.Reader = Reader;
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var io;
    (function (io) {
        /**
         * JSweet implementation.
         */
        var Writer = (function () {
            function Writer(lock) {
                var _this = this;
                if (((lock != null) || lock === null)) {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Appendable", "java.io.Closeable", "java.lang.AutoCloseable", "java.io.Flushable"] });
                    (function () {
                        if (lock == null) {
                            throw new java.lang.NullPointerException();
                        }
                        _this.lock = lock;
                    })();
                }
                else if (lock === undefined) {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Appendable", "java.io.Closeable", "java.lang.AutoCloseable", "java.io.Flushable"] });
                    (function () {
                        _this.lock = _this;
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            Writer.prototype.write$int = function (c) {
                {
                    if (this.writeBuffer == null) {
                        this.writeBuffer = new Array(Writer.WRITE_BUFFER_SIZE);
                    }
                    this.writeBuffer[0] = String.fromCharCode(c);
                    this.write(this.writeBuffer, 0, 1);
                }
                ;
            };
            Writer.prototype.write$char_A = function (cbuf) {
                this.write(cbuf, 0, cbuf.length);
            };
            Writer.prototype.write$char_A$int$int = function (cbuf, off, len) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
            Writer.prototype.write$java_lang_String = function (str) {
                this.write(str, 0, str.length);
            };
            Writer.prototype.write = function (str, off, len) {
                var _this = this;
                if (((typeof str === 'string') || str === null) && ((typeof off === 'number') || off === null) && ((typeof len === 'number') || len === null)) {
                    return (function () {
                        {
                            var cbuf;
                            if (len <= Writer.WRITE_BUFFER_SIZE) {
                                if (_this.writeBuffer == null) {
                                    _this.writeBuffer = new Array(Writer.WRITE_BUFFER_SIZE);
                                }
                                cbuf = _this.writeBuffer;
                            }
                            else {
                                cbuf = new Array(len);
                            }
                            str.getChars(off, (off + len), cbuf, 0);
                            _this.write(cbuf, 0, len);
                        }
                        ;
                    })();
                }
                else if (((str != null && str instanceof Array) || str === null) && ((typeof off === 'number') || off === null) && ((typeof len === 'number') || len === null)) {
                    return this.write$char_A$int$int(str, off, len);
                }
                else if (((str != null && str instanceof Array) || str === null) && off === undefined && len === undefined) {
                    return this.write$char_A(str);
                }
                else if (((typeof str === 'string') || str === null) && off === undefined && len === undefined) {
                    return this.write$java_lang_String(str);
                }
                else if (((typeof str === 'number') || str === null) && off === undefined && len === undefined) {
                    return this.write$int(str);
                }
                else
                    throw new Error('invalid overload');
            };
            Writer.prototype.append$java_lang_CharSequence = function (csq) {
                if (csq == null)
                    this.write("null");
                else
                    this.write(csq.toString());
                return this;
            };
            Writer.prototype.append = function (csq, start, end) {
                var _this = this;
                if (((csq != null && (csq["__interfaces"] != null && csq["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof csq === "string")) || csq === null) && ((typeof start === 'number') || start === null) && ((typeof end === 'number') || end === null)) {
                    return (function () {
                        var cs = (csq == null ? "null" : csq);
                        _this.write(/* subSequence */ cs.substring(start, end).toString());
                        return _this;
                    })();
                }
                else if (((csq != null && (csq["__interfaces"] != null && csq["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof csq === "string")) || csq === null) && start === undefined && end === undefined) {
                    return this.append$java_lang_CharSequence(csq);
                }
                else if (((typeof csq === 'string') || csq === null) && start === undefined && end === undefined) {
                    return this.append$char(csq);
                }
                else
                    throw new Error('invalid overload');
            };
            Writer.prototype.append$char = function (c) {
                this.write(c);
                return this;
            };
            Writer.WRITE_BUFFER_SIZE = 1024;
            return Writer;
        }());
        io.Writer = Writer;
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var lang;
    (function (lang) {
        /**
         * A base class to share implementation between {@link StringBuffer} and {@link StringBuilder}.
         * <p>
         * Most methods will give expected performance results. Exception is {@link #setCharAt(int, char)},
         * which is O(n), and thus should not be used many times on the same <code>StringBuffer</code>.
         */
        var AbstractStringBuilder = (function () {
            function AbstractStringBuilder(string) {
                this.string = string;
            }
            AbstractStringBuilder.prototype.length = function () {
                return this.string.length;
            };
            AbstractStringBuilder.prototype.setLength = function (newLength) {
                var oldLength = this.length();
                if (newLength < oldLength) {
                    this.string = this.string.substring(0, newLength);
                }
                else if (newLength > oldLength) {
                    this.string += new String(new Array(newLength - oldLength)).toString();
                }
            };
            AbstractStringBuilder.prototype.capacity = function () {
                return javaemul.internal.IntegerHelper.MAX_VALUE;
            };
            AbstractStringBuilder.prototype.ensureCapacity = function (ignoredCapacity) {
            };
            AbstractStringBuilder.prototype.trimToSize = function () {
            };
            AbstractStringBuilder.prototype.charAt = function (index) {
                return this.string.charAt(index);
            };
            AbstractStringBuilder.prototype.getChars = function (srcStart, srcEnd, dst, dstStart) {
                javaemul.internal.InternalPreconditions.checkStringBounds(srcStart, srcEnd, this.length());
                javaemul.internal.InternalPreconditions.checkStringBounds(dstStart, dstStart + (srcEnd - srcStart), dst.length);
                while ((srcStart < srcEnd)) {
                    dst[dstStart++] = this.string.charAt(srcStart++);
                }
                ;
            };
            /**
             * Warning! This method is <b>much</b> slower than the JRE implementation. If you need to do
             * character level manipulation, you are strongly advised to use a char[] directly.
             */
            AbstractStringBuilder.prototype.setCharAt = function (index, x) {
                this.replace0(index, index + 1, /* valueOf */ new String(x).toString());
            };
            AbstractStringBuilder.prototype.subSequence = function (start, end) {
                return this.string.substring(start, end);
            };
            AbstractStringBuilder.prototype.substring$int = function (begin) {
                return this.string.substring(begin);
            };
            AbstractStringBuilder.prototype.substring = function (begin, end) {
                var _this = this;
                if (((typeof begin === 'number') || begin === null) && ((typeof end === 'number') || end === null)) {
                    return (function () {
                        return _this.string.substring(begin, end);
                    })();
                }
                else if (((typeof begin === 'number') || begin === null) && end === undefined) {
                    return this.substring$int(begin);
                }
                else
                    throw new Error('invalid overload');
            };
            AbstractStringBuilder.prototype.indexOf$java_lang_String = function (x) {
                return this.string.indexOf(x);
            };
            AbstractStringBuilder.prototype.indexOf = function (x, start) {
                var _this = this;
                if (((typeof x === 'string') || x === null) && ((typeof start === 'number') || start === null)) {
                    return (function () {
                        return _this.string.indexOf(x, start);
                    })();
                }
                else if (((typeof x === 'string') || x === null) && start === undefined) {
                    return this.indexOf$java_lang_String(x);
                }
                else
                    throw new Error('invalid overload');
            };
            AbstractStringBuilder.prototype.lastIndexOf$java_lang_String = function (s) {
                return this.string.lastIndexOf(s);
            };
            AbstractStringBuilder.prototype.lastIndexOf = function (s, start) {
                var _this = this;
                if (((typeof s === 'string') || s === null) && ((typeof start === 'number') || start === null)) {
                    return (function () {
                        return _this.string.lastIndexOf(s, start);
                    })();
                }
                else if (((typeof s === 'string') || s === null) && start === undefined) {
                    return this.lastIndexOf$java_lang_String(s);
                }
                else
                    throw new Error('invalid overload');
            };
            AbstractStringBuilder.prototype.toString = function () {
                return this.string;
            };
            AbstractStringBuilder.prototype.append0 = function (x, start, end) {
                if (x == null) {
                    x = "null";
                }
                this.string += x.substring(start, end);
            };
            AbstractStringBuilder.prototype.appendCodePoint0 = function (x) {
                this.string += new String(/* toChars */ String.fromCharCode(x)).toString();
            };
            AbstractStringBuilder.prototype.replace0 = function (start, end, toInsert) {
                this.string = this.string.substring(0, start) + toInsert + this.string.substring(end);
            };
            AbstractStringBuilder.prototype.reverse0 = function () {
                var length = this.string.length;
                if (length <= 1) {
                    return;
                }
                var buffer = new Array(length);
                buffer[0] = this.string.charAt(length - 1);
                for (var i = 1; i < length; i++) {
                    buffer[i] = this.string.charAt(length - 1 - i);
                    if (javaemul.internal.CharacterHelper.isSurrogatePair(buffer[i], buffer[i - 1])) {
                        AbstractStringBuilder.swap(buffer, i - 1, i);
                    }
                }
                this.string = new String(buffer);
            };
            AbstractStringBuilder.swap = function (buffer, f, s) {
                var tmp = buffer[f];
                buffer[f] = buffer[s];
                buffer[s] = tmp;
            };
            return AbstractStringBuilder;
        }());
        lang.AbstractStringBuilder = AbstractStringBuilder;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var lang;
    (function (lang) {
        var annotation;
        (function (annotation) {
            /**
             * Indicates the annotation parser determined the annotation was malformed when
             * reading from the class file <a
             * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/annotation/AnnotationFormatError.html">[Sun
             * docs]</a>.
             */
            var AnnotationFormatError = (function (_super) {
                __extends(AnnotationFormatError, _super);
                function AnnotationFormatError() {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                }
                return AnnotationFormatError;
            }(Error));
            annotation.AnnotationFormatError = AnnotationFormatError;
        })(annotation = lang.annotation || (lang.annotation = {}));
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var lang;
    (function (lang) {
        var annotation;
        (function (annotation) {
            /**
             * Enumerates types of declared elements in a Java program <a
             * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/annotation/ElementType.html">[Sun
             * docs]</a>.
             */
            (function (ElementType) {
                ElementType[ElementType["ANNOTATION_TYPE"] = 0] = "ANNOTATION_TYPE";
                ElementType[ElementType["CONSTRUCTOR"] = 1] = "CONSTRUCTOR";
                ElementType[ElementType["FIELD"] = 2] = "FIELD";
                ElementType[ElementType["LOCAL_VARIABLE"] = 3] = "LOCAL_VARIABLE";
                ElementType[ElementType["METHOD"] = 4] = "METHOD";
                ElementType[ElementType["PACKAGE"] = 5] = "PACKAGE";
                ElementType[ElementType["PARAMETER"] = 6] = "PARAMETER";
                ElementType[ElementType["TYPE"] = 7] = "TYPE";
            })(annotation.ElementType || (annotation.ElementType = {}));
            var ElementType = annotation.ElementType;
        })(annotation = lang.annotation || (lang.annotation = {}));
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var lang;
    (function (lang) {
        var annotation;
        (function (annotation) {
            /**
             * Enumerates annotation retention policies <a
             * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/annotation/RetentionPolicy.html">[Sun
             * docs]</a>.
             */
            (function (RetentionPolicy) {
                RetentionPolicy[RetentionPolicy["CLASS"] = 0] = "CLASS";
                RetentionPolicy[RetentionPolicy["RUNTIME"] = 1] = "RUNTIME";
                RetentionPolicy[RetentionPolicy["SOURCE"] = 2] = "SOURCE";
            })(annotation.RetentionPolicy || (annotation.RetentionPolicy = {}));
            var RetentionPolicy = annotation.RetentionPolicy;
        })(annotation = lang.annotation || (lang.annotation = {}));
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var lang;
    (function (lang) {
        /**
         * Represents an error caused by an assertion failure.
         */
        var AssertionError = (function (_super) {
            __extends(AssertionError, _super);
            function AssertionError(message, cause) {
                if (((typeof message === 'string') || message === null) && ((cause != null && cause instanceof Error) || cause === null)) {
                    _super.call(this, message);
                    this.message = message;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (((typeof message === 'string') || message === null) && cause === undefined) {
                    _super.call(this, message);
                    this.message = message;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (((typeof message === 'boolean') || message === null) && cause === undefined) {
                    {
                        var message = new String(message).toString();
                        _super.call(this, /* valueOf */ new String(message).toString());
                        this.message = new String(message).toString();
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                        (function () {
                        })();
                    }
                    (function () {
                    })();
                }
                else if (((typeof message === 'string') || message === null) && cause === undefined) {
                    {
                        var message = new String(message).toString();
                        _super.call(this, /* valueOf */ new String(message).toString());
                        this.message = new String(message).toString();
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                        (function () {
                        })();
                    }
                    (function () {
                    })();
                }
                else if (((typeof message === 'number') || message === null) && cause === undefined) {
                    {
                        var message = new String(message).toString();
                        _super.call(this, /* valueOf */ new String(message).toString());
                        this.message = new String(message).toString();
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                        (function () {
                        })();
                    }
                    (function () {
                    })();
                }
                else if (((typeof message === 'number') || message === null) && cause === undefined) {
                    {
                        var message = new String(message).toString();
                        _super.call(this, /* valueOf */ new String(message).toString());
                        this.message = new String(message).toString();
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                        (function () {
                        })();
                    }
                    (function () {
                    })();
                }
                else if (((typeof message === 'number') || message === null) && cause === undefined) {
                    {
                        var message = new String(message).toString();
                        _super.call(this, /* valueOf */ new String(message).toString());
                        this.message = new String(message).toString();
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                        (function () {
                        })();
                    }
                    (function () {
                    })();
                }
                else if (((typeof message === 'number') || message === null) && cause === undefined) {
                    {
                        var message = new String(message).toString();
                        _super.call(this, /* valueOf */ new String(message).toString());
                        this.message = new String(message).toString();
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                        (function () {
                        })();
                    }
                    (function () {
                    })();
                }
                else if (((message != null) || message === null) && cause === undefined) {
                    _super.call(this, /* valueOf */ new String(message).toString());
                    this.message = new String(message).toString();
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (message === undefined && cause === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            return AssertionError;
        }(Error));
        lang.AssertionError = AssertionError;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var lang;
    (function (lang) {
        /**
         * Generally unsupported. This class is provided so that the GWT compiler can
         * choke down class literal references.
         * <p>
         * NOTE: The code in this class is very sensitive and should keep its
         * dependencies upon other classes to a minimum.
         *
         * @param <T>
         * the type of the object
         */
        var Class = (function () {
            /**
             * Not publicly instantiable.
             *
             * @skip
             */
            function Class() {
                this.sequentialId = Class.nextSequentialId++;
                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.reflect.Type"] });
                this.modifiers = 0;
                this.typeName = null;
                this.simpleName = null;
                this.packageName = null;
                this.compoundName = null;
                this.canonicalName = null;
                this.typeId = null;
                this.arrayLiterals = null;
            }
            Class.constructors_$LI$ = function () { if (Class.constructors == null)
                Class.constructors = new Array(); return Class.constructors; };
            ;
            Class.classes_$LI$ = function () { if (Class.classes == null)
                Class.classes = new Array(); return Class.classes; };
            ;
            Class.getConstructorForClass = function (clazz) {
                var index = (Class.classes_$LI$().indexOf(clazz) | 0);
                return index === -1 ? null : Class.constructors_$LI$()[index];
            };
            Class.getClassForConstructor = function (constructor) {
                var index = (Class.constructors_$LI$().indexOf(constructor) | 0);
                return index === -1 ? null : Class.classes_$LI$()[index];
            };
            Class.mapConstructorToClass = function (constructor, clazz) {
                Class.constructors_$LI$().push(constructor);
                Class.classes_$LI$().push(clazz);
            };
            /**
             * Create a Class object for an array.
             * <p>
             *
             * Arrays are not registered in the prototype table and get the class
             * literal explicitly at construction.
             * <p>
             */
            Class.getClassLiteralForArray = function (leafClass, dimensions) {
                var arrayLiterals = leafClass.arrayLiterals = leafClass.arrayLiterals == null ? new Array(0) : leafClass.arrayLiterals;
                return arrayLiterals[dimensions] != null ? arrayLiterals[dimensions] : (arrayLiterals[dimensions] = leafClass.createClassLiteralForArray(dimensions));
            };
            Class.prototype.createClassLiteralForArray = function (dimensions) {
                var clazz = new java.lang.Class();
                clazz.modifiers = Class.ARRAY;
                clazz.superclass = Object;
                if (dimensions > 1) {
                    clazz.componentType = Class.getClassLiteralForArray(this, dimensions - 1);
                }
                else {
                    clazz.componentType = this;
                }
                return clazz;
            };
            /**
             * Create a Class object for a class.
             *
             * @skip
             */
            Class.createForClass = function (packageName, compoundClassName, typeId, superclass) {
                var clazz = Class.createClassObject(packageName, compoundClassName, typeId);
                clazz.superclass = superclass;
                return clazz;
            };
            /**
             * Create a Class object for an enum.
             *
             * @skip
             */
            Class.createForEnum = function (packageName, compoundClassName, typeId, superclass, enumConstantsFunc, enumValueOfFunc) {
                var clazz = Class.createClassObject(packageName, compoundClassName, typeId);
                clazz.modifiers = (enumConstantsFunc != null) ? Class.ENUM : 0;
                clazz.superclass = clazz.enumSuperclass = superclass;
                clazz.enumConstantsFunc = enumConstantsFunc;
                clazz.enumValueOfFunc = enumValueOfFunc;
                return clazz;
            };
            /**
             * Create a Class object for an interface.
             *
             * @skip
             */
            Class.createForInterface = function (packageName, compoundClassName) {
                var clazz = Class.createClassObject(packageName, compoundClassName, null);
                clazz.modifiers = Class.INTERFACE;
                return clazz;
            };
            /**
             * Create a Class object for a primitive.
             *
             * @skip
             */
            Class.createForPrimitive = function (className, primitiveTypeId) {
                var clazz = Class.createClassObject("", className, primitiveTypeId);
                clazz.modifiers = Class.PRIMITIVE;
                return clazz;
            };
            /**
             * Used by {@link WebModePayloadSink} to create uninitialized instances.
             */
            Class.getPrototypeForClass = function (clazz) {
                if (clazz.isPrimitive()) {
                    return null;
                }
                return Class.getConstructorForClass(clazz).prototype;
            };
            /**
             * Creates the class object for a type and initiliazes its fields.
             */
            Class.createClassObject = function (packageName, compoundClassName, typeId) {
                var clazz = new java.lang.Class();
                clazz.packageName = packageName;
                clazz.compoundName = compoundClassName;
                return clazz;
            };
            /**
             * Initiliazes {@code clazz} names from metadata.
             * <p>
             * Written in JSNI to minimize dependencies (on String.+).
             */
            Class.initializeNames = function (clazz) {
                if (clazz.isArray()) {
                    var componentType = clazz.componentType;
                    if (componentType.isPrimitive()) {
                        clazz.typeName = "[" + componentType.typeId;
                    }
                    else if (!componentType.isArray()) {
                        clazz.typeName = "[L" + componentType.getName() + ";";
                    }
                    else {
                        clazz.typeName = "[" + componentType.getName();
                    }
                    clazz.canonicalName = componentType.getCanonicalName() + "[]";
                    clazz.simpleName = componentType.getSimpleName() + "[]";
                    return;
                }
                var packageName = clazz.packageName;
                var compoundName = clazz.compoundName.split("/");
                clazz.typeName = ([packageName, (compoundName).join("$")]).join(".");
                clazz.canonicalName = ([packageName, (compoundName).join(".")]).join(".");
                clazz.simpleName = compoundName[compoundName.length - 1];
            };
            /**
             * Sets the class object for primitives.
             * <p>
             * Written in JSNI to minimize dependencies (on (String)+).
             */
            Class.synthesizePrimitiveNamesFromTypeId = function (clazz, primitiveTypeId) {
                clazz.typeName = "Class$" + primitiveTypeId;
                clazz.canonicalName = clazz.typeName;
                clazz.simpleName = clazz.typeName;
            };
            Class.prototype.desiredAssertionStatus = function () {
                return false;
            };
            Class.prototype.ensureNamesAreInitialized = function () {
                if (this.typeName != null) {
                    return;
                }
                Class.initializeNames(this);
            };
            Class.prototype.getCanonicalName = function () {
                this.ensureNamesAreInitialized();
                return this.canonicalName;
            };
            Class.prototype.getComponentType = function () {
                return this.componentType;
            };
            Class.prototype.getEnumConstants = function () {
                return this.enumConstantsFunc
                    && (this.enumConstantsFunc)();
            };
            Class.prototype.getName = function () {
                this.ensureNamesAreInitialized();
                return this.typeName;
            };
            Class.prototype.getSimpleName = function () {
                this.ensureNamesAreInitialized();
                return this.simpleName;
            };
            Class.prototype.getSuperclass = function () {
                return this.superclass;
            };
            Class.prototype.isArray = function () {
                return (this.modifiers & Class.ARRAY) !== 0;
            };
            Class.prototype.isEnum = function () {
                return (this.modifiers & Class.ENUM) !== 0;
            };
            Class.prototype.isInterface = function () {
                return (this.modifiers & Class.INTERFACE) !== 0;
            };
            Class.prototype.isPrimitive = function () {
                return (this.modifiers & Class.PRIMITIVE) !== 0;
            };
            Class.prototype.toString = function () {
                return (this.isInterface() ? "interface " : (this.isPrimitive() ? "" : "class ")) + this.getName();
            };
            /**
             * Used by Enum to allow getSuperclass() to be pruned.
             */
            Class.prototype.getEnumSuperclass = function () {
                return this.enumSuperclass;
            };
            Class.PRIMITIVE = 1;
            Class.INTERFACE = 2;
            Class.ARRAY = 4;
            Class.ENUM = 8;
            Class.nextSequentialId = 1;
            return Class;
        }());
        lang.Class = Class;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var lang;
    (function (lang) {
        /**
         * The first-class representation of an enumeration.
         *
         * @param <E>
         */
        var Enum = (function () {
            function Enum(name, ordinal) {
                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Comparable", "java.io.Serializable"] });
                this.__ordinal = 0;
                this.__name = name;
                this.__ordinal = ordinal;
            }
            Enum.valueOf = function (enumType, name) {
                if (((enumType != null && enumType instanceof java.lang.Class) || enumType === null) && ((typeof name === 'string') || name === null)) {
                    return (function () {
                        var enumValueOfFunc = javaemul.internal.InternalPreconditions.checkNotNull(enumType).enumValueOfFunc;
                        javaemul.internal.InternalPreconditions.checkCriticalArgument(enumValueOfFunc != null);
                        javaemul.internal.InternalPreconditions.checkNotNull(name);
                        return Enum.invokeValueOf(enumValueOfFunc, name);
                    })();
                }
                else if (((enumType != null && enumType instanceof Object) || enumType === null) && ((typeof name === 'string') || name === null)) {
                    return java.lang.Enum.valueOf$jsweet_lang_Object$java_lang_String(enumType, name);
                }
                else
                    throw new Error('invalid overload');
            };
            Enum.createValueOfMap = function (enumConstants) {
                var result = new Object();
                for (var index121 = 0; index121 < enumConstants.length; index121++) {
                    var value = enumConstants[index121];
                    {
                        Enum.put0(result, ":" + value.name(), value);
                    }
                }
                return result;
            };
            Enum.valueOf$jsweet_lang_Object$java_lang_String = function (map, name) {
                javaemul.internal.InternalPreconditions.checkNotNull(name);
                var result = java.lang.Enum.get0(map, ":" + name);
                javaemul.internal.InternalPreconditions.checkCriticalArgument(result != null, "Enum constant undefined: %s", name);
                return result;
            };
            Enum.get0 = function (map, name) {
                return map[name];
            };
            Enum.invokeValueOf = function (enumValueOfFunc, name) {
                return enumValueOfFunc(name);
            };
            Enum.put0 = function (map, name, value) {
                map[name] = value;
            };
            Enum.prototype.compareTo = function (other) {
                var _this = this;
                if (((other != null) || other === null)) {
                    return (function () {
                        return _this.__ordinal - other.__ordinal;
                    })();
                }
                else
                    throw new Error('invalid overload');
            };
            Enum.prototype.getDeclaringClass = function () {
                return null;
            };
            Enum.prototype.name = function () {
                return this.__name != null ? this.__name : "" + this.__ordinal;
            };
            Enum.prototype.ordinal = function () {
                return this.__ordinal;
            };
            Enum.prototype.toString = function () {
                return this.name();
            };
            return Enum;
        }());
        lang.Enum = Enum;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var lang;
    (function (lang) {
        /**
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Exception.html">the
         * official Java API doc</a> for details.
         */
        var Exception = (function (_super) {
            __extends(Exception, _super);
            function Exception(message, cause, enableSuppression, writableStackTrace) {
                if (((typeof message === 'string') || message === null) && ((cause != null && cause instanceof Error) || cause === null) && ((typeof enableSuppression === 'boolean') || enableSuppression === null) && ((typeof writableStackTrace === 'boolean') || writableStackTrace === null)) {
                    _super.call(this, message);
                    this.message = message;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (((typeof message === 'string') || message === null) && ((cause != null && cause instanceof Error) || cause === null) && enableSuppression === undefined && writableStackTrace === undefined) {
                    _super.call(this, message);
                    this.message = message;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (((typeof message === 'string') || message === null) && cause === undefined && enableSuppression === undefined && writableStackTrace === undefined) {
                    _super.call(this, message);
                    this.message = message;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (((message != null && message instanceof Error) || message === null) && cause === undefined && enableSuppression === undefined && writableStackTrace === undefined) {
                    var cause = message;
                    _super.call(this, cause);
                    this.message = cause;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (message === undefined && cause === undefined && enableSuppression === undefined && writableStackTrace === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            return Exception;
        }(Error));
        lang.Exception = Exception;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var lang;
    (function (lang) {
        /**
         * Included for hosted mode source compatibility. Partially implemented
         *
         * @skip
         */
        var StackTraceElement = (function () {
            function StackTraceElement(className, methodName, fileName, lineNumber) {
                var _this = this;
                if (((typeof className === 'string') || className === null) && ((typeof methodName === 'string') || methodName === null) && ((typeof fileName === 'string') || fileName === null) && ((typeof lineNumber === 'number') || lineNumber === null)) {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    this.lineNumber = 0;
                    (function () {
                        _this.className = className;
                        _this.methodName = methodName;
                        _this.fileName = fileName;
                        _this.lineNumber = lineNumber;
                    })();
                }
                else if (className === undefined && methodName === undefined && fileName === undefined && lineNumber === undefined) {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    this.lineNumber = 0;
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            StackTraceElement.prototype.getClassName = function () {
                return this.className;
            };
            StackTraceElement.prototype.getFileName = function () {
                return this.fileName;
            };
            StackTraceElement.prototype.getLineNumber = function () {
                return this.lineNumber;
            };
            StackTraceElement.prototype.getMethodName = function () {
                return this.methodName;
            };
            StackTraceElement.prototype.equals = function (other) {
                if (other != null && other instanceof java.lang.StackTraceElement) {
                    var st = other;
                    return this.lineNumber === st.lineNumber && java.util.Objects.equals(this.methodName, st.methodName) && java.util.Objects.equals(this.className, st.className) && java.util.Objects.equals(this.fileName, st.fileName);
                }
                return false;
            };
            StackTraceElement.prototype.hashCode = function () {
                return java.util.Objects.hash(this.lineNumber, this.className, this.methodName, this.fileName);
            };
            StackTraceElement.prototype.toString = function () {
                return this.className + "." + this.methodName + "(" + (this.fileName != null ? this.fileName : "Unknown Source") + (this.lineNumber >= 0 ? ":" + this.lineNumber : "") + ")";
            };
            return StackTraceElement;
        }());
        lang.StackTraceElement = StackTraceElement;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var lang;
    (function (lang) {
        /**
         * Thrown to indicate that the Java Virtual Machine is broken or has
         * run out of resources necessary for it to continue operating.
         *
         *
         * @author  Frank Yellin
         * @since   JDK1.0
         */
        var VirtualMachineError = (function (_super) {
            __extends(VirtualMachineError, _super);
            /**
             * Constructs a {@code VirtualMachineError} with the specified
             * detail message and cause.  <p>Note that the detail message
             * associated with {@code cause} is <i>not</i> automatically
             * incorporated in this error's detail message.
             *
             * @param  message the detail message (which is saved for later retrieval
             * by the {@link #getMessage()} method).
             * @param  cause the cause (which is saved for later retrieval by the
             * {@link #getCause()} method).  (A {@code null} value is
             * permitted, and indicates that the cause is nonexistent or
             * unknown.)
             * @since  1.8
             */
            function VirtualMachineError(message, cause) {
                if (((typeof message === 'string') || message === null) && ((cause != null && cause instanceof Error) || cause === null)) {
                    _super.call(this, message);
                    this.message = message;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (((typeof message === 'string') || message === null) && cause === undefined) {
                    _super.call(this, message);
                    this.message = message;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (((message != null && message instanceof Error) || message === null) && cause === undefined) {
                    var cause = message;
                    _super.call(this, cause);
                    this.message = cause;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (message === undefined && cause === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            VirtualMachineError.serialVersionUID = 4161983926571568670;
            return VirtualMachineError;
        }(Error));
        lang.VirtualMachineError = VirtualMachineError;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var lang;
    (function (lang) {
        /**
         * For JRE compatibility.
         */
        var Void = (function () {
            /**
             * Not instantiable.
             */
            function Void() {
            }
            return Void;
        }());
        lang.Void = Void;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var nio;
    (function (nio) {
        var charset;
        (function (charset) {
            /**
             * A minimal emulation of {@link Charset}.
             */
            var Charset = (function () {
                function Charset(name, aliasesIgnored) {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Comparable"] });
                    this.__name = name;
                }
                Charset.availableCharsets = function () {
                    if (Charset.AvailableCharsets.CHARSETS == null) {
                        var map = new java.util.TreeMap();
                        map.put(javaemul.internal.EmulatedCharset.ISO_8859_1_$LI$().name(), javaemul.internal.EmulatedCharset.ISO_8859_1_$LI$());
                        map.put(javaemul.internal.EmulatedCharset.ISO_LATIN_1_$LI$().name(), javaemul.internal.EmulatedCharset.ISO_LATIN_1_$LI$());
                        map.put(javaemul.internal.EmulatedCharset.UTF_8_$LI$().name(), javaemul.internal.EmulatedCharset.UTF_8_$LI$());
                        Charset.AvailableCharsets.CHARSETS = java.util.Collections.unmodifiableSortedMap(map);
                    }
                    return Charset.AvailableCharsets.CHARSETS;
                };
                Charset.forName = function (charsetName) {
                    javaemul.internal.InternalPreconditions.checkArgument(charsetName != null, "Null charset name");
                    charsetName = charsetName.toUpperCase();
                    if ((javaemul.internal.EmulatedCharset.ISO_8859_1_$LI$().name() === charsetName)) {
                        return javaemul.internal.EmulatedCharset.ISO_8859_1_$LI$();
                    }
                    else if ((javaemul.internal.EmulatedCharset.ISO_LATIN_1_$LI$().name() === charsetName)) {
                        return javaemul.internal.EmulatedCharset.ISO_LATIN_1_$LI$();
                    }
                    else if ((javaemul.internal.EmulatedCharset.UTF_8_$LI$().name() === charsetName)) {
                        return javaemul.internal.EmulatedCharset.UTF_8_$LI$();
                    }
                    if (!Charset.createLegalCharsetNameRegex().test(charsetName)) {
                        throw new java.nio.charset.IllegalCharsetNameException(charsetName);
                    }
                    else {
                        throw new java.nio.charset.UnsupportedCharsetException(charsetName);
                    }
                };
                Charset.createLegalCharsetNameRegex = function () {
                    return new RegExp("^[A-Za-z0-9][\\w-:\\.\\+]*$");
                };
                Charset.prototype.name = function () {
                    return this.__name;
                };
                Charset.prototype.compareTo = function (that) {
                    var _this = this;
                    if (((that != null && that instanceof java.nio.charset.Charset) || that === null)) {
                        return (function () {
                            return _this.__name.toUpperCase().localeCompare(that.__name.toUpperCase());
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                };
                Charset.prototype.hashCode = function () {
                    return this.__name.toString();
                };
                Charset.prototype.equals = function (o) {
                    if (o === this) {
                        return true;
                    }
                    if (!(o != null && o instanceof java.nio.charset.Charset)) {
                        return false;
                    }
                    var that = o;
                    return (this.__name === that.__name);
                };
                Charset.prototype.toString = function () {
                    return this.__name;
                };
                return Charset;
            }());
            charset.Charset = Charset;
            var Charset;
            (function (Charset) {
                var AvailableCharsets = (function () {
                    function AvailableCharsets() {
                    }
                    return AvailableCharsets;
                }());
                Charset.AvailableCharsets = AvailableCharsets;
            })(Charset = charset.Charset || (charset.Charset = {}));
        })(charset = nio.charset || (nio.charset = {}));
    })(nio = java.nio || (java.nio = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var security;
    (function (security) {
        /**
         * Message Digest Service Provider Interface - <a
         * href="http://java.sun.com/j2se/1.4.2/docs/api/java/security/MessageDigestSpi.html">[Sun's
         * docs]</a>.
         */
        var MessageDigestSpi = (function () {
            function MessageDigestSpi() {
            }
            MessageDigestSpi.prototype.engineDigest$ = function () { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
            MessageDigestSpi.prototype.engineDigest = function (buf, offset, len) {
                var _this = this;
                if (((buf != null && buf instanceof Array) || buf === null) && ((typeof offset === 'number') || offset === null) && ((typeof len === 'number') || len === null)) {
                    return (function () {
                        var digest = _this.engineDigest();
                        if (buf.length < digest.length + offset) {
                            throw new java.security.DigestException("Insufficient buffer space for digest");
                        }
                        if (len < digest.length) {
                            throw new java.security.DigestException("Length not large enough to hold digest");
                        }
                        java.lang.System.arraycopy(digest, 0, buf, offset, digest.length);
                        return digest.length;
                    })();
                }
                else if (buf === undefined && offset === undefined && len === undefined) {
                    return this.engineDigest$();
                }
                else
                    throw new Error('invalid overload');
            };
            MessageDigestSpi.prototype.engineGetDigestLength = function () {
                return 0;
            };
            MessageDigestSpi.prototype.engineUpdate$byte = function (input) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
            MessageDigestSpi.prototype.engineUpdate = function (input, offset, len) {
                if (((input != null && input instanceof Array) || input === null) && ((typeof offset === 'number') || offset === null) && ((typeof len === 'number') || len === null)) {
                }
                else if (((typeof input === 'number') || input === null) && offset === undefined && len === undefined) {
                    return this.engineUpdate$byte(input);
                }
                else
                    throw new Error('invalid overload');
            };
            return MessageDigestSpi;
        }());
        security.MessageDigestSpi = MessageDigestSpi;
    })(security = java.security || (java.security = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * Skeletal implementation of the Collection interface. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractCollection.html">[Sun
         * docs]</a>
         *
         * @param <E> the element type.
         */
        var AbstractCollection = (function () {
            function AbstractCollection() {
                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Collection", "java.lang.Iterable"] });
            }
            AbstractCollection.prototype.forEach = function (action) {
                javaemul.internal.InternalPreconditions.checkNotNull(action);
                for (var index122 = this.iterator(); index122.hasNext();) {
                    var t = index122.next();
                    {
                        action(t);
                    }
                }
            };
            AbstractCollection.prototype.add = function (index, element) {
                if (((index != null) || index === null) && element === undefined) {
                    return this.add$java_lang_Object(index);
                }
                else
                    throw new Error('invalid overload');
            };
            AbstractCollection.prototype.add$java_lang_Object = function (o) {
                throw new java.lang.UnsupportedOperationException("Add not supported on this collection");
            };
            AbstractCollection.prototype.addAll = function (index, c) {
                if (((index != null && index["__interfaces"] != null && index["__interfaces"].indexOf("java.util.Collection") >= 0) || index === null) && c === undefined) {
                    return this.addAll$java_util_Collection(index);
                }
                else
                    throw new Error('invalid overload');
            };
            AbstractCollection.prototype.addAll$java_util_Collection = function (c) {
                javaemul.internal.InternalPreconditions.checkNotNull(c);
                var changed = false;
                for (var index123 = c.iterator(); index123.hasNext();) {
                    var e = index123.next();
                    {
                        changed = changed || this.add(e);
                    }
                }
                return changed;
            };
            AbstractCollection.prototype.clear = function () {
                for (var iter = this.iterator(); iter.hasNext();) {
                    iter.next();
                    iter.remove();
                }
            };
            AbstractCollection.prototype.contains = function (o) {
                return this.advanceToFind(o, false);
            };
            AbstractCollection.prototype.containsAll = function (c) {
                javaemul.internal.InternalPreconditions.checkNotNull(c);
                for (var index124 = c.iterator(); index124.hasNext();) {
                    var e = index124.next();
                    {
                        if (!this.contains(e)) {
                            return false;
                        }
                    }
                }
                return true;
            };
            AbstractCollection.prototype.isEmpty = function () {
                return this.size() === 0;
            };
            AbstractCollection.prototype.remove = function (index) {
                if (((index != null) || index === null)) {
                    return this.remove$java_lang_Object(index);
                }
                else
                    throw new Error('invalid overload');
            };
            AbstractCollection.prototype.remove$java_lang_Object = function (o) {
                return this.advanceToFind(o, true);
            };
            AbstractCollection.prototype.removeAll = function (c) {
                javaemul.internal.InternalPreconditions.checkNotNull(c);
                var changed = false;
                for (var iter = this.iterator(); iter.hasNext();) {
                    var o = iter.next();
                    if (c.contains(o)) {
                        iter.remove();
                        changed = true;
                    }
                }
                return changed;
            };
            AbstractCollection.prototype.retainAll = function (c) {
                javaemul.internal.InternalPreconditions.checkNotNull(c);
                var changed = false;
                for (var iter = this.iterator(); iter.hasNext();) {
                    var o = iter.next();
                    if (!c.contains(o)) {
                        iter.remove();
                        changed = true;
                    }
                }
                return changed;
            };
            AbstractCollection.prototype.toArray$ = function () {
                return this.toArray(new Array(this.size()));
            };
            AbstractCollection.prototype.toArray = function (a) {
                var _this = this;
                if (((a != null && a instanceof Array) || a === null)) {
                    return (function () {
                        var size = _this.size();
                        if (a.length < size) {
                            a = javaemul.internal.ArrayHelper.createFrom(a, size);
                        }
                        var result = a;
                        var it = _this.iterator();
                        for (var i = 0; i < size; ++i) {
                            result[i] = it.next();
                        }
                        if (a.length > size) {
                            a[size] = null;
                        }
                        return a;
                    })();
                }
                else if (a === undefined) {
                    return this.toArray$();
                }
                else
                    throw new Error('invalid overload');
            };
            AbstractCollection.prototype.toString = function () {
                var joiner = new java.util.StringJoiner(", ", "[", "]");
                for (var index125 = this.iterator(); index125.hasNext();) {
                    var e = index125.next();
                    {
                        joiner.add(e === this ? "(this Collection)" : new String(e).toString());
                    }
                }
                return joiner.toString();
            };
            AbstractCollection.prototype.advanceToFind = function (o, remove) {
                for (var iter = this.iterator(); iter.hasNext();) {
                    var e = iter.next();
                    if (java.util.Objects.equals(o, e)) {
                        if (remove) {
                            iter.remove();
                        }
                        return true;
                    }
                }
                return false;
            };
            return AbstractCollection;
        }());
        util.AbstractCollection = AbstractCollection;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * Basic {@link Map.Entry} implementation that implements hashCode, equals, and
         * toString.
         */
        var AbstractMapEntry = (function () {
            function AbstractMapEntry() {
                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Map.Entry"] });
            }
            AbstractMapEntry.prototype.equals = function (other) {
                if (!(other != null && other["__interfaces"] != null && other["__interfaces"].indexOf("java.util.Map.Entry") >= 0)) {
                    return false;
                }
                var entry = other;
                return java.util.Objects.equals(this.getKey(), entry.getKey()) && java.util.Objects.equals(this.getValue(), entry.getValue());
            };
            /**
             * Calculate the hash code using Sun's specified algorithm.
             */
            AbstractMapEntry.prototype.hashCode = function () {
                return java.util.Objects.hashCode(this.getKey()) ^ java.util.Objects.hashCode(this.getValue());
            };
            AbstractMapEntry.prototype.toString = function () {
                return this.getKey() + "=" + this.getValue();
            };
            return AbstractMapEntry;
        }());
        util.AbstractMapEntry = AbstractMapEntry;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        var Comparators = (function () {
            function Comparators() {
            }
            Comparators.NATURAL_$LI$ = function () { if (Comparators.NATURAL == null)
                Comparators.NATURAL = new Comparators.NaturalComparator(); return Comparators.NATURAL; };
            ;
            /**
             * Returns the natural Comparator.
             * <p>
             * Example:
             *
             * <pre>Comparator&lt;String&gt; compareString = Comparators.natural()</pre>
             *
             * @return the natural Comparator
             */
            Comparators.natural = function () {
                return Comparators.NATURAL_$LI$();
            };
            return Comparators;
        }());
        util.Comparators = Comparators;
        var Comparators;
        (function (Comparators) {
            var NaturalComparator = (function () {
                function NaturalComparator() {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Comparator"] });
                }
                NaturalComparator.prototype.compare = function (o1, o2) {
                    javaemul.internal.InternalPreconditions.checkNotNull(o1);
                    javaemul.internal.InternalPreconditions.checkNotNull(o2);
                    return o1.compareTo(o2);
                };
                return NaturalComparator;
            }());
            Comparators.NaturalComparator = NaturalComparator;
        })(Comparators = util.Comparators || (util.Comparators = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * Represents a date and time.
         */
        var Date = (function () {
            function Date(year, month, date, hrs, min, sec) {
                var _this = this;
                if (((typeof year === 'number') || year === null) && ((typeof month === 'number') || month === null) && ((typeof date === 'number') || date === null) && ((typeof hrs === 'number') || hrs === null) && ((typeof min === 'number') || min === null) && ((typeof sec === 'number') || sec === null)) {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.lang.Comparable", "java.io.Serializable"] });
                    (function () {
                        _this.jsdate = new (Date.jsdateClass())();
                        _this.jsdate["setFullYear"](_this.jsdate, year + 1900, month, date);
                        _this.jsdate["setHours"](_this.jsdate, hrs, min, sec, 0);
                        _this.fixDaylightSavings(hrs);
                    })();
                }
                else if (((typeof year === 'number') || year === null) && ((typeof month === 'number') || month === null) && ((typeof date === 'number') || date === null) && ((typeof hrs === 'number') || hrs === null) && ((typeof min === 'number') || min === null) && sec === undefined) {
                    {
                        var sec = 0;
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.lang.Comparable", "java.io.Serializable"] });
                        (function () {
                            _this.jsdate = new (Date.jsdateClass())();
                            _this.jsdate["setFullYear"](_this.jsdate, year + 1900, month, date);
                            _this.jsdate["setHours"](_this.jsdate, hrs, min, sec, 0);
                            _this.fixDaylightSavings(hrs);
                        })();
                    }
                    (function () {
                    })();
                }
                else if (((typeof year === 'number') || year === null) && ((typeof month === 'number') || month === null) && ((typeof date === 'number') || date === null) && hrs === undefined && min === undefined && sec === undefined) {
                    {
                        var hrs = 0;
                        var min = 0;
                        var sec = 0;
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.lang.Comparable", "java.io.Serializable"] });
                        (function () {
                            _this.jsdate = new (Date.jsdateClass())();
                            _this.jsdate["setFullYear"](_this.jsdate, year + 1900, month, date);
                            _this.jsdate["setHours"](_this.jsdate, hrs, min, sec, 0);
                            _this.fixDaylightSavings(hrs);
                        })();
                    }
                    (function () {
                    })();
                }
                else if (((typeof year === 'string') || year === null) && month === undefined && date === undefined && hrs === undefined && min === undefined && sec === undefined) {
                    var date = year;
                    {
                        var date = Date.parse(date);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.lang.Comparable", "java.io.Serializable"] });
                        (function () {
                            _this.jsdate = new Date(date);
                        })();
                    }
                    (function () {
                    })();
                }
                else if (((typeof year === 'number') || year === null) && month === undefined && date === undefined && hrs === undefined && min === undefined && sec === undefined) {
                    var date = year;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.lang.Comparable", "java.io.Serializable"] });
                    (function () {
                        _this.jsdate = new Date(date);
                    })();
                }
                else if (year === undefined && month === undefined && date === undefined && hrs === undefined && min === undefined && sec === undefined) {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.lang.Comparable", "java.io.Serializable"] });
                    (function () {
                        _this.jsdate = new (Date.jsdateClass())();
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            Date.parse = function (s) {
                var parsed = Date.jsdateClass()["parse"](s);
                if ((Number.NaN === parsed)) {
                    throw new java.lang.IllegalArgumentException();
                }
                return Math.round(parsed);
            };
            Date.UTC = function (year, month, date, hrs, min, sec) {
                return Math.round(Date.jsdateClass()["UTC"](year + 1900, month, date, hrs, min, sec, 0));
            };
            /**
             * Ensure a number is displayed with two digits.
             *
             * @return a two-character base 10 representation of the number
             */
            Date.padTwo = function (number) {
                if (number < 10) {
                    return "0" + number;
                }
                else {
                    return new String(number).toString();
                }
            };
            Date.jsdateClass = function () {
                return window["Date"];
            };
            Date.prototype.after = function (ts) {
                if (((ts != null && ts instanceof java.util.Date) || ts === null)) {
                    return this.after$java_util_Date(ts);
                }
                else
                    throw new Error('invalid overload');
            };
            Date.prototype.after$java_util_Date = function (when) {
                return this.getTime() > when.getTime();
            };
            Date.prototype.before = function (ts) {
                if (((ts != null && ts instanceof java.util.Date) || ts === null)) {
                    return this.before$java_util_Date(ts);
                }
                else
                    throw new Error('invalid overload');
            };
            Date.prototype.before$java_util_Date = function (when) {
                return this.getTime() < when.getTime();
            };
            Date.prototype.clone = function () {
                return new Date(this.getTime());
            };
            Date.prototype.compareTo = function (other) {
                var _this = this;
                if (((other != null && other instanceof java.util.Date) || other === null)) {
                    return (function () {
                        return javaemul.internal.LongHelper.compare(_this.getTime(), other.getTime());
                    })();
                }
                else
                    throw new Error('invalid overload');
            };
            Date.prototype.equals = function (ts) {
                if (((ts != null) || ts === null)) {
                    return this.equals$java_lang_Object(ts);
                }
                else
                    throw new Error('invalid overload');
            };
            Date.prototype.equals$java_lang_Object = function (obj) {
                return ((obj != null && obj instanceof java.util.Date) && (this.getTime() === obj.getTime()));
            };
            Date.prototype.getDate = function () {
                return (this.jsdate["getDate"](this.jsdate) | 0);
            };
            Date.prototype.getDay = function () {
                return (this.jsdate["getDay"](this.jsdate) | 0);
            };
            Date.prototype.getHours = function () {
                return (this.jsdate["getHours"](this.jsdate) | 0);
            };
            Date.prototype.getMinutes = function () {
                return (this.jsdate["getMinutes"](this.jsdate) | 0);
            };
            Date.prototype.getMonth = function () {
                return (this.jsdate["getMonth"](this.jsdate) | 0);
            };
            Date.prototype.getSeconds = function () {
                return (this.jsdate["getSeconds"](this.jsdate) | 0);
            };
            Date.prototype.getTime = function () {
                return Math.round(this.jsdate["getTime"](this.jsdate));
            };
            Date.prototype.getTimezoneOffset = function () {
                return (this.jsdate["getTimezoneOffset"](this.jsdate) | 0);
            };
            Date.prototype.getYear = function () {
                return (this.jsdate["getFullYear"](this.jsdate) | 0) - 1900;
            };
            Date.prototype.hashCode = function () {
                var time = this.getTime();
                return ((time ^ (time >>> 32)) | 0);
            };
            Date.prototype.setDate = function (date) {
                var hours = this.getHours();
                this.jsdate["setDate"](this.jsdate, date);
                this.fixDaylightSavings(hours);
            };
            Date.prototype.setHours = function (hours) {
                this.jsdate["setHours"](this.jsdate, hours);
                this.fixDaylightSavings(hours);
            };
            Date.prototype.setMinutes = function (minutes) {
                var hours = this.getHours() + (minutes / 60 | 0);
                this.jsdate["setMinutes"](this.jsdate, minutes);
                this.fixDaylightSavings(hours);
            };
            Date.prototype.setMonth = function (month) {
                var hours = this.getHours();
                this.jsdate["setMonth"](this.jsdate, month);
                this.fixDaylightSavings(hours);
            };
            Date.prototype.setSeconds = function (seconds) {
                var hours = this.getHours() + (seconds / (60 * 60) | 0);
                this.jsdate["setSeconds"](this.jsdate, seconds);
                this.fixDaylightSavings(hours);
            };
            Date.prototype.setTime = function (time) {
                this.jsdate["setTime"](this.jsdate, time);
            };
            Date.prototype.setYear = function (year) {
                var hours = this.getHours();
                this.jsdate["setFullYear"](this.jsdate, year + 1900);
                this.fixDaylightSavings(hours);
            };
            Date.prototype.toGMTString = function () {
                return this.jsdate["getUTCDate"](this.jsdate) + " " + Date.StringData.MONTHS_$LI$()[(this.jsdate["getUTCMonth"](this.jsdate) | 0)] + " " + this.jsdate["getUTCFullYear"](this.jsdate) + " " + Date.padTwo((this.jsdate["getUTCHours"](this.jsdate) | 0)) + ":" + Date.padTwo((this.jsdate["getUTCMinutes"](this.jsdate) | 0)) + ":" + Date.padTwo((this.jsdate["getUTCSeconds"](this.jsdate) | 0)) + " GMT";
            };
            Date.prototype.toLocaleString = function () {
                return this.jsdate.toLocaleString();
            };
            Date.prototype.toString = function () {
                var offset = -(this.getTimezoneOffset() | 0);
                var hourOffset = ((offset >= 0) ? "+" : "") + ((offset / 60 | 0));
                var minuteOffset = Date.padTwo(Math.abs(offset) % 60);
                return Date.StringData.DAYS_$LI$()[(this.getDay() | 0)] + " " + Date.StringData.MONTHS_$LI$()[(this.getMonth() | 0)] + " " + Date.padTwo((this.getDate() | 0)) + " " + Date.padTwo((this.getHours() | 0)) + ":" + Date.padTwo((this.getMinutes() | 0)) + ":" + Date.padTwo((this.getSeconds() | 0)) + " GMT" + hourOffset + minuteOffset + " " + this.jsdate["getFullYear"](this.jsdate);
            };
            Date.ONE_HOUR_IN_MILLISECONDS_$LI$ = function () { if (Date.ONE_HOUR_IN_MILLISECONDS == null)
                Date.ONE_HOUR_IN_MILLISECONDS = 60 * 60 * 1000; return Date.ONE_HOUR_IN_MILLISECONDS; };
            ;
            /**
             * Detects if the requested time falls into a non-existent time range due to
             * local time advancing into daylight savings time or is ambiguous due to
             * going out of daylight savings. If so, adjust accordingly.
             */
            Date.prototype.fixDaylightSavings = function (requestedHours) {
                requestedHours %= 24;
                if (this.getHours() !== requestedHours) {
                    var copy = new (Date.jsdateClass())(this.getTime());
                    copy["setDate"](((copy["getDate"](copy) | 0) + 1));
                    var timeDiff = (this.jsdate["getTimezoneOffset"](this.jsdate) | 0) - (copy["getTimezoneOffset"](copy) | 0);
                    if (timeDiff > 0) {
                        var timeDiffHours = (timeDiff / 60 | 0);
                        var timeDiffMinutes = timeDiff % 60;
                        var day = (this.getDate() | 0);
                        var badHours = (this.getHours() | 0);
                        if (badHours + timeDiffHours >= 24) {
                            day++;
                        }
                        var newTime = new (Date.jsdateClass())((this.jsdate["getFullYear"](this.jsdate) | 0), this.getMonth(), day, requestedHours + timeDiffHours, this.getMinutes() + timeDiffMinutes, this.getSeconds(), Math.round(this.jsdate["getMilliseconds"](this.jsdate)));
                        this.setTime(newTime["getMilliseconds"](newTime));
                    }
                }
                var originalTimeInMillis = this.getTime();
                this.setTime(originalTimeInMillis + Date.ONE_HOUR_IN_MILLISECONDS_$LI$());
                if (this.getHours() !== requestedHours) {
                    this.setTime(originalTimeInMillis);
                }
            };
            return Date;
        }());
        util.Date = Date;
        var Date;
        (function (Date) {
            /**
             * Encapsulates static data to avoid Date itself having a static
             * initializer.
             */
            var StringData = (function () {
                function StringData() {
                }
                StringData.DAYS_$LI$ = function () { if (StringData.DAYS == null)
                    StringData.DAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]; return StringData.DAYS; };
                ;
                StringData.MONTHS_$LI$ = function () { if (StringData.MONTHS == null)
                    StringData.MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]; return StringData.MONTHS; };
                ;
                return StringData;
            }());
            Date.StringData = StringData;
        })(Date = util.Date || (util.Date = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * Available as a superclass of event objects.
         */
        var EventObject = (function () {
            function EventObject(source) {
                this.source = source;
            }
            EventObject.prototype.getSource = function () {
                return this.source;
            };
            return EventObject;
        }());
        util.EventObject = EventObject;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * A simple wrapper around JavaScriptObject to provide {@link java.util.Map}-like semantics for any
         * key type.
         * <p>
         * Implementation notes:
         * <p>
         * A key's hashCode is the index in backingMap which should contain that key. Since several keys may
         * have the same hash, each value in hashCodeMap is actually an array containing all entries whose
         * keys share the same hash.
         */
        var InternalHashCodeMap = (function () {
            function InternalHashCodeMap(host) {
                this.backingMap = java.util.InternalJsMapFactory.newJsMap();
                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Iterable"] });
                this.__size = 0;
                this.host = host;
            }
            InternalHashCodeMap.prototype.forEach = function (action) {
                javaemul.internal.InternalPreconditions.checkNotNull(action);
                for (var index126 = this.iterator(); index126.hasNext();) {
                    var t = index126.next();
                    {
                        action(t);
                    }
                }
            };
            InternalHashCodeMap.prototype.put = function (key, value) {
                var hashCode = this.hash(key);
                var chain = this.getChainOrEmpty(hashCode);
                if (chain.length === 0) {
                    this.backingMap.set(hashCode, chain);
                }
                else {
                    var entry = this.findEntryInChain(key, chain);
                    if (entry != null) {
                        return entry.setValue(value);
                    }
                }
                chain[chain.length] = new util.AbstractMap.SimpleEntry(key, value);
                this.__size++;
                java.util.ConcurrentModificationDetector.structureChanged(this.host);
                return null;
            };
            InternalHashCodeMap.prototype.remove = function (key) {
                var hashCode = this.hash(key);
                var chain = this.getChainOrEmpty(hashCode);
                for (var i = 0; i < chain.length; i++) {
                    var entry = chain[i];
                    if (this.host._equals(key, entry.getKey())) {
                        if (chain.length === 1) {
                            javaemul.internal.ArrayHelper.setLength(chain, 0);
                            this.backingMap.delete(hashCode);
                        }
                        else {
                            javaemul.internal.ArrayHelper.removeFrom(chain, i, 1);
                        }
                        this.__size--;
                        java.util.ConcurrentModificationDetector.structureChanged(this.host);
                        return entry.getValue();
                    }
                }
                return null;
            };
            InternalHashCodeMap.prototype.getEntry = function (key) {
                return this.findEntryInChain(key, this.getChainOrEmpty(this.hash(key)));
            };
            InternalHashCodeMap.prototype.findEntryInChain = function (key, chain) {
                for (var index127 = 0; index127 < chain.length; index127++) {
                    var entry = chain[index127];
                    {
                        if (this.host._equals(key, entry.getKey())) {
                            return entry;
                        }
                    }
                }
                return null;
            };
            InternalHashCodeMap.prototype.size = function () {
                return this.__size;
            };
            InternalHashCodeMap.prototype.iterator = function () {
                return new InternalHashCodeMap.InternalHashCodeMap$0(this);
            };
            InternalHashCodeMap.prototype.getChainOrEmpty = function (hashCode) {
                var chain = this.unsafeCastToArray(this.backingMap.get(hashCode));
                return chain == null ? this.newEntryChain() : chain;
            };
            InternalHashCodeMap.prototype.newEntryChain = function () {
                return [];
            };
            InternalHashCodeMap.prototype.unsafeCastToArray = function (arr) {
                return arr;
            };
            /**
             * Returns hash code of the key as calculated by {@link AbstractHashMap#getHashCode(Object)} but
             * also handles null keys as well.
             */
            InternalHashCodeMap.prototype.hash = function (key) {
                return key == null ? 0 : this.host.getHashCode(key);
            };
            return InternalHashCodeMap;
        }());
        util.InternalHashCodeMap = InternalHashCodeMap;
        var InternalHashCodeMap;
        (function (InternalHashCodeMap) {
            var InternalHashCodeMap$0 = (function () {
                function InternalHashCodeMap$0(__parent) {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Iterator"] });
                    this.__parent = __parent;
                    this.chains = this.__parent.backingMap.entries();
                    this.itemIndex = 0;
                    this.chain = this.__parent.newEntryChain();
                    this.lastEntry = null;
                }
                InternalHashCodeMap$0.prototype.forEachRemaining = function (consumer) {
                    javaemul.internal.InternalPreconditions.checkNotNull(consumer);
                    while ((this.hasNext())) {
                        consumer(this.next());
                    }
                    ;
                };
                InternalHashCodeMap$0.prototype.hasNext = function () {
                    if (this.itemIndex < this.chain.length) {
                        return true;
                    }
                    var current = this.chains.next();
                    if (!current.done) {
                        this.chain = this.__parent.unsafeCastToArray(current.value[1]);
                        this.itemIndex = 0;
                        return true;
                    }
                    return false;
                };
                InternalHashCodeMap$0.prototype.next = function () {
                    this.lastEntry = this.chain[this.itemIndex++];
                    return this.lastEntry;
                };
                InternalHashCodeMap$0.prototype.remove = function () {
                    this.__parent.remove(this.lastEntry.getKey());
                    if (this.itemIndex !== 0) {
                        this.itemIndex--;
                    }
                };
                return InternalHashCodeMap$0;
            }());
            InternalHashCodeMap.InternalHashCodeMap$0 = InternalHashCodeMap$0;
        })(InternalHashCodeMap = util.InternalHashCodeMap || (util.InternalHashCodeMap = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        var InternalJsMap = (function () {
            function InternalJsMap() {
            }
            InternalJsMap.prototype.get$int = function (key) {
                return null;
            };
            InternalJsMap.prototype.get = function (key) {
                if (((typeof key === 'string') || key === null)) {
                    return (function () {
                        return null;
                    })();
                }
                else if (((typeof key === 'number') || key === null)) {
                    return this.get$int(key);
                }
                else
                    throw new Error('invalid overload');
            };
            InternalJsMap.prototype.set$int$java_lang_Object = function (key, value) {
            };
            InternalJsMap.prototype.set = function (key, value) {
                if (((typeof key === 'string') || key === null) && ((value != null) || value === null)) {
                    return (function () {
                    })();
                }
                else if (((typeof key === 'number') || key === null) && ((value != null) || value === null)) {
                    return this.set$int$java_lang_Object(key, value);
                }
                else
                    throw new Error('invalid overload');
            };
            InternalJsMap.prototype.delete$int = function (key) {
                InternalJsMap.JsHelper.delete(this, key);
            };
            InternalJsMap.prototype.delete = function (key) {
                var _this = this;
                if (((typeof key === 'string') || key === null)) {
                    return (function () {
                        InternalJsMap.JsHelper.delete(_this, key);
                    })();
                }
                else if (((typeof key === 'number') || key === null)) {
                    return this.delete$int(key);
                }
                else
                    throw new Error('invalid overload');
            };
            InternalJsMap.prototype.entries = function () {
                return null;
            };
            return InternalJsMap;
        }());
        util.InternalJsMap = InternalJsMap;
        var InternalJsMap;
        (function (InternalJsMap) {
            var Iterator = (function () {
                function Iterator() {
                }
                Iterator.prototype.next = function () {
                    return null;
                };
                return Iterator;
            }());
            InternalJsMap.Iterator = Iterator;
            var IteratorEntry = (function () {
                function IteratorEntry() {
                    this.done = false;
                }
                return IteratorEntry;
            }());
            InternalJsMap.IteratorEntry = IteratorEntry;
            var JsHelper = (function () {
                function JsHelper() {
                }
                JsHelper.delete$java_util_InternalJsMap$int = function (obj, key) {
                    obj["delete"](key);
                };
                JsHelper.delete = function (obj, key) {
                    if (((obj != null && obj instanceof java.util.InternalJsMap) || obj === null) && ((typeof key === 'string') || key === null)) {
                        return (function () {
                            obj["delete"](key);
                        })();
                    }
                    else if (((obj != null && obj instanceof java.util.InternalJsMap) || obj === null) && ((typeof key === 'number') || key === null)) {
                        return java.util.InternalJsMap.JsHelper.delete$java_util_InternalJsMap$int(obj, key);
                    }
                    else
                        throw new Error('invalid overload');
                };
                return JsHelper;
            }());
            InternalJsMap.JsHelper = JsHelper;
        })(InternalJsMap = util.InternalJsMap || (util.InternalJsMap = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * A factory to create JavaScript Map instances.
         */
        var InternalJsMapFactory = (function () {
            function InternalJsMapFactory() {
            }
            InternalJsMapFactory.jsMapCtor_$LI$ = function () { if (InternalJsMapFactory.jsMapCtor == null)
                InternalJsMapFactory.jsMapCtor = InternalJsMapFactory.getJsMapConstructor(); return InternalJsMapFactory.jsMapCtor; };
            ;
            InternalJsMapFactory.getJsMapConstructor = function () {
                return Map;
            };
            InternalJsMapFactory.newJsMap = function () {
                return new (InternalJsMapFactory.jsMapCtor_$LI$())();
            };
            return InternalJsMapFactory;
        }());
        util.InternalJsMapFactory = InternalJsMapFactory;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * A very simple emulation of Locale for shared-code patterns like
         * {@code String.toUpperCase(Locale.US)}.
         * <p>
         * Note: Any changes to this class should put into account the assumption that
         * was made in rest of the JRE emulation.
         */
        var Locale = (function () {
            function Locale() {
            }
            Locale.ROOT_$LI$ = function () { if (Locale.ROOT == null)
                Locale.ROOT = new Locale.RootLocale(); return Locale.ROOT; };
            ;
            Locale.ENGLISH_$LI$ = function () { if (Locale.ENGLISH == null)
                Locale.ENGLISH = new Locale.EnglishLocale(); return Locale.ENGLISH; };
            ;
            Locale.US_$LI$ = function () { if (Locale.US == null)
                Locale.US = new Locale.USLocale(); return Locale.US; };
            ;
            Locale.defaultLocale_$LI$ = function () { if (Locale.defaultLocale == null)
                Locale.defaultLocale = new Locale.DefaultLocale(); return Locale.defaultLocale; };
            ;
            /**
             * Returns an instance that represents the browser's default locale (not
             * necessarily the one defined by 'gwt.locale').
             */
            Locale.getDefault = function () {
                return Locale.defaultLocale_$LI$();
            };
            return Locale;
        }());
        util.Locale = Locale;
        var Locale;
        (function (Locale) {
            var RootLocale = (function (_super) {
                __extends(RootLocale, _super);
                function RootLocale() {
                    _super.apply(this, arguments);
                }
                RootLocale.prototype.toString = function () {
                    return "";
                };
                return RootLocale;
            }(java.util.Locale));
            Locale.RootLocale = RootLocale;
            var EnglishLocale = (function (_super) {
                __extends(EnglishLocale, _super);
                function EnglishLocale() {
                    _super.apply(this, arguments);
                }
                EnglishLocale.prototype.toString = function () {
                    return "en";
                };
                return EnglishLocale;
            }(java.util.Locale));
            Locale.EnglishLocale = EnglishLocale;
            var USLocale = (function (_super) {
                __extends(USLocale, _super);
                function USLocale() {
                    _super.apply(this, arguments);
                }
                USLocale.prototype.toString = function () {
                    return "en_US";
                };
                return USLocale;
            }(java.util.Locale));
            Locale.USLocale = USLocale;
            var DefaultLocale = (function (_super) {
                __extends(DefaultLocale, _super);
                function DefaultLocale() {
                    _super.apply(this, arguments);
                }
                DefaultLocale.prototype.toString = function () {
                    return "unknown";
                };
                return DefaultLocale;
            }(java.util.Locale));
            Locale.DefaultLocale = DefaultLocale;
        })(Locale = util.Locale || (util.Locale = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        var logging;
        (function (logging) {
            /**
             * An emulation of the java.util.logging.Formatter class. See
             * <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/logging/Formatter.html">
             * The Java API doc for details</a>
             */
            var Formatter = (function () {
                function Formatter() {
                }
                Formatter.prototype.formatMessage = function (record) {
                    return this.format(record);
                };
                return Formatter;
            }());
            logging.Formatter = Formatter;
        })(logging = util.logging || (util.logging = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        var logging;
        (function (logging) {
            /**
             * An emulation of the java.util.logging.Handler class. See
             * <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/logging/Handler.html">
             * The Java API doc for details</a>
             */
            var Handler = (function () {
                function Handler() {
                }
                Handler.prototype.getFormatter = function () {
                    return this.formatter;
                };
                Handler.prototype.getLevel = function () {
                    if (this.level != null) {
                        return this.level;
                    }
                    return java.util.logging.Level.ALL_$LI$();
                };
                Handler.prototype.isLoggable = function (record) {
                    return this.getLevel().intValue() <= record.getLevel().intValue();
                };
                Handler.prototype.setFormatter = function (newFormatter) {
                    this.formatter = newFormatter;
                };
                Handler.prototype.setLevel = function (newLevel) {
                    this.level = newLevel;
                };
                return Handler;
            }());
            logging.Handler = Handler;
        })(logging = util.logging || (util.logging = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        var logging;
        (function (logging) {
            /**
             * An emulation of the java.util.logging.Level class. See
             * <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/logging/Level.html">
             * The Java API doc for details</a>
             */
            var Level = (function () {
                function Level() {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                }
                Level.ALL_$LI$ = function () { if (Level.ALL == null)
                    Level.ALL = new Level.LevelAll(); return Level.ALL; };
                ;
                Level.CONFIG_$LI$ = function () { if (Level.CONFIG == null)
                    Level.CONFIG = new Level.LevelConfig(); return Level.CONFIG; };
                ;
                Level.FINE_$LI$ = function () { if (Level.FINE == null)
                    Level.FINE = new Level.LevelFine(); return Level.FINE; };
                ;
                Level.FINER_$LI$ = function () { if (Level.FINER == null)
                    Level.FINER = new Level.LevelFiner(); return Level.FINER; };
                ;
                Level.FINEST_$LI$ = function () { if (Level.FINEST == null)
                    Level.FINEST = new Level.LevelFinest(); return Level.FINEST; };
                ;
                Level.INFO_$LI$ = function () { if (Level.INFO == null)
                    Level.INFO = new Level.LevelInfo(); return Level.INFO; };
                ;
                Level.OFF_$LI$ = function () { if (Level.OFF == null)
                    Level.OFF = new Level.LevelOff(); return Level.OFF; };
                ;
                Level.SEVERE_$LI$ = function () { if (Level.SEVERE == null)
                    Level.SEVERE = new Level.LevelSevere(); return Level.SEVERE; };
                ;
                Level.WARNING_$LI$ = function () { if (Level.WARNING == null)
                    Level.WARNING = new Level.LevelWarning(); return Level.WARNING; };
                ;
                Level.parse = function (name) {
                    java.util.logging.Logger.assertLoggingValues();
                    var loggingDisabled = (java.lang.System.getProperty("gwt.logging.enabled", "FALSE") === "FALSE");
                    if (loggingDisabled) {
                        return null;
                    }
                    var value = name.toUpperCase();
                    switch ((value)) {
                        case "ALL":
                            return Level.ALL_$LI$();
                        case "CONFIG":
                            return Level.CONFIG_$LI$();
                        case "FINE":
                            return Level.FINE_$LI$();
                        case "FINER":
                            return Level.FINER_$LI$();
                        case "FINEST":
                            return Level.FINEST_$LI$();
                        case "INFO":
                            return Level.INFO_$LI$();
                        case "OFF":
                            return Level.OFF_$LI$();
                        case "SEVERE":
                            return Level.SEVERE_$LI$();
                        case "WARNING":
                            return Level.WARNING_$LI$();
                        default:
                            throw new java.lang.IllegalArgumentException("Invalid level \"" + name + "\"");
                    }
                };
                Level.prototype.getName = function () {
                    return "DUMMY";
                };
                Level.prototype.intValue = function () {
                    return -1;
                };
                Level.prototype.toString = function () {
                    return this.getName();
                };
                return Level;
            }());
            logging.Level = Level;
            var Level;
            (function (Level) {
                var LevelAll = (function (_super) {
                    __extends(LevelAll, _super);
                    function LevelAll() {
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    }
                    LevelAll.prototype.getName = function () {
                        return "ALL";
                    };
                    LevelAll.prototype.intValue = function () {
                        return javaemul.internal.IntegerHelper.MIN_VALUE;
                    };
                    return LevelAll;
                }(java.util.logging.Level));
                Level.LevelAll = LevelAll;
                var LevelConfig = (function (_super) {
                    __extends(LevelConfig, _super);
                    function LevelConfig() {
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    }
                    LevelConfig.prototype.getName = function () {
                        return "CONFIG";
                    };
                    LevelConfig.prototype.intValue = function () {
                        return 700;
                    };
                    return LevelConfig;
                }(java.util.logging.Level));
                Level.LevelConfig = LevelConfig;
                var LevelFine = (function (_super) {
                    __extends(LevelFine, _super);
                    function LevelFine() {
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    }
                    LevelFine.prototype.getName = function () {
                        return "FINE";
                    };
                    LevelFine.prototype.intValue = function () {
                        return 500;
                    };
                    return LevelFine;
                }(java.util.logging.Level));
                Level.LevelFine = LevelFine;
                var LevelFiner = (function (_super) {
                    __extends(LevelFiner, _super);
                    function LevelFiner() {
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    }
                    LevelFiner.prototype.getName = function () {
                        return "FINER";
                    };
                    LevelFiner.prototype.intValue = function () {
                        return 400;
                    };
                    return LevelFiner;
                }(java.util.logging.Level));
                Level.LevelFiner = LevelFiner;
                var LevelFinest = (function (_super) {
                    __extends(LevelFinest, _super);
                    function LevelFinest() {
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    }
                    LevelFinest.prototype.getName = function () {
                        return "FINEST";
                    };
                    LevelFinest.prototype.intValue = function () {
                        return 300;
                    };
                    return LevelFinest;
                }(java.util.logging.Level));
                Level.LevelFinest = LevelFinest;
                var LevelInfo = (function (_super) {
                    __extends(LevelInfo, _super);
                    function LevelInfo() {
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    }
                    LevelInfo.prototype.getName = function () {
                        return "INFO";
                    };
                    LevelInfo.prototype.intValue = function () {
                        return 800;
                    };
                    return LevelInfo;
                }(java.util.logging.Level));
                Level.LevelInfo = LevelInfo;
                var LevelOff = (function (_super) {
                    __extends(LevelOff, _super);
                    function LevelOff() {
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    }
                    LevelOff.prototype.getName = function () {
                        return "OFF";
                    };
                    LevelOff.prototype.intValue = function () {
                        return javaemul.internal.IntegerHelper.MAX_VALUE;
                    };
                    return LevelOff;
                }(java.util.logging.Level));
                Level.LevelOff = LevelOff;
                var LevelSevere = (function (_super) {
                    __extends(LevelSevere, _super);
                    function LevelSevere() {
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    }
                    LevelSevere.prototype.getName = function () {
                        return "SEVERE";
                    };
                    LevelSevere.prototype.intValue = function () {
                        return 1000;
                    };
                    return LevelSevere;
                }(java.util.logging.Level));
                Level.LevelSevere = LevelSevere;
                var LevelWarning = (function (_super) {
                    __extends(LevelWarning, _super);
                    function LevelWarning() {
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    }
                    LevelWarning.prototype.getName = function () {
                        return "WARNING";
                    };
                    LevelWarning.prototype.intValue = function () {
                        return 900;
                    };
                    return LevelWarning;
                }(java.util.logging.Level));
                Level.LevelWarning = LevelWarning;
            })(Level = logging.Level || (logging.Level = {}));
        })(logging = util.logging || (util.logging = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        var logging;
        (function (logging) {
            /**
             * An emulation of the java.util.logging.LogManager class. See
             * <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/logging/LogManger.html">
             * The Java API doc for details</a>
             */
            var LogManager = (function () {
                function LogManager() {
                    this.loggerMap = new java.util.HashMap();
                }
                LogManager.getLogManager = function () {
                    if (LogManager.singleton == null) {
                        LogManager.singleton = new LogManager();
                        var rootLogger = new java.util.logging.Logger("", null);
                        rootLogger.setLevel(java.util.logging.Level.INFO_$LI$());
                        LogManager.singleton.addLoggerImpl(rootLogger);
                    }
                    return LogManager.singleton;
                };
                LogManager.prototype.addLogger = function (logger) {
                    if (this.getLogger(logger.getName()) != null) {
                        return false;
                    }
                    this.addLoggerAndEnsureParents(logger);
                    return true;
                };
                LogManager.prototype.getLogger = function (name) {
                    return this.loggerMap.get(name);
                };
                LogManager.prototype.getLoggerNames = function () {
                    return java.util.Collections.enumeration(this.loggerMap.keySet());
                };
                /**
                 * Helper function to add a logger when we have already determined that it
                 * does not exist.  When we add a logger, we recursively add all of it's
                 * ancestors. Since loggers do not get removed, logger creation is cheap,
                 * and there are not usually too many loggers in an ancestry chain,
                 * this is a simple way to ensure that the parent/child relationships are
                 * always correctly set up.
                 */
                LogManager.prototype.addLoggerAndEnsureParents = function (logger) {
                    var name = logger.getName();
                    var parentName = name.substring(0, Math.max(0, name.lastIndexOf('.')));
                    logger.setParent(this.ensureLogger(parentName));
                    this.addLoggerImpl(logger);
                };
                LogManager.prototype.addLoggerImpl = function (logger) {
                    if ((java.lang.System.getProperty("gwt.logging.simpleConsoleHandler", "ENABLED") === "ENABLED")) {
                        if ((logger.getName().length === 0)) {
                            logger.addHandler(new java.util.logging.SimpleConsoleLogHandler());
                        }
                    }
                    this.loggerMap.put(logger.getName(), logger);
                };
                /**
                 * Helper function to create a logger if it does not exist since the public
                 * APIs for getLogger and addLogger make it difficult to use those functions
                 * for this.
                 */
                LogManager.prototype.ensureLogger = function (name) {
                    var logger = this.getLogger(name);
                    if (logger == null) {
                        var newLogger = new java.util.logging.Logger(name, null);
                        this.addLoggerAndEnsureParents(newLogger);
                        return newLogger;
                    }
                    return logger;
                };
                return LogManager;
            }());
            logging.LogManager = LogManager;
        })(logging = util.logging || (util.logging = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        var logging;
        (function (logging) {
            /**
             * An emulation of the java.util.logging.LogRecord class. See
             * <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/logging/LogRecord.html">
             * The Java API doc for details</a>
             */
            var LogRecord = (function () {
                function LogRecord(level, msg) {
                    var _this = this;
                    this.loggerName = "";
                    this.thrown = null;
                    if (((level != null && level instanceof java.util.logging.Level) || level === null) && ((typeof msg === 'string') || msg === null)) {
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                        this.millis = 0;
                        (function () {
                            _this.level = level;
                            _this.msg = msg;
                            _this.millis = java.lang.System.currentTimeMillis();
                        })();
                    }
                    else if (level === undefined && msg === undefined) {
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                        this.millis = 0;
                        (function () {
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                }
                LogRecord.prototype.getLevel = function () {
                    return this.level;
                };
                LogRecord.prototype.getLoggerName = function () {
                    return this.loggerName;
                };
                LogRecord.prototype.getMessage = function () {
                    return this.msg;
                };
                LogRecord.prototype.getMillis = function () {
                    return this.millis;
                };
                LogRecord.prototype.getThrown = function () {
                    return this.thrown;
                };
                LogRecord.prototype.setLevel = function (newLevel) {
                    this.level = newLevel;
                };
                LogRecord.prototype.setLoggerName = function (newName) {
                    this.loggerName = newName;
                };
                LogRecord.prototype.setMessage = function (newMessage) {
                    this.msg = newMessage;
                };
                LogRecord.prototype.setMillis = function (newMillis) {
                    this.millis = newMillis;
                };
                LogRecord.prototype.setThrown = function (newThrown) {
                    this.thrown = newThrown;
                };
                return LogRecord;
            }());
            logging.LogRecord = LogRecord;
        })(logging = util.logging || (util.logging = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * See <a
         * href="http://docs.oracle.com/javase/7/docs/api/java/util/Objects.html">the
         * official Java API doc</a> for details.
         */
        var Objects = (function () {
            function Objects() {
            }
            Objects.compare = function (a, b, c) {
                return a === b ? 0 : c.compare(a, b);
            };
            Objects.deepEquals = function (a, b) {
                if (a === b) {
                    return true;
                }
                if (a == null || b == null) {
                    return false;
                }
                if ((a === b)) {
                    return true;
                }
                var class1 = a.getClass();
                var class2 = b.getClass();
                if (!class1.isArray() || !class1.equals(class2)) {
                    return false;
                }
                if (a != null && a instanceof Array) {
                    return java.util.Arrays.deepEquals(a, b);
                }
                if (a != null && a instanceof Array) {
                    return java.util.Arrays.equals(a, b);
                }
                if (a != null && a instanceof Array) {
                    return java.util.Arrays.equals(a, b);
                }
                if (a != null && a instanceof Array) {
                    return java.util.Arrays.equals(a, b);
                }
                if (a != null && a instanceof Array) {
                    return java.util.Arrays.equals(a, b);
                }
                if (a != null && a instanceof Array) {
                    return java.util.Arrays.equals(a, b);
                }
                if (a != null && a instanceof Array) {
                    return java.util.Arrays.equals(a, b);
                }
                if (a != null && a instanceof Array) {
                    return java.util.Arrays.equals(a, b);
                }
                if (a != null && a instanceof Array) {
                    return java.util.Arrays.equals(a, b);
                }
                return true;
            };
            Objects.equals = function (a, b) {
                return (a === b) || (a != null && (a === b));
            };
            Objects.hashCode = function (o) {
                return o != null ? o.toString() : 0;
            };
            Objects.hash = function () {
                var values = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    values[_i - 0] = arguments[_i];
                }
                return java.util.Arrays.hashCode(values);
            };
            Objects.isNull = function (obj) {
                return obj == null;
            };
            Objects.nonNull = function (obj) {
                return obj != null;
            };
            Objects.requireNonNull$java_lang_Object = function (obj) {
                if (obj == null) {
                    throw new java.lang.NullPointerException();
                }
                return obj;
            };
            Objects.requireNonNull = function (obj, message) {
                if (((obj != null) || obj === null) && ((typeof message === 'string') || message === null)) {
                    return (function () {
                        if (obj == null) {
                            throw new java.lang.NullPointerException(message);
                        }
                        return obj;
                    })();
                }
                else if (((obj != null) || obj === null) && ((typeof message === 'function' && message.length == 0) || message === null)) {
                    return java.util.Objects.requireNonNull$java_lang_Object$java_util_function_Supplier(obj, message);
                }
                else if (((obj != null) || obj === null) && message === undefined) {
                    return java.util.Objects.requireNonNull$java_lang_Object(obj);
                }
                else
                    throw new Error('invalid overload');
            };
            Objects.requireNonNull$java_lang_Object$java_util_function_Supplier = function (obj, messageSupplier) {
                if (obj == null) {
                    throw new java.lang.NullPointerException(messageSupplier());
                }
                return obj;
            };
            Objects.toString$java_lang_Object = function (o) {
                return new String(o).toString();
            };
            Objects.toString = function (o, nullDefault) {
                if (((o != null) || o === null) && ((typeof nullDefault === 'string') || nullDefault === null)) {
                    return (function () {
                        return o != null ? o.toString() : nullDefault;
                    })();
                }
                else if (((o != null) || o === null) && nullDefault === undefined) {
                    return java.util.Objects.toString$java_lang_Object(o);
                }
                else
                    throw new Error('invalid overload');
            };
            return Objects;
        }());
        util.Objects = Objects;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * Implementation of the observable class.
         */
        var Observable = (function () {
            /**
             * Construct an Observable with zero Observers.
             */
            function Observable() {
                this.changed = false;
                this.obs = new java.util.Vector();
            }
            /**
             * Adds an observer to the set of observers for this object, provided that
             * it is not the same as some observer already in the set. The order in
             * which notifications will be delivered to multiple observers is not
             * specified. See the class comment.
             *
             * @param o
             * an observer to be added.
             * @throws NullPointerException
             * if the parameter o is null.
             */
            Observable.prototype.addObserver = function (o) {
                if (o == null)
                    throw new java.lang.NullPointerException();
                if (!this.obs.contains(o)) {
                    this.obs.addElement(o);
                }
            };
            /**
             * Deletes an observer from the set of observers of this object. Passing
             * <CODE>null</CODE> to this method will have no effect.
             *
             * @param o
             * the observer to be deleted.
             */
            Observable.prototype.deleteObserver = function (o) {
                this.obs.removeElement(o);
            };
            /**
             * If this object has changed, as indicated by the <code>hasChanged</code>
             * method, then notify all of its observers and then call the
             * <code>clearChanged</code> method to indicate that this object has no
             * longer changed.
             * <p>
             * Each observer has its <code>update</code> method called with two
             * arguments: this observable object and the <code>arg</code> argument.
             *
             * @param arg
             * any object.
             * @see java.util.Observable#clearChanged()
             * @see java.util.Observable#hasChanged()
             * @see java.util.Observer#update(java.util.Observable, java.lang.Object)
             */
            Observable.prototype.notifyObservers = function (arg) {
                if (arg === void 0) { arg = null; }
                var arrLocal;
                if (!this.changed)
                    return;
                arrLocal = this.obs.toArray();
                this.clearChanged();
                for (var i = arrLocal.length - 1; i >= 0; i--)
                    arrLocal[i].update(this, arg);
            };
            /**
             * Clears the observer list so that this object no longer has any observers.
             */
            Observable.prototype.deleteObservers = function () {
                this.obs.removeAllElements();
            };
            /**
             * Marks this <tt>Observable</tt> object as having been changed; the
             * <tt>hasChanged</tt> method will now return <tt>true</tt>.
             */
            Observable.prototype.setChanged = function () {
                this.changed = true;
            };
            /**
             * Indicates that this object has no longer changed, or that it has already
             * notified all of its observers of its most recent change, so that the
             * <tt>hasChanged</tt> method will now return <tt>false</tt>. This method is
             * called automatically by the <code>notifyObservers</code> methods.
             *
             * @see java.util.Observable#notifyObservers()
             * @see java.util.Observable#notifyObservers(java.lang.Object)
             */
            Observable.prototype.clearChanged = function () {
                this.changed = false;
            };
            /**
             * Tests if this object has changed.
             *
             * @return <code>true</code> if and only if the <code>setChanged</code>
             * method has been called more recently than the
             * <code>clearChanged</code> method on this object;
             * <code>false</code> otherwise.
             * @see java.util.Observable#clearChanged()
             * @see java.util.Observable#setChanged()
             */
            Observable.prototype.hasChanged = function () {
                return this.changed;
            };
            /**
             * Returns the number of observers of this <tt>Observable</tt> object.
             *
             * @return the number of observers of this object.
             */
            Observable.prototype.countObservers = function () {
                return this.obs.size();
            };
            return Observable;
        }());
        util.Observable = Observable;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * See <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html">
         * the official Java API doc</a> for details.
         *
         * @param <T> type of the wrapped reference
         */
        var Optional = (function () {
            function Optional(ref) {
                var _this = this;
                if (((ref != null) || ref === null)) {
                    (function () {
                        _this.ref = javaemul.internal.InternalPreconditions.checkCriticalNotNull(ref);
                    })();
                }
                else if (ref === undefined) {
                    (function () {
                        _this.ref = null;
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            Optional.empty = function () {
                return Optional.EMPTY_$LI$();
            };
            Optional.of = function (value) {
                return new Optional(value);
            };
            Optional.ofNullable = function (value) {
                return value == null ? Optional.empty() : Optional.of(value);
            };
            Optional.EMPTY_$LI$ = function () { if (Optional.EMPTY == null)
                Optional.EMPTY = new Optional(); return Optional.EMPTY; };
            ;
            Optional.prototype.isPresent = function () {
                return this.ref != null;
            };
            Optional.prototype.get = function () {
                javaemul.internal.InternalPreconditions.checkCriticalElement(this.isPresent());
                return this.ref;
            };
            Optional.prototype.ifPresent = function (consumer) {
                if (this.isPresent()) {
                    consumer(this.ref);
                }
            };
            Optional.prototype.filter = function (predicate) {
                javaemul.internal.InternalPreconditions.checkCriticalNotNull(predicate);
                if (!this.isPresent() || predicate(this.ref)) {
                    return this;
                }
                return Optional.empty();
            };
            Optional.prototype.map = function (mapper) {
                javaemul.internal.InternalPreconditions.checkCriticalNotNull(mapper);
                if (this.isPresent()) {
                    return Optional.ofNullable(mapper(this.ref));
                }
                return Optional.empty();
            };
            Optional.prototype.flatMap = function (mapper) {
                javaemul.internal.InternalPreconditions.checkCriticalNotNull(mapper);
                if (this.isPresent()) {
                    return javaemul.internal.InternalPreconditions.checkCriticalNotNull(mapper(this.ref));
                }
                return Optional.empty();
            };
            Optional.prototype.orElse = function (other) {
                return this.isPresent() ? this.ref : other;
            };
            Optional.prototype.orElseGet = function (other) {
                return this.isPresent() ? this.ref : other();
            };
            Optional.prototype.orElseThrow = function (exceptionSupplier) {
                if (this.isPresent()) {
                    return this.ref;
                }
                throw exceptionSupplier();
            };
            Optional.prototype.equals = function (obj) {
                if (obj === this) {
                    return true;
                }
                if (!(obj != null && obj instanceof java.util.Optional)) {
                    return false;
                }
                var other = obj;
                return java.util.Objects.equals(this.ref, other.ref);
            };
            Optional.prototype.hashCode = function () {
                return java.util.Objects.hashCode(this.ref);
            };
            Optional.prototype.toString = function () {
                return this.isPresent() ? "Optional.of(" + new String(this.ref).toString() + ")" : "Optional.empty()";
            };
            return Optional;
        }());
        util.Optional = Optional;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * See <a href="https://docs.oracle.com/javase/8/docs/api/java/util/OptionalDouble.html">
         * the official Java API doc</a> for details.
         */
        var OptionalDouble = (function () {
            function OptionalDouble(value) {
                var _this = this;
                if (((typeof value === 'number') || value === null)) {
                    this.ref = 0;
                    this.present = false;
                    (function () {
                        _this.ref = value;
                        _this.present = true;
                    })();
                }
                else if (value === undefined) {
                    this.ref = 0;
                    this.present = false;
                    (function () {
                        _this.ref = 0;
                        _this.present = false;
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            OptionalDouble.empty = function () {
                return OptionalDouble.EMPTY_$LI$();
            };
            OptionalDouble.of = function (value) {
                return new OptionalDouble(value);
            };
            OptionalDouble.EMPTY_$LI$ = function () { if (OptionalDouble.EMPTY == null)
                OptionalDouble.EMPTY = new OptionalDouble(); return OptionalDouble.EMPTY; };
            ;
            OptionalDouble.prototype.isPresent = function () {
                return this.present;
            };
            OptionalDouble.prototype.getAsDouble = function () {
                javaemul.internal.InternalPreconditions.checkCriticalElement(this.present);
                return this.ref;
            };
            OptionalDouble.prototype.ifPresent = function (consumer) {
                if (this.present) {
                    consumer(this.ref);
                }
            };
            OptionalDouble.prototype.orElse = function (other) {
                return this.present ? this.ref : other;
            };
            OptionalDouble.prototype.orElseGet = function (other) {
                return this.present ? this.ref : other();
            };
            OptionalDouble.prototype.orElseThrow = function (exceptionSupplier) {
                if (this.present) {
                    return this.ref;
                }
                throw exceptionSupplier();
            };
            OptionalDouble.prototype.equals = function (obj) {
                if (obj === this) {
                    return true;
                }
                if (!(obj != null && obj instanceof java.util.OptionalDouble)) {
                    return false;
                }
                var other = obj;
                return this.present === other.present && javaemul.internal.DoubleHelper.compare(this.ref, other.ref) === 0;
            };
            OptionalDouble.prototype.hashCode = function () {
                return this.present ? javaemul.internal.DoubleHelper.hashCode(this.ref) : 0;
            };
            OptionalDouble.prototype.toString = function () {
                return this.present ? "OptionalDouble.of(" + ('' + this.ref) + ")" : "OptionalDouble.empty()";
            };
            return OptionalDouble;
        }());
        util.OptionalDouble = OptionalDouble;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * See <a href="https://docs.oracle.com/javase/8/docs/api/java/util/OptionalInt.html">
         * the official Java API doc</a> for details.
         */
        var OptionalInt = (function () {
            function OptionalInt(value) {
                var _this = this;
                if (((typeof value === 'number') || value === null)) {
                    this.ref = 0;
                    this.present = false;
                    (function () {
                        _this.ref = value;
                        _this.present = true;
                    })();
                }
                else if (value === undefined) {
                    this.ref = 0;
                    this.present = false;
                    (function () {
                        _this.ref = 0;
                        _this.present = false;
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            OptionalInt.empty = function () {
                return OptionalInt.EMPTY_$LI$();
            };
            OptionalInt.of = function (value) {
                return new OptionalInt(value);
            };
            OptionalInt.EMPTY_$LI$ = function () { if (OptionalInt.EMPTY == null)
                OptionalInt.EMPTY = new OptionalInt(); return OptionalInt.EMPTY; };
            ;
            OptionalInt.prototype.isPresent = function () {
                return this.present;
            };
            OptionalInt.prototype.getAsInt = function () {
                javaemul.internal.InternalPreconditions.checkCriticalElement(this.present);
                return this.ref;
            };
            OptionalInt.prototype.ifPresent = function (consumer) {
                if (this.present) {
                    consumer(this.ref);
                }
            };
            OptionalInt.prototype.orElse = function (other) {
                return this.present ? this.ref : other;
            };
            OptionalInt.prototype.orElseGet = function (other) {
                return this.present ? this.ref : other();
            };
            OptionalInt.prototype.orElseThrow = function (exceptionSupplier) {
                if (this.present) {
                    return this.ref;
                }
                throw exceptionSupplier();
            };
            OptionalInt.prototype.equals = function (obj) {
                if (obj === this) {
                    return true;
                }
                if (!(obj != null && obj instanceof java.util.OptionalInt)) {
                    return false;
                }
                var other = obj;
                return this.present === other.present && javaemul.internal.IntegerHelper.compare(this.ref, other.ref) === 0;
            };
            OptionalInt.prototype.hashCode = function () {
                return this.present ? javaemul.internal.IntegerHelper.hashCode(this.ref) : 0;
            };
            OptionalInt.prototype.toString = function () {
                return this.present ? "OptionalInt.of(" + ('' + this.ref) + ")" : "OptionalInt.empty()";
            };
            return OptionalInt;
        }());
        util.OptionalInt = OptionalInt;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * See <a href="https://docs.oracle.com/javase/8/docs/api/java/util/OptionalLong.html">
         * the official Java API doc</a> for details.
         */
        var OptionalLong = (function () {
            function OptionalLong(value) {
                var _this = this;
                if (((typeof value === 'number') || value === null)) {
                    this.ref = 0;
                    this.present = false;
                    (function () {
                        _this.ref = value;
                        _this.present = true;
                    })();
                }
                else if (value === undefined) {
                    this.ref = 0;
                    this.present = false;
                    (function () {
                        _this.ref = 0;
                        _this.present = false;
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            OptionalLong.empty = function () {
                return OptionalLong.EMPTY_$LI$();
            };
            OptionalLong.of = function (value) {
                return new OptionalLong(value);
            };
            OptionalLong.EMPTY_$LI$ = function () { if (OptionalLong.EMPTY == null)
                OptionalLong.EMPTY = new OptionalLong(); return OptionalLong.EMPTY; };
            ;
            OptionalLong.prototype.isPresent = function () {
                return this.present;
            };
            OptionalLong.prototype.getAsLong = function () {
                javaemul.internal.InternalPreconditions.checkCriticalElement(this.present);
                return this.ref;
            };
            OptionalLong.prototype.ifPresent = function (consumer) {
                if (this.present) {
                    consumer(this.ref);
                }
            };
            OptionalLong.prototype.orElse = function (other) {
                return this.present ? this.ref : other;
            };
            OptionalLong.prototype.orElseGet = function (other) {
                return this.present ? this.ref : other();
            };
            OptionalLong.prototype.orElseThrow = function (exceptionSupplier) {
                if (this.present) {
                    return this.ref;
                }
                throw exceptionSupplier();
            };
            OptionalLong.prototype.equals = function (obj) {
                if (obj === this) {
                    return true;
                }
                if (!(obj != null && obj instanceof java.util.OptionalLong)) {
                    return false;
                }
                var other = obj;
                return this.present === other.present && javaemul.internal.LongHelper.compare(this.ref, other.ref) === 0;
            };
            OptionalLong.prototype.hashCode = function () {
                return this.present ? javaemul.internal.LongHelper.hashCode(this.ref) : 0;
            };
            OptionalLong.prototype.toString = function () {
                return this.present ? "OptionalLong.of(" + ('' + this.ref) + ")" : "OptionalLong.empty()";
            };
            return OptionalLong;
        }());
        util.OptionalLong = OptionalLong;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * This class provides methods that generates pseudo-random numbers of different
         * types, such as {@code int}, {@code long}, {@code double}, and {@code float}.
         * It follows the algorithms specified in the JRE javadoc.
         *
         * This emulated version of Random is not serializable.
         */
        var Random = (function () {
            /**
             * Construct a random generator with the given {@code seed} as the initial
             * state.
             *
             * @param seed the seed that will determine the initial state of this random
             * number generator.
             * @see #setSeed
             */
            function Random(seed) {
                var _this = this;
                /**
                 * The boolean value indicating if the second Gaussian number is available.
                 */
                this.haveNextNextGaussian = false;
                if (((typeof seed === 'number') || seed === null)) {
                    this.nextNextGaussian = 0;
                    this.seedhi = 0;
                    this.seedlo = 0;
                    (function () {
                        _this.setSeed(seed);
                    })();
                }
                else if (seed === undefined) {
                    this.nextNextGaussian = 0;
                    this.seedhi = 0;
                    this.seedlo = 0;
                    (function () {
                        var seed = Random.uniqueSeed++ + javaemul.internal.DateUtil.now();
                        var hi = (Math.floor(seed * Random.twoToTheMinus24) | 0) & 16777215;
                        var lo = ((seed - (hi * Random.twoToThe24)) | 0);
                        _this.setSeed(hi, lo);
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            Random.__static_initialize = function () { if (!Random.__static_initialized) {
                Random.__static_initialized = true;
                Random.__static_initializer_0();
            } };
            Random.twoToTheXMinus24_$LI$ = function () { Random.__static_initialize(); if (Random.twoToTheXMinus24 == null)
                Random.twoToTheXMinus24 = new Array(25); return Random.twoToTheXMinus24; };
            ;
            Random.twoToTheXMinus48_$LI$ = function () { Random.__static_initialize(); if (Random.twoToTheXMinus48 == null)
                Random.twoToTheXMinus48 = new Array(33); return Random.twoToTheXMinus48; };
            ;
            Random.__static_initializer_0 = function () {
                var twoToTheXMinus48Tmp = 1.52587890625E-5;
                for (var i = 32; i >= 0; i--) {
                    Random.twoToTheXMinus48_$LI$()[i] = twoToTheXMinus48Tmp;
                    twoToTheXMinus48Tmp *= 0.5;
                }
                var twoToTheXMinus24Tmp = 1.0;
                for (var i = 24; i >= 0; i--) {
                    Random.twoToTheXMinus24_$LI$()[i] = twoToTheXMinus24Tmp;
                    twoToTheXMinus24Tmp *= 0.5;
                }
            };
            /**
             * Returns the next pseudo-random, uniformly distributed {@code boolean} value
             * generated by this generator.
             *
             * @return a pseudo-random, uniformly distributed boolean value.
             */
            Random.prototype.nextBoolean = function () {
                return this.nextInternal(1) !== 0;
            };
            /**
             * Modifies the {@code byte} array by a random sequence of {@code byte}s
             * generated by this random number generator.
             *
             * @param buf non-null array to contain the new random {@code byte}s.
             * @see #next
             */
            Random.prototype.nextBytes = function (buf) {
                javaemul.internal.InternalPreconditions.checkNotNull(buf);
                var rand = 0;
                var count = 0;
                var loop = 0;
                while ((count < buf.length)) {
                    if (loop === 0) {
                        rand = (this.nextInternal(32) | 0);
                        loop = 3;
                    }
                    else {
                        loop--;
                    }
                    buf[count++] = (rand | 0);
                    rand >>= 8;
                }
                ;
            };
            /**
             * Generates a normally distributed random {@code double} number between 0.0
             * inclusively and 1.0 exclusively.
             *
             * @return a random {@code double} in the range [0.0 - 1.0)
             * @see #nextFloat
             */
            Random.prototype.nextDouble = function () {
                return this.nextInternal(26) * Random.twoToTheMinus26 + this.nextInternal(27) * Random.twoToTheMinus53;
            };
            /**
             * Generates a normally distributed random {@code float} number between 0.0
             * inclusively and 1.0 exclusively.
             *
             * @return float a random {@code float} number between [0.0 and 1.0)
             * @see #nextDouble
             */
            Random.prototype.nextFloat = function () {
                return (this.nextInternal(24) * Random.twoToTheMinus24);
            };
            /**
             * Pseudo-randomly generates (approximately) a normally distributed {@code
             * double} value with mean 0.0 and a standard deviation value of {@code 1.0}
             * using the <i>polar method<i> of G. E. P. Box, M. E. Muller, and G.
             * Marsaglia, as described by Donald E. Knuth in <i>The Art of Computer
             * Programming, Volume 2: Seminumerical Algorithms</i>, section 3.4.1,
             * subsection C, algorithm P.
             *
             * @return a random {@code double}
             * @see #nextDouble
             */
            Random.prototype.nextGaussian = function () {
                if (this.haveNextNextGaussian) {
                    this.haveNextNextGaussian = false;
                    return this.nextNextGaussian;
                }
                var v1;
                var v2;
                var s;
                do {
                    v1 = 2 * this.nextDouble() - 1;
                    v2 = 2 * this.nextDouble() - 1;
                    s = v1 * v1 + v2 * v2;
                } while ((s >= 1));
                var norm = (s === 0) ? 0.0 : Math.sqrt(-2.0 * Math.log(s) / s);
                this.nextNextGaussian = v2 * norm;
                this.haveNextNextGaussian = true;
                return v1 * norm;
            };
            /**
             * Generates a uniformly distributed 32-bit {@code int} value from the random
             * number sequence.
             *
             * @return a uniformly distributed {@code int} value.
             * @see java.lang.Integer#MAX_VALUE
             * @see java.lang.Integer#MIN_VALUE
             * @see #next
             * @see #nextLong
             */
            Random.prototype.nextInt$ = function () {
                return (this.nextInternal(32) | 0);
            };
            /**
             * Returns a new pseudo-random {@code int} value which is uniformly
             * distributed between 0 (inclusively) and the value of {@code n}
             * (exclusively).
             *
             * @param n the exclusive upper border of the range [0 - n).
             * @return a random {@code int}.
             */
            Random.prototype.nextInt = function (n) {
                var _this = this;
                if (((typeof n === 'number') || n === null)) {
                    return (function () {
                        javaemul.internal.InternalPreconditions.checkCriticalArgument(n > 0);
                        if ((n & -n) === n) {
                            return (((n * _this.nextInternal(31)) * Random.twoToTheMinus31) | 0);
                        }
                        var bits;
                        var val;
                        do {
                            bits = _this.nextInternal(31);
                            val = bits % n;
                        } while ((bits - val + (n - 1) < 0));
                        return (val | 0);
                    })();
                }
                else if (n === undefined) {
                    return this.nextInt$();
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Generates a uniformly distributed 64-bit integer value from the random
             * number sequence.
             *
             * @return 64-bit random integer.
             * @see java.lang.Integer#MAX_VALUE
             * @see java.lang.Integer#MIN_VALUE
             * @see #next
             * @see #nextInt()
             * @see #nextInt(int)
             */
            Random.prototype.nextLong = function () {
                return (Math.round(this.nextInternal(32)) << 32) + Math.round(this.nextInternal(32));
            };
            /**
             * Modifies the seed a using linear congruential formula presented in <i>The
             * Art of Computer Programming, Volume 2</i>, Section 3.2.1.
             *
             * @param seed the seed that alters the state of the random number generator.
             * @see #next
             * @see #Random()
             * @see #Random(long)
             */
            Random.prototype.setSeed$long = function (seed) {
                this.setSeed((((seed >> 24) & 16777215) | 0), ((seed & 16777215) | 0));
            };
            /**
             * Returns a pseudo-random uniformly distributed {@code int} value of the
             * number of bits specified by the argument {@code bits} as described by
             * Donald E. Knuth in <i>The Art of Computer Programming, Volume 2:
             * Seminumerical Algorithms</i>, section 3.2.1.
             *
             * @param bits number of bits of the returned value.
             * @return a pseudo-random generated int number.
             * @see #nextBytes
             * @see #nextDouble
             * @see #nextFloat
             * @see #nextInt()
             * @see #nextInt(int)
             * @see #nextGaussian
             * @see #nextLong
             */
            Random.prototype.next = function (bits) {
                return (this.nextInternal(bits) | 0);
            };
            Random.prototype.nextInternal = function (bits) {
                var hi = this.seedhi * Random.multiplierLo + this.seedlo * Random.multiplierHi;
                var lo = this.seedlo * Random.multiplierLo + 11;
                var carry = Math.floor(lo * Random.twoToTheMinus24);
                hi += carry;
                lo -= carry * Random.twoToThe24;
                hi %= Random.twoToThe24;
                this.seedhi = hi;
                this.seedlo = lo;
                if (bits <= 24) {
                    return Math.floor(this.seedhi * Random.twoToTheXMinus24_$LI$()[bits]);
                }
                else {
                    var h = this.seedhi * (1 << (bits - 24));
                    var l = Math.floor(this.seedlo * Random.twoToTheXMinus48_$LI$()[bits]);
                    var dval = h + l;
                    if (dval >= Random.twoToThe31) {
                        dval -= Random.twoToThe32;
                    }
                    return dval;
                }
            };
            Random.prototype.setSeed = function (seedhi, seedlo) {
                var _this = this;
                if (((typeof seedhi === 'number') || seedhi === null) && ((typeof seedlo === 'number') || seedlo === null)) {
                    return (function () {
                        _this.seedhi = seedhi ^ 1502;
                        _this.seedlo = seedlo ^ 15525485;
                        _this.haveNextNextGaussian = false;
                    })();
                }
                else if (((typeof seedhi === 'number') || seedhi === null) && seedlo === undefined) {
                    return this.setSeed$long(seedhi);
                }
                else
                    throw new Error('invalid overload');
            };
            Random.__static_initialized = false;
            Random.multiplierHi = 1502;
            Random.multiplierLo = 15525485;
            Random.twoToThe24 = 1.6777216E7;
            Random.twoToThe31 = 2.147483648E9;
            Random.twoToThe32 = 4.294967296E9;
            Random.twoToTheMinus24 = 5.9604644775390625E-8;
            Random.twoToTheMinus26 = 1.4901161193847656E-8;
            Random.twoToTheMinus31 = 4.6566128730773926E-10;
            Random.twoToTheMinus53 = 1.1102230246251565E-16;
            /**
             * A value used to avoid two random number generators produced at the same
             * time having the same seed.
             */
            Random.uniqueSeed = 0;
            return Random;
        }());
        util.Random = Random;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * See <a href="https://docs.oracle.com/javase/8/docs/api/java/util/StringJoiner.html">
         * the official Java API doc</a> for details.
         */
        var StringJoiner = (function () {
            function StringJoiner(delimiter, prefix, suffix) {
                if (prefix === void 0) { prefix = ""; }
                if (suffix === void 0) { suffix = ""; }
                javaemul.internal.InternalPreconditions.checkNotNull(delimiter, "delimiter");
                javaemul.internal.InternalPreconditions.checkNotNull(prefix, "prefix");
                javaemul.internal.InternalPreconditions.checkNotNull(suffix, "suffix");
                this.delimiter = delimiter.toString();
                this.prefix = prefix.toString();
                this.suffix = suffix.toString();
                this.emptyValue = this.prefix + this.suffix;
            }
            StringJoiner.prototype.add = function (newElement) {
                this.initBuilderOrAddDelimiter();
                this.builder.append(newElement);
                return this;
            };
            StringJoiner.prototype.length = function () {
                if (this.builder == null) {
                    return this.emptyValue.length;
                }
                return this.builder.length() + this.suffix.length;
            };
            StringJoiner.prototype.merge = function (other) {
                if (other.builder != null) {
                    var otherLength = other.builder.length();
                    this.initBuilderOrAddDelimiter();
                    this.builder.append(other.builder, other.prefix.length, otherLength);
                }
                return this;
            };
            StringJoiner.prototype.setEmptyValue = function (emptyValue) {
                javaemul.internal.InternalPreconditions.checkNotNull(emptyValue);
                this.emptyValue = emptyValue.toString();
                return this;
            };
            StringJoiner.prototype.toString = function () {
                if (this.builder == null) {
                    return this.emptyValue;
                }
                else if ((this.suffix.length === 0)) {
                    return this.builder.toString();
                }
                else {
                    return this.builder.toString() + this.suffix;
                }
            };
            StringJoiner.prototype.initBuilderOrAddDelimiter = function () {
                if (this.builder == null) {
                    this.builder = new java.lang.StringBuilder(this.prefix);
                }
                else {
                    this.builder.append(this.delimiter);
                }
            };
            return StringJoiner;
        }());
        util.StringJoiner = StringJoiner;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var javaemul;
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Provides utilities to perform operations on Arrays.
         */
        var ArrayHelper = (function () {
            function ArrayHelper() {
            }
            ArrayHelper.clone = function (array, fromIndex, toIndex) {
                var result = ArrayHelper.unsafeClone(array, fromIndex, toIndex);
                return javaemul.internal.ArrayStamper.stampJavaTypeInfo(result, array);
            };
            /**
             * Unlike clone, this method returns a copy of the array that is not type
             * marked. This is only safe for temp arrays as returned array will not do
             * any type checks.
             */
            ArrayHelper.unsafeClone = function (array, fromIndex, toIndex) {
                return array.slice(fromIndex, toIndex);
            };
            ArrayHelper.createFrom = function (array, length) {
                var result = ArrayHelper.createNativeArray(length);
                return javaemul.internal.ArrayStamper.stampJavaTypeInfo(result, array);
            };
            ArrayHelper.createNativeArray = function (length) {
                return new Array(length);
            };
            ArrayHelper.getLength = function (array) {
                return (array.length | 0);
            };
            ArrayHelper.setLength = function (array, length) {
                array.length = length;
            };
            ArrayHelper.removeFrom = function (array, index, deleteCount) {
                array.splice(index, deleteCount);
            };
            ArrayHelper.insertTo$java_lang_Object$int$java_lang_Object = function (array, index, value) {
                array.splice(index, 0, value);
            };
            ArrayHelper.insertTo = function (array, index, values) {
                if (((array != null) || array === null) && ((typeof index === 'number') || index === null) && ((values != null && values instanceof Array) || values === null)) {
                    return (function () {
                        ArrayHelper.copy(values, 0, array, index, values.length, false);
                    })();
                }
                else if (((array != null) || array === null) && ((typeof index === 'number') || index === null) && ((values != null) || values === null)) {
                    return javaemul.internal.ArrayHelper.insertTo$java_lang_Object$int$java_lang_Object(array, index, values);
                }
                else
                    throw new Error('invalid overload');
            };
            ArrayHelper.copy = function (src, srcOfs, dest, destOfs, len, overwrite) {
                if (overwrite === void 0) { overwrite = true; }
                if (src === dest) {
                    src = ArrayHelper.unsafeClone(src, srcOfs, srcOfs + len);
                    srcOfs = 0;
                }
                for (var batchStart = srcOfs, end = srcOfs + len; batchStart < end;) {
                    var batchEnd = Math.min(batchStart + ArrayHelper.ARRAY_PROCESS_BATCH_SIZE, end);
                    len = batchEnd - batchStart;
                    batchStart = batchEnd;
                    destOfs += len;
                }
            };
            ArrayHelper.ARRAY_PROCESS_BATCH_SIZE = 10000;
            return ArrayHelper;
        }());
        internal.ArrayHelper = ArrayHelper;
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var javaemul;
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * A utility to provide array stamping. Provided as a separate class to simplify
         * super-source.
         */
        var ArrayStamper = (function () {
            function ArrayStamper() {
            }
            ArrayStamper.stampJavaTypeInfo = function (array, referenceType) {
                return array;
            };
            return ArrayStamper;
        }());
        internal.ArrayStamper = ArrayStamper;
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var javaemul;
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Wraps native <code>boolean</code> as an object.
         */
        var BooleanHelper = (function () {
            function BooleanHelper() {
                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Comparable", "java.io.Serializable"] });
            }
            BooleanHelper.TYPE_$LI$ = function () { if (BooleanHelper.TYPE == null)
                BooleanHelper.TYPE = Boolean; return BooleanHelper.TYPE; };
            ;
            BooleanHelper.compare = function (x, y) {
                return (x === y) ? 0 : (x ? 1 : -1);
            };
            BooleanHelper.hashCode = function (value) {
                return value ? 1231 : 1237;
            };
            BooleanHelper.logicalAnd = function (a, b) {
                return a && b;
            };
            BooleanHelper.logicalOr = function (a, b) {
                return a || b;
            };
            BooleanHelper.logicalXor = function (a, b) {
                return a !== b;
            };
            BooleanHelper.parseBoolean = function (s) {
                return (function (o1, o2) { return o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()); })("true", s);
            };
            BooleanHelper.toString = function (x) {
                return new String(x).toString();
            };
            BooleanHelper.valueOf$boolean = function (b) {
                return b ? BooleanHelper.TRUE : BooleanHelper.FALSE;
            };
            BooleanHelper.valueOf = function (s) {
                if (((typeof s === 'string') || s === null)) {
                    return (function () {
                        return BooleanHelper.valueOf(BooleanHelper.parseBoolean(s));
                    })();
                }
                else if (((typeof s === 'boolean') || s === null)) {
                    return javaemul.internal.BooleanHelper.valueOf$boolean(s);
                }
                else
                    throw new Error('invalid overload');
            };
            BooleanHelper.prototype.booleanValue = function () {
                return BooleanHelper.unsafeCast(javaemul.internal.InternalPreconditions.checkNotNull(this));
            };
            BooleanHelper.unsafeCast = function (value) {
                return value;
            };
            BooleanHelper.prototype.compareTo = function (b) {
                var _this = this;
                if (((b != null && b instanceof javaemul.internal.BooleanHelper) || b === null)) {
                    return (function () {
                        return BooleanHelper.compare(_this.booleanValue(), b.booleanValue());
                    })();
                }
                else
                    throw new Error('invalid overload');
            };
            BooleanHelper.prototype.equals = function (o) {
                return javaemul.internal.InternalPreconditions.checkNotNull(this) === o;
            };
            BooleanHelper.prototype.hashCode = function () {
                return BooleanHelper.hashCode(this.booleanValue());
            };
            BooleanHelper.prototype.toString = function () {
                return BooleanHelper.toString(this.booleanValue());
            };
            BooleanHelper.FALSE = false;
            BooleanHelper.TRUE = true;
            return BooleanHelper;
        }());
        internal.BooleanHelper = BooleanHelper;
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var javaemul;
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Wraps a native <code>char</code> as an object.
         *
         * TODO(jat): many of the classification methods implemented here are not
         * correct in that they only handle ASCII characters, and many other methods are
         * not currently implemented. I think the proper approach is to introduce * a
         * deferred binding parameter which substitutes an implementation using a
         * fully-correct Unicode character database, at the expense of additional data
         * being downloaded. That way developers that need the functionality can get it
         * without those who don't need it paying for it.
         *
         * <pre>
         * The following methods are still not implemented -- most would require Unicode
         * character db to be useful:
         * - digit / is* / to*(int codePoint)
         * - isDefined(char)
         * - isIdentifierIgnorable(char)
         * - isJavaIdentifierPart(char)
         * - isJavaIdentifierStart(char)
         * - isJavaLetter(char) -- deprecated, so probably not
         * - isJavaLetterOrDigit(char) -- deprecated, so probably not
         * - isISOControl(char)
         * - isMirrored(char)
         * - isSpaceChar(char)
         * - isTitleCase(char)
         * - isUnicodeIdentifierPart(char)
         * - isUnicodeIdentifierStart(char)
         * - getDirectionality(*)
         * - getNumericValue(*)
         * - getType(*)
         * - reverseBytes(char) -- any use for this at all in the browser?
         * - toTitleCase(*)
         * - all the category constants for classification
         *
         * The following do not properly handle characters outside of ASCII:
         * - digit(char c, int radix)
         * - isDigit(char c)
         * - isLetter(char c)
         * - isLetterOrDigit(char c)
         * - isLowerCase(char c)
         * - isUpperCase(char c)
         * </pre>
         */
        var CharacterHelper = (function () {
            function CharacterHelper(value) {
                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Comparable", "java.io.Serializable"] });
                this.value = null;
                this.value = value;
            }
            CharacterHelper.TYPE_$LI$ = function () { if (CharacterHelper.TYPE == null)
                CharacterHelper.TYPE = String; return CharacterHelper.TYPE; };
            ;
            CharacterHelper.charCount = function (codePoint) {
                return codePoint >= CharacterHelper.MIN_SUPPLEMENTARY_CODE_POINT ? 2 : 1;
            };
            CharacterHelper.codePointAt$char_A$int = function (a, index) {
                return CharacterHelper.codePointAt(new String(a), index, a.length);
            };
            CharacterHelper.codePointAt = function (a, index, limit) {
                if (((a != null && a instanceof Array) || a === null) && ((typeof index === 'number') || index === null) && ((typeof limit === 'number') || limit === null)) {
                    return (function () {
                        return CharacterHelper.codePointAt(new String(a), index, limit);
                    })();
                }
                else if (((a != null && (a["__interfaces"] != null && a["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof a === "string")) || a === null) && ((typeof index === 'number') || index === null) && ((typeof limit === 'number') || limit === null)) {
                    return javaemul.internal.CharacterHelper.codePointAt$java_lang_CharSequence$int$int(a, index, limit);
                }
                else if (((a != null && a instanceof Array) || a === null) && ((typeof index === 'number') || index === null) && limit === undefined) {
                    return javaemul.internal.CharacterHelper.codePointAt$char_A$int(a, index);
                }
                else if (((a != null && (a["__interfaces"] != null && a["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof a === "string")) || a === null) && ((typeof index === 'number') || index === null) && limit === undefined) {
                    return javaemul.internal.CharacterHelper.codePointAt$java_lang_CharSequence$int(a, index);
                }
                else
                    throw new Error('invalid overload');
            };
            CharacterHelper.codePointAt$java_lang_CharSequence$int = function (seq, index) {
                return CharacterHelper.codePointAt(seq, index, seq.length);
            };
            CharacterHelper.codePointBefore$char_A$int = function (a, index) {
                return CharacterHelper.codePointBefore(new String(a), index, 0);
            };
            CharacterHelper.codePointBefore = function (a, index, start) {
                if (((a != null && a instanceof Array) || a === null) && ((typeof index === 'number') || index === null) && ((typeof start === 'number') || start === null)) {
                    return (function () {
                        return CharacterHelper.codePointBefore(new String(a), index, start);
                    })();
                }
                else if (((a != null && (a["__interfaces"] != null && a["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof a === "string")) || a === null) && ((typeof index === 'number') || index === null) && ((typeof start === 'number') || start === null)) {
                    return javaemul.internal.CharacterHelper.codePointBefore$java_lang_CharSequence$int$int(a, index, start);
                }
                else if (((a != null && a instanceof Array) || a === null) && ((typeof index === 'number') || index === null) && start === undefined) {
                    return javaemul.internal.CharacterHelper.codePointBefore$char_A$int(a, index);
                }
                else if (((a != null && (a["__interfaces"] != null && a["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof a === "string")) || a === null) && ((typeof index === 'number') || index === null) && start === undefined) {
                    return javaemul.internal.CharacterHelper.codePointBefore$java_lang_CharSequence$int(a, index);
                }
                else
                    throw new Error('invalid overload');
            };
            CharacterHelper.codePointBefore$java_lang_CharSequence$int = function (cs, index) {
                return CharacterHelper.codePointBefore(cs, index, 0);
            };
            CharacterHelper.codePointCount = function (a, offset, count) {
                if (((a != null && a instanceof Array) || a === null) && ((typeof offset === 'number') || offset === null) && ((typeof count === 'number') || count === null)) {
                    return (function () {
                        return CharacterHelper.codePointCount(new String(a), offset, offset + count);
                    })();
                }
                else if (((a != null && (a["__interfaces"] != null && a["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof a === "string")) || a === null) && ((typeof offset === 'number') || offset === null) && ((typeof count === 'number') || count === null)) {
                    return javaemul.internal.CharacterHelper.codePointCount$java_lang_CharSequence$int$int(a, offset, count);
                }
                else
                    throw new Error('invalid overload');
            };
            CharacterHelper.codePointCount$java_lang_CharSequence$int$int = function (seq, beginIndex, endIndex) {
                var count = 0;
                for (var idx = beginIndex; idx < endIndex;) {
                    var ch = seq.charAt(idx++);
                    if (CharacterHelper.isHighSurrogate(ch) && idx < endIndex && (CharacterHelper.isLowSurrogate(seq.charAt(idx)))) {
                        ++idx;
                    }
                    ++count;
                }
                return count;
            };
            CharacterHelper.compare = function (x, y) {
                return (x).charCodeAt(0) - (y).charCodeAt(0);
            };
            CharacterHelper.digit = function (c, radix) {
                if (radix < CharacterHelper.MIN_RADIX || radix > CharacterHelper.MAX_RADIX) {
                    return -1;
                }
                if ((c).charCodeAt(0) >= ('0').charCodeAt(0) && (c).charCodeAt(0) < ('0').charCodeAt(0) + Math.min(radix, 10)) {
                    return (c).charCodeAt(0) - ('0').charCodeAt(0);
                }
                if ((c).charCodeAt(0) >= ('a').charCodeAt(0) && (c).charCodeAt(0) < (radix + ('a').charCodeAt(0) - 10)) {
                    return (c).charCodeAt(0) - ('a').charCodeAt(0) + 10;
                }
                if ((c).charCodeAt(0) >= ('A').charCodeAt(0) && (c).charCodeAt(0) < (radix + ('A').charCodeAt(0) - 10)) {
                    return (c).charCodeAt(0) - ('A').charCodeAt(0) + 10;
                }
                return -1;
            };
            CharacterHelper.getNumericValue = function (ch) {
                return (ch.charCodeAt(0) | 0);
            };
            CharacterHelper.forDigit = function (digit, radix) {
                if (((typeof digit === 'number') || digit === null) && ((typeof radix === 'number') || radix === null)) {
                    return (function () {
                        if (radix < CharacterHelper.MIN_RADIX || radix > CharacterHelper.MAX_RADIX) {
                            return 0;
                        }
                        if (digit < 0 || digit >= radix) {
                            return 0;
                        }
                        return CharacterHelper.forDigit(digit);
                    })();
                }
                else if (((typeof digit === 'number') || digit === null) && radix === undefined) {
                    return javaemul.internal.CharacterHelper.forDigit$int(digit);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * @skip
             *
             * public for shared implementation with Arrays.hashCode
             */
            CharacterHelper.hashCode = function (c) {
                return (c).charCodeAt(0);
            };
            CharacterHelper.isDigit = function (c) {
                var result = (new String(c).toString()).match(CharacterHelper.digitRegex());
                return result != null && result.length > 0;
            };
            CharacterHelper.digitRegex = function () {
                return new RegExp("\\d");
            };
            CharacterHelper.isHighSurrogate = function (ch) {
                return (ch).charCodeAt(0) >= (CharacterHelper.MIN_HIGH_SURROGATE).charCodeAt(0) && (ch).charCodeAt(0) <= (CharacterHelper.MAX_HIGH_SURROGATE).charCodeAt(0);
            };
            CharacterHelper.isLetter = function (c) {
                return (new String(c).toString()).match(CharacterHelper.leterRegex()).length > 0;
            };
            CharacterHelper.leterRegex = function () {
                return new RegExp("[A-Z]", "i");
            };
            CharacterHelper.isLetterOrDigit = function (c) {
                return (new String(c).toString()).match(CharacterHelper.leterOrDigitRegex()).length > 0;
            };
            CharacterHelper.leterOrDigitRegex = function () {
                return new RegExp("[A-Z\\d]", "i");
            };
            CharacterHelper.isLowerCase = function (c) {
                return CharacterHelper.toLowerCase(c) === c && CharacterHelper.isLetter(c);
            };
            CharacterHelper.isLowSurrogate = function (ch) {
                return (ch).charCodeAt(0) >= (CharacterHelper.MIN_LOW_SURROGATE).charCodeAt(0) && (ch).charCodeAt(0) <= (CharacterHelper.MAX_LOW_SURROGATE).charCodeAt(0);
            };
            /**
             * Deprecated - see isWhitespace(char).
             */
            CharacterHelper.isSpace = function (c) {
                switch ((c)) {
                    case ' ':
                        return true;
                    case '\n':
                        return true;
                    case '\t':
                        return true;
                    case '\f':
                        return true;
                    case '\r':
                        return true;
                    default:
                        return false;
                }
            };
            CharacterHelper.isWhitespace = function (ch) {
                if (((typeof ch === 'string') || ch === null)) {
                    return (function () {
                        return (new String(ch).toString()).match(CharacterHelper.whitespaceRegex()).length > 0;
                    })();
                }
                else if (((typeof ch === 'number') || ch === null)) {
                    return javaemul.internal.CharacterHelper.isWhitespace$int(ch);
                }
                else
                    throw new Error('invalid overload');
            };
            CharacterHelper.isWhitespace$int = function (codePoint) {
                return (String.fromCharCode(codePoint)).match(CharacterHelper.whitespaceRegex()).length > 0;
            };
            CharacterHelper.whitespaceRegex = function () {
                return new RegExp("[\\t-\\r \\u1680\\u180E\\u2000-\\u2006\\u2008-\\u200A\\u2028\\u2029\\u205F\\u3000\\uFEFF]|[\\x1C-\\x1F]");
            };
            CharacterHelper.isSupplementaryCodePoint = function (codePoint) {
                return codePoint >= CharacterHelper.MIN_SUPPLEMENTARY_CODE_POINT && codePoint <= CharacterHelper.MAX_CODE_POINT;
            };
            CharacterHelper.isSurrogatePair = function (highSurrogate, lowSurrogate) {
                return CharacterHelper.isHighSurrogate(highSurrogate) && CharacterHelper.isLowSurrogate(lowSurrogate);
            };
            CharacterHelper.isUpperCase = function (c) {
                return CharacterHelper.toUpperCase(c) === c && CharacterHelper.isLetter(c);
            };
            CharacterHelper.isValidCodePoint = function (codePoint) {
                return codePoint >= CharacterHelper.MIN_CODE_POINT && codePoint <= CharacterHelper.MAX_CODE_POINT;
            };
            CharacterHelper.offsetByCodePoints = function (a, start, count, index, codePointOffset) {
                if (((a != null && a instanceof Array) || a === null) && ((typeof start === 'number') || start === null) && ((typeof count === 'number') || count === null) && ((typeof index === 'number') || index === null) && ((typeof codePointOffset === 'number') || codePointOffset === null)) {
                    return (function () {
                        return CharacterHelper.offsetByCodePoints((function (str, index, len) { return str.substring(index, index + len); })((a).join(''), start, count), index, codePointOffset);
                    })();
                }
                else if (((a != null && (a["__interfaces"] != null && a["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof a === "string")) || a === null) && ((typeof start === 'number') || start === null) && ((typeof count === 'number') || count === null) && index === undefined && codePointOffset === undefined) {
                    return javaemul.internal.CharacterHelper.offsetByCodePoints$java_lang_CharSequence$int$int(a, start, count);
                }
                else
                    throw new Error('invalid overload');
            };
            CharacterHelper.offsetByCodePoints$java_lang_CharSequence$int$int = function (seq, index, codePointOffset) {
                if (codePointOffset < 0) {
                    while ((codePointOffset < 0)) {
                        --index;
                        if (CharacterHelper.isLowSurrogate(seq.charAt(index)) && CharacterHelper.isHighSurrogate(seq.charAt(index - 1))) {
                            --index;
                        }
                        ++codePointOffset;
                    }
                    ;
                }
                else {
                    while ((codePointOffset > 0)) {
                        if (CharacterHelper.isHighSurrogate(seq.charAt(index)) && CharacterHelper.isLowSurrogate(seq.charAt(index + 1))) {
                            ++index;
                        }
                        ++index;
                        --codePointOffset;
                    }
                    ;
                }
                return index;
            };
            CharacterHelper.toChars$int = function (codePoint) {
                javaemul.internal.InternalPreconditions.checkCriticalArgument(codePoint >= 0 && codePoint <= CharacterHelper.MAX_CODE_POINT);
                if (codePoint >= CharacterHelper.MIN_SUPPLEMENTARY_CODE_POINT) {
                    return [CharacterHelper.getHighSurrogate(codePoint), CharacterHelper.getLowSurrogate(codePoint)];
                }
                else {
                    return [String.fromCharCode(codePoint)];
                }
            };
            CharacterHelper.toChars = function (codePoint, dst, dstIndex) {
                if (((typeof codePoint === 'number') || codePoint === null) && ((dst != null && dst instanceof Array) || dst === null) && ((typeof dstIndex === 'number') || dstIndex === null)) {
                    return (function () {
                        javaemul.internal.InternalPreconditions.checkCriticalArgument(codePoint >= 0 && codePoint <= CharacterHelper.MAX_CODE_POINT);
                        if (codePoint >= CharacterHelper.MIN_SUPPLEMENTARY_CODE_POINT) {
                            dst[dstIndex++] = CharacterHelper.getHighSurrogate(codePoint);
                            dst[dstIndex] = CharacterHelper.getLowSurrogate(codePoint);
                            return 2;
                        }
                        else {
                            dst[dstIndex] = String.fromCharCode(codePoint);
                            return 1;
                        }
                    })();
                }
                else if (((typeof codePoint === 'number') || codePoint === null) && dst === undefined && dstIndex === undefined) {
                    return javaemul.internal.CharacterHelper.toChars$int(codePoint);
                }
                else
                    throw new Error('invalid overload');
            };
            CharacterHelper.toCodePoint = function (highSurrogate, lowSurrogate) {
                return CharacterHelper.MIN_SUPPLEMENTARY_CODE_POINT + (((highSurrogate).charCodeAt(0) & 1023) << 10) + ((lowSurrogate).charCodeAt(0) & 1023);
            };
            CharacterHelper.toLowerCase = function (c) {
                return new String(c).toString().toLowerCase().charAt(0);
            };
            CharacterHelper.toString = function (x) {
                return new String(x).toString();
            };
            CharacterHelper.toUpperCase = function (c) {
                return new String(c).toString().toUpperCase().charAt(0);
            };
            CharacterHelper.valueOf = function (c) {
                if ((c).charCodeAt(0) < 128) {
                    var result = CharacterHelper.BoxedValues.boxedValues_$LI$()[c];
                    if (result == null) {
                        result = CharacterHelper.BoxedValues.boxedValues_$LI$()[c] = new CharacterHelper(c);
                    }
                    return result;
                }
                return new CharacterHelper(c);
            };
            CharacterHelper.codePointAt$java_lang_CharSequence$int$int = function (cs, index, limit) {
                var hiSurrogate = cs.charAt(index++);
                var loSurrogate;
                if (CharacterHelper.isHighSurrogate(hiSurrogate) && index < limit && CharacterHelper.isLowSurrogate(loSurrogate = cs.charAt(index))) {
                    return CharacterHelper.toCodePoint(hiSurrogate, loSurrogate);
                }
                return (hiSurrogate).charCodeAt(0);
            };
            CharacterHelper.codePointBefore$java_lang_CharSequence$int$int = function (cs, index, start) {
                var loSurrogate = cs.charAt(--index);
                var highSurrogate;
                if (CharacterHelper.isLowSurrogate(loSurrogate) && index > start && CharacterHelper.isHighSurrogate(highSurrogate = cs.charAt(index - 1))) {
                    return CharacterHelper.toCodePoint(highSurrogate, loSurrogate);
                }
                return (loSurrogate).charCodeAt(0);
            };
            /**
             * Shared implementation with {@link LongHelper#toString}.
             *
             * @skip
             */
            CharacterHelper.forDigit$int = function (digit) {
                var overBaseTen = digit - 10;
                return String.fromCharCode((overBaseTen < 0 ? ('0').charCodeAt(0) + digit : ('a').charCodeAt(0) + overBaseTen));
            };
            /**
             * Computes the high surrogate character of the UTF16 representation of a
             * non-BMP code point. See {@link getLowSurrogate}.
             *
             * @param codePoint
             * requested codePoint, required to be >=
             * MIN_SUPPLEMENTARY_CODE_POINT
             * @return high surrogate character
             */
            CharacterHelper.getHighSurrogate = function (codePoint) {
                return String.fromCharCode(((CharacterHelper.MIN_HIGH_SURROGATE).charCodeAt(0) + (((codePoint - CharacterHelper.MIN_SUPPLEMENTARY_CODE_POINT) >> 10) & 1023)));
            };
            /**
             * Computes the low surrogate character of the UTF16 representation of a
             * non-BMP code point. See {@link getHighSurrogate}.
             *
             * @param codePoint
             * requested codePoint, required to be >=
             * MIN_SUPPLEMENTARY_CODE_POINT
             * @return low surrogate character
             */
            CharacterHelper.getLowSurrogate = function (codePoint) {
                return String.fromCharCode(((CharacterHelper.MIN_LOW_SURROGATE).charCodeAt(0) + ((codePoint - CharacterHelper.MIN_SUPPLEMENTARY_CODE_POINT) & 1023)));
            };
            CharacterHelper.prototype.charValue = function () {
                return this.value;
            };
            CharacterHelper.prototype.compareTo = function (c) {
                var _this = this;
                if (((c != null && c instanceof javaemul.internal.CharacterHelper) || c === null)) {
                    return (function () {
                        return CharacterHelper.compare(_this.value, c.value);
                    })();
                }
                else
                    throw new Error('invalid overload');
            };
            CharacterHelper.prototype.equals = function (o) {
                return (o != null && o instanceof javaemul.internal.CharacterHelper) && (o.value === this.value);
            };
            CharacterHelper.prototype.hashCode = function () {
                return CharacterHelper.hashCode(this.value);
            };
            CharacterHelper.prototype.toString = function () {
                return new String(this.value).toString();
            };
            CharacterHelper.MIN_RADIX = 2;
            CharacterHelper.MAX_RADIX = 36;
            CharacterHelper.MIN_VALUE = '\u0000';
            CharacterHelper.MAX_VALUE = '\uffff';
            CharacterHelper.MIN_SURROGATE = '\ud800';
            CharacterHelper.MAX_SURROGATE = '\udfff';
            CharacterHelper.MIN_LOW_SURROGATE = '\udc00';
            CharacterHelper.MAX_LOW_SURROGATE = '\udfff';
            CharacterHelper.MIN_HIGH_SURROGATE = '\ud800';
            CharacterHelper.MAX_HIGH_SURROGATE = '\udbff';
            CharacterHelper.MIN_SUPPLEMENTARY_CODE_POINT = 65536;
            CharacterHelper.MIN_CODE_POINT = 0;
            CharacterHelper.MAX_CODE_POINT = 1114111;
            CharacterHelper.SIZE = 16;
            return CharacterHelper;
        }());
        internal.CharacterHelper = CharacterHelper;
        var CharacterHelper;
        (function (CharacterHelper) {
            /**
             * Use nested class to avoid clinit on outer.
             */
            var BoxedValues = (function () {
                function BoxedValues() {
                }
                BoxedValues.boxedValues_$LI$ = function () { if (BoxedValues.boxedValues == null)
                    BoxedValues.boxedValues = new Array(128); return BoxedValues.boxedValues; };
                ;
                return BoxedValues;
            }());
            CharacterHelper.BoxedValues = BoxedValues;
        })(CharacterHelper = internal.CharacterHelper || (internal.CharacterHelper = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var javaemul;
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Private implementation class for GWT. This API should not be
         * considered public or stable.
         */
        var Coercions = (function () {
            function Coercions() {
            }
            /**
             * Coerce js int to 32 bits.
             * Trick related to JS and lack of integer rollover.
             * {@see com.google.gwt.lang.Cast#narrow_int}
             */
            Coercions.ensureInt = function (value) {
                return value | 0;
            };
            return Coercions;
        }());
        internal.Coercions = Coercions;
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var javaemul;
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Simple Helper class to return Date.now.
         */
        var DateUtil = (function () {
            function DateUtil() {
            }
            /**
             * Returns the numeric value corresponding to the current time -
             * the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC.
             */
            DateUtil.now = function () {
                // IE8 does not have Date.now
                // when removing IE8 support we change this to Date.now()
                if (Date.now) {
                    // Date.now vs Date.getTime() performance comparison:
                    // http://jsperf.com/date-now-vs-new-date/8
                    return Date.now();
                }
                return (new Date()).getTime();
            };
            return DateUtil;
        }());
        internal.DateUtil = DateUtil;
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var javaemul;
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Contains logics for calculating hash codes in JavaScript.
         */
        var HashCodes = (function () {
            function HashCodes() {
            }
            HashCodes.hashCodeForString = function (s) {
                return javaemul.internal.StringHashCache.getHashCode(s);
            };
            HashCodes.getIdentityHashCode = function (o) {
                if (o == null) {
                    return 0;
                }
                return (typeof o === 'string') ? HashCodes.hashCodeForString(javaemul.internal.JsUtils.unsafeCastToString(o)) : HashCodes.getObjectIdentityHashCode(o);
            };
            HashCodes.getObjectIdentityHashCode = function (o) {
                if (o[HashCodes.HASH_CODE_PROPERTY] != null) {
                    return o[HashCodes.HASH_CODE_PROPERTY];
                }
                else {
                    return o[HashCodes.HASH_CODE_PROPERTY] = HashCodes.getNextHashId();
                }
            };
            /**
             * Called from JSNI. Do not change this implementation without updating:
             * <ul>
             * <li>{@link com.google.gwt.user.client.rpc.impl.SerializerBase}</li>
             * </ul>
             */
            HashCodes.getNextHashId = function () {
                return ++HashCodes.sNextHashId;
            };
            HashCodes.sNextHashId = 0;
            HashCodes.HASH_CODE_PROPERTY = "$H";
            return HashCodes;
        }());
        internal.HashCodes = HashCodes;
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var javaemul;
(function (javaemul) {
    var internal;
    (function (internal) {
        var JreHelper = (function () {
            function JreHelper() {
            }
            JreHelper.LOG10E_$LI$ = function () { if (JreHelper.LOG10E == null)
                JreHelper.LOG10E = Math.LOG10E; return JreHelper.LOG10E; };
            ;
            return JreHelper;
        }());
        internal.JreHelper = JreHelper;
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var javaemul;
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Provides an interface for simple JavaScript idioms that can not be expressed in Java.
         */
        var JsUtils = (function () {
            function JsUtils() {
            }
            JsUtils.getInfinity = function () {
                return Infinity;
            };
            JsUtils.isUndefined = function (value) {
                return value == null;
            };
            JsUtils.unsafeCastToString = function (string) {
                return string;
            };
            JsUtils.setPropertySafe = function (map, key, value) {
                try {
                    map[key] = value;
                }
                catch (e) {
                }
                ;
            };
            JsUtils.getIntProperty = function (map, key) {
                return (map[key] | 0);
            };
            JsUtils.setIntProperty = function (map, key, value) {
                map[key] = value;
            };
            JsUtils.typeOf = function (o) {
                return typeof o;
            };
            return JsUtils;
        }());
        internal.JsUtils = JsUtils;
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var javaemul;
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * A helper class for long comparison.
         */
        var LongCompareHolder = (function () {
            function LongCompareHolder() {
            }
            LongCompareHolder.getLongComparator = function () {
                return function (l1, l2) { return l2 - l1; };
            };
            return LongCompareHolder;
        }());
        internal.LongCompareHolder = LongCompareHolder;
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var javaemul;
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Math utility methods and constants.
         */
        var MathHelper = (function () {
            function MathHelper() {
            }
            MathHelper.EPSILON_$LI$ = function () { if (MathHelper.EPSILON == null)
                MathHelper.EPSILON = MathHelper.pow(2, -52); return MathHelper.EPSILON; };
            ;
            MathHelper.MAX_VALUE_$LI$ = function () { if (MathHelper.MAX_VALUE == null)
                MathHelper.MAX_VALUE = (2 - MathHelper.EPSILON_$LI$()) * MathHelper.pow(2, 1023); return MathHelper.MAX_VALUE; };
            ;
            MathHelper.MIN_VALUE_$LI$ = function () { if (MathHelper.MIN_VALUE == null)
                MathHelper.MIN_VALUE = MathHelper.pow(2, -1022); return MathHelper.MIN_VALUE; };
            ;
            MathHelper.nextDown = function (x) {
                return -MathHelper.nextUp(-x);
            };
            MathHelper.ulp = function (x) {
                return x < 0 ? MathHelper.nextUp(x) - x : x - (-MathHelper.nextUp(-x));
            };
            MathHelper.nextUp = function (x) {
                if (x !== x) {
                    return x;
                }
                if (x === (-1 / 0 | 0)) {
                    return -MathHelper.MAX_VALUE_$LI$();
                }
                if (x === (+1 / 0 | 0)) {
                    return (+1 / 0 | 0);
                }
                if (x === +MathHelper.MAX_VALUE_$LI$()) {
                    return (+1 / 0 | 0);
                }
                var y = x * (x < 0 ? 1 - MathHelper.EPSILON_$LI$() / 2 : 1 + MathHelper.EPSILON_$LI$());
                if (y === x) {
                    y = MathHelper.MIN_VALUE_$LI$() * MathHelper.EPSILON_$LI$() > 0 ? x + MathHelper.MIN_VALUE_$LI$() * MathHelper.EPSILON_$LI$() : x + MathHelper.MIN_VALUE_$LI$();
                }
                if (y === (+1 / 0 | 0)) {
                    y = +MathHelper.MAX_VALUE_$LI$();
                }
                var b = x + (y - x) / 2;
                if (x < b && b < y) {
                    y = b;
                }
                var c = (y + x) / 2;
                if (x < c && c < y) {
                    y = c;
                }
                return y === 0 ? -0 : y;
            };
            MathHelper.PI_OVER_180_$LI$ = function () { if (MathHelper.PI_OVER_180 == null)
                MathHelper.PI_OVER_180 = MathHelper.PI / 180.0; return MathHelper.PI_OVER_180; };
            ;
            MathHelper.PI_UNDER_180_$LI$ = function () { if (MathHelper.PI_UNDER_180 == null)
                MathHelper.PI_UNDER_180 = 180.0 / MathHelper.PI; return MathHelper.PI_UNDER_180; };
            ;
            MathHelper.abs$double = function (x) {
                return x <= 0 ? 0.0 - x : x;
            };
            MathHelper.abs$float = function (x) {
                return MathHelper.abs(x);
            };
            MathHelper.abs = function (x) {
                if (((typeof x === 'number') || x === null)) {
                    return (function () {
                        return x < 0 ? -x : x;
                    })();
                }
                else if (((typeof x === 'number') || x === null)) {
                    return javaemul.internal.MathHelper.abs$long(x);
                }
                else if (((typeof x === 'number') || x === null)) {
                    return javaemul.internal.MathHelper.abs$float(x);
                }
                else if (((typeof x === 'number') || x === null)) {
                    return javaemul.internal.MathHelper.abs$double(x);
                }
                else
                    throw new Error('invalid overload');
            };
            MathHelper.abs$long = function (x) {
                return x < 0 ? -x : x;
            };
            MathHelper.acos = function (x) {
                return Math.acos(x);
            };
            MathHelper.asin = function (x) {
                return Math.asin(x);
            };
            MathHelper.atan = function (x) {
                return Math.atan(x);
            };
            MathHelper.atan2 = function (y, x) {
                return Math.atan2(y, x);
            };
            MathHelper.cbrt = function (x) {
                return MathHelper.pow(x, 1.0 / 3.0);
            };
            MathHelper.ceil = function (x) {
                return Math.ceil(x);
            };
            MathHelper.copySign$double$double = function (magnitude, sign) {
                if (sign < 0) {
                    return (magnitude < 0) ? magnitude : -magnitude;
                }
                else {
                    return (magnitude > 0) ? magnitude : -magnitude;
                }
            };
            MathHelper.copySign = function (magnitude, sign) {
                if (((typeof magnitude === 'number') || magnitude === null) && ((typeof sign === 'number') || sign === null)) {
                    return (function () {
                        return (MathHelper.copySign(magnitude, sign));
                    })();
                }
                else if (((typeof magnitude === 'number') || magnitude === null) && ((typeof sign === 'number') || sign === null)) {
                    return javaemul.internal.MathHelper.copySign$double$double(magnitude, sign);
                }
                else
                    throw new Error('invalid overload');
            };
            MathHelper.cos = function (x) {
                return Math.cos(x);
            };
            MathHelper.cosh = function (x) {
                return (MathHelper.exp(x) + MathHelper.exp(-x)) / 2.0;
            };
            MathHelper.exp = function (x) {
                return Math.exp(x);
            };
            MathHelper.expm1 = function (d) {
                if (d === 0.0 || (Number.NaN === d)) {
                    return d;
                }
                else if (!(function (value) { return Number.NEGATIVE_INFINITY === value || Number.POSITIVE_INFINITY === value; })(d)) {
                    if (d < 0.0) {
                        return -1.0;
                    }
                    else {
                        return javaemul.internal.DoubleHelper.POSITIVE_INFINITY;
                    }
                }
                return MathHelper.exp(d) + 1.0;
            };
            MathHelper.floor = function (x) {
                return Math.floor(x);
            };
            MathHelper.hypot = function (x, y) {
                return MathHelper.sqrt(x * x + y * y);
            };
            MathHelper.log = function (x) {
                return Math.log(x);
            };
            MathHelper.log10 = function (x) {
                return Math.log(x) * Math.LOG10E;
            };
            MathHelper.log1p = function (x) {
                return MathHelper.log(x + 1.0);
            };
            MathHelper.max$double$double = function (x, y) {
                return Math.max(x, y);
            };
            MathHelper.max$float$float = function (x, y) {
                return Math.max(x, y);
            };
            MathHelper.max = function (x, y) {
                if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return (function () {
                        return x > y ? x : y;
                    })();
                }
                else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return javaemul.internal.MathHelper.max$long$long(x, y);
                }
                else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return javaemul.internal.MathHelper.max$float$float(x, y);
                }
                else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return javaemul.internal.MathHelper.max$double$double(x, y);
                }
                else
                    throw new Error('invalid overload');
            };
            MathHelper.max$long$long = function (x, y) {
                return x > y ? x : y;
            };
            MathHelper.min$double$double = function (x, y) {
                return Math.min(x, y);
            };
            MathHelper.min$float$float = function (x, y) {
                return Math.min(x, y);
            };
            MathHelper.min = function (x, y) {
                if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return (function () {
                        return x < y ? x : y;
                    })();
                }
                else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return javaemul.internal.MathHelper.min$long$long(x, y);
                }
                else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return javaemul.internal.MathHelper.min$float$float(x, y);
                }
                else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return javaemul.internal.MathHelper.min$double$double(x, y);
                }
                else
                    throw new Error('invalid overload');
            };
            MathHelper.min$long$long = function (x, y) {
                return x < y ? x : y;
            };
            MathHelper.pow = function (x, exp) {
                return Math.pow(x, exp);
            };
            MathHelper.random = function () {
                return Math.random();
            };
            MathHelper.rint = function (d) {
                if ((Number.NaN === d)) {
                    return d;
                }
                else if ((function (value) { return Number.NEGATIVE_INFINITY === value || Number.POSITIVE_INFINITY === value; })(d)) {
                    return d;
                }
                else if (d === 0.0) {
                    return d;
                }
                else {
                    return MathHelper.round(d);
                }
            };
            MathHelper.round$double = function (x) {
                return Math.round(Math.round(x));
            };
            MathHelper.round = function (x) {
                if (((typeof x === 'number') || x === null)) {
                    return (function () {
                        var roundedValue = Math.round(x);
                        return MathHelper.unsafeCastToInt(roundedValue);
                    })();
                }
                else if (((typeof x === 'number') || x === null)) {
                    return javaemul.internal.MathHelper.round$double(x);
                }
                else
                    throw new Error('invalid overload');
            };
            MathHelper.unsafeCastToInt = function (d) {
                return d;
            };
            MathHelper.scalb$double$int = function (d, scaleFactor) {
                if (scaleFactor >= 31 || scaleFactor <= -31) {
                    return d * MathHelper.pow(2, scaleFactor);
                }
                else if (scaleFactor > 0) {
                    return d * (1 << scaleFactor);
                }
                else if (scaleFactor === 0) {
                    return d;
                }
                else {
                    return d * 1.0 / (1 << -scaleFactor);
                }
            };
            MathHelper.scalb = function (f, scaleFactor) {
                if (((typeof f === 'number') || f === null) && ((typeof scaleFactor === 'number') || scaleFactor === null)) {
                    return (function () {
                        if (scaleFactor >= 31 || scaleFactor <= -31) {
                            return f * MathHelper.pow(2, scaleFactor);
                        }
                        else if (scaleFactor > 0) {
                            return f * (1 << scaleFactor);
                        }
                        else if (scaleFactor === 0) {
                            return f;
                        }
                        else {
                            return f * 1.0 / (1 << -scaleFactor);
                        }
                    })();
                }
                else if (((typeof f === 'number') || f === null) && ((typeof scaleFactor === 'number') || scaleFactor === null)) {
                    return javaemul.internal.MathHelper.scalb$double$int(f, scaleFactor);
                }
                else
                    throw new Error('invalid overload');
            };
            MathHelper.signum$double = function (d) {
                if (d > 0.0) {
                    return 1.0;
                }
                else if (d < 0.0) {
                    return -1.0;
                }
                else {
                    return 0.0;
                }
            };
            MathHelper.signum = function (f) {
                if (((typeof f === 'number') || f === null)) {
                    return (function () {
                        if (f > 0.0) {
                            return 1.0;
                        }
                        else if (f < 0.0) {
                            return -1.0;
                        }
                        else {
                            return 0.0;
                        }
                    })();
                }
                else if (((typeof f === 'number') || f === null)) {
                    return javaemul.internal.MathHelper.signum$double(f);
                }
                else
                    throw new Error('invalid overload');
            };
            MathHelper.sin = function (x) {
                return Math.sin(x);
            };
            MathHelper.sinh = function (x) {
                return (MathHelper.exp(x) - MathHelper.exp(-x)) / 2.0;
            };
            MathHelper.sqrt = function (x) {
                return Math.sqrt(x);
            };
            MathHelper.tan = function (x) {
                return Math.tan(x);
            };
            MathHelper.tanh = function (x) {
                if (x === javaemul.internal.JsUtils.getInfinity()) {
                    return 1.0;
                }
                else if (x === -javaemul.internal.JsUtils.getInfinity()) {
                    return -1.0;
                }
                var e2x = MathHelper.exp(2.0 * x);
                return (e2x - 1) / (e2x + 1);
            };
            MathHelper.toDegrees = function (x) {
                return x * MathHelper.PI_UNDER_180_$LI$();
            };
            MathHelper.toRadians = function (x) {
                return x * MathHelper.PI_OVER_180_$LI$();
            };
            MathHelper.IEEEremainder = function (f1, f2) {
                var r = Math.abs(f1 % f2);
                if ((Number.NaN === r) || r === f2 || r <= Math.abs(f2) / 2.0) {
                    return r;
                }
                else {
                    return (function (f) { if (f > 0) {
                        return 1;
                    }
                    else if (f < 0) {
                        return -1;
                    }
                    else {
                        return 0;
                    } })(f1) * (r - f2);
                }
            };
            MathHelper.E = 2.718281828459045;
            MathHelper.PI = 3.141592653589793;
            return MathHelper;
        }());
        internal.MathHelper = MathHelper;
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var javaemul;
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Abstract base class for numeric wrapper classes.
         */
        var NumberHelper = (function () {
            function NumberHelper() {
                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
            }
            /**
             * @skip
             *
             * This function will determine the radix that the string is expressed
             * in based on the parsing rules defined in the Javadocs for
             * Integer.decode() and invoke __parseAndValidateInt.
             */
            NumberHelper.__decodeAndValidateInt = function (s, lowerBound, upperBound) {
                var decode = NumberHelper.__decodeNumberString(s);
                return NumberHelper.__parseAndValidateInt(decode.payload, decode.radix, lowerBound, upperBound);
            };
            NumberHelper.__decodeNumberString = function (s) {
                var negative;
                if ((function (str, searchString, position) {
                    if (position === void 0) { position = 0; }
                    return str.substr(position, searchString.length) === searchString;
                })(s, "-")) {
                    negative = true;
                    s = s.substring(1);
                }
                else {
                    negative = false;
                    if ((function (str, searchString, position) {
                        if (position === void 0) { position = 0; }
                        return str.substr(position, searchString.length) === searchString;
                    })(s, "+")) {
                        s = s.substring(1);
                    }
                }
                var radix;
                if ((function (str, searchString, position) {
                    if (position === void 0) { position = 0; }
                    return str.substr(position, searchString.length) === searchString;
                })(s, "0x") || (function (str, searchString, position) {
                    if (position === void 0) { position = 0; }
                    return str.substr(position, searchString.length) === searchString;
                })(s, "0X")) {
                    s = s.substring(2);
                    radix = 16;
                }
                else if ((function (str, searchString, position) {
                    if (position === void 0) { position = 0; }
                    return str.substr(position, searchString.length) === searchString;
                })(s, "#")) {
                    s = s.substring(1);
                    radix = 16;
                }
                else if ((function (str, searchString, position) {
                    if (position === void 0) { position = 0; }
                    return str.substr(position, searchString.length) === searchString;
                })(s, "0")) {
                    radix = 8;
                }
                else {
                    radix = 10;
                }
                if (negative) {
                    s = "-" + s;
                }
                return new NumberHelper.__Decode(radix, s);
            };
            /**
             * @skip
             *
             * This function contains common logic for parsing a String as a
             * floating- point number and validating the range.
             */
            NumberHelper.__parseAndValidateDouble = function (s) {
                if (!NumberHelper.__isValidDouble(s)) {
                    throw java.lang.NumberFormatException.forInputString(s);
                }
                return parseFloat(s);
            };
            /**
             * @skip
             *
             * This function contains common logic for parsing a String in a given
             * radix and validating the result.
             */
            NumberHelper.__parseAndValidateInt = function (s, radix, lowerBound, upperBound) {
                if (s == null) {
                    throw java.lang.NumberFormatException.forNullInputString();
                }
                if (radix < javaemul.internal.CharacterHelper.MIN_RADIX || radix > javaemul.internal.CharacterHelper.MAX_RADIX) {
                    throw java.lang.NumberFormatException.forRadix(radix);
                }
                var length = s.length;
                var startIndex = (length > 0) && (s.charAt(0) === '-' || s.charAt(0) === '+') ? 1 : 0;
                for (var i = startIndex; i < length; i++) {
                    if (javaemul.internal.CharacterHelper.digit(s.charAt(i), radix) === -1) {
                        throw java.lang.NumberFormatException.forInputString(s);
                    }
                }
                var toReturn = (parseInt(s, radix) | 0);
                var isTooLow = toReturn < lowerBound;
                if (javaemul.internal.DoubleHelper.isNaN(toReturn)) {
                    throw java.lang.NumberFormatException.forInputString(s);
                }
                else if (isTooLow || toReturn > upperBound) {
                    throw java.lang.NumberFormatException.forInputString(s);
                }
                return toReturn;
            };
            /**
             * @skip
             *
             * This function contains common logic for parsing a String in a given
             * radix and validating the result.
             */
            NumberHelper.__parseAndValidateLong = function (s, radix) {
                if (s == null) {
                    throw java.lang.NumberFormatException.forNullInputString();
                }
                if (radix < javaemul.internal.CharacterHelper.MIN_RADIX || radix > javaemul.internal.CharacterHelper.MAX_RADIX) {
                    throw java.lang.NumberFormatException.forRadix(radix);
                }
                var orig = s;
                var length = s.length;
                var negative = false;
                if (length > 0) {
                    var c = s.charAt(0);
                    if (c === '-' || c === '+') {
                        s = s.substring(1);
                        length--;
                        negative = (c === '-');
                    }
                }
                if (length === 0) {
                    throw java.lang.NumberFormatException.forInputString(orig);
                }
                while ((s.length > 0 && s.charAt(0) === '0')) {
                    s = s.substring(1);
                    length--;
                }
                ;
                if (length > NumberHelper.__ParseLong.maxLengthForRadix_$LI$()[radix]) {
                    throw java.lang.NumberFormatException.forInputString(orig);
                }
                for (var i = 0; i < length; i++) {
                    if (javaemul.internal.CharacterHelper.digit(s.charAt(i), radix) === -1) {
                        throw java.lang.NumberFormatException.forInputString(orig);
                    }
                }
                var toReturn = 0;
                var maxDigits = NumberHelper.__ParseLong.maxDigitsForRadix_$LI$()[radix];
                var radixPower = NumberHelper.__ParseLong.maxDigitsRadixPower_$LI$()[radix];
                var minValue = -NumberHelper.__ParseLong.maxValueForRadix_$LI$()[radix];
                var firstTime = true;
                var head = length % maxDigits;
                if (head > 0) {
                    toReturn = -(parseInt(s.substring(0, head), radix) | 0);
                    s = s.substring(head);
                    length -= head;
                    firstTime = false;
                }
                while ((length >= maxDigits)) {
                    head = (parseInt(s.substring(0, maxDigits), radix) | 0);
                    s = s.substring(maxDigits);
                    length -= maxDigits;
                    if (!firstTime) {
                        if (toReturn < minValue) {
                            throw java.lang.NumberFormatException.forInputString(orig);
                        }
                        toReturn *= radixPower;
                    }
                    else {
                        firstTime = false;
                    }
                    toReturn -= head;
                }
                ;
                if (toReturn > 0) {
                    throw java.lang.NumberFormatException.forInputString(orig);
                }
                if (!negative) {
                    toReturn = -toReturn;
                    if (toReturn < 0) {
                        throw java.lang.NumberFormatException.forInputString(orig);
                    }
                }
                return toReturn;
            };
            /**
             * @skip
             *
             * @param str
             * @return {@code true} if the string matches the float format,
             * {@code false} otherwise
             */
            NumberHelper.__isValidDouble = function (str) {
                if (NumberHelper.floatRegex == null) {
                    NumberHelper.floatRegex = NumberHelper.createFloatRegex();
                }
                return NumberHelper.floatRegex.test(str);
            };
            NumberHelper.createFloatRegex = function () {
                return /^\s*[+-]?(NaN|Infinity|((\d+\.?\d*)|(\.\d+))([eE][+-]?\d+)?[dDfF]?)\s*$/;
            };
            NumberHelper.prototype.byteValue = function () {
                return (this.intValue() | 0);
            };
            NumberHelper.prototype.shortValue = function () {
                return (this.intValue() | 0);
            };
            return NumberHelper;
        }());
        internal.NumberHelper = NumberHelper;
        var NumberHelper;
        (function (NumberHelper) {
            var __Decode = (function () {
                function __Decode(radix, payload) {
                    this.radix = 0;
                    this.radix = radix;
                    this.payload = payload;
                }
                return __Decode;
            }());
            NumberHelper.__Decode = __Decode;
            /**
             * Use nested class to avoid clinit on outer.
             */
            var __ParseLong = (function () {
                function __ParseLong() {
                }
                __ParseLong.__static_initialize = function () { if (!__ParseLong.__static_initialized) {
                    __ParseLong.__static_initialized = true;
                    __ParseLong.__static_initializer_0();
                } };
                __ParseLong.maxDigitsForRadix_$LI$ = function () { __ParseLong.__static_initialize(); if (__ParseLong.maxDigitsForRadix == null)
                    __ParseLong.maxDigitsForRadix = [-1, -1, 30, 19, 15, 13, 11, 11, 10, 9, 9, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5]; return __ParseLong.maxDigitsForRadix; };
                ;
                __ParseLong.maxDigitsRadixPower_$LI$ = function () { __ParseLong.__static_initialize(); if (__ParseLong.maxDigitsRadixPower == null)
                    __ParseLong.maxDigitsRadixPower = new Array(37); return __ParseLong.maxDigitsRadixPower; };
                ;
                __ParseLong.maxLengthForRadix_$LI$ = function () { __ParseLong.__static_initialize(); if (__ParseLong.maxLengthForRadix == null)
                    __ParseLong.maxLengthForRadix = [-1, -1, 63, 40, 32, 28, 25, 23, 21, 20, 19, 19, 18, 18, 17, 17, 16, 16, 16, 15, 15, 15, 15, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13]; return __ParseLong.maxLengthForRadix; };
                ;
                __ParseLong.maxValueForRadix_$LI$ = function () { __ParseLong.__static_initialize(); if (__ParseLong.maxValueForRadix == null)
                    __ParseLong.maxValueForRadix = new Array(37); return __ParseLong.maxValueForRadix; };
                ;
                __ParseLong.__static_initializer_0 = function () {
                    for (var i = 2; i <= 36; i++) {
                        __ParseLong.maxDigitsRadixPower_$LI$()[i] = (Math.pow(i, __ParseLong.maxDigitsForRadix_$LI$()[i]) | 0);
                        __ParseLong.maxValueForRadix_$LI$()[i] = Math.round(9223372036854775807 / __ParseLong.maxDigitsRadixPower_$LI$()[i]);
                    }
                };
                __ParseLong.__static_initialized = false;
                return __ParseLong;
            }());
            NumberHelper.__ParseLong = __ParseLong;
        })(NumberHelper = internal.NumberHelper || (internal.NumberHelper = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var javaemul;
(function (javaemul) {
    var internal;
    (function (internal) {
        var ObjectHelper = (function () {
            function ObjectHelper() {
            }
            ObjectHelper.clone = function (obj) {
                var copy;
                // Handle the 3 simple types, and null or undefined
                if (null == obj || "object" != typeof obj)
                    return obj;
                // Handle Date
                if (obj instanceof Date) {
                    copy = new Date();
                    copy.setTime(obj.getTime());
                    return copy;
                }
                // Handle Array
                if (obj instanceof Array) {
                    copy = [];
                    for (var i = 0, len = obj.length; i < len; i++) {
                        copy[i] = javaemul.internal.ObjectHelper.clone(obj[i]);
                    }
                    return copy;
                }
                // Handle Object
                if (obj instanceof Object) {
                    copy = {};
                    for (var attr in obj) {
                        if (obj.hasOwnProperty(attr))
                            copy[attr] = javaemul.internal.ObjectHelper.clone(obj[attr]);
                    }
                    return copy;
                }
                throw new Error("Unable to copy obj! Its type isn't supported.");
            };
            return ObjectHelper;
        }());
        internal.ObjectHelper = ObjectHelper;
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var javaemul;
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Hashcode caching for strings.
         */
        var StringHashCache = (function () {
            function StringHashCache() {
            }
            StringHashCache.back_$LI$ = function () { if (StringHashCache.back == null)
                StringHashCache.back = StringHashCache.createNativeObject(); return StringHashCache.back; };
            ;
            StringHashCache.front_$LI$ = function () { if (StringHashCache.front == null)
                StringHashCache.front = StringHashCache.createNativeObject(); return StringHashCache.front; };
            ;
            StringHashCache.getHashCode = function (str) {
                var key = ":" + str;
                var result = StringHashCache.getProperty(StringHashCache.front_$LI$(), key);
                if (!javaemul.internal.JsUtils.isUndefined(result)) {
                    return StringHashCache.unsafeCastToInt(result);
                }
                result = StringHashCache.getProperty(StringHashCache.back_$LI$(), key);
                var hashCode = javaemul.internal.JsUtils.isUndefined(result) ? StringHashCache.compute(str) : StringHashCache.unsafeCastToInt(result);
                StringHashCache.increment();
                javaemul.internal.JsUtils.setIntProperty(StringHashCache.front_$LI$(), key, hashCode);
                return hashCode;
            };
            StringHashCache.compute = function (str) {
                var hashCode = 0;
                var n = str.length;
                var nBatch = n - 4;
                var i = 0;
                while ((i < nBatch)) {
                    hashCode = (str.charAt(i + 3)).charCodeAt(0) + 31 * ((str.charAt(i + 2)).charCodeAt(0) + 31 * ((str.charAt(i + 1)).charCodeAt(0) + 31 * ((str.charAt(i)).charCodeAt(0) + 31 * hashCode)));
                    hashCode = javaemul.internal.Coercions.ensureInt(hashCode);
                    i += 4;
                }
                ;
                while ((i < n)) {
                    hashCode = hashCode * 31 + (str.charAt(i++)).charCodeAt(0);
                }
                ;
                hashCode = javaemul.internal.Coercions.ensureInt(hashCode);
                return hashCode;
            };
            StringHashCache.increment = function () {
                if (StringHashCache.count === StringHashCache.MAX_CACHE) {
                    StringHashCache.back = StringHashCache.front;
                    StringHashCache.front = StringHashCache.createNativeObject();
                    StringHashCache.count = 0;
                }
                ++StringHashCache.count;
            };
            StringHashCache.getProperty = function (map, key) {
                return map[key];
            };
            StringHashCache.createNativeObject = function () {
                return {};
            };
            StringHashCache.unsafeCastToInt = function (o) {
                return o;
            };
            /**
             * Tracks the number of entries in front.
             */
            StringHashCache.count = 0;
            /**
             * Pulled this number out of thin air.
             */
            StringHashCache.MAX_CACHE = 256;
            return StringHashCache;
        }());
        internal.StringHashCache = StringHashCache;
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var sun;
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var ChainEnd = (function () {
                function ChainEnd(first, partner) {
                    this.etag = 0;
                    this.head = first;
                    this.tail = first;
                    this.partner = partner;
                    this.etag = first.getEdgeTag();
                }
                ChainEnd.prototype.getChain = function () {
                    return this.head;
                };
                ChainEnd.prototype.setOtherEnd = function (partner) {
                    this.partner = partner;
                };
                ChainEnd.prototype.getPartner = function () {
                    return this.partner;
                };
                ChainEnd.prototype.linkTo = function (that) {
                    if (this.etag === sun.awt.geom.AreaOp.ETAG_IGNORE || that.etag === sun.awt.geom.AreaOp.ETAG_IGNORE) {
                        throw new java.lang.InternalError("ChainEnd linked more than once!");
                    }
                    if (this.etag === that.etag) {
                        throw new java.lang.InternalError("Linking chains of the same type!");
                    }
                    var enter;
                    var exit;
                    if (this.etag === sun.awt.geom.AreaOp.ETAG_ENTER) {
                        enter = this;
                        exit = that;
                    }
                    else {
                        enter = that;
                        exit = this;
                    }
                    this.etag = sun.awt.geom.AreaOp.ETAG_IGNORE;
                    that.etag = sun.awt.geom.AreaOp.ETAG_IGNORE;
                    enter.tail.setNext(exit.head);
                    enter.tail = exit.tail;
                    if (this.partner === that) {
                        return enter.head;
                    }
                    var otherenter = exit.partner;
                    var otherexit = enter.partner;
                    otherenter.partner = otherexit;
                    otherexit.partner = otherenter;
                    if (enter.head.getYTop() < otherenter.head.getYTop()) {
                        enter.tail.setNext(otherenter.head);
                        otherenter.head = enter.head;
                    }
                    else {
                        otherexit.tail.setNext(enter.head);
                        otherexit.tail = enter.tail;
                    }
                    return null;
                };
                ChainEnd.prototype.addLink = function (newlink) {
                    if (this.etag === sun.awt.geom.AreaOp.ETAG_ENTER) {
                        this.tail.setNext(newlink);
                        this.tail = newlink;
                    }
                    else {
                        newlink.setNext(this.head);
                        this.head = newlink;
                    }
                };
                ChainEnd.prototype.getX = function () {
                    if (this.etag === sun.awt.geom.AreaOp.ETAG_ENTER) {
                        return this.tail.getXBot();
                    }
                    else {
                        return this.head.getXBot();
                    }
                };
                return ChainEnd;
            }());
            geom.ChainEnd = ChainEnd;
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var sun;
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var Crossings = (function () {
                function Crossings(xlo, ylo, xhi, yhi) {
                    this.limit = 0;
                    this.yranges = new Array(10);
                    this.tmp = new java.util.Vector();
                    this.xlo = 0;
                    this.ylo = 0;
                    this.xhi = 0;
                    this.yhi = 0;
                    this.xlo = xlo;
                    this.ylo = ylo;
                    this.xhi = xhi;
                    this.yhi = yhi;
                }
                Crossings.prototype.getXLo = function () {
                    return this.xlo;
                };
                Crossings.prototype.getYLo = function () {
                    return this.ylo;
                };
                Crossings.prototype.getXHi = function () {
                    return this.xhi;
                };
                Crossings.prototype.getYHi = function () {
                    return this.yhi;
                };
                Crossings.prototype.print = function () {
                    console.info("Crossings [");
                    console.info("  bounds = [" + this.ylo + ", " + this.yhi + "]");
                    for (var i = 0; i < this.limit; i += 2) {
                        console.info("  [" + this.yranges[i] + ", " + this.yranges[i + 1] + "]");
                    }
                    console.info("]");
                };
                Crossings.prototype.isEmpty = function () {
                    return (this.limit === 0);
                };
                Crossings.findCrossings = function (curves, xlo, ylo, xhi, yhi) {
                    if (((curves != null && curves instanceof java.util.Vector) || curves === null) && ((typeof xlo === 'number') || xlo === null) && ((typeof ylo === 'number') || ylo === null) && ((typeof xhi === 'number') || xhi === null) && ((typeof yhi === 'number') || yhi === null)) {
                        return (function () {
                            var cross = new Crossings.EvenOdd(xlo, ylo, xhi, yhi);
                            var enum_ = curves.elements();
                            while ((enum_.hasMoreElements())) {
                                var c = enum_.nextElement();
                                if (c.accumulateCrossings(cross)) {
                                    return null;
                                }
                            }
                            ;
                            if (Crossings.debug) {
                                cross.print();
                            }
                            return cross;
                        })();
                    }
                    else if (((curves != null && curves["__interfaces"] != null && curves["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0) || curves === null) && ((typeof xlo === 'number') || xlo === null) && ((typeof ylo === 'number') || ylo === null) && ((typeof xhi === 'number') || xhi === null) && ((typeof yhi === 'number') || yhi === null)) {
                        return sun.awt.geom.Crossings.findCrossings$java_awt_geom_PathIterator$double$double$double$double(curves, xlo, ylo, xhi, yhi);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Crossings.findCrossings$java_awt_geom_PathIterator$double$double$double$double = function (pi, xlo, ylo, xhi, yhi) {
                    var cross;
                    if (pi.getWindingRule() === java.awt.geom.PathIterator.WIND_EVEN_ODD) {
                        cross = new Crossings.EvenOdd(xlo, ylo, xhi, yhi);
                    }
                    else {
                        cross = new Crossings.NonZero(xlo, ylo, xhi, yhi);
                    }
                    var coords = new Array(23);
                    var movx = 0;
                    var movy = 0;
                    var curx = 0;
                    var cury = 0;
                    var newx;
                    var newy;
                    while ((!pi.isDone())) {
                        var type = pi.currentSegment(coords);
                        switch ((type)) {
                            case java.awt.geom.PathIterator.SEG_MOVETO:
                                if (movy !== cury && cross.accumulateLine(curx, cury, movx, movy)) {
                                    return null;
                                }
                                movx = curx = coords[0];
                                movy = cury = coords[1];
                                break;
                            case java.awt.geom.PathIterator.SEG_LINETO:
                                newx = coords[0];
                                newy = coords[1];
                                if (cross.accumulateLine(curx, cury, newx, newy)) {
                                    return null;
                                }
                                curx = newx;
                                cury = newy;
                                break;
                            case java.awt.geom.PathIterator.SEG_QUADTO:
                                newx = coords[2];
                                newy = coords[3];
                                if (cross.accumulateQuad(curx, cury, coords)) {
                                    return null;
                                }
                                curx = newx;
                                cury = newy;
                                break;
                            case java.awt.geom.PathIterator.SEG_CUBICTO:
                                newx = coords[4];
                                newy = coords[5];
                                if (cross.accumulateCubic(curx, cury, coords)) {
                                    return null;
                                }
                                curx = newx;
                                cury = newy;
                                break;
                            case java.awt.geom.PathIterator.SEG_CLOSE:
                                if (movy !== cury && cross.accumulateLine(curx, cury, movx, movy)) {
                                    return null;
                                }
                                curx = movx;
                                cury = movy;
                                break;
                        }
                        pi.next();
                    }
                    ;
                    if (movy !== cury) {
                        if (cross.accumulateLine(curx, cury, movx, movy)) {
                            return null;
                        }
                    }
                    if (Crossings.debug) {
                        cross.print();
                    }
                    return cross;
                };
                Crossings.prototype.accumulateLine$double$double$double$double = function (x0, y0, x1, y1) {
                    if (y0 <= y1) {
                        return this.accumulateLine(x0, y0, x1, y1, 1);
                    }
                    else {
                        return this.accumulateLine(x1, y1, x0, y0, -1);
                    }
                };
                Crossings.prototype.accumulateLine = function (x0, y0, x1, y1, direction) {
                    var _this = this;
                    if (((typeof x0 === 'number') || x0 === null) && ((typeof y0 === 'number') || y0 === null) && ((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof direction === 'number') || direction === null)) {
                        return (function () {
                            if (_this.yhi <= y0 || _this.ylo >= y1) {
                                return false;
                            }
                            if (x0 >= _this.xhi && x1 >= _this.xhi) {
                                return false;
                            }
                            if (y0 === y1) {
                                return (x0 >= _this.xlo || x1 >= _this.xlo);
                            }
                            var xstart;
                            var ystart;
                            var xend;
                            var yend;
                            var dx = (x1 - x0);
                            var dy = (y1 - y0);
                            if (y0 < _this.ylo) {
                                xstart = x0 + (_this.ylo - y0) * dx / dy;
                                ystart = _this.ylo;
                            }
                            else {
                                xstart = x0;
                                ystart = y0;
                            }
                            if (_this.yhi < y1) {
                                xend = x0 + (_this.yhi - y0) * dx / dy;
                                yend = _this.yhi;
                            }
                            else {
                                xend = x1;
                                yend = y1;
                            }
                            if (xstart >= _this.xhi && xend >= _this.xhi) {
                                return false;
                            }
                            if (xstart > _this.xlo || xend > _this.xlo) {
                                return true;
                            }
                            _this.record(ystart, yend, direction);
                            return false;
                        })();
                    }
                    else if (((typeof x0 === 'number') || x0 === null) && ((typeof y0 === 'number') || y0 === null) && ((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && direction === undefined) {
                        return this.accumulateLine$double$double$double$double(x0, y0, x1, y1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Crossings.prototype.accumulateQuad = function (x0, y0, coords) {
                    if (y0 < this.ylo && coords[1] < this.ylo && coords[3] < this.ylo) {
                        return false;
                    }
                    if (y0 > this.yhi && coords[1] > this.yhi && coords[3] > this.yhi) {
                        return false;
                    }
                    if (x0 > this.xhi && coords[0] > this.xhi && coords[2] > this.xhi) {
                        return false;
                    }
                    if (x0 < this.xlo && coords[0] < this.xlo && coords[2] < this.xlo) {
                        if (y0 < coords[3]) {
                            this.record(Math.max(y0, this.ylo), Math.min(coords[3], this.yhi), 1);
                        }
                        else if (y0 > coords[3]) {
                            this.record(Math.max(coords[3], this.ylo), Math.min(y0, this.yhi), -1);
                        }
                        return false;
                    }
                    sun.awt.geom.Curve.insertQuad(this.tmp, x0, y0, coords);
                    var enum_ = this.tmp.elements();
                    while ((enum_.hasMoreElements())) {
                        var c = enum_.nextElement();
                        if (c.accumulateCrossings(this)) {
                            return true;
                        }
                    }
                    ;
                    this.tmp.clear();
                    return false;
                };
                Crossings.prototype.accumulateCubic = function (x0, y0, coords) {
                    if (y0 < this.ylo && coords[1] < this.ylo && coords[3] < this.ylo && coords[5] < this.ylo) {
                        return false;
                    }
                    if (y0 > this.yhi && coords[1] > this.yhi && coords[3] > this.yhi && coords[5] > this.yhi) {
                        return false;
                    }
                    if (x0 > this.xhi && coords[0] > this.xhi && coords[2] > this.xhi && coords[4] > this.xhi) {
                        return false;
                    }
                    if (x0 < this.xlo && coords[0] < this.xlo && coords[2] < this.xlo && coords[4] < this.xlo) {
                        if (y0 <= coords[5]) {
                            this.record(Math.max(y0, this.ylo), Math.min(coords[5], this.yhi), 1);
                        }
                        else {
                            this.record(Math.max(coords[5], this.ylo), Math.min(y0, this.yhi), -1);
                        }
                        return false;
                    }
                    sun.awt.geom.Curve.insertCubic(this.tmp, x0, y0, coords);
                    var enum_ = this.tmp.elements();
                    while ((enum_.hasMoreElements())) {
                        var c = enum_.nextElement();
                        if (c.accumulateCrossings(this)) {
                            return true;
                        }
                    }
                    ;
                    this.tmp.clear();
                    return false;
                };
                Crossings.debug = false;
                return Crossings;
            }());
            geom.Crossings = Crossings;
            var Crossings;
            (function (Crossings) {
                var EvenOdd = (function (_super) {
                    __extends(EvenOdd, _super);
                    function EvenOdd(xlo, ylo, xhi, yhi) {
                        _super.call(this, xlo, ylo, xhi, yhi);
                    }
                    EvenOdd.prototype.covers = function (ystart, yend) {
                        return (this.limit === 2 && this.yranges[0] <= ystart && this.yranges[1] >= yend);
                    };
                    EvenOdd.prototype.record = function (ystart, yend, direction) {
                        if (ystart >= yend) {
                            return;
                        }
                        var from = 0;
                        while ((from < this.limit && ystart > this.yranges[from + 1])) {
                            from += 2;
                        }
                        ;
                        var to = from;
                        while ((from < this.limit)) {
                            var yrlo = this.yranges[from++];
                            var yrhi = this.yranges[from++];
                            if (yend < yrlo) {
                                this.yranges[to++] = ystart;
                                this.yranges[to++] = yend;
                                ystart = yrlo;
                                yend = yrhi;
                                continue;
                            }
                            var yll;
                            var ylh;
                            var yhl;
                            var yhh;
                            if (ystart < yrlo) {
                                yll = ystart;
                                ylh = yrlo;
                            }
                            else {
                                yll = yrlo;
                                ylh = ystart;
                            }
                            if (yend < yrhi) {
                                yhl = yend;
                                yhh = yrhi;
                            }
                            else {
                                yhl = yrhi;
                                yhh = yend;
                            }
                            if (ylh === yhl) {
                                ystart = yll;
                                yend = yhh;
                            }
                            else {
                                if (ylh > yhl) {
                                    ystart = yhl;
                                    yhl = ylh;
                                    ylh = ystart;
                                }
                                if (yll !== ylh) {
                                    this.yranges[to++] = yll;
                                    this.yranges[to++] = ylh;
                                }
                                ystart = yhl;
                                yend = yhh;
                            }
                            if (ystart >= yend) {
                                break;
                            }
                        }
                        ;
                        if (to < from && from < this.limit) {
                            java.lang.System.arraycopy(this.yranges, from, this.yranges, to, this.limit - from);
                        }
                        to += (this.limit - from);
                        if (ystart < yend) {
                            if (to >= this.yranges.length) {
                                var newranges = new Array(to + 10);
                                java.lang.System.arraycopy(this.yranges, 0, newranges, 0, to);
                                this.yranges = newranges;
                            }
                            this.yranges[to++] = ystart;
                            this.yranges[to++] = yend;
                        }
                        this.limit = to;
                    };
                    return EvenOdd;
                }(sun.awt.geom.Crossings));
                Crossings.EvenOdd = EvenOdd;
                var NonZero = (function (_super) {
                    __extends(NonZero, _super);
                    function NonZero(xlo, ylo, xhi, yhi) {
                        _super.call(this, xlo, ylo, xhi, yhi);
                        this.crosscounts = new Array((this.yranges.length / 2 | 0));
                    }
                    NonZero.prototype.covers = function (ystart, yend) {
                        var i = 0;
                        while ((i < this.limit)) {
                            var ylo = this.yranges[i++];
                            var yhi = this.yranges[i++];
                            if (ystart >= yhi) {
                                continue;
                            }
                            if (ystart < ylo) {
                                return false;
                            }
                            if (yend <= yhi) {
                                return true;
                            }
                            ystart = yhi;
                        }
                        ;
                        return (ystart >= yend);
                    };
                    NonZero.prototype.remove = function (cur) {
                        this.limit -= 2;
                        var rem = this.limit - cur;
                        if (rem > 0) {
                            java.lang.System.arraycopy(this.yranges, cur + 2, this.yranges, cur, rem);
                            java.lang.System.arraycopy(this.crosscounts, (cur / 2 | 0) + 1, this.crosscounts, (cur / 2 | 0), (rem / 2 | 0));
                        }
                    };
                    NonZero.prototype.insert = function (cur, lo, hi, dir) {
                        var rem = this.limit - cur;
                        var oldranges = this.yranges;
                        var oldcounts = this.crosscounts;
                        if (this.limit >= this.yranges.length) {
                            this.yranges = new Array(this.limit + 10);
                            java.lang.System.arraycopy(oldranges, 0, this.yranges, 0, cur);
                            this.crosscounts = new Array(((this.limit + 10) / 2 | 0));
                            java.lang.System.arraycopy(oldcounts, 0, this.crosscounts, 0, (cur / 2 | 0));
                        }
                        if (rem > 0) {
                            java.lang.System.arraycopy(oldranges, cur, this.yranges, cur + 2, rem);
                            java.lang.System.arraycopy(oldcounts, (cur / 2 | 0), this.crosscounts, (cur / 2 | 0) + 1, (rem / 2 | 0));
                        }
                        this.yranges[cur + 0] = lo;
                        this.yranges[cur + 1] = hi;
                        this.crosscounts[(cur / 2 | 0)] = dir;
                        this.limit += 2;
                    };
                    NonZero.prototype.record = function (ystart, yend, direction) {
                        if (ystart >= yend) {
                            return;
                        }
                        var cur = 0;
                        while ((cur < this.limit && ystart > this.yranges[cur + 1])) {
                            cur += 2;
                        }
                        ;
                        if (cur < this.limit) {
                            var rdir = this.crosscounts[(cur / 2 | 0)];
                            var yrlo = this.yranges[cur + 0];
                            var yrhi = this.yranges[cur + 1];
                            if (yrhi === ystart && rdir === direction) {
                                if (cur + 2 === this.limit) {
                                    this.yranges[cur + 1] = yend;
                                    return;
                                }
                                this.remove(cur);
                                ystart = yrlo;
                                rdir = this.crosscounts[(cur / 2 | 0)];
                                yrlo = this.yranges[cur + 0];
                                yrhi = this.yranges[cur + 1];
                            }
                            if (yend < yrlo) {
                                this.insert(cur, ystart, yend, direction);
                                return;
                            }
                            if (yend === yrlo && rdir === direction) {
                                this.yranges[cur] = ystart;
                                return;
                            }
                            if (ystart < yrlo) {
                                this.insert(cur, ystart, yrlo, direction);
                                cur += 2;
                                ystart = yrlo;
                            }
                            else if (yrlo < ystart) {
                                this.insert(cur, yrlo, ystart, rdir);
                                cur += 2;
                                yrlo = ystart;
                            }
                            var newdir = rdir + direction;
                            var newend = Math.min(yend, yrhi);
                            if (newdir === 0) {
                                this.remove(cur);
                            }
                            else {
                                this.crosscounts[(cur / 2 | 0)] = newdir;
                                this.yranges[cur++] = ystart;
                                this.yranges[cur++] = newend;
                            }
                            ystart = yrlo = newend;
                            if (yrlo < yrhi) {
                                this.insert(cur, yrlo, yrhi, rdir);
                            }
                        }
                        if (ystart < yend) {
                            this.insert(cur, ystart, yend, direction);
                        }
                    };
                    return NonZero;
                }(sun.awt.geom.Crossings));
                Crossings.NonZero = NonZero;
            })(Crossings = geom.Crossings || (geom.Crossings = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var sun;
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var Curve = (function () {
                function Curve(direction) {
                    this.direction = 0;
                    this.direction = direction;
                }
                Curve.insertMove = function (curves, x, y) {
                    curves.add(new sun.awt.geom.Order0(x, y));
                };
                Curve.insertLine = function (curves, x0, y0, x1, y1) {
                    if (y0 < y1) {
                        curves.add(new sun.awt.geom.Order1(x0, y0, x1, y1, Curve.INCREASING));
                    }
                    else if (y0 > y1) {
                        curves.add(new sun.awt.geom.Order1(x1, y1, x0, y0, Curve.DECREASING));
                    }
                    else {
                    }
                };
                Curve.insertQuad = function (curves, x0, y0, coords) {
                    var y1 = coords[3];
                    if (y0 > y1) {
                        sun.awt.geom.Order2.insert(curves, coords, coords[2], y1, coords[0], coords[1], x0, y0, Curve.DECREASING);
                    }
                    else if (y0 === y1 && y0 === coords[1]) {
                        return;
                    }
                    else {
                        sun.awt.geom.Order2.insert(curves, coords, x0, y0, coords[0], coords[1], coords[2], y1, Curve.INCREASING);
                    }
                };
                Curve.insertCubic = function (curves, x0, y0, coords) {
                    var y1 = coords[5];
                    if (y0 > y1) {
                        sun.awt.geom.Order3.insert(curves, coords, coords[4], y1, coords[2], coords[3], coords[0], coords[1], x0, y0, Curve.DECREASING);
                    }
                    else if (y0 === y1 && y0 === coords[1] && y0 === coords[3]) {
                        return;
                    }
                    else {
                        sun.awt.geom.Order3.insert(curves, coords, x0, y0, coords[0], coords[1], coords[2], coords[3], coords[4], y1, Curve.INCREASING);
                    }
                };
                /**
                 * Calculates the number of times the given path crosses the ray extending
                 * to the right from (px,py). If the point lies on a part of the path, then
                 * no crossings are counted for that intersection. +1 is added for each
                 * crossing where the Y coordinate is increasing -1 is added for each
                 * crossing where the Y coordinate is decreasing The return value is the sum
                 * of all crossings for every segment in the path. The path must start with
                 * a SEG_MOVETO, otherwise an exception is thrown. The caller must check
                 * p[xy] for NaN values. The caller may also reject infinite p[xy] values as
                 * well.
                 */
                Curve.pointCrossingsForPath = function (pi, px, py) {
                    if (pi.isDone()) {
                        return 0;
                    }
                    var coords = new Array(6);
                    if (pi.currentSegment(coords) !== java.awt.geom.PathIterator.SEG_MOVETO) {
                        throw new java.awt.geom.IllegalPathStateException("missing initial moveto in path definition");
                    }
                    pi.next();
                    var movx = coords[0];
                    var movy = coords[1];
                    var curx = movx;
                    var cury = movy;
                    var endx;
                    var endy;
                    var crossings = 0;
                    while ((!pi.isDone())) {
                        switch ((pi.currentSegment(coords))) {
                            case java.awt.geom.PathIterator.SEG_MOVETO:
                                if (cury !== movy) {
                                    crossings += Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                                }
                                movx = curx = coords[0];
                                movy = cury = coords[1];
                                break;
                            case java.awt.geom.PathIterator.SEG_LINETO:
                                endx = coords[0];
                                endy = coords[1];
                                crossings += Curve.pointCrossingsForLine(px, py, curx, cury, endx, endy);
                                curx = endx;
                                cury = endy;
                                break;
                            case java.awt.geom.PathIterator.SEG_QUADTO:
                                endx = coords[2];
                                endy = coords[3];
                                crossings += Curve.pointCrossingsForQuad(px, py, curx, cury, coords[0], coords[1], endx, endy, 0);
                                curx = endx;
                                cury = endy;
                                break;
                            case java.awt.geom.PathIterator.SEG_CUBICTO:
                                endx = coords[4];
                                endy = coords[5];
                                crossings += Curve.pointCrossingsForCubic(px, py, curx, cury, coords[0], coords[1], coords[2], coords[3], endx, endy, 0);
                                curx = endx;
                                cury = endy;
                                break;
                            case java.awt.geom.PathIterator.SEG_CLOSE:
                                if (cury !== movy) {
                                    crossings += Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                                }
                                curx = movx;
                                cury = movy;
                                break;
                        }
                        pi.next();
                    }
                    ;
                    if (cury !== movy) {
                        crossings += Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                    }
                    return crossings;
                };
                /**
                 * Calculates the number of times the line from (x0,y0) to (x1,y1) crosses
                 * the ray extending to the right from (px,py). If the point lies on the
                 * line, then no crossings are recorded. +1 is returned for a crossing where
                 * the Y coordinate is increasing -1 is returned for a crossing where the Y
                 * coordinate is decreasing
                 */
                Curve.pointCrossingsForLine = function (px, py, x0, y0, x1, y1) {
                    if (py < y0 && py < y1)
                        return 0;
                    if (py >= y0 && py >= y1)
                        return 0;
                    if (px >= x0 && px >= x1)
                        return 0;
                    if (px < x0 && px < x1)
                        return (y0 < y1) ? 1 : -1;
                    var xintercept = x0 + (py - y0) * (x1 - x0) / (y1 - y0);
                    if (px >= xintercept)
                        return 0;
                    return (y0 < y1) ? 1 : -1;
                };
                /**
                 * Calculates the number of times the quad from (x0,y0) to (x1,y1) crosses
                 * the ray extending to the right from (px,py). If the point lies on a part
                 * of the curve, then no crossings are counted for that intersection. the
                 * level parameter should be 0 at the top-level call and will count up for
                 * each recursion level to prevent infinite recursion +1 is added for each
                 * crossing where the Y coordinate is increasing -1 is added for each
                 * crossing where the Y coordinate is decreasing
                 */
                Curve.pointCrossingsForQuad = function (px, py, x0, y0, xc, yc, x1, y1, level) {
                    if (py < y0 && py < yc && py < y1)
                        return 0;
                    if (py >= y0 && py >= yc && py >= y1)
                        return 0;
                    if (px >= x0 && px >= xc && px >= x1)
                        return 0;
                    if (px < x0 && px < xc && px < x1) {
                        if (py >= y0) {
                            if (py < y1)
                                return 1;
                        }
                        else {
                            if (py >= y1)
                                return -1;
                        }
                        return 0;
                    }
                    if (level > 52)
                        return Curve.pointCrossingsForLine(px, py, x0, y0, x1, y1);
                    var x0c = (x0 + xc) / 2;
                    var y0c = (y0 + yc) / 2;
                    var xc1 = (xc + x1) / 2;
                    var yc1 = (yc + y1) / 2;
                    xc = (x0c + xc1) / 2;
                    yc = (y0c + yc1) / 2;
                    if ((Number.NaN === xc) || (Number.NaN === yc)) {
                        return 0;
                    }
                    return (Curve.pointCrossingsForQuad(px, py, x0, y0, x0c, y0c, xc, yc, level + 1) + Curve.pointCrossingsForQuad(px, py, xc, yc, xc1, yc1, x1, y1, level + 1));
                };
                /**
                 * Calculates the number of times the cubic from (x0,y0) to (x1,y1) crosses
                 * the ray extending to the right from (px,py). If the point lies on a part
                 * of the curve, then no crossings are counted for that intersection. the
                 * level parameter should be 0 at the top-level call and will count up for
                 * each recursion level to prevent infinite recursion +1 is added for each
                 * crossing where the Y coordinate is increasing -1 is added for each
                 * crossing where the Y coordinate is decreasing
                 */
                Curve.pointCrossingsForCubic = function (px, py, x0, y0, xc0, yc0, xc1, yc1, x1, y1, level) {
                    if (py < y0 && py < yc0 && py < yc1 && py < y1)
                        return 0;
                    if (py >= y0 && py >= yc0 && py >= yc1 && py >= y1)
                        return 0;
                    if (px >= x0 && px >= xc0 && px >= xc1 && px >= x1)
                        return 0;
                    if (px < x0 && px < xc0 && px < xc1 && px < x1) {
                        if (py >= y0) {
                            if (py < y1)
                                return 1;
                        }
                        else {
                            if (py >= y1)
                                return -1;
                        }
                        return 0;
                    }
                    if (level > 52)
                        return Curve.pointCrossingsForLine(px, py, x0, y0, x1, y1);
                    var xmid = (xc0 + xc1) / 2;
                    var ymid = (yc0 + yc1) / 2;
                    xc0 = (x0 + xc0) / 2;
                    yc0 = (y0 + yc0) / 2;
                    xc1 = (xc1 + x1) / 2;
                    yc1 = (yc1 + y1) / 2;
                    var xc0m = (xc0 + xmid) / 2;
                    var yc0m = (yc0 + ymid) / 2;
                    var xmc1 = (xmid + xc1) / 2;
                    var ymc1 = (ymid + yc1) / 2;
                    xmid = (xc0m + xmc1) / 2;
                    ymid = (yc0m + ymc1) / 2;
                    if ((Number.NaN === xmid) || (Number.NaN === ymid)) {
                        return 0;
                    }
                    return (Curve.pointCrossingsForCubic(px, py, x0, y0, xc0, yc0, xc0m, yc0m, xmid, ymid, level + 1) + Curve.pointCrossingsForCubic(px, py, xmid, ymid, xmc1, ymc1, xc1, yc1, x1, y1, level + 1));
                };
                /**
                 * Accumulate the number of times the path crosses the shadow extending to
                 * the right of the rectangle. See the comment for the RECT_INTERSECTS
                 * constant for more complete details. The return value is the sum of all
                 * crossings for both the top and bottom of the shadow for every segment in
                 * the path, or the special value RECT_INTERSECTS if the path ever enters
                 * the interior of the rectangle. The path must start with a SEG_MOVETO,
                 * otherwise an exception is thrown. The caller must check r[xy]{min,max}
                 * for NaN values.
                 */
                Curve.rectCrossingsForPath = function (pi, rxmin, rymin, rxmax, rymax) {
                    if (rxmax <= rxmin || rymax <= rymin) {
                        return 0;
                    }
                    if (pi.isDone()) {
                        return 0;
                    }
                    var coords = new Array(6);
                    if (pi.currentSegment(coords) !== java.awt.geom.PathIterator.SEG_MOVETO) {
                        throw new java.awt.geom.IllegalPathStateException("missing initial moveto in path definition");
                    }
                    pi.next();
                    var curx;
                    var cury;
                    var movx;
                    var movy;
                    var endx;
                    var endy;
                    curx = movx = coords[0];
                    cury = movy = coords[1];
                    var crossings = 0;
                    while ((crossings !== Curve.RECT_INTERSECTS && !pi.isDone())) {
                        switch ((pi.currentSegment(coords))) {
                            case java.awt.geom.PathIterator.SEG_MOVETO:
                                if (curx !== movx || cury !== movy) {
                                    crossings = Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                                }
                                movx = curx = coords[0];
                                movy = cury = coords[1];
                                break;
                            case java.awt.geom.PathIterator.SEG_LINETO:
                                endx = coords[0];
                                endy = coords[1];
                                crossings = Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, endx, endy);
                                curx = endx;
                                cury = endy;
                                break;
                            case java.awt.geom.PathIterator.SEG_QUADTO:
                                endx = coords[2];
                                endy = coords[3];
                                crossings = Curve.rectCrossingsForQuad(crossings, rxmin, rymin, rxmax, rymax, curx, cury, coords[0], coords[1], endx, endy, 0);
                                curx = endx;
                                cury = endy;
                                break;
                            case java.awt.geom.PathIterator.SEG_CUBICTO:
                                endx = coords[4];
                                endy = coords[5];
                                crossings = Curve.rectCrossingsForCubic(crossings, rxmin, rymin, rxmax, rymax, curx, cury, coords[0], coords[1], coords[2], coords[3], endx, endy, 0);
                                curx = endx;
                                cury = endy;
                                break;
                            case java.awt.geom.PathIterator.SEG_CLOSE:
                                if (curx !== movx || cury !== movy) {
                                    crossings = Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                                }
                                curx = movx;
                                cury = movy;
                                break;
                        }
                        pi.next();
                    }
                    ;
                    if (crossings !== Curve.RECT_INTERSECTS && (curx !== movx || cury !== movy)) {
                        crossings = Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                    }
                    return crossings;
                };
                /**
                 * Accumulate the number of times the line crosses the shadow extending to
                 * the right of the rectangle. See the comment for the RECT_INTERSECTS
                 * constant for more complete details.
                 */
                Curve.rectCrossingsForLine = function (crossings, rxmin, rymin, rxmax, rymax, x0, y0, x1, y1) {
                    if (y0 >= rymax && y1 >= rymax)
                        return crossings;
                    if (y0 <= rymin && y1 <= rymin)
                        return crossings;
                    if (x0 <= rxmin && x1 <= rxmin)
                        return crossings;
                    if (x0 >= rxmax && x1 >= rxmax) {
                        if (y0 < y1) {
                            if (y0 <= rymin)
                                crossings++;
                            if (y1 >= rymax)
                                crossings++;
                        }
                        else if (y1 < y0) {
                            if (y1 <= rymin)
                                crossings--;
                            if (y0 >= rymax)
                                crossings--;
                        }
                        return crossings;
                    }
                    if ((x0 > rxmin && x0 < rxmax && y0 > rymin && y0 < rymax) || (x1 > rxmin && x1 < rxmax && y1 > rymin && y1 < rymax)) {
                        return Curve.RECT_INTERSECTS;
                    }
                    var xi0 = x0;
                    if (y0 < rymin) {
                        xi0 += ((rymin - y0) * (x1 - x0) / (y1 - y0));
                    }
                    else if (y0 > rymax) {
                        xi0 += ((rymax - y0) * (x1 - x0) / (y1 - y0));
                    }
                    var xi1 = x1;
                    if (y1 < rymin) {
                        xi1 += ((rymin - y1) * (x0 - x1) / (y0 - y1));
                    }
                    else if (y1 > rymax) {
                        xi1 += ((rymax - y1) * (x0 - x1) / (y0 - y1));
                    }
                    if (xi0 <= rxmin && xi1 <= rxmin)
                        return crossings;
                    if (xi0 >= rxmax && xi1 >= rxmax) {
                        if (y0 < y1) {
                            if (y0 <= rymin)
                                crossings++;
                            if (y1 >= rymax)
                                crossings++;
                        }
                        else if (y1 < y0) {
                            if (y1 <= rymin)
                                crossings--;
                            if (y0 >= rymax)
                                crossings--;
                        }
                        return crossings;
                    }
                    return Curve.RECT_INTERSECTS;
                };
                /**
                 * Accumulate the number of times the quad crosses the shadow extending to
                 * the right of the rectangle. See the comment for the RECT_INTERSECTS
                 * constant for more complete details.
                 */
                Curve.rectCrossingsForQuad = function (crossings, rxmin, rymin, rxmax, rymax, x0, y0, xc, yc, x1, y1, level) {
                    if (y0 >= rymax && yc >= rymax && y1 >= rymax)
                        return crossings;
                    if (y0 <= rymin && yc <= rymin && y1 <= rymin)
                        return crossings;
                    if (x0 <= rxmin && xc <= rxmin && x1 <= rxmin)
                        return crossings;
                    if (x0 >= rxmax && xc >= rxmax && x1 >= rxmax) {
                        if (y0 < y1) {
                            if (y0 <= rymin && y1 > rymin)
                                crossings++;
                            if (y0 < rymax && y1 >= rymax)
                                crossings++;
                        }
                        else if (y1 < y0) {
                            if (y1 <= rymin && y0 > rymin)
                                crossings--;
                            if (y1 < rymax && y0 >= rymax)
                                crossings--;
                        }
                        return crossings;
                    }
                    if ((x0 < rxmax && x0 > rxmin && y0 < rymax && y0 > rymin) || (x1 < rxmax && x1 > rxmin && y1 < rymax && y1 > rymin)) {
                        return Curve.RECT_INTERSECTS;
                    }
                    if (level > 52) {
                        return Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, x0, y0, x1, y1);
                    }
                    var x0c = (x0 + xc) / 2;
                    var y0c = (y0 + yc) / 2;
                    var xc1 = (xc + x1) / 2;
                    var yc1 = (yc + y1) / 2;
                    xc = (x0c + xc1) / 2;
                    yc = (y0c + yc1) / 2;
                    if ((Number.NaN === xc) || (Number.NaN === yc)) {
                        return 0;
                    }
                    crossings = Curve.rectCrossingsForQuad(crossings, rxmin, rymin, rxmax, rymax, x0, y0, x0c, y0c, xc, yc, level + 1);
                    if (crossings !== Curve.RECT_INTERSECTS) {
                        crossings = Curve.rectCrossingsForQuad(crossings, rxmin, rymin, rxmax, rymax, xc, yc, xc1, yc1, x1, y1, level + 1);
                    }
                    return crossings;
                };
                /**
                 * Accumulate the number of times the cubic crosses the shadow extending to
                 * the right of the rectangle. See the comment for the RECT_INTERSECTS
                 * constant for more complete details.
                 */
                Curve.rectCrossingsForCubic = function (crossings, rxmin, rymin, rxmax, rymax, x0, y0, xc0, yc0, xc1, yc1, x1, y1, level) {
                    if (y0 >= rymax && yc0 >= rymax && yc1 >= rymax && y1 >= rymax) {
                        return crossings;
                    }
                    if (y0 <= rymin && yc0 <= rymin && yc1 <= rymin && y1 <= rymin) {
                        return crossings;
                    }
                    if (x0 <= rxmin && xc0 <= rxmin && xc1 <= rxmin && x1 <= rxmin) {
                        return crossings;
                    }
                    if (x0 >= rxmax && xc0 >= rxmax && xc1 >= rxmax && x1 >= rxmax) {
                        if (y0 < y1) {
                            if (y0 <= rymin && y1 > rymin)
                                crossings++;
                            if (y0 < rymax && y1 >= rymax)
                                crossings++;
                        }
                        else if (y1 < y0) {
                            if (y1 <= rymin && y0 > rymin)
                                crossings--;
                            if (y1 < rymax && y0 >= rymax)
                                crossings--;
                        }
                        return crossings;
                    }
                    if ((x0 > rxmin && x0 < rxmax && y0 > rymin && y0 < rymax) || (x1 > rxmin && x1 < rxmax && y1 > rymin && y1 < rymax)) {
                        return Curve.RECT_INTERSECTS;
                    }
                    if (level > 52) {
                        return Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, x0, y0, x1, y1);
                    }
                    var xmid = (xc0 + xc1) / 2;
                    var ymid = (yc0 + yc1) / 2;
                    xc0 = (x0 + xc0) / 2;
                    yc0 = (y0 + yc0) / 2;
                    xc1 = (xc1 + x1) / 2;
                    yc1 = (yc1 + y1) / 2;
                    var xc0m = (xc0 + xmid) / 2;
                    var yc0m = (yc0 + ymid) / 2;
                    var xmc1 = (xmid + xc1) / 2;
                    var ymc1 = (ymid + yc1) / 2;
                    xmid = (xc0m + xmc1) / 2;
                    ymid = (yc0m + ymc1) / 2;
                    if ((Number.NaN === xmid) || (Number.NaN === ymid)) {
                        return 0;
                    }
                    crossings = Curve.rectCrossingsForCubic(crossings, rxmin, rymin, rxmax, rymax, x0, y0, xc0, yc0, xc0m, yc0m, xmid, ymid, level + 1);
                    if (crossings !== Curve.RECT_INTERSECTS) {
                        crossings = Curve.rectCrossingsForCubic(crossings, rxmin, rymin, rxmax, rymax, xmid, ymid, xmc1, ymc1, xc1, yc1, x1, y1, level + 1);
                    }
                    return crossings;
                };
                Curve.prototype.getDirection = function () {
                    return this.direction;
                };
                Curve.prototype.getWithDirection = function (direction) {
                    return (this.direction === direction ? this : this.getReversedCurve());
                };
                Curve.round = function (v) {
                    return v;
                };
                Curve.orderof = function (x1, x2) {
                    if (x1 < x2) {
                        return -1;
                    }
                    if (x1 > x2) {
                        return 1;
                    }
                    return 0;
                };
                Curve.signeddiffbits = function (y1, y2) {
                    return (javaemul.internal.DoubleHelper.doubleToLongBits(y1) - javaemul.internal.DoubleHelper.doubleToLongBits(y2));
                };
                Curve.diffbits = function (y1, y2) {
                    return Math.abs(javaemul.internal.DoubleHelper.doubleToLongBits(y1) - javaemul.internal.DoubleHelper.doubleToLongBits(y2));
                };
                Curve.prev = function (v) {
                    return javaemul.internal.DoubleHelper.longBitsToDouble(javaemul.internal.DoubleHelper.doubleToLongBits(v) - 1);
                };
                Curve.next = function (v) {
                    return javaemul.internal.DoubleHelper.longBitsToDouble(javaemul.internal.DoubleHelper.doubleToLongBits(v) + 1);
                };
                Curve.prototype.toString = function () {
                    return ("Curve[" + this.getOrder() + ", " + ("(" + Curve.round(this.getX0()) + ", " + Curve.round(this.getY0()) + "), ") + this.controlPointString() + ("(" + Curve.round(this.getX1()) + ", " + Curve.round(this.getY1()) + "), ") + (this.direction === Curve.INCREASING ? "D" : "U") + "]");
                };
                Curve.prototype.controlPointString = function () {
                    return "";
                };
                Curve.prototype.crossingsFor = function (x, y) {
                    if (y >= this.getYTop() && y < this.getYBot()) {
                        if (x < this.getXMax() && (x < this.getXMin() || x < this.XforY(y))) {
                            return 1;
                        }
                    }
                    return 0;
                };
                Curve.prototype.accumulateCrossings = function (c) {
                    var xhi = c.getXHi();
                    if (this.getXMin() >= xhi) {
                        return false;
                    }
                    var xlo = c.getXLo();
                    var ylo = c.getYLo();
                    var yhi = c.getYHi();
                    var y0 = this.getYTop();
                    var y1 = this.getYBot();
                    var tstart;
                    var ystart;
                    var tend;
                    var yend;
                    if (y0 < ylo) {
                        if (y1 <= ylo) {
                            return false;
                        }
                        ystart = ylo;
                        tstart = this.TforY(ylo);
                    }
                    else {
                        if (y0 >= yhi) {
                            return false;
                        }
                        ystart = y0;
                        tstart = 0;
                    }
                    if (y1 > yhi) {
                        yend = yhi;
                        tend = this.TforY(yhi);
                    }
                    else {
                        yend = y1;
                        tend = 1;
                    }
                    var hitLo = false;
                    var hitHi = false;
                    while ((true)) {
                        var x = this.XforT(tstart);
                        if (x < xhi) {
                            if (hitHi || x > xlo) {
                                return true;
                            }
                            hitLo = true;
                        }
                        else {
                            if (hitLo) {
                                return true;
                            }
                            hitHi = true;
                        }
                        if (tstart >= tend) {
                            break;
                        }
                        tstart = this.nextVertical(tstart, tend);
                    }
                    ;
                    if (hitLo) {
                        c.record(ystart, yend, this.direction);
                    }
                    return false;
                };
                Curve.prototype.getSubCurve$double$double = function (ystart, yend) {
                    return this.getSubCurve(ystart, yend, this.direction);
                };
                Curve.prototype.getSubCurve = function (ystart, yend, dir) {
                    if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && ((typeof dir === 'number') || dir === null)) {
                        return null;
                    }
                    else if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && dir === undefined) {
                        return this.getSubCurve$double$double(ystart, yend);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Curve.prototype.compareTo = function (that, yrange) {
                    var y0 = yrange[0];
                    var y1 = yrange[1];
                    y1 = Math.min(Math.min(y1, this.getYBot()), that.getYBot());
                    if (y1 <= yrange[0]) {
                        console.error("this == " + this);
                        console.error("that == " + that);
                        console.info("target range = " + yrange[0] + "=>" + yrange[1]);
                        throw new java.lang.InternalError("backstepping from " + yrange[0] + " to " + y1);
                    }
                    yrange[1] = y1;
                    if (this.getXMax() <= that.getXMin()) {
                        if (this.getXMin() === that.getXMax()) {
                            return 0;
                        }
                        return -1;
                    }
                    if (this.getXMin() >= that.getXMax()) {
                        return 1;
                    }
                    var s0 = this.TforY(y0);
                    var ys0 = this.YforT(s0);
                    if (ys0 < y0) {
                        s0 = this.refineTforY(s0, ys0, y0);
                        ys0 = this.YforT(s0);
                    }
                    var s1 = this.TforY(y1);
                    if (this.YforT(s1) < y0) {
                        s1 = this.refineTforY(s1, this.YforT(s1), y0);
                    }
                    var t0 = that.TforY(y0);
                    var yt0 = that.YforT(t0);
                    if (yt0 < y0) {
                        t0 = that.refineTforY(t0, yt0, y0);
                        yt0 = that.YforT(t0);
                    }
                    var t1 = that.TforY(y1);
                    if (that.YforT(t1) < y0) {
                        t1 = that.refineTforY(t1, that.YforT(t1), y0);
                    }
                    var xs0 = this.XforT(s0);
                    var xt0 = that.XforT(t0);
                    var scale = Math.max(Math.abs(y0), Math.abs(y1));
                    var ymin = Math.max(scale * 1.0E-14, 1.0E-300);
                    if (this.fairlyClose(xs0, xt0)) {
                        var bump = ymin;
                        var maxbump = Math.min(ymin * 1.0E13, (y1 - y0) * 0.1);
                        var y = y0 + bump;
                        while ((y <= y1)) {
                            if (this.fairlyClose(this.XforY(y), that.XforY(y))) {
                                if ((bump *= 2) > maxbump) {
                                    bump = maxbump;
                                }
                            }
                            else {
                                y -= bump;
                                while ((true)) {
                                    bump /= 2;
                                    var newy = y + bump;
                                    if (newy <= y) {
                                        break;
                                    }
                                    if (this.fairlyClose(this.XforY(newy), that.XforY(newy))) {
                                        y = newy;
                                    }
                                }
                                ;
                                break;
                            }
                            y += bump;
                        }
                        ;
                        if (y > y0) {
                            if (y < y1) {
                                yrange[1] = y;
                            }
                            return 0;
                        }
                    }
                    if (ymin <= 0) {
                        console.info("ymin = " + ymin);
                    }
                    while ((s0 < s1 && t0 < t1)) {
                        var sh = this.nextVertical(s0, s1);
                        var xsh = this.XforT(sh);
                        var ysh = this.YforT(sh);
                        var th = that.nextVertical(t0, t1);
                        var xth = that.XforT(th);
                        var yth = that.YforT(th);
                        try {
                            if (this.findIntersect(that, yrange, ymin, 0, 0, s0, xs0, ys0, sh, xsh, ysh, t0, xt0, yt0, th, xth, yth)) {
                                break;
                            }
                        }
                        catch (t) {
                            console.error("Error: " + t);
                            console.error("y range was " + yrange[0] + "=>" + yrange[1]);
                            console.error("s y range is " + ys0 + "=>" + ysh);
                            console.error("t y range is " + yt0 + "=>" + yth);
                            console.error("ymin is " + ymin);
                            return 0;
                        }
                        ;
                        if (ysh < yth) {
                            if (ysh > yrange[0]) {
                                if (ysh < yrange[1]) {
                                    yrange[1] = ysh;
                                }
                                break;
                            }
                            s0 = sh;
                            xs0 = xsh;
                            ys0 = ysh;
                        }
                        else {
                            if (yth > yrange[0]) {
                                if (yth < yrange[1]) {
                                    yrange[1] = yth;
                                }
                                break;
                            }
                            t0 = th;
                            xt0 = xth;
                            yt0 = yth;
                        }
                    }
                    ;
                    var ymid = (yrange[0] + yrange[1]) / 2;
                    return Curve.orderof(this.XforY(ymid), that.XforY(ymid));
                };
                Curve.prototype.findIntersect = function (that, yrange, ymin, slevel, tlevel, s0, xs0, ys0, s1, xs1, ys1, t0, xt0, yt0, t1, xt1, yt1) {
                    if (ys0 > yt1 || yt0 > ys1) {
                        return false;
                    }
                    if (Math.min(xs0, xs1) > Math.max(xt0, xt1) || Math.max(xs0, xs1) < Math.min(xt0, xt1)) {
                        return false;
                    }
                    if (s1 - s0 > Curve.TMIN) {
                        var s = (s0 + s1) / 2;
                        var xs = this.XforT(s);
                        var ys = this.YforT(s);
                        if (s === s0 || s === s1) {
                            console.info("s0 = " + s0);
                            console.info("s1 = " + s1);
                            throw new java.lang.InternalError("no s progress!");
                        }
                        if (t1 - t0 > Curve.TMIN) {
                            var t = (t0 + t1) / 2;
                            var xt = that.XforT(t);
                            var yt = that.YforT(t);
                            if (t === t0 || t === t1) {
                                console.info("t0 = " + t0);
                                console.info("t1 = " + t1);
                                throw new java.lang.InternalError("no t progress!");
                            }
                            if (ys >= yt0 && yt >= ys0) {
                                if (this.findIntersect(that, yrange, ymin, slevel + 1, tlevel + 1, s0, xs0, ys0, s, xs, ys, t0, xt0, yt0, t, xt, yt)) {
                                    return true;
                                }
                            }
                            if (ys >= yt) {
                                if (this.findIntersect(that, yrange, ymin, slevel + 1, tlevel + 1, s0, xs0, ys0, s, xs, ys, t, xt, yt, t1, xt1, yt1)) {
                                    return true;
                                }
                            }
                            if (yt >= ys) {
                                if (this.findIntersect(that, yrange, ymin, slevel + 1, tlevel + 1, s, xs, ys, s1, xs1, ys1, t0, xt0, yt0, t, xt, yt)) {
                                    return true;
                                }
                            }
                            if (ys1 >= yt && yt1 >= ys) {
                                if (this.findIntersect(that, yrange, ymin, slevel + 1, tlevel + 1, s, xs, ys, s1, xs1, ys1, t, xt, yt, t1, xt1, yt1)) {
                                    return true;
                                }
                            }
                        }
                        else {
                            if (ys >= yt0) {
                                if (this.findIntersect(that, yrange, ymin, slevel + 1, tlevel, s0, xs0, ys0, s, xs, ys, t0, xt0, yt0, t1, xt1, yt1)) {
                                    return true;
                                }
                            }
                            if (yt1 >= ys) {
                                if (this.findIntersect(that, yrange, ymin, slevel + 1, tlevel, s, xs, ys, s1, xs1, ys1, t0, xt0, yt0, t1, xt1, yt1)) {
                                    return true;
                                }
                            }
                        }
                    }
                    else if (t1 - t0 > Curve.TMIN) {
                        var t = (t0 + t1) / 2;
                        var xt = that.XforT(t);
                        var yt = that.YforT(t);
                        if (t === t0 || t === t1) {
                            console.info("t0 = " + t0);
                            console.info("t1 = " + t1);
                            throw new java.lang.InternalError("no t progress!");
                        }
                        if (yt >= ys0) {
                            if (this.findIntersect(that, yrange, ymin, slevel, tlevel + 1, s0, xs0, ys0, s1, xs1, ys1, t0, xt0, yt0, t, xt, yt)) {
                                return true;
                            }
                        }
                        if (ys1 >= yt) {
                            if (this.findIntersect(that, yrange, ymin, slevel, tlevel + 1, s0, xs0, ys0, s1, xs1, ys1, t, xt, yt, t1, xt1, yt1)) {
                                return true;
                            }
                        }
                    }
                    else {
                        var xlk = xs1 - xs0;
                        var ylk = ys1 - ys0;
                        var xnm = xt1 - xt0;
                        var ynm = yt1 - yt0;
                        var xmk = xt0 - xs0;
                        var ymk = yt0 - ys0;
                        var det = xnm * ylk - ynm * xlk;
                        if (det !== 0) {
                            var detinv = 1 / det;
                            var s = (xnm * ymk - ynm * xmk) * detinv;
                            var t = (xlk * ymk - ylk * xmk) * detinv;
                            if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
                                s = s0 + s * (s1 - s0);
                                t = t0 + t * (t1 - t0);
                                if (s < 0 || s > 1 || t < 0 || t > 1) {
                                    console.info("Uh oh!");
                                }
                                var y = (this.YforT(s) + that.YforT(t)) / 2;
                                if (y <= yrange[1] && y > yrange[0]) {
                                    yrange[1] = y;
                                    return true;
                                }
                            }
                        }
                    }
                    return false;
                };
                Curve.prototype.refineTforY = function (t0, yt0, y0) {
                    var t1 = 1;
                    while ((true)) {
                        var th = (t0 + t1) / 2;
                        if (th === t0 || th === t1) {
                            return t1;
                        }
                        var y = this.YforT(th);
                        if (y < y0) {
                            t0 = th;
                            yt0 = y;
                        }
                        else if (y > y0) {
                            t1 = th;
                        }
                        else {
                            return t1;
                        }
                    }
                    ;
                };
                Curve.prototype.fairlyClose = function (v1, v2) {
                    return (Math.abs(v1 - v2) < Math.max(Math.abs(v1), Math.abs(v2)) * 1.0E-10);
                };
                Curve.INCREASING = 1;
                Curve.DECREASING = -1;
                /**
                 * The rectangle intersection test counts the number of times that the path
                 * crosses through the shadow that the rectangle projects to the right
                 * towards (x => +INFINITY).
                 *
                 * During processing of the path it actually counts every time the path
                 * crosses either or both of the top and bottom edges of that shadow. If the
                 * path enters from the top, the count is incremented. If it then exits back
                 * through the top, the same way it came in, the count is decremented and
                 * there is no impact on the winding count. If, instead, the path exits out
                 * the bottom, then the count is incremented again and a full pass through
                 * the shadow is indicated by the winding count having been incremented by
                 * 2.
                 *
                 * Thus, the winding count that it accumulates is actually double the real
                 * winding count. Since the path is continuous, the final answer should be a
                 * multiple of 2, otherwise there is a logic error somewhere.
                 *
                 * If the path ever has a direct hit on the rectangle, then a special value
                 * is returned. This special value terminates all ongoing accumulation on up
                 * through the call chain and ends up getting returned to the calling
                 * function which can then produce an answer directly. For intersection
                 * tests, the answer is always "true" if the path intersects the rectangle.
                 * For containment tests, the answer is always "false" if the path
                 * intersects the rectangle. Thus, no further processing is ever needed if
                 * an intersection occurs.
                 */
                Curve.RECT_INTERSECTS = -2147483648;
                Curve.TMIN = 0.001;
                return Curve;
            }());
            geom.Curve = Curve;
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var sun;
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var CurveLink = (function () {
                function CurveLink(curve, ystart, yend, etag) {
                    this.ytop = 0;
                    this.ybot = 0;
                    this.etag = 0;
                    this.curve = curve;
                    this.ytop = ystart;
                    this.ybot = yend;
                    this.etag = etag;
                    if (this.ytop < curve.getYTop() || this.ybot > curve.getYBot()) {
                        throw new java.lang.InternalError("bad curvelink [" + this.ytop + "=>" + this.ybot + "] for " + curve);
                    }
                }
                CurveLink.prototype.absorb$sun_awt_geom_CurveLink = function (link) {
                    return this.absorb(link.curve, link.ytop, link.ybot, link.etag);
                };
                CurveLink.prototype.absorb = function (curve, ystart, yend, etag) {
                    var _this = this;
                    if (((curve != null && curve instanceof sun.awt.geom.Curve) || curve === null) && ((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && ((typeof etag === 'number') || etag === null)) {
                        return (function () {
                            if (_this.curve !== curve || _this.etag !== etag || _this.ybot < ystart || _this.ytop > yend) {
                                return false;
                            }
                            if (ystart < curve.getYTop() || yend > curve.getYBot()) {
                                throw new java.lang.InternalError("bad curvelink [" + ystart + "=>" + yend + "] for " + curve);
                            }
                            _this.ytop = Math.min(_this.ytop, ystart);
                            _this.ybot = Math.max(_this.ybot, yend);
                            return true;
                        })();
                    }
                    else if (((curve != null && curve instanceof sun.awt.geom.CurveLink) || curve === null) && ystart === undefined && yend === undefined && etag === undefined) {
                        return this.absorb$sun_awt_geom_CurveLink(curve);
                    }
                    else
                        throw new Error('invalid overload');
                };
                CurveLink.prototype.isEmpty = function () {
                    return (this.ytop === this.ybot);
                };
                CurveLink.prototype.getCurve = function () {
                    return this.curve;
                };
                CurveLink.prototype.getSubCurve = function () {
                    if (this.ytop === this.curve.getYTop() && this.ybot === this.curve.getYBot()) {
                        return this.curve.getWithDirection(this.etag);
                    }
                    return this.curve.getSubCurve(this.ytop, this.ybot, this.etag);
                };
                CurveLink.prototype.getMoveto = function () {
                    return new sun.awt.geom.Order0(this.getXTop(), this.getYTop());
                };
                CurveLink.prototype.getXTop = function () {
                    return this.curve.XforY(this.ytop);
                };
                CurveLink.prototype.getYTop = function () {
                    return this.ytop;
                };
                CurveLink.prototype.getXBot = function () {
                    return this.curve.XforY(this.ybot);
                };
                CurveLink.prototype.getYBot = function () {
                    return this.ybot;
                };
                CurveLink.prototype.getX = function () {
                    return this.curve.XforY(this.ytop);
                };
                CurveLink.prototype.getEdgeTag = function () {
                    return this.etag;
                };
                CurveLink.prototype.setNext = function (link) {
                    this.next = link;
                };
                CurveLink.prototype.getNext = function () {
                    return this.next;
                };
                return CurveLink;
            }());
            geom.CurveLink = CurveLink;
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var sun;
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var Edge = (function () {
                function Edge(c, ctag, etag) {
                    if (etag === void 0) { etag = sun.awt.geom.AreaOp.ETAG_IGNORE; }
                    this.ctag = 0;
                    this.etag = 0;
                    this.activey = 0;
                    this.equivalence = 0;
                    this.lastResult = 0;
                    this.lastLimit = 0;
                    this.curve = c;
                    this.ctag = ctag;
                    this.etag = etag;
                }
                Edge.prototype.getCurve = function () {
                    return this.curve;
                };
                Edge.prototype.getCurveTag = function () {
                    return this.ctag;
                };
                Edge.prototype.getEdgeTag = function () {
                    return this.etag;
                };
                Edge.prototype.setEdgeTag = function (etag) {
                    this.etag = etag;
                };
                Edge.prototype.getEquivalence = function () {
                    return this.equivalence;
                };
                Edge.prototype.setEquivalence = function (eq) {
                    this.equivalence = eq;
                };
                Edge.prototype.compareTo = function (other, yrange) {
                    if (other === this.lastEdge && yrange[0] < this.lastLimit) {
                        if (yrange[1] > this.lastLimit) {
                            yrange[1] = this.lastLimit;
                        }
                        return this.lastResult;
                    }
                    if (this === other.lastEdge && yrange[0] < other.lastLimit) {
                        if (yrange[1] > other.lastLimit) {
                            yrange[1] = other.lastLimit;
                        }
                        return 0 - other.lastResult;
                    }
                    var ret = this.curve.compareTo(other.curve, yrange);
                    this.lastEdge = other;
                    this.lastLimit = yrange[1];
                    this.lastResult = ret;
                    return ret;
                };
                Edge.prototype.record = function (yend, etag) {
                    this.activey = yend;
                    this.etag = etag;
                };
                Edge.prototype.isActiveFor = function (y, etag) {
                    return (this.etag === etag && this.activey >= y);
                };
                Edge.prototype.toString = function () {
                    return ("Edge[" + this.curve + ", " + (this.ctag === sun.awt.geom.AreaOp.CTAG_LEFT ? "L" : "R") + ", " + (this.etag === sun.awt.geom.AreaOp.ETAG_ENTER ? "I" : (this.etag === sun.awt.geom.AreaOp.ETAG_EXIT ? "O" : "N")) + "]");
                };
                Edge.INIT_PARTS = 4;
                Edge.GROW_PARTS = 10;
                return Edge;
            }());
            geom.Edge = Edge;
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var test;
(function (test) {
    var Test = (function () {
        function Test() {
        }
        Test.assertEquals = function (o1, o2) {
            if (!(o1 === o2)) {
                throw new Error("invalid assertion: " + o1 + "!=" + o2);
            }
        };
        Test.assertTrue = function (b) {
            if (!b) {
                throw new Error("invalid assertion");
            }
        };
        Test.assertFalse = function (b) {
            if (b) {
                throw new Error("invalid assertion");
            }
        };
        Test.test = function () {
            try {
                Test.testList();
                Test.testMap();
                Test.testSet();
                Test.testString();
                Test.testIO();
                Test.testAwtGeom();
                var result = document.getElementById("result");
                if (result != null) {
                    result.innerHTML = "Success!";
                }
            }
            catch (e) {
                console.error(e);
                var result = document.getElementById("result");
                if (result != null) {
                    result.innerHTML = "Failure: " + e.message;
                }
            }
            ;
        };
        Test.testList = function () {
            console.info("testing lists");
            var l = new java.util.ArrayList();
            l.add("a");
            l.add("b");
            l.add("c");
            Test.assertEquals(l.toString(), "[a, b, c]");
            Test.assertEquals(l.subList(1, 3).toString(), "[b, c]");
            Test.assertEquals(l.remove("b"), true);
            Test.assertEquals(l.remove("d"), false);
            Test.assertEquals(l.remove(1), "c");
            l.add("c");
            Test.assertEquals(l.toString(), "[a, c]");
            Test.assertEquals(l.size(), 2);
            Test.assertEquals(l.get(1), "c");
            Test.assertEquals(l.indexOf("a"), 0);
            var res = "";
            for (var index128 = l.iterator(); index128.hasNext();) {
                var s = index128.next();
                {
                    res += s;
                }
            }
            Test.assertEquals("ac", res);
            var it = l.iterator();
            Test.assertTrue(it.hasNext());
            Test.assertEquals("a", it.next());
            Test.assertTrue(it.hasNext());
            Test.assertEquals("c", it.next());
            Test.assertFalse(it.hasNext());
            console.info("end testing lists");
        };
        Test.testSet = function () {
            console.info("testing sets");
            var s = new java.util.HashSet();
            s.add("a");
            s.add("a");
            s.add("b");
            s.add("c");
            s.add("c");
            Test.assertEquals(s.toString(), "[a, b, c]");
            s.remove("b");
            Test.assertTrue(s.contains("a"));
            Test.assertTrue(s.contains("c"));
            Test.assertFalse(s.contains("b"));
            Test.assertEquals(s.size(), 2);
            console.info("end testing sets");
        };
        Test.testMap = function () {
            console.info("testing maps");
            var m = new java.util.HashMap();
            m.put("a", "aa");
            m.put("b", "bb");
            m.put("c", "cc");
            Test.assertEquals(m.size(), 3);
            Test.assertEquals("bb", m.get("b"));
            m.remove("aa");
            Test.assertEquals(m.size(), 3);
            m.remove("a");
            Test.assertEquals(m.size(), 2);
            console.info("end testing maps");
        };
        Test.testString = function () {
            console.info("testing strings");
            var sb = new java.lang.StringBuilder();
            sb.append(true);
            sb.append('c');
            sb.append("test");
            sb.deleteCharAt(sb.length() - 1);
            Test.assertEquals("truectes", sb.toString());
            sb.append("abc", 0, 1);
            Test.assertEquals("truectesa", sb.toString());
            var sb2 = new java.lang.StringBuffer();
            sb2.append(true);
            sb2.append('c');
            sb2.append("test");
            sb2.deleteCharAt(sb2.length() - 1);
            Test.assertEquals("truectes", sb2.toString());
            console.info("end testing strings");
        };
        Test.testIO = function () {
            console.info("testing io");
            localStorage.clear();
            var s = new java.io.ByteArrayInputStream(/* getBytes */ ("abc").split('').map(function (s) { return s.charCodeAt(0); }));
            Test.assertEquals(javaemul.internal.CharacterHelper.getNumericValue('a'), s.read());
            var dir = new java.io.File("/a/b/c");
            Test.assertFalse(dir.exists());
            dir.mkdirs();
            Test.assertTrue(dir.exists());
            var f = new java.io.File(dir, "test.txt");
            Test.assertFalse(f.exists());
            f.createNewFile();
            Test.assertTrue(f.exists());
            var fw = new java.io.FileWriter(f);
            fw.append("abc");
            fw.close();
            var reader = new java.io.BufferedReader(new java.io.FileReader(f));
            var line = reader.readLine();
            reader.close();
            Test.assertEquals("abc", line);
            console.info("end testing io");
        };
        Test.testAwtGeom = function () {
            console.info("testing awt.geom");
            var r = new java.awt.geom.Rectangle2D.Double(0, 0, 10, 10);
            var p1 = new java.awt.geom.Point2D.Double(5, 5);
            var p2 = new java.awt.geom.Point2D.Double(5, 50);
            Test.assertTrue(r.contains(p1));
            Test.assertFalse(r.contains(p2));
            console.info("end testing awt.geom");
        };
        return Test;
    }());
    test.Test = Test;
})(test || (test = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        var Button = (function (_super) {
            __extends(Button, _super);
            function Button(label) {
                _super.call(this);
                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.HTMLComponent"] });
                this.label = label;
                this.actionCommand = label;
            }
            Button.prototype.bind = function (id) {
                this.button = document.getElementById(id);
                this.button.innerHTML = this.label;
            };
            Button.prototype.init = function () {
                if (this.button != null) {
                    return;
                }
                this.button = document.createElement("button");
                this.button.innerHTML = this.label;
                this.button.id = "cmp" + java.applet.Applet.CURRENT_ID++;
                if (this.background != null) {
                    this.button.style.backgroundColor = this.background.toHTML();
                }
                this.initActionListener();
            };
            Button.prototype.initActionListener = function () {
                var _this = this;
                if (this.actionListener != null) {
                    this.button.onclick = function (e) {
                        console.log("button clicked: " + _this.actionCommand);
                        _this.actionListener.actionPerformed(new java.awt.event.ActionEvent(_this, _this.actionCommand));
                        return e;
                    };
                }
            };
            Button.prototype.getHTMLElement = function () {
                if (this.button == null) {
                    this.init();
                }
                return this.button;
            };
            Button.prototype.addActionListener = function (actionListener) {
                this.actionListener = actionListener;
                if (this.button != null) {
                    this.initActionListener();
                }
            };
            Button.prototype.setBackground = function (background) {
                this.background = background;
            };
            return Button;
        }(java.awt.Component));
        awt.Button = Button;
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        var TextField = (function (_super) {
            __extends(TextField, _super);
            function TextField(cols) {
                _super.call(this);
                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.HTMLComponent"] });
            }
            TextField.prototype.init = function () {
                if (this.input != null) {
                    return;
                }
                this.input = document.createElement("input");
                this.input.setAttribute("type", "text");
                this.input.id = "cmp" + java.applet.Applet.CURRENT_ID++;
                this.initActionListener();
            };
            TextField.prototype.initActionListener = function () {
                var _this = this;
                if (this.actionListener != null) {
                    this.input.onclick = function (e) {
                        _this.actionListener.actionPerformed(new java.awt.event.ActionEvent(_this, null));
                        return e;
                    };
                }
            };
            TextField.prototype.bind = function (id) {
                this.input = document.getElementById(id);
            };
            TextField.prototype.getHTMLElement = function () {
                if (this.input == null) {
                    this.init();
                }
                return this.input;
            };
            TextField.prototype.addActionListener = function (actionListener) {
                this.actionListener = actionListener;
                if (this.input != null) {
                    this.initActionListener();
                }
            };
            TextField.prototype.setText = function (text) {
                this.input.value = text;
            };
            TextField.prototype.getText = function () {
                return this.input.value;
            };
            return TextField;
        }(java.awt.Component));
        awt.TextField = TextField;
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        /**
         * The <code>Dimension</code> class encapsulates the width and
         * height of a component (in integer precision) in a single object.
         * The class is
         * associated with certain properties of components. Several methods
         * defined by the <code>Component</code> class and the
         * <code>LayoutManager</code> interface return a
         * <code>Dimension</code> object.
         * <p>
         * Normally the values of <code>width</code>
         * and <code>height</code> are non-negative integers.
         * The constructors that allow you to create a dimension do
         * not prevent you from setting a negative value for these properties.
         * If the value of <code>width</code> or <code>height</code> is
         * negative, the behavior of some methods defined by other objects is
         * undefined.
         *
         * @author      Sami Shaio
         * @author      Arthur van Hoff
         * @see         java.awt.Component
         * @see         java.awt.LayoutManager
         * @since       1.0
         */
        var Dimension = (function (_super) {
            __extends(Dimension, _super);
            /**
             * Constructs a <code>Dimension</code> and initializes
             * it to the specified width and specified height.
             *
             * @param width the specified width
             * @param height the specified height
             */
            function Dimension(width, height) {
                var _this = this;
                if (((typeof width === 'number') || width === null) && ((typeof height === 'number') || height === null)) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.io.Serializable"] });
                    this.width = 0;
                    this.height = 0;
                    (function () {
                        _this.width = width;
                        _this.height = height;
                    })();
                }
                else if (((width != null && width instanceof java.awt.Dimension) || width === null) && height === undefined) {
                    var d = width;
                    {
                        var width = d.width;
                        var height = d.height;
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.io.Serializable"] });
                        this.width = 0;
                        this.height = 0;
                        (function () {
                            _this.width = width;
                            _this.height = height;
                        })();
                    }
                    (function () {
                    })();
                }
                else if (width === undefined && height === undefined) {
                    {
                        var width = 0;
                        var height = 0;
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.io.Serializable"] });
                        this.width = 0;
                        this.height = 0;
                        (function () {
                            _this.width = width;
                            _this.height = height;
                        })();
                    }
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * {@inheritDoc}
             * @since 1.2
             */
            Dimension.prototype.getWidth = function () {
                return this.width;
            };
            /**
             * {@inheritDoc}
             * @since 1.2
             */
            Dimension.prototype.getHeight = function () {
                return this.height;
            };
            /**
             * Sets the size of this <code>Dimension</code> object to
             * the specified width and height in double precision.
             * Note that if <code>width</code> or <code>height</code>
             * are larger than <code>Integer.MAX_VALUE</code>, they will
             * be reset to <code>Integer.MAX_VALUE</code>.
             *
             * @param width  the new width for the <code>Dimension</code> object
             * @param height the new height for the <code>Dimension</code> object
             * @since 1.2
             */
            Dimension.prototype.setSize$double$double = function (width, height) {
                this.width = (Math.ceil(width) | 0);
                this.height = (Math.ceil(height) | 0);
            };
            /**
             * Gets the size of this <code>Dimension</code> object.
             * This method is included for completeness, to parallel the
             * <code>getSize</code> method defined by <code>Component</code>.
             *
             * @return   the size of this dimension, a new instance of
             * <code>Dimension</code> with the same width and height
             * @see      java.awt.Dimension#setSize
             * @see      java.awt.Component#getSize
             * @since    1.1
             */
            Dimension.prototype.getSize = function () {
                return new Dimension(this.width, this.height);
            };
            /**
             * Sets the size of this <code>Dimension</code> object to the specified size.
             * This method is included for completeness, to parallel the
             * <code>setSize</code> method defined by <code>Component</code>.
             * @param    d  the new size for this <code>Dimension</code> object
             * @see      java.awt.Dimension#getSize
             * @see      java.awt.Component#setSize
             * @since    1.1
             */
            Dimension.prototype.setSize$java_awt_Dimension = function (d) {
                this.setSize(d.width, d.height);
            };
            /**
             * Sets the size of this <code>Dimension</code> object
             * to the specified width and height.
             * This method is included for completeness, to parallel the
             * <code>setSize</code> method defined by <code>Component</code>.
             *
             * @param    width   the new width for this <code>Dimension</code> object
             * @param    height  the new height for this <code>Dimension</code> object
             * @see      java.awt.Dimension#getSize
             * @see      java.awt.Component#setSize
             * @since    1.1
             */
            Dimension.prototype.setSize = function (width, height) {
                var _this = this;
                if (((typeof width === 'number') || width === null) && ((typeof height === 'number') || height === null)) {
                    return (function () {
                        _this.width = width;
                        _this.height = height;
                    })();
                }
                else if (((typeof width === 'number') || width === null) && ((typeof height === 'number') || height === null)) {
                    return this.setSize$double$double(width, height);
                }
                else if (((width != null && width instanceof java.awt.Dimension) || width === null) && height === undefined) {
                    return this.setSize$java_awt_Dimension(width);
                }
                else if (((width != null && width instanceof java.awt.geom.Dimension2D) || width === null) && height === undefined) {
                    return this.setSize$java_awt_geom_Dimension2D(width);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Checks whether two dimension objects have equal values.
             */
            Dimension.prototype.equals = function (obj) {
                if (obj != null && obj instanceof java.awt.Dimension) {
                    var d = obj;
                    return (this.width === d.width) && (this.height === d.height);
                }
                return false;
            };
            /**
             * Returns the hash code for this <code>Dimension</code>.
             *
             * @return    a hash code for this <code>Dimension</code>
             */
            Dimension.prototype.hashCode = function () {
                var sum = this.width + this.height;
                return (sum * (sum + 1) / 2 | 0) + this.width;
            };
            /**
             * Returns a string representation of the values of this
             * <code>Dimension</code> object's <code>height</code> and
             * <code>width</code> fields. This method is intended to be used only
             * for debugging purposes, and the content and format of the returned
             * string may vary between implementations. The returned string may be
             * empty but may not be <code>null</code>.
             *
             * @return  a string representation of this <code>Dimension</code>
             * object
             */
            Dimension.prototype.toString = function () {
                return "java.awt.Dimension" + "[width=" + this.width + ",height=" + this.height + "]";
            };
            Dimension.serialVersionUID = 4723952579491349524;
            return Dimension;
        }(java.awt.geom.Dimension2D));
        awt.Dimension = Dimension;
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The {@code Path2D} class provides a simple, yet flexible shape which
             * represents an arbitrary geometric path. It can fully represent any path which
             * can be iterated by the {@link PathIterator} interface including all of its
             * segment types and winding rules and it implements all of the basic hit
             * testing methods of the {@link Shape} interface.
             * <p>
             * Use {@link Path2D.Float} when dealing with data that can be represented and
             * used with floating point precision. Use {@link Path2D.Double} for data that
             * requires the accuracy or range of double precision.
             * <p>
             * {@code Path2D} provides exactly those facilities required for basic
             * construction and management of a geometric path and implementation of the
             * above interfaces with little added interpretation. If it is useful to
             * manipulate the interiors of closed geometric shapes beyond simple hit testing
             * then the {@link Area} class provides additional capabilities specifically
             * targeted at closed figures. While both classes nominally implement the
             * {@code Shape} interface, they differ in purpose and together they provide two
             * useful views of a geometric shape where {@code Path2D} deals primarily with a
             * trajectory formed by path segments and {@code Area} deals more with
             * interpretation and manipulation of enclosed regions of 2D geometric space.
             * <p>
             * The {@link PathIterator} interface has more detailed descriptions of the
             * types of segments that make up a path and the winding rules that control how
             * to determine which regions are inside or outside the path.
             *
             * @author Jim Graham
             * @since 1.6
             */
            var Path2D = (function () {
                /**
                 * Constructs a new {@code Path2D} object from the given specified initial
                 * values. This method is only intended for internal use and should not be
                 * made public if the other constructors for this class are ever exposed.
                 *
                 * @param rule
                 * the winding rule
                 * @param initialTypes
                 * the size to make the initial array to store the path segment
                 * types
                 * @since 1.6
                 */
                function Path2D(rule, initialTypes) {
                    var _this = this;
                    if (((typeof rule === 'number') || rule === null) && ((typeof initialTypes === 'number') || initialTypes === null)) {
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable"] });
                        this.numTypes = 0;
                        this.numCoords = 0;
                        this.windingRule = 0;
                        (function () {
                            _this.setWindingRule(rule);
                            _this.pointTypes = new Array(initialTypes);
                        })();
                    }
                    else if (rule === undefined && initialTypes === undefined) {
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable"] });
                        this.numTypes = 0;
                        this.numCoords = 0;
                        this.windingRule = 0;
                        (function () {
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                }
                Path2D.WIND_EVEN_ODD_$LI$ = function () { if (Path2D.WIND_EVEN_ODD == null)
                    Path2D.WIND_EVEN_ODD = java.awt.geom.PathIterator.WIND_EVEN_ODD; return Path2D.WIND_EVEN_ODD; };
                ;
                Path2D.WIND_NON_ZERO_$LI$ = function () { if (Path2D.WIND_NON_ZERO == null)
                    Path2D.WIND_NON_ZERO = java.awt.geom.PathIterator.WIND_NON_ZERO; return Path2D.WIND_NON_ZERO; };
                ;
                Path2D.SEG_MOVETO_$LI$ = function () { if (Path2D.SEG_MOVETO == null)
                    Path2D.SEG_MOVETO = (java.awt.geom.PathIterator.SEG_MOVETO | 0); return Path2D.SEG_MOVETO; };
                ;
                Path2D.SEG_LINETO_$LI$ = function () { if (Path2D.SEG_LINETO == null)
                    Path2D.SEG_LINETO = (java.awt.geom.PathIterator.SEG_LINETO | 0); return Path2D.SEG_LINETO; };
                ;
                Path2D.SEG_QUADTO_$LI$ = function () { if (Path2D.SEG_QUADTO == null)
                    Path2D.SEG_QUADTO = (java.awt.geom.PathIterator.SEG_QUADTO | 0); return Path2D.SEG_QUADTO; };
                ;
                Path2D.SEG_CUBICTO_$LI$ = function () { if (Path2D.SEG_CUBICTO == null)
                    Path2D.SEG_CUBICTO = (java.awt.geom.PathIterator.SEG_CUBICTO | 0); return Path2D.SEG_CUBICTO; };
                ;
                Path2D.SEG_CLOSE_$LI$ = function () { if (Path2D.SEG_CLOSE == null)
                    Path2D.SEG_CLOSE = (java.awt.geom.PathIterator.SEG_CLOSE | 0); return Path2D.SEG_CLOSE; };
                ;
                Path2D.prototype.append$float$float = function (x, y) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                Path2D.prototype.append$double$double = function (x, y) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Adds a point to the path by moving to the specified coordinates
                 * specified in float precision.
                 * <p>
                 * This method provides a single precision variant of the double
                 * precision {@code moveTo()} method on the base {@code Path2D} class.
                 *
                 * @param x
                 * the specified X coordinate
                 * @param y
                 * the specified Y coordinate
                 * @see Path2D#moveTo
                 * @since 1.6
                 */
                Path2D.prototype.moveTo = function (x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.moveTo$double$double(x, y);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Adds a point to the path by moving to the specified coordinates specified
                 * in double precision.
                 *
                 * @param x
                 * the specified X coordinate
                 * @param y
                 * the specified Y coordinate
                 * @since 1.6
                 */
                Path2D.prototype.moveTo$double$double = function (x, y) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Adds a point to the path by drawing a straight line from the current
                 * coordinates to the new specified coordinates specified in float
                 * precision.
                 * <p>
                 * This method provides a single precision variant of the double
                 * precision {@code lineTo()} method on the base {@code Path2D} class.
                 *
                 * @param x
                 * the specified X coordinate
                 * @param y
                 * the specified Y coordinate
                 * @see Path2D#lineTo
                 * @since 1.6
                 */
                Path2D.prototype.lineTo = function (x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.lineTo$double$double(x, y);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Adds a point to the path by drawing a straight line from the current
                 * coordinates to the new specified coordinates specified in double
                 * precision.
                 *
                 * @param x
                 * the specified X coordinate
                 * @param y
                 * the specified Y coordinate
                 * @since 1.6
                 */
                Path2D.prototype.lineTo$double$double = function (x, y) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Adds a curved segment, defined by two new points, to the path by
                 * drawing a Quadratic curve that intersects both the current
                 * coordinates and the specified coordinates {@code (x2,y2)}, using the
                 * specified point {@code (x1,y1)} as a quadratic parametric control
                 * point. All coordinates are specified in float precision.
                 * <p>
                 * This method provides a single precision variant of the double
                 * precision {@code quadTo()} method on the base {@code Path2D} class.
                 *
                 * @param x1
                 * the X coordinate of the quadratic control point
                 * @param y1
                 * the Y coordinate of the quadratic control point
                 * @param x2
                 * the X coordinate of the final end point
                 * @param y2
                 * the Y coordinate of the final end point
                 * @see Path2D#quadTo
                 * @since 1.6
                 */
                Path2D.prototype.quadTo = function (x1, y1, x2, y2) {
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        return this.quadTo$double$double$double$double(x1, y1, x2, y2);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Adds a curved segment, defined by two new points, to the path by drawing
                 * a Quadratic curve that intersects both the current coordinates and the
                 * specified coordinates {@code (x2,y2)}, using the specified point
                 * {@code (x1,y1)} as a quadratic parametric control point. All coordinates
                 * are specified in double precision.
                 *
                 * @param x1
                 * the X coordinate of the quadratic control point
                 * @param y1
                 * the Y coordinate of the quadratic control point
                 * @param x2
                 * the X coordinate of the final end point
                 * @param y2
                 * the Y coordinate of the final end point
                 * @since 1.6
                 */
                Path2D.prototype.quadTo$double$double$double$double = function (x1, y1, x2, y2) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Adds a curved segment, defined by three new points, to the path by
                 * drawing a B&eacute;zier curve that intersects both the current
                 * coordinates and the specified coordinates {@code (x3,y3)}, using the
                 * specified points {@code (x1,y1)} and {@code (x2,y2)} as B&eacute;zier
                 * control points. All coordinates are specified in float precision.
                 * <p>
                 * This method provides a single precision variant of the double
                 * precision {@code curveTo()} method on the base {@code Path2D} class.
                 *
                 * @param x1
                 * the X coordinate of the first B&eacute;zier control point
                 * @param y1
                 * the Y coordinate of the first B&eacute;zier control point
                 * @param x2
                 * the X coordinate of the second B&eacute;zier control point
                 * @param y2
                 * the Y coordinate of the second B&eacute;zier control point
                 * @param x3
                 * the X coordinate of the final end point
                 * @param y3
                 * the Y coordinate of the final end point
                 * @see Path2D#curveTo
                 * @since 1.6
                 */
                Path2D.prototype.curveTo = function (x1, y1, x2, y2, x3, y3) {
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null) && ((typeof x3 === 'number') || x3 === null) && ((typeof y3 === 'number') || y3 === null)) {
                        return this.curveTo$double$double$double$double$double$double(x1, y1, x2, y2, x3, y3);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Adds a curved segment, defined by three new points, to the path by
                 * drawing a B&eacute;zier curve that intersects both the current
                 * coordinates and the specified coordinates {@code (x3,y3)}, using the
                 * specified points {@code (x1,y1)} and {@code (x2,y2)} as B&eacute;zier
                 * control points. All coordinates are specified in double precision.
                 *
                 * @param x1
                 * the X coordinate of the first B&eacute;zier control point
                 * @param y1
                 * the Y coordinate of the first B&eacute;zier control point
                 * @param x2
                 * the X coordinate of the second B&eacute;zier control point
                 * @param y2
                 * the Y coordinate of the second B&eacute;zier control point
                 * @param x3
                 * the X coordinate of the final end point
                 * @param y3
                 * the Y coordinate of the final end point
                 * @since 1.6
                 */
                Path2D.prototype.curveTo$double$double$double$double$double$double = function (x1, y1, x2, y2, x3, y3) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Closes the current subpath by drawing a straight line back to the
                 * coordinates of the last {@code moveTo}. If the path is already closed
                 * then this method has no effect.
                 *
                 * @since 1.6
                 */
                Path2D.prototype.closePath = function () {
                    if (this.numTypes === 0 || this.pointTypes[this.numTypes - 1] !== Path2D.SEG_CLOSE_$LI$()) {
                        this.needRoom(true, 0);
                        this.pointTypes[this.numTypes++] = Path2D.SEG_CLOSE_$LI$();
                    }
                };
                /**
                 * Appends the geometry of the specified {@code Shape} object to the path,
                 * possibly connecting the new geometry to the existing path segments with a
                 * line segment. If the {@code connect} parameter is {@code true} and the
                 * path is not empty then any initial {@code moveTo} in the geometry of the
                 * appended {@code Shape} is turned into a {@code lineTo} segment. If the
                 * destination coordinates of such a connecting {@code lineTo} segment match
                 * the ending coordinates of a currently open subpath then the segment is
                 * omitted as superfluous. The winding rule of the specified {@code Shape}
                 * is ignored and the appended geometry is governed by the winding rule
                 * specified for this path.
                 *
                 * @param s
                 * the {@code Shape} whose geometry is appended to this path
                 * @param connect
                 * a boolean to control whether or not to turn an initial
                 * {@code moveTo} segment into a {@code lineTo} segment to
                 * connect the new geometry to the existing path
                 * @since 1.6
                 */
                Path2D.prototype.append = function (s, connect) {
                    var _this = this;
                    if (((s != null && s["__interfaces"] != null && s["__interfaces"].indexOf("java.awt.Shape") >= 0) || s === null) && ((typeof connect === 'boolean') || connect === null)) {
                        return (function () {
                            _this.append(s.getPathIterator(null), connect);
                        })();
                    }
                    else if (((s != null && s["__interfaces"] != null && s["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0) || s === null) && ((typeof connect === 'boolean') || connect === null)) {
                        return this.append$java_awt_geom_PathIterator$boolean(s, connect);
                    }
                    else if (((typeof s === 'number') || s === null) && ((typeof connect === 'number') || connect === null)) {
                        return this.append$float$float(s, connect);
                    }
                    else if (((typeof s === 'number') || s === null) && ((typeof connect === 'number') || connect === null)) {
                        return this.append$double$double(s, connect);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Appends the geometry of the specified {@link PathIterator} object to the
                 * path, possibly connecting the new geometry to the existing path segments
                 * with a line segment. If the {@code connect} parameter is {@code true} and
                 * the path is not empty then any initial {@code moveTo} in the geometry of
                 * the appended {@code Shape} is turned into a {@code lineTo} segment. If
                 * the destination coordinates of such a connecting {@code lineTo} segment
                 * match the ending coordinates of a currently open subpath then the segment
                 * is omitted as superfluous. The winding rule of the specified
                 * {@code Shape} is ignored and the appended geometry is governed by the
                 * winding rule specified for this path.
                 *
                 * @param pi
                 * the {@code PathIterator} whose geometry is appended to this
                 * path
                 * @param connect
                 * a boolean to control whether or not to turn an initial
                 * {@code moveTo} segment into a {@code lineTo} segment to
                 * connect the new geometry to the existing path
                 * @since 1.6
                 */
                Path2D.prototype.append$java_awt_geom_PathIterator$boolean = function (pi, connect) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Returns the fill style winding rule.
                 *
                 * @return an integer representing the current winding rule.
                 * @see #WIND_EVEN_ODD
                 * @see #WIND_NON_ZERO
                 * @see #setWindingRule
                 * @since 1.6
                 */
                Path2D.prototype.getWindingRule = function () {
                    return this.windingRule;
                };
                /**
                 * Sets the winding rule for this path to the specified value.
                 *
                 * @param rule
                 * an integer representing the specified winding rule
                 * @exception IllegalArgumentException
                 * if {@code rule} is not either {@link #WIND_EVEN_ODD} or
                 * {@link #WIND_NON_ZERO}
                 * @see #getWindingRule
                 * @since 1.6
                 */
                Path2D.prototype.setWindingRule = function (rule) {
                    if (rule !== Path2D.WIND_EVEN_ODD_$LI$() && rule !== Path2D.WIND_NON_ZERO_$LI$()) {
                        throw new java.lang.IllegalArgumentException("winding rule must be WIND_EVEN_ODD or WIND_NON_ZERO");
                    }
                    this.windingRule = rule;
                };
                /**
                 * Returns the coordinates most recently added to the end of the path as a
                 * {@link Point2D} object.
                 *
                 * @return a {@code Point2D} object containing the ending coordinates of the
                 * path or {@code null} if there are no points in the path.
                 * @since 1.6
                 */
                Path2D.prototype.getCurrentPoint = function () {
                    var index = this.numCoords;
                    if (this.numTypes < 1 || index < 1) {
                        return null;
                    }
                    if (this.pointTypes[this.numTypes - 1] === Path2D.SEG_CLOSE_$LI$()) {
                        loop: for (var i = this.numTypes - 2; i > 0; i--) {
                            switch ((this.pointTypes[i])) {
                                case Path2D.SEG_MOVETO_$LI$():
                                    break loop;
                                case Path2D.SEG_LINETO_$LI$():
                                    index -= 2;
                                    break;
                                case Path2D.SEG_QUADTO_$LI$():
                                    index -= 4;
                                    break;
                                case Path2D.SEG_CUBICTO_$LI$():
                                    index -= 6;
                                    break;
                                case Path2D.SEG_CLOSE_$LI$():
                                    break;
                            }
                        }
                    }
                    return this.getPoint(index - 2);
                };
                /**
                 * Resets the path to empty. The append position is set back to the
                 * beginning of the path and all coordinates and point types are forgotten.
                 *
                 * @since 1.6
                 */
                Path2D.prototype.reset = function () {
                    this.numTypes = this.numCoords = 0;
                };
                /**
                 * Returns a new {@code Shape} representing a transformed version of this
                 * {@code Path2D}. Note that the exact type and coordinate precision of the
                 * return value is not specified for this method. The method will return a
                 * Shape that contains no less precision for the transformed geometry than
                 * this {@code Path2D} currently maintains, but it may contain no more
                 * precision either. If the tradeoff of precision vs. storage size in the
                 * result is important then the convenience constructors in the
                 * {@link Path2D.Float#Path2D.Float(Shape, AffineTransform) Path2D.Float}
                 * and {@link Path2D.Double#Path2D.Double(Shape, AffineTransform)
                 * Path2D.Double} subclasses should be used to make the choice explicit.
                 *
                 * @param at
                 * the {@code AffineTransform} used to transform a new
                 * {@code Shape}.
                 * @return a new {@code Shape}, transformed with the specified
                 * {@code AffineTransform}.
                 * @since 1.6
                 */
                Path2D.prototype.createTransformedShape = function (at) {
                    var p2d = this.clone();
                    if (at != null) {
                        p2d.transform(at);
                    }
                    return p2d;
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.6
                 */
                Path2D.prototype.getBounds = function () {
                    return this.getBounds2D().getBounds();
                };
                /**
                 * Tests if the specified coordinates are inside the closed boundary of the
                 * specified {@link PathIterator}.
                 * <p>
                 * This method provides a basic facility for implementors of the
                 * {@link Shape} interface to implement support for the
                 * {@link Shape#contains(double, double)} method.
                 *
                 * @param pi
                 * the specified {@code PathIterator}
                 * @param x
                 * the specified X coordinate
                 * @param y
                 * the specified Y coordinate
                 * @return {@code true} if the specified coordinates are inside the
                 * specified {@code PathIterator}; {@code false} otherwise
                 * @since 1.6
                 */
                Path2D.contains$java_awt_geom_PathIterator$double$double = function (pi, x, y) {
                    if (x * 0.0 + y * 0.0 === 0.0) {
                        var mask = (pi.getWindingRule() === Path2D.WIND_NON_ZERO_$LI$() ? -1 : 1);
                        var cross = sun.awt.geom.Curve.pointCrossingsForPath(pi, x, y);
                        return ((cross & mask) !== 0);
                    }
                    else {
                        return false;
                    }
                };
                /**
                 * Tests if the specified {@link Point2D} is inside the closed boundary of
                 * the specified {@link PathIterator}.
                 * <p>
                 * This method provides a basic facility for implementors of the
                 * {@link Shape} interface to implement support for the
                 * {@link Shape#contains(Point2D)} method.
                 *
                 * @param pi
                 * the specified {@code PathIterator}
                 * @param p
                 * the specified {@code Point2D}
                 * @return {@code true} if the specified coordinates are inside the
                 * specified {@code PathIterator}; {@code false} otherwise
                 * @since 1.6
                 */
                Path2D.contains$java_awt_geom_PathIterator$java_awt_geom_Point2D = function (pi, p) {
                    return Path2D.contains(pi, p.getX(), p.getY());
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.6
                 */
                Path2D.prototype.contains$double$double = function (x, y) {
                    if (x * 0.0 + y * 0.0 === 0.0) {
                        if (this.numTypes < 2) {
                            return false;
                        }
                        var mask = (this.windingRule === Path2D.WIND_NON_ZERO_$LI$() ? -1 : 1);
                        return ((this.pointCrossings(x, y) & mask) !== 0);
                    }
                    else {
                        return false;
                    }
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.6
                 */
                Path2D.prototype.contains$java_awt_geom_Point2D = function (p) {
                    return this.contains(p.getX(), p.getY());
                };
                /**
                 * Tests if the specified rectangular area is entirely inside the closed
                 * boundary of the specified {@link PathIterator}.
                 * <p>
                 * This method provides a basic facility for implementors of the
                 * {@link Shape} interface to implement support for the
                 * {@link Shape#contains(double, double, double, double)} method.
                 * <p>
                 * This method object may conservatively return false in cases where the
                 * specified rectangular area intersects a segment of the path, but that
                 * segment does not represent a boundary between the interior and exterior
                 * of the path. Such segments could lie entirely within the interior of the
                 * path if they are part of a path with a {@link #WIND_NON_ZERO} winding
                 * rule or if the segments are retraced in the reverse direction such that
                 * the two sets of segments cancel each other out without any exterior area
                 * falling between them. To determine whether segments represent true
                 * boundaries of the interior of the path would require extensive
                 * calculations involving all of the segments of the path and the winding
                 * rule and are thus beyond the scope of this implementation.
                 *
                 * @param pi
                 * the specified {@code PathIterator}
                 * @param x
                 * the specified X coordinate
                 * @param y
                 * the specified Y coordinate
                 * @param w
                 * the width of the specified rectangular area
                 * @param h
                 * the height of the specified rectangular area
                 * @return {@code true} if the specified {@code PathIterator} contains the
                 * specified rectangular area; {@code false} otherwise.
                 * @since 1.6
                 */
                Path2D.contains = function (pi, x, y, w, h) {
                    if (((pi != null && pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0) || pi === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return (function () {
                            if ((Number.NaN === x + w) || (Number.NaN === y + h)) {
                                return false;
                            }
                            if (w <= 0 || h <= 0) {
                                return false;
                            }
                            var mask = (pi.getWindingRule() === Path2D.WIND_NON_ZERO_$LI$() ? -1 : 2);
                            var crossings = sun.awt.geom.Curve.rectCrossingsForPath(pi, x, y, x + w, y + h);
                            return (crossings !== sun.awt.geom.Curve.RECT_INTERSECTS && (crossings & mask) !== 0);
                        })();
                    }
                    else if (((pi != null && pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0) || pi === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined) {
                        return java.awt.geom.Path2D.contains$java_awt_geom_PathIterator$double$double(pi, x, y);
                    }
                    else if (((pi != null && pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0) || pi === null) && ((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return java.awt.geom.Path2D.contains$java_awt_geom_PathIterator$java_awt_geom_Point2D(pi, x);
                    }
                    else if (((pi != null && pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0) || pi === null) && ((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return java.awt.geom.Path2D.contains$java_awt_geom_PathIterator$java_awt_geom_Rectangle2D(pi, x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Tests if the specified {@link Rectangle2D} is entirely inside the closed
                 * boundary of the specified {@link PathIterator}.
                 * <p>
                 * This method provides a basic facility for implementors of the
                 * {@link Shape} interface to implement support for the
                 * {@link Shape#contains(Rectangle2D)} method.
                 * <p>
                 * This method object may conservatively return false in cases where the
                 * specified rectangular area intersects a segment of the path, but that
                 * segment does not represent a boundary between the interior and exterior
                 * of the path. Such segments could lie entirely within the interior of the
                 * path if they are part of a path with a {@link #WIND_NON_ZERO} winding
                 * rule or if the segments are retraced in the reverse direction such that
                 * the two sets of segments cancel each other out without any exterior area
                 * falling between them. To determine whether segments represent true
                 * boundaries of the interior of the path would require extensive
                 * calculations involving all of the segments of the path and the winding
                 * rule and are thus beyond the scope of this implementation.
                 *
                 * @param pi
                 * the specified {@code PathIterator}
                 * @param r
                 * a specified {@code Rectangle2D}
                 * @return {@code true} if the specified {@code PathIterator} contains the
                 * specified {@code Rectangle2D}; {@code false} otherwise.
                 * @since 1.6
                 */
                Path2D.contains$java_awt_geom_PathIterator$java_awt_geom_Rectangle2D = function (pi, r) {
                    return Path2D.contains(pi, r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                /**
                 * {@inheritDoc}
                 * <p>
                 * This method object may conservatively return false in cases where the
                 * specified rectangular area intersects a segment of the path, but that
                 * segment does not represent a boundary between the interior and exterior
                 * of the path. Such segments could lie entirely within the interior of the
                 * path if they are part of a path with a {@link #WIND_NON_ZERO} winding
                 * rule or if the segments are retraced in the reverse direction such that
                 * the two sets of segments cancel each other out without any exterior area
                 * falling between them. To determine whether segments represent true
                 * boundaries of the interior of the path would require extensive
                 * calculations involving all of the segments of the path and the winding
                 * rule and are thus beyond the scope of this implementation.
                 *
                 * @since 1.6
                 */
                Path2D.prototype.contains = function (x, y, w, h) {
                    var _this = this;
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return (function () {
                            if ((Number.NaN === x + w) || (Number.NaN === y + h)) {
                                return false;
                            }
                            if (w <= 0 || h <= 0) {
                                return false;
                            }
                            var mask = (_this.windingRule === Path2D.WIND_NON_ZERO_$LI$() ? -1 : 2);
                            var crossings = _this.rectCrossings(x, y, x + w, y + h);
                            return (crossings !== sun.awt.geom.Curve.RECT_INTERSECTS && (crossings & mask) !== 0);
                        })();
                    }
                    else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined) {
                        return this.contains$double$double(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Point2D(x);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 * <p>
                 * This method object may conservatively return false in cases where the
                 * specified rectangular area intersects a segment of the path, but that
                 * segment does not represent a boundary between the interior and exterior
                 * of the path. Such segments could lie entirely within the interior of the
                 * path if they are part of a path with a {@link #WIND_NON_ZERO} winding
                 * rule or if the segments are retraced in the reverse direction such that
                 * the two sets of segments cancel each other out without any exterior area
                 * falling between them. To determine whether segments represent true
                 * boundaries of the interior of the path would require extensive
                 * calculations involving all of the segments of the path and the winding
                 * rule and are thus beyond the scope of this implementation.
                 *
                 * @since 1.6
                 */
                Path2D.prototype.contains$java_awt_geom_Rectangle2D = function (r) {
                    return this.contains(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                /**
                 * Tests if the interior of the specified {@link PathIterator} intersects
                 * the interior of a specified set of rectangular coordinates.
                 * <p>
                 * This method provides a basic facility for implementors of the
                 * {@link Shape} interface to implement support for the
                 * {@link Shape#intersects(double, double, double, double)} method.
                 * <p>
                 * This method object may conservatively return true in cases where the
                 * specified rectangular area intersects a segment of the path, but that
                 * segment does not represent a boundary between the interior and exterior
                 * of the path. Such a case may occur if some set of segments of the path
                 * are retraced in the reverse direction such that the two sets of segments
                 * cancel each other out without any interior area between them. To
                 * determine whether segments represent true boundaries of the interior of
                 * the path would require extensive calculations involving all of the
                 * segments of the path and the winding rule and are thus beyond the scope
                 * of this implementation.
                 *
                 * @param pi
                 * the specified {@code PathIterator}
                 * @param x
                 * the specified X coordinate
                 * @param y
                 * the specified Y coordinate
                 * @param w
                 * the width of the specified rectangular coordinates
                 * @param h
                 * the height of the specified rectangular coordinates
                 * @return {@code true} if the specified {@code PathIterator} and the
                 * interior of the specified set of rectangular coordinates
                 * intersect each other; {@code false} otherwise.
                 * @since 1.6
                 */
                Path2D.intersects = function (pi, x, y, w, h) {
                    if (((pi != null && pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0) || pi === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return (function () {
                            if ((Number.NaN === x + w) || (Number.NaN === y + h)) {
                                return false;
                            }
                            if (w <= 0 || h <= 0) {
                                return false;
                            }
                            var mask = (pi.getWindingRule() === Path2D.WIND_NON_ZERO_$LI$() ? -1 : 2);
                            var crossings = sun.awt.geom.Curve.rectCrossingsForPath(pi, x, y, x + w, y + h);
                            return (crossings === sun.awt.geom.Curve.RECT_INTERSECTS || (crossings & mask) !== 0);
                        })();
                    }
                    else if (((pi != null && pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0) || pi === null) && ((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return java.awt.geom.Path2D.intersects$java_awt_geom_PathIterator$java_awt_geom_Rectangle2D(pi, x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Tests if the interior of the specified {@link PathIterator} intersects
                 * the interior of a specified {@link Rectangle2D}.
                 * <p>
                 * This method provides a basic facility for implementors of the
                 * {@link Shape} interface to implement support for the
                 * {@link Shape#intersects(Rectangle2D)} method.
                 * <p>
                 * This method object may conservatively return true in cases where the
                 * specified rectangular area intersects a segment of the path, but that
                 * segment does not represent a boundary between the interior and exterior
                 * of the path. Such a case may occur if some set of segments of the path
                 * are retraced in the reverse direction such that the two sets of segments
                 * cancel each other out without any interior area between them. To
                 * determine whether segments represent true boundaries of the interior of
                 * the path would require extensive calculations involving all of the
                 * segments of the path and the winding rule and are thus beyond the scope
                 * of this implementation.
                 *
                 * @param pi
                 * the specified {@code PathIterator}
                 * @param r
                 * the specified {@code Rectangle2D}
                 * @return {@code true} if the specified {@code PathIterator} and the
                 * interior of the specified {@code Rectangle2D} intersect each
                 * other; {@code false} otherwise.
                 * @since 1.6
                 */
                Path2D.intersects$java_awt_geom_PathIterator$java_awt_geom_Rectangle2D = function (pi, r) {
                    return Path2D.intersects(pi, r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                /**
                 * {@inheritDoc}
                 * <p>
                 * This method object may conservatively return true in cases where the
                 * specified rectangular area intersects a segment of the path, but that
                 * segment does not represent a boundary between the interior and exterior
                 * of the path. Such a case may occur if some set of segments of the path
                 * are retraced in the reverse direction such that the two sets of segments
                 * cancel each other out without any interior area between them. To
                 * determine whether segments represent true boundaries of the interior of
                 * the path would require extensive calculations involving all of the
                 * segments of the path and the winding rule and are thus beyond the scope
                 * of this implementation.
                 *
                 * @since 1.6
                 */
                Path2D.prototype.intersects = function (x, y, w, h) {
                    var _this = this;
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return (function () {
                            if ((Number.NaN === x + w) || (Number.NaN === y + h)) {
                                return false;
                            }
                            if (w <= 0 || h <= 0) {
                                return false;
                            }
                            var mask = (_this.windingRule === Path2D.WIND_NON_ZERO_$LI$() ? -1 : 2);
                            var crossings = _this.rectCrossings(x, y, x + w, y + h);
                            return (crossings === sun.awt.geom.Curve.RECT_INTERSECTS || (crossings & mask) !== 0);
                        })();
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.intersects$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 * <p>
                 * This method object may conservatively return true in cases where the
                 * specified rectangular area intersects a segment of the path, but that
                 * segment does not represent a boundary between the interior and exterior
                 * of the path. Such a case may occur if some set of segments of the path
                 * are retraced in the reverse direction such that the two sets of segments
                 * cancel each other out without any interior area between them. To
                 * determine whether segments represent true boundaries of the interior of
                 * the path would require extensive calculations involving all of the
                 * segments of the path and the winding rule and are thus beyond the scope
                 * of this implementation.
                 *
                 * @since 1.6
                 */
                Path2D.prototype.intersects$java_awt_geom_Rectangle2D = function (r) {
                    return this.intersects(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                /**
                 * {@inheritDoc}
                 * <p>
                 * The iterator for this class is not multi-threaded safe, which means that
                 * this {@code Path2D} class does not guarantee that modifications to the
                 * geometry of this {@code Path2D} object do not affect any iterations of
                 * that geometry that are already in process.
                 *
                 * @since 1.6
                 */
                Path2D.prototype.getPathIterator = function (at, flatness) {
                    var _this = this;
                    if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
                        return (function () {
                            return new java.awt.geom.FlatteningPathIterator(_this.getPathIterator(at), flatness);
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                };
                Path2D.INIT_SIZE = 20;
                Path2D.EXPAND_MAX = 500;
                return Path2D;
            }());
            geom.Path2D = Path2D;
            var Path2D;
            (function (Path2D) {
                var Iterator = (function () {
                    function Iterator(path) {
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.geom.PathIterator"] });
                        this.typeIdx = 0;
                        this.pointIdx = 0;
                        this.path = path;
                    }
                    Iterator.curvecoords_$LI$ = function () { if (Iterator.curvecoords == null)
                        Iterator.curvecoords = [2, 2, 4, 6, 0]; return Iterator.curvecoords; };
                    ;
                    Iterator.prototype.getWindingRule = function () {
                        return this.path.getWindingRule();
                    };
                    Iterator.prototype.isDone = function () {
                        return (this.typeIdx >= this.path.numTypes);
                    };
                    Iterator.prototype.next = function (doNext) {
                        if (doNext === undefined) {
                            return this.next$();
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    Iterator.prototype.next$ = function () {
                        var type = this.path.pointTypes[this.typeIdx++];
                        this.pointIdx += Iterator.curvecoords_$LI$()[type];
                    };
                    return Iterator;
                }());
                Path2D.Iterator = Iterator;
                /**
                 * The {@code Float} class defines a geometric path with coordinates stored
                 * in single precision floating point.
                 *
                 * @since 1.6
                 */
                var Float = (function (_super) {
                    __extends(Float, _super);
                    /**
                     * Constructs a new single precision {@code Path2D} object from an
                     * arbitrary {@link Shape} object, transformed by an
                     * {@link AffineTransform} object. All of the initial geometry and the
                     * winding rule for this path are taken from the specified {@code Shape}
                     * object and transformed by the specified {@code AffineTransform}
                     * object.
                     *
                     * @param s
                     * the specified {@code Shape} object
                     * @param at
                     * the specified {@code AffineTransform} object
                     * @since 1.6
                     */
                    function Float(s, at) {
                        var _this = this;
                        if (((s != null && s["__interfaces"] != null && s["__interfaces"].indexOf("java.awt.Shape") >= 0) || s === null) && ((at != null && at instanceof java.awt.geom.AffineTransform) || at === null)) {
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            (function () {
                                if (s != null && s instanceof java.awt.geom.Path2D) {
                                    var p2d = s;
                                    _this.setWindingRule(p2d.windingRule);
                                    _this.numTypes = p2d.numTypes;
                                    _this.pointTypes = java.util.Arrays.copyOf(p2d.pointTypes, p2d.pointTypes.length);
                                    _this.numCoords = p2d.numCoords;
                                    _this.floatCoords = p2d.cloneCoordsFloat(at);
                                }
                                else {
                                    var pi = s.getPathIterator(at);
                                    _this.setWindingRule(pi.getWindingRule());
                                    _this.pointTypes = new Array(java.awt.geom.Path2D.INIT_SIZE);
                                    _this.floatCoords = new Array(java.awt.geom.Path2D.INIT_SIZE * 2);
                                    _this.append(pi, false);
                                }
                            })();
                        }
                        else if (((typeof s === 'number') || s === null) && ((typeof at === 'number') || at === null)) {
                            var rule = s;
                            var initialCapacity = at;
                            _super.call(this, rule, initialCapacity);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            (function () {
                                _this.floatCoords = new Array(initialCapacity * 2);
                            })();
                        }
                        else if (((s != null && s["__interfaces"] != null && s["__interfaces"].indexOf("java.awt.Shape") >= 0) || s === null) && at === undefined) {
                            {
                                var at = null;
                                _super.call(this);
                                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                                (function () {
                                    if (s != null && s instanceof java.awt.geom.Path2D) {
                                        var p2d = s;
                                        _this.setWindingRule(p2d.windingRule);
                                        _this.numTypes = p2d.numTypes;
                                        _this.pointTypes = java.util.Arrays.copyOf(p2d.pointTypes, p2d.pointTypes.length);
                                        _this.numCoords = p2d.numCoords;
                                        _this.floatCoords = p2d.cloneCoordsFloat(at);
                                    }
                                    else {
                                        var pi = s.getPathIterator(at);
                                        _this.setWindingRule(pi.getWindingRule());
                                        _this.pointTypes = new Array(java.awt.geom.Path2D.INIT_SIZE);
                                        _this.floatCoords = new Array(java.awt.geom.Path2D.INIT_SIZE * 2);
                                        _this.append(pi, false);
                                    }
                                })();
                            }
                            (function () {
                            })();
                        }
                        else if (((typeof s === 'number') || s === null) && at === undefined) {
                            var rule = s;
                            {
                                var initialCapacity = java.awt.geom.Path2D.INIT_SIZE;
                                _super.call(this, rule, initialCapacity);
                                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                                (function () {
                                    _this.floatCoords = new Array(initialCapacity * 2);
                                })();
                            }
                            (function () {
                            })();
                        }
                        else if (s === undefined && at === undefined) {
                            {
                                var rule = java.awt.geom.Path2D.WIND_NON_ZERO_$LI$();
                                var initialCapacity = java.awt.geom.Path2D.INIT_SIZE;
                                _super.call(this, rule, initialCapacity);
                                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                                (function () {
                                    _this.floatCoords = new Array(initialCapacity * 2);
                                })();
                            }
                            (function () {
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    Float.prototype.cloneCoordsFloat = function (at) {
                        var ret;
                        if (at == null) {
                            ret = java.util.Arrays.copyOf(this.floatCoords, this.floatCoords.length);
                        }
                        else {
                            ret = new Array(this.floatCoords.length);
                            at.transform(this.floatCoords, 0, ret, 0, (this.numCoords / 2 | 0));
                        }
                        return ret;
                    };
                    Float.prototype.cloneCoordsDouble = function (at) {
                        var ret = new Array(this.floatCoords.length);
                        if (at == null) {
                            for (var i = 0; i < this.numCoords; i++) {
                                ret[i] = this.floatCoords[i];
                            }
                        }
                        else {
                            at.transform(this.floatCoords, 0, ret, 0, (this.numCoords / 2 | 0));
                        }
                        return ret;
                    };
                    Float.prototype.append$float$float = function (x, y) {
                        this.floatCoords[this.numCoords++] = x;
                        this.floatCoords[this.numCoords++] = y;
                    };
                    Float.prototype.append$double$double = function (x, y) {
                        this.floatCoords[this.numCoords++] = x;
                        this.floatCoords[this.numCoords++] = y;
                    };
                    Float.prototype.getPoint = function (coordindex) {
                        return new java.awt.geom.Point2D.Float(this.floatCoords[coordindex], this.floatCoords[coordindex + 1]);
                    };
                    Float.prototype.needRoom = function (needMove, newCoords) {
                        if (needMove && this.numTypes === 0) {
                            throw new java.awt.geom.IllegalPathStateException("missing initial moveto in path definition");
                        }
                        var size = this.pointTypes.length;
                        if (this.numTypes >= size) {
                            var grow = size;
                            if (grow > java.awt.geom.Path2D.EXPAND_MAX) {
                                grow = java.awt.geom.Path2D.EXPAND_MAX;
                            }
                            this.pointTypes = java.util.Arrays.copyOf(this.pointTypes, size + grow);
                        }
                        size = this.floatCoords.length;
                        if (this.numCoords + newCoords > size) {
                            var grow = size;
                            if (grow > java.awt.geom.Path2D.EXPAND_MAX * 2) {
                                grow = java.awt.geom.Path2D.EXPAND_MAX * 2;
                            }
                            if (grow < newCoords) {
                                grow = newCoords;
                            }
                            this.floatCoords = java.util.Arrays.copyOf(this.floatCoords, size + grow);
                        }
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     */
                    Float.prototype.moveTo$double$double = function (x, y) {
                        if (this.numTypes > 0 && this.pointTypes[this.numTypes - 1] === java.awt.geom.Path2D.SEG_MOVETO_$LI$()) {
                            this.floatCoords[this.numCoords - 2] = x;
                            this.floatCoords[this.numCoords - 1] = y;
                        }
                        else {
                            this.needRoom(false, 2);
                            this.pointTypes[this.numTypes++] = java.awt.geom.Path2D.SEG_MOVETO_$LI$();
                            this.floatCoords[this.numCoords++] = x;
                            this.floatCoords[this.numCoords++] = y;
                        }
                    };
                    /**
                     * Adds a point to the path by moving to the specified coordinates
                     * specified in float precision.
                     * <p>
                     * This method provides a single precision variant of the double
                     * precision {@code moveTo()} method on the base {@code Path2D} class.
                     *
                     * @param x
                     * the specified X coordinate
                     * @param y
                     * the specified Y coordinate
                     * @see Path2D#moveTo
                     * @since 1.6
                     */
                    Float.prototype.moveTo = function (x, y) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            return (function () {
                                if (_this.numTypes > 0 && _this.pointTypes[_this.numTypes - 1] === java.awt.geom.Path2D.SEG_MOVETO_$LI$()) {
                                    _this.floatCoords[_this.numCoords - 2] = x;
                                    _this.floatCoords[_this.numCoords - 1] = y;
                                }
                                else {
                                    _this.needRoom(false, 2);
                                    _this.pointTypes[_this.numTypes++] = java.awt.geom.Path2D.SEG_MOVETO_$LI$();
                                    _this.floatCoords[_this.numCoords++] = x;
                                    _this.floatCoords[_this.numCoords++] = y;
                                }
                            })();
                        }
                        else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            return this.moveTo$double$double(x, y);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     */
                    Float.prototype.lineTo$double$double = function (x, y) {
                        this.needRoom(true, 2);
                        this.pointTypes[this.numTypes++] = java.awt.geom.Path2D.SEG_LINETO_$LI$();
                        this.floatCoords[this.numCoords++] = x;
                        this.floatCoords[this.numCoords++] = y;
                    };
                    /**
                     * Adds a point to the path by drawing a straight line from the current
                     * coordinates to the new specified coordinates specified in float
                     * precision.
                     * <p>
                     * This method provides a single precision variant of the double
                     * precision {@code lineTo()} method on the base {@code Path2D} class.
                     *
                     * @param x
                     * the specified X coordinate
                     * @param y
                     * the specified Y coordinate
                     * @see Path2D#lineTo
                     * @since 1.6
                     */
                    Float.prototype.lineTo = function (x, y) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            return (function () {
                                _this.needRoom(true, 2);
                                _this.pointTypes[_this.numTypes++] = java.awt.geom.Path2D.SEG_LINETO_$LI$();
                                _this.floatCoords[_this.numCoords++] = x;
                                _this.floatCoords[_this.numCoords++] = y;
                            })();
                        }
                        else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            return this.lineTo$double$double(x, y);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     */
                    Float.prototype.quadTo$double$double$double$double = function (x1, y1, x2, y2) {
                        this.needRoom(true, 4);
                        this.pointTypes[this.numTypes++] = java.awt.geom.Path2D.SEG_QUADTO_$LI$();
                        this.floatCoords[this.numCoords++] = x1;
                        this.floatCoords[this.numCoords++] = y1;
                        this.floatCoords[this.numCoords++] = x2;
                        this.floatCoords[this.numCoords++] = y2;
                    };
                    /**
                     * Adds a curved segment, defined by two new points, to the path by
                     * drawing a Quadratic curve that intersects both the current
                     * coordinates and the specified coordinates {@code (x2,y2)}, using the
                     * specified point {@code (x1,y1)} as a quadratic parametric control
                     * point. All coordinates are specified in float precision.
                     * <p>
                     * This method provides a single precision variant of the double
                     * precision {@code quadTo()} method on the base {@code Path2D} class.
                     *
                     * @param x1
                     * the X coordinate of the quadratic control point
                     * @param y1
                     * the Y coordinate of the quadratic control point
                     * @param x2
                     * the X coordinate of the final end point
                     * @param y2
                     * the Y coordinate of the final end point
                     * @see Path2D#quadTo
                     * @since 1.6
                     */
                    Float.prototype.quadTo = function (x1, y1, x2, y2) {
                        var _this = this;
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            return (function () {
                                _this.needRoom(true, 4);
                                _this.pointTypes[_this.numTypes++] = java.awt.geom.Path2D.SEG_QUADTO_$LI$();
                                _this.floatCoords[_this.numCoords++] = x1;
                                _this.floatCoords[_this.numCoords++] = y1;
                                _this.floatCoords[_this.numCoords++] = x2;
                                _this.floatCoords[_this.numCoords++] = y2;
                            })();
                        }
                        else if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            return this.quadTo$double$double$double$double(x1, y1, x2, y2);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     */
                    Float.prototype.curveTo$double$double$double$double$double$double = function (x1, y1, x2, y2, x3, y3) {
                        this.needRoom(true, 6);
                        this.pointTypes[this.numTypes++] = java.awt.geom.Path2D.SEG_CUBICTO_$LI$();
                        this.floatCoords[this.numCoords++] = x1;
                        this.floatCoords[this.numCoords++] = y1;
                        this.floatCoords[this.numCoords++] = x2;
                        this.floatCoords[this.numCoords++] = y2;
                        this.floatCoords[this.numCoords++] = x3;
                        this.floatCoords[this.numCoords++] = y3;
                    };
                    /**
                     * Adds a curved segment, defined by three new points, to the path by
                     * drawing a B&eacute;zier curve that intersects both the current
                     * coordinates and the specified coordinates {@code (x3,y3)}, using the
                     * specified points {@code (x1,y1)} and {@code (x2,y2)} as B&eacute;zier
                     * control points. All coordinates are specified in float precision.
                     * <p>
                     * This method provides a single precision variant of the double
                     * precision {@code curveTo()} method on the base {@code Path2D} class.
                     *
                     * @param x1
                     * the X coordinate of the first B&eacute;zier control point
                     * @param y1
                     * the Y coordinate of the first B&eacute;zier control point
                     * @param x2
                     * the X coordinate of the second B&eacute;zier control point
                     * @param y2
                     * the Y coordinate of the second B&eacute;zier control point
                     * @param x3
                     * the X coordinate of the final end point
                     * @param y3
                     * the Y coordinate of the final end point
                     * @see Path2D#curveTo
                     * @since 1.6
                     */
                    Float.prototype.curveTo = function (x1, y1, x2, y2, x3, y3) {
                        var _this = this;
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null) && ((typeof x3 === 'number') || x3 === null) && ((typeof y3 === 'number') || y3 === null)) {
                            return (function () {
                                _this.needRoom(true, 6);
                                _this.pointTypes[_this.numTypes++] = java.awt.geom.Path2D.SEG_CUBICTO_$LI$();
                                _this.floatCoords[_this.numCoords++] = x1;
                                _this.floatCoords[_this.numCoords++] = y1;
                                _this.floatCoords[_this.numCoords++] = x2;
                                _this.floatCoords[_this.numCoords++] = y2;
                                _this.floatCoords[_this.numCoords++] = x3;
                                _this.floatCoords[_this.numCoords++] = y3;
                            })();
                        }
                        else if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null) && ((typeof x3 === 'number') || x3 === null) && ((typeof y3 === 'number') || y3 === null)) {
                            return this.curveTo$double$double$double$double$double$double(x1, y1, x2, y2, x3, y3);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    Float.prototype.pointCrossings = function (px, py) {
                        var movx;
                        var movy;
                        var curx;
                        var cury;
                        var endx;
                        var endy;
                        var coords = this.floatCoords;
                        curx = movx = coords[0];
                        cury = movy = coords[1];
                        var crossings = 0;
                        var ci = 2;
                        for (var i = 1; i < this.numTypes; i++) {
                            switch ((this.pointTypes[i])) {
                                case java.awt.geom.PathIterator.SEG_MOVETO:
                                    if (cury !== movy) {
                                        crossings += sun.awt.geom.Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                                    }
                                    movx = curx = coords[ci++];
                                    movy = cury = coords[ci++];
                                    break;
                                case java.awt.geom.PathIterator.SEG_LINETO:
                                    crossings += sun.awt.geom.Curve.pointCrossingsForLine(px, py, curx, cury, endx = coords[ci++], endy = coords[ci++]);
                                    curx = endx;
                                    cury = endy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_QUADTO:
                                    crossings += sun.awt.geom.Curve.pointCrossingsForQuad(px, py, curx, cury, coords[ci++], coords[ci++], endx = coords[ci++], endy = coords[ci++], 0);
                                    curx = endx;
                                    cury = endy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_CUBICTO:
                                    crossings += sun.awt.geom.Curve.pointCrossingsForCubic(px, py, curx, cury, coords[ci++], coords[ci++], coords[ci++], coords[ci++], endx = coords[ci++], endy = coords[ci++], 0);
                                    curx = endx;
                                    cury = endy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_CLOSE:
                                    if (cury !== movy) {
                                        crossings += sun.awt.geom.Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                                    }
                                    curx = movx;
                                    cury = movy;
                                    break;
                            }
                        }
                        if (cury !== movy) {
                            crossings += sun.awt.geom.Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                        }
                        return crossings;
                    };
                    Float.prototype.rectCrossings = function (rxmin, rymin, rxmax, rymax) {
                        var coords = this.floatCoords;
                        var curx;
                        var cury;
                        var movx;
                        var movy;
                        var endx;
                        var endy;
                        curx = movx = coords[0];
                        cury = movy = coords[1];
                        var crossings = 0;
                        var ci = 2;
                        for (var i = 1; crossings !== sun.awt.geom.Curve.RECT_INTERSECTS && i < this.numTypes; i++) {
                            switch ((this.pointTypes[i])) {
                                case java.awt.geom.PathIterator.SEG_MOVETO:
                                    if (curx !== movx || cury !== movy) {
                                        crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                                    }
                                    movx = curx = coords[ci++];
                                    movy = cury = coords[ci++];
                                    break;
                                case java.awt.geom.PathIterator.SEG_LINETO:
                                    crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, endx = coords[ci++], endy = coords[ci++]);
                                    curx = endx;
                                    cury = endy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_QUADTO:
                                    crossings = sun.awt.geom.Curve.rectCrossingsForQuad(crossings, rxmin, rymin, rxmax, rymax, curx, cury, coords[ci++], coords[ci++], endx = coords[ci++], endy = coords[ci++], 0);
                                    curx = endx;
                                    cury = endy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_CUBICTO:
                                    crossings = sun.awt.geom.Curve.rectCrossingsForCubic(crossings, rxmin, rymin, rxmax, rymax, curx, cury, coords[ci++], coords[ci++], coords[ci++], coords[ci++], endx = coords[ci++], endy = coords[ci++], 0);
                                    curx = endx;
                                    cury = endy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_CLOSE:
                                    if (curx !== movx || cury !== movy) {
                                        crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                                    }
                                    curx = movx;
                                    cury = movy;
                                    break;
                            }
                        }
                        if (crossings !== sun.awt.geom.Curve.RECT_INTERSECTS && (curx !== movx || cury !== movy)) {
                            crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                        }
                        return crossings;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     */
                    Float.prototype.append = function (pi, connect) {
                        var _this = this;
                        if (((pi != null && pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0) || pi === null) && ((typeof connect === 'boolean') || connect === null)) {
                            return (function () {
                                var coords = new Array(6);
                                while ((!pi.isDone())) {
                                    switch ((pi.currentSegment(coords))) {
                                        case java.awt.geom.Path2D.SEG_MOVETO_$LI$():
                                            if (!connect || _this.numTypes < 1 || _this.numCoords < 1) {
                                                _this.moveTo(coords[0], coords[1]);
                                                break;
                                            }
                                            if (_this.pointTypes[_this.numTypes - 1] !== java.awt.geom.Path2D.SEG_CLOSE_$LI$() && _this.floatCoords[_this.numCoords - 2] === coords[0] && _this.floatCoords[_this.numCoords - 1] === coords[1]) {
                                                break;
                                            }
                                            _this.lineTo(coords[0], coords[1]);
                                            break;
                                        case java.awt.geom.Path2D.SEG_LINETO_$LI$():
                                            _this.lineTo(coords[0], coords[1]);
                                            break;
                                        case java.awt.geom.Path2D.SEG_QUADTO_$LI$():
                                            _this.quadTo(coords[0], coords[1], coords[2], coords[3]);
                                            break;
                                        case java.awt.geom.Path2D.SEG_CUBICTO_$LI$():
                                            _this.curveTo(coords[0], coords[1], coords[2], coords[3], coords[4], coords[5]);
                                            break;
                                        case java.awt.geom.Path2D.SEG_CLOSE_$LI$():
                                            _this.closePath();
                                            break;
                                    }
                                    pi.next();
                                    connect = false;
                                }
                                ;
                            })();
                        }
                        else if (((typeof pi === 'number') || pi === null) && ((typeof connect === 'number') || connect === null)) {
                            return this.append$float$float(pi, connect);
                        }
                        else if (((typeof pi === 'number') || pi === null) && ((typeof connect === 'number') || connect === null)) {
                            return this.append$double$double(pi, connect);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     */
                    Float.prototype.transform = function (at) {
                        at.transform(this.floatCoords, 0, this.floatCoords, 0, (this.numCoords / 2 | 0));
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     */
                    Float.prototype.getBounds2D = function () {
                        var x1;
                        var y1;
                        var x2;
                        var y2;
                        var i = this.numCoords;
                        if (i > 0) {
                            y1 = y2 = this.floatCoords[--i];
                            x1 = x2 = this.floatCoords[--i];
                            while ((i > 0)) {
                                var y = this.floatCoords[--i];
                                var x = this.floatCoords[--i];
                                if (x < x1)
                                    x1 = x;
                                if (y < y1)
                                    y1 = y;
                                if (x > x2)
                                    x2 = x;
                                if (y > y2)
                                    y2 = y;
                            }
                            ;
                        }
                        else {
                            x1 = y1 = x2 = y2 = 0.0;
                        }
                        return new java.awt.geom.Rectangle2D.Float(x1, y1, x2 - x1, y2 - y1);
                    };
                    /**
                     * {@inheritDoc}
                     * <p>
                     * The iterator for this class is not multi-threaded safe, which means
                     * that the {@code Path2D} class does not guarantee that modifications
                     * to the geometry of this {@code Path2D} object do not affect any
                     * iterations of that geometry that are already in process.
                     *
                     * @since 1.6
                     */
                    Float.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
                        if (at == null) {
                            return new Float.CopyIterator(this);
                        }
                        else {
                            return new Float.TxIterator(this, at);
                        }
                    };
                    /**
                     * Creates a new object of the same class as this object.
                     *
                     * @return a clone of this instance.
                     * @exception OutOfMemoryError
                     * if there is not enough memory.
                     * @see java.lang.Cloneable
                     * @since 1.6
                     */
                    Float.prototype.clone = function () {
                        if (this != null && this instanceof java.awt.geom.GeneralPath) {
                            return new java.awt.geom.GeneralPath(this);
                        }
                        else {
                            return new java.awt.geom.Path2D.Float(this);
                        }
                    };
                    Float.serialVersionUID = 6990832515060788886;
                    return Float;
                }(java.awt.geom.Path2D));
                Path2D.Float = Float;
                var Float;
                (function (Float) {
                    var CopyIterator = (function (_super) {
                        __extends(CopyIterator, _super);
                        function CopyIterator(p2df) {
                            _super.call(this, p2df);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.geom.PathIterator"] });
                            this.floatCoords = p2df.floatCoords;
                        }
                        CopyIterator.prototype.currentSegment = function (coords) {
                            var _this = this;
                            if (((coords != null && coords instanceof Array) || coords === null)) {
                                return (function () {
                                    var type = _this.path.pointTypes[_this.typeIdx];
                                    var numCoords = java.awt.geom.Path2D.Iterator.curvecoords_$LI$()[type];
                                    if (numCoords > 0) {
                                        java.lang.System.arraycopy(_this.floatCoords, _this.pointIdx, coords, 0, numCoords);
                                    }
                                    return type;
                                })();
                            }
                            else if (((coords != null && coords instanceof Array) || coords === null)) {
                                return this.currentSegment$double_A(coords);
                            }
                            else
                                throw new Error('invalid overload');
                        };
                        CopyIterator.prototype.currentSegment$double_A = function (coords) {
                            var type = this.path.pointTypes[this.typeIdx];
                            var numCoords = java.awt.geom.Path2D.Iterator.curvecoords_$LI$()[type];
                            if (numCoords > 0) {
                                for (var i = 0; i < numCoords; i++) {
                                    coords[i] = this.floatCoords[this.pointIdx + i];
                                }
                            }
                            return type;
                        };
                        return CopyIterator;
                    }(java.awt.geom.Path2D.Iterator));
                    Float.CopyIterator = CopyIterator;
                    var TxIterator = (function (_super) {
                        __extends(TxIterator, _super);
                        function TxIterator(p2df, at) {
                            _super.call(this, p2df);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.geom.PathIterator"] });
                            this.floatCoords = p2df.floatCoords;
                            this.affine = at;
                        }
                        TxIterator.prototype.currentSegment = function (coords) {
                            var _this = this;
                            if (((coords != null && coords instanceof Array) || coords === null)) {
                                return (function () {
                                    var type = _this.path.pointTypes[_this.typeIdx];
                                    var numCoords = java.awt.geom.Path2D.Iterator.curvecoords_$LI$()[type];
                                    if (numCoords > 0) {
                                        _this.affine.transform(_this.floatCoords, _this.pointIdx, coords, 0, (numCoords / 2 | 0));
                                    }
                                    return type;
                                })();
                            }
                            else if (((coords != null && coords instanceof Array) || coords === null)) {
                                return this.currentSegment$double_A(coords);
                            }
                            else
                                throw new Error('invalid overload');
                        };
                        TxIterator.prototype.currentSegment$double_A = function (coords) {
                            var type = this.path.pointTypes[this.typeIdx];
                            var numCoords = java.awt.geom.Path2D.Iterator.curvecoords_$LI$()[type];
                            if (numCoords > 0) {
                                this.affine.transform(this.floatCoords, this.pointIdx, coords, 0, (numCoords / 2 | 0));
                            }
                            return type;
                        };
                        return TxIterator;
                    }(java.awt.geom.Path2D.Iterator));
                    Float.TxIterator = TxIterator;
                })(Float = Path2D.Float || (Path2D.Float = {}));
                /**
                 * The {@code Double} class defines a geometric path with coordinates stored
                 * in double precision floating point.
                 *
                 * @since 1.6
                 */
                var Double = (function (_super) {
                    __extends(Double, _super);
                    /**
                     * Constructs a new double precision {@code Path2D} object from an
                     * arbitrary {@link Shape} object, transformed by an
                     * {@link AffineTransform} object. All of the initial geometry and the
                     * winding rule for this path are taken from the specified {@code Shape}
                     * object and transformed by the specified {@code AffineTransform}
                     * object.
                     *
                     * @param s
                     * the specified {@code Shape} object
                     * @param at
                     * the specified {@code AffineTransform} object
                     * @since 1.6
                     */
                    function Double(s, at) {
                        var _this = this;
                        if (((s != null && s["__interfaces"] != null && s["__interfaces"].indexOf("java.awt.Shape") >= 0) || s === null) && ((at != null && at instanceof java.awt.geom.AffineTransform) || at === null)) {
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            (function () {
                                if (s != null && s instanceof java.awt.geom.Path2D) {
                                    var p2d = s;
                                    _this.setWindingRule(p2d.windingRule);
                                    _this.numTypes = p2d.numTypes;
                                    _this.pointTypes = java.util.Arrays.copyOf(p2d.pointTypes, p2d.pointTypes.length);
                                    _this.numCoords = p2d.numCoords;
                                    _this.doubleCoords = p2d.cloneCoordsDouble(at);
                                }
                                else {
                                    var pi = s.getPathIterator(at);
                                    _this.setWindingRule(pi.getWindingRule());
                                    _this.pointTypes = new Array(java.awt.geom.Path2D.INIT_SIZE);
                                    _this.doubleCoords = new Array(java.awt.geom.Path2D.INIT_SIZE * 2);
                                    _this.append(pi, false);
                                }
                            })();
                        }
                        else if (((typeof s === 'number') || s === null) && ((typeof at === 'number') || at === null)) {
                            var rule = s;
                            var initialCapacity = at;
                            _super.call(this, rule, initialCapacity);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            (function () {
                                _this.doubleCoords = new Array(initialCapacity * 2);
                            })();
                        }
                        else if (((s != null && s["__interfaces"] != null && s["__interfaces"].indexOf("java.awt.Shape") >= 0) || s === null) && at === undefined) {
                            {
                                var at = null;
                                _super.call(this);
                                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                                (function () {
                                    if (s != null && s instanceof java.awt.geom.Path2D) {
                                        var p2d = s;
                                        _this.setWindingRule(p2d.windingRule);
                                        _this.numTypes = p2d.numTypes;
                                        _this.pointTypes = java.util.Arrays.copyOf(p2d.pointTypes, p2d.pointTypes.length);
                                        _this.numCoords = p2d.numCoords;
                                        _this.doubleCoords = p2d.cloneCoordsDouble(at);
                                    }
                                    else {
                                        var pi = s.getPathIterator(at);
                                        _this.setWindingRule(pi.getWindingRule());
                                        _this.pointTypes = new Array(java.awt.geom.Path2D.INIT_SIZE);
                                        _this.doubleCoords = new Array(java.awt.geom.Path2D.INIT_SIZE * 2);
                                        _this.append(pi, false);
                                    }
                                })();
                            }
                            (function () {
                            })();
                        }
                        else if (((typeof s === 'number') || s === null) && at === undefined) {
                            var rule = s;
                            {
                                var initialCapacity = java.awt.geom.Path2D.INIT_SIZE;
                                _super.call(this, rule, initialCapacity);
                                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                                (function () {
                                    _this.doubleCoords = new Array(initialCapacity * 2);
                                })();
                            }
                            (function () {
                            })();
                        }
                        else if (s === undefined && at === undefined) {
                            {
                                var rule = java.awt.geom.Path2D.WIND_NON_ZERO_$LI$();
                                var initialCapacity = java.awt.geom.Path2D.INIT_SIZE;
                                _super.call(this, rule, initialCapacity);
                                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                                (function () {
                                    _this.doubleCoords = new Array(initialCapacity * 2);
                                })();
                            }
                            (function () {
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    Double.prototype.cloneCoordsFloat = function (at) {
                        var ret = new Array(this.doubleCoords.length);
                        if (at == null) {
                            for (var i = 0; i < this.numCoords; i++) {
                                ret[i] = this.doubleCoords[i];
                            }
                        }
                        else {
                            at.transform(this.doubleCoords, 0, ret, 0, (this.numCoords / 2 | 0));
                        }
                        return ret;
                    };
                    Double.prototype.cloneCoordsDouble = function (at) {
                        var ret;
                        if (at == null) {
                            ret = java.util.Arrays.copyOf(this.doubleCoords, this.doubleCoords.length);
                        }
                        else {
                            ret = new Array(this.doubleCoords.length);
                            at.transform(this.doubleCoords, 0, ret, 0, (this.numCoords / 2 | 0));
                        }
                        return ret;
                    };
                    Double.prototype.append$float$float = function (x, y) {
                        this.doubleCoords[this.numCoords++] = x;
                        this.doubleCoords[this.numCoords++] = y;
                    };
                    Double.prototype.append$double$double = function (x, y) {
                        this.doubleCoords[this.numCoords++] = x;
                        this.doubleCoords[this.numCoords++] = y;
                    };
                    Double.prototype.getPoint = function (coordindex) {
                        return new java.awt.geom.Point2D.Double(this.doubleCoords[coordindex], this.doubleCoords[coordindex + 1]);
                    };
                    Double.prototype.needRoom = function (needMove, newCoords) {
                        if (needMove && this.numTypes === 0) {
                            throw new java.awt.geom.IllegalPathStateException("missing initial moveto in path definition");
                        }
                        var size = this.pointTypes.length;
                        if (this.numTypes >= size) {
                            var grow = size;
                            if (grow > java.awt.geom.Path2D.EXPAND_MAX) {
                                grow = java.awt.geom.Path2D.EXPAND_MAX;
                            }
                            this.pointTypes = java.util.Arrays.copyOf(this.pointTypes, size + grow);
                        }
                        size = this.doubleCoords.length;
                        if (this.numCoords + newCoords > size) {
                            var grow = size;
                            if (grow > java.awt.geom.Path2D.EXPAND_MAX * 2) {
                                grow = java.awt.geom.Path2D.EXPAND_MAX * 2;
                            }
                            if (grow < newCoords) {
                                grow = newCoords;
                            }
                            this.doubleCoords = java.util.Arrays.copyOf(this.doubleCoords, size + grow);
                        }
                    };
                    /**
                     * Adds a point to the path by moving to the specified coordinates
                     * specified in float precision.
                     * <p>
                     * This method provides a single precision variant of the double
                     * precision {@code moveTo()} method on the base {@code Path2D} class.
                     *
                     * @param x
                     * the specified X coordinate
                     * @param y
                     * the specified Y coordinate
                     * @see Path2D#moveTo
                     * @since 1.6
                     */
                    Double.prototype.moveTo = function (x, y) {
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            return this.moveTo$double$double(x, y);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     */
                    Double.prototype.moveTo$double$double = function (x, y) {
                        if (this.numTypes > 0 && this.pointTypes[this.numTypes - 1] === java.awt.geom.Path2D.SEG_MOVETO_$LI$()) {
                            this.doubleCoords[this.numCoords - 2] = x;
                            this.doubleCoords[this.numCoords - 1] = y;
                        }
                        else {
                            this.needRoom(false, 2);
                            this.pointTypes[this.numTypes++] = java.awt.geom.Path2D.SEG_MOVETO_$LI$();
                            this.doubleCoords[this.numCoords++] = x;
                            this.doubleCoords[this.numCoords++] = y;
                        }
                    };
                    /**
                     * Adds a point to the path by drawing a straight line from the current
                     * coordinates to the new specified coordinates specified in float
                     * precision.
                     * <p>
                     * This method provides a single precision variant of the double
                     * precision {@code lineTo()} method on the base {@code Path2D} class.
                     *
                     * @param x
                     * the specified X coordinate
                     * @param y
                     * the specified Y coordinate
                     * @see Path2D#lineTo
                     * @since 1.6
                     */
                    Double.prototype.lineTo = function (x, y) {
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            return this.lineTo$double$double(x, y);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     */
                    Double.prototype.lineTo$double$double = function (x, y) {
                        this.needRoom(true, 2);
                        this.pointTypes[this.numTypes++] = java.awt.geom.Path2D.SEG_LINETO_$LI$();
                        this.doubleCoords[this.numCoords++] = x;
                        this.doubleCoords[this.numCoords++] = y;
                    };
                    /**
                     * Adds a curved segment, defined by two new points, to the path by
                     * drawing a Quadratic curve that intersects both the current
                     * coordinates and the specified coordinates {@code (x2,y2)}, using the
                     * specified point {@code (x1,y1)} as a quadratic parametric control
                     * point. All coordinates are specified in float precision.
                     * <p>
                     * This method provides a single precision variant of the double
                     * precision {@code quadTo()} method on the base {@code Path2D} class.
                     *
                     * @param x1
                     * the X coordinate of the quadratic control point
                     * @param y1
                     * the Y coordinate of the quadratic control point
                     * @param x2
                     * the X coordinate of the final end point
                     * @param y2
                     * the Y coordinate of the final end point
                     * @see Path2D#quadTo
                     * @since 1.6
                     */
                    Double.prototype.quadTo = function (x1, y1, x2, y2) {
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            return this.quadTo$double$double$double$double(x1, y1, x2, y2);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     */
                    Double.prototype.quadTo$double$double$double$double = function (x1, y1, x2, y2) {
                        this.needRoom(true, 4);
                        this.pointTypes[this.numTypes++] = java.awt.geom.Path2D.SEG_QUADTO_$LI$();
                        this.doubleCoords[this.numCoords++] = x1;
                        this.doubleCoords[this.numCoords++] = y1;
                        this.doubleCoords[this.numCoords++] = x2;
                        this.doubleCoords[this.numCoords++] = y2;
                    };
                    /**
                     * Adds a curved segment, defined by three new points, to the path by
                     * drawing a B&eacute;zier curve that intersects both the current
                     * coordinates and the specified coordinates {@code (x3,y3)}, using the
                     * specified points {@code (x1,y1)} and {@code (x2,y2)} as B&eacute;zier
                     * control points. All coordinates are specified in float precision.
                     * <p>
                     * This method provides a single precision variant of the double
                     * precision {@code curveTo()} method on the base {@code Path2D} class.
                     *
                     * @param x1
                     * the X coordinate of the first B&eacute;zier control point
                     * @param y1
                     * the Y coordinate of the first B&eacute;zier control point
                     * @param x2
                     * the X coordinate of the second B&eacute;zier control point
                     * @param y2
                     * the Y coordinate of the second B&eacute;zier control point
                     * @param x3
                     * the X coordinate of the final end point
                     * @param y3
                     * the Y coordinate of the final end point
                     * @see Path2D#curveTo
                     * @since 1.6
                     */
                    Double.prototype.curveTo = function (x1, y1, x2, y2, x3, y3) {
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null) && ((typeof x3 === 'number') || x3 === null) && ((typeof y3 === 'number') || y3 === null)) {
                            return this.curveTo$double$double$double$double$double$double(x1, y1, x2, y2, x3, y3);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     */
                    Double.prototype.curveTo$double$double$double$double$double$double = function (x1, y1, x2, y2, x3, y3) {
                        this.needRoom(true, 6);
                        this.pointTypes[this.numTypes++] = java.awt.geom.Path2D.SEG_CUBICTO_$LI$();
                        this.doubleCoords[this.numCoords++] = x1;
                        this.doubleCoords[this.numCoords++] = y1;
                        this.doubleCoords[this.numCoords++] = x2;
                        this.doubleCoords[this.numCoords++] = y2;
                        this.doubleCoords[this.numCoords++] = x3;
                        this.doubleCoords[this.numCoords++] = y3;
                    };
                    Double.prototype.pointCrossings = function (px, py) {
                        var movx;
                        var movy;
                        var curx;
                        var cury;
                        var endx;
                        var endy;
                        var coords = this.doubleCoords;
                        curx = movx = coords[0];
                        cury = movy = coords[1];
                        var crossings = 0;
                        var ci = 2;
                        for (var i = 1; i < this.numTypes; i++) {
                            switch ((this.pointTypes[i])) {
                                case java.awt.geom.PathIterator.SEG_MOVETO:
                                    if (cury !== movy) {
                                        crossings += sun.awt.geom.Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                                    }
                                    movx = curx = coords[ci++];
                                    movy = cury = coords[ci++];
                                    break;
                                case java.awt.geom.PathIterator.SEG_LINETO:
                                    crossings += sun.awt.geom.Curve.pointCrossingsForLine(px, py, curx, cury, endx = coords[ci++], endy = coords[ci++]);
                                    curx = endx;
                                    cury = endy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_QUADTO:
                                    crossings += sun.awt.geom.Curve.pointCrossingsForQuad(px, py, curx, cury, coords[ci++], coords[ci++], endx = coords[ci++], endy = coords[ci++], 0);
                                    curx = endx;
                                    cury = endy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_CUBICTO:
                                    crossings += sun.awt.geom.Curve.pointCrossingsForCubic(px, py, curx, cury, coords[ci++], coords[ci++], coords[ci++], coords[ci++], endx = coords[ci++], endy = coords[ci++], 0);
                                    curx = endx;
                                    cury = endy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_CLOSE:
                                    if (cury !== movy) {
                                        crossings += sun.awt.geom.Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                                    }
                                    curx = movx;
                                    cury = movy;
                                    break;
                            }
                        }
                        if (cury !== movy) {
                            crossings += sun.awt.geom.Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                        }
                        return crossings;
                    };
                    Double.prototype.rectCrossings = function (rxmin, rymin, rxmax, rymax) {
                        var coords = this.doubleCoords;
                        var curx;
                        var cury;
                        var movx;
                        var movy;
                        var endx;
                        var endy;
                        curx = movx = coords[0];
                        cury = movy = coords[1];
                        var crossings = 0;
                        var ci = 2;
                        for (var i = 1; crossings !== sun.awt.geom.Curve.RECT_INTERSECTS && i < this.numTypes; i++) {
                            switch ((this.pointTypes[i])) {
                                case java.awt.geom.PathIterator.SEG_MOVETO:
                                    if (curx !== movx || cury !== movy) {
                                        crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                                    }
                                    movx = curx = coords[ci++];
                                    movy = cury = coords[ci++];
                                    break;
                                case java.awt.geom.PathIterator.SEG_LINETO:
                                    endx = coords[ci++];
                                    endy = coords[ci++];
                                    crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, endx, endy);
                                    curx = endx;
                                    cury = endy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_QUADTO:
                                    crossings = sun.awt.geom.Curve.rectCrossingsForQuad(crossings, rxmin, rymin, rxmax, rymax, curx, cury, coords[ci++], coords[ci++], endx = coords[ci++], endy = coords[ci++], 0);
                                    curx = endx;
                                    cury = endy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_CUBICTO:
                                    crossings = sun.awt.geom.Curve.rectCrossingsForCubic(crossings, rxmin, rymin, rxmax, rymax, curx, cury, coords[ci++], coords[ci++], coords[ci++], coords[ci++], endx = coords[ci++], endy = coords[ci++], 0);
                                    curx = endx;
                                    cury = endy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_CLOSE:
                                    if (curx !== movx || cury !== movy) {
                                        crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                                    }
                                    curx = movx;
                                    cury = movy;
                                    break;
                            }
                        }
                        if (crossings !== sun.awt.geom.Curve.RECT_INTERSECTS && (curx !== movx || cury !== movy)) {
                            crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                        }
                        return crossings;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     */
                    Double.prototype.append = function (pi, connect) {
                        var _this = this;
                        if (((pi != null && pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0) || pi === null) && ((typeof connect === 'boolean') || connect === null)) {
                            return (function () {
                                var coords = new Array(6);
                                while ((!pi.isDone())) {
                                    switch ((pi.currentSegment(coords))) {
                                        case java.awt.geom.Path2D.SEG_MOVETO_$LI$():
                                            if (!connect || _this.numTypes < 1 || _this.numCoords < 1) {
                                                _this.moveTo(coords[0], coords[1]);
                                                break;
                                            }
                                            if (_this.pointTypes[_this.numTypes - 1] !== java.awt.geom.Path2D.SEG_CLOSE_$LI$() && _this.doubleCoords[_this.numCoords - 2] === coords[0] && _this.doubleCoords[_this.numCoords - 1] === coords[1]) {
                                                break;
                                            }
                                            _this.lineTo(coords[0], coords[1]);
                                            break;
                                        case java.awt.geom.Path2D.SEG_LINETO_$LI$():
                                            _this.lineTo(coords[0], coords[1]);
                                            break;
                                        case java.awt.geom.Path2D.SEG_QUADTO_$LI$():
                                            _this.quadTo(coords[0], coords[1], coords[2], coords[3]);
                                            break;
                                        case java.awt.geom.Path2D.SEG_CUBICTO_$LI$():
                                            _this.curveTo(coords[0], coords[1], coords[2], coords[3], coords[4], coords[5]);
                                            break;
                                        case java.awt.geom.Path2D.SEG_CLOSE_$LI$():
                                            _this.closePath();
                                            break;
                                    }
                                    pi.next();
                                    connect = false;
                                }
                                ;
                            })();
                        }
                        else if (((typeof pi === 'number') || pi === null) && ((typeof connect === 'number') || connect === null)) {
                            return this.append$float$float(pi, connect);
                        }
                        else if (((typeof pi === 'number') || pi === null) && ((typeof connect === 'number') || connect === null)) {
                            return this.append$double$double(pi, connect);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     */
                    Double.prototype.transform = function (at) {
                        at.transform(this.doubleCoords, 0, this.doubleCoords, 0, (this.numCoords / 2 | 0));
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     */
                    Double.prototype.getBounds2D = function () {
                        var x1;
                        var y1;
                        var x2;
                        var y2;
                        var i = this.numCoords;
                        if (i > 0) {
                            y1 = y2 = this.doubleCoords[--i];
                            x1 = x2 = this.doubleCoords[--i];
                            while ((i > 0)) {
                                var y = this.doubleCoords[--i];
                                var x = this.doubleCoords[--i];
                                if (x < x1)
                                    x1 = x;
                                if (y < y1)
                                    y1 = y;
                                if (x > x2)
                                    x2 = x;
                                if (y > y2)
                                    y2 = y;
                            }
                            ;
                        }
                        else {
                            x1 = y1 = x2 = y2 = 0.0;
                        }
                        return new java.awt.geom.Rectangle2D.Double(x1, y1, x2 - x1, y2 - y1);
                    };
                    /**
                     * {@inheritDoc}
                     * <p>
                     * The iterator for this class is not multi-threaded safe, which means
                     * that the {@code Path2D} class does not guarantee that modifications
                     * to the geometry of this {@code Path2D} object do not affect any
                     * iterations of that geometry that are already in process.
                     *
                     * @param at
                     * an {@code AffineTransform}
                     * @return a new {@code PathIterator} that iterates along the boundary
                     * of this {@code Shape} and provides access to the geometry of
                     * this {@code Shape}'s outline
                     * @since 1.6
                     */
                    Double.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
                        if (at == null) {
                            return new Double.CopyIterator(this);
                        }
                        else {
                            return new Double.TxIterator(this, at);
                        }
                    };
                    /**
                     * Creates a new object of the same class as this object.
                     *
                     * @return a clone of this instance.
                     * @exception OutOfMemoryError
                     * if there is not enough memory.
                     * @see java.lang.Cloneable
                     * @since 1.6
                     */
                    Double.prototype.clone = function () {
                        return new java.awt.geom.Path2D.Double(this);
                    };
                    Double.serialVersionUID = 1826762518450014216;
                    return Double;
                }(java.awt.geom.Path2D));
                Path2D.Double = Double;
                var Double;
                (function (Double) {
                    var CopyIterator = (function (_super) {
                        __extends(CopyIterator, _super);
                        function CopyIterator(p2dd) {
                            _super.call(this, p2dd);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.geom.PathIterator"] });
                            this.doubleCoords = p2dd.doubleCoords;
                        }
                        CopyIterator.prototype.currentSegment = function (coords) {
                            var _this = this;
                            if (((coords != null && coords instanceof Array) || coords === null)) {
                                return (function () {
                                    var type = _this.path.pointTypes[_this.typeIdx];
                                    var numCoords = java.awt.geom.Path2D.Iterator.curvecoords_$LI$()[type];
                                    if (numCoords > 0) {
                                        for (var i = 0; i < numCoords; i++) {
                                            coords[i] = _this.doubleCoords[_this.pointIdx + i];
                                        }
                                    }
                                    return type;
                                })();
                            }
                            else if (((coords != null && coords instanceof Array) || coords === null)) {
                                return this.currentSegment$double_A(coords);
                            }
                            else
                                throw new Error('invalid overload');
                        };
                        CopyIterator.prototype.currentSegment$double_A = function (coords) {
                            var type = this.path.pointTypes[this.typeIdx];
                            var numCoords = java.awt.geom.Path2D.Iterator.curvecoords_$LI$()[type];
                            if (numCoords > 0) {
                                java.lang.System.arraycopy(this.doubleCoords, this.pointIdx, coords, 0, numCoords);
                            }
                            return type;
                        };
                        return CopyIterator;
                    }(java.awt.geom.Path2D.Iterator));
                    Double.CopyIterator = CopyIterator;
                    var TxIterator = (function (_super) {
                        __extends(TxIterator, _super);
                        function TxIterator(p2dd, at) {
                            _super.call(this, p2dd);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.geom.PathIterator"] });
                            this.doubleCoords = p2dd.doubleCoords;
                            this.affine = at;
                        }
                        TxIterator.prototype.currentSegment = function (coords) {
                            var _this = this;
                            if (((coords != null && coords instanceof Array) || coords === null)) {
                                return (function () {
                                    var type = _this.path.pointTypes[_this.typeIdx];
                                    var numCoords = java.awt.geom.Path2D.Iterator.curvecoords_$LI$()[type];
                                    if (numCoords > 0) {
                                        _this.affine.transform(_this.doubleCoords, _this.pointIdx, coords, 0, (numCoords / 2 | 0));
                                    }
                                    return type;
                                })();
                            }
                            else if (((coords != null && coords instanceof Array) || coords === null)) {
                                return this.currentSegment$double_A(coords);
                            }
                            else
                                throw new Error('invalid overload');
                        };
                        TxIterator.prototype.currentSegment$double_A = function (coords) {
                            var type = this.path.pointTypes[this.typeIdx];
                            var numCoords = java.awt.geom.Path2D.Iterator.curvecoords_$LI$()[type];
                            if (numCoords > 0) {
                                this.affine.transform(this.doubleCoords, this.pointIdx, coords, 0, (numCoords / 2 | 0));
                            }
                            return type;
                        };
                        return TxIterator;
                    }(java.awt.geom.Path2D.Iterator));
                    Double.TxIterator = TxIterator;
                })(Double = Path2D.Double || (Path2D.Double = {}));
            })(Path2D = geom.Path2D || (geom.Path2D = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        /**
         * A point representing a location in {@code (x,y)} coordinate space,
         * specified in integer precision.
         *
         * @author      Sami Shaio
         * @since       1.0
         */
        var Point = (function (_super) {
            __extends(Point, _super);
            /**
             * Constructs and initializes a point at the specified
             * {@code (x,y)} location in the coordinate space.
             * @param x the X coordinate of the newly constructed <code>Point</code>
             * @param y the Y coordinate of the newly constructed <code>Point</code>
             * @since 1.0
             */
            function Point(x, y) {
                var _this = this;
                if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.io.Serializable"] });
                    this.x = 0;
                    this.y = 0;
                    (function () {
                        _this.x = x;
                        _this.y = y;
                    })();
                }
                else if (((x != null && x instanceof java.awt.Point) || x === null) && y === undefined) {
                    var p = x;
                    {
                        var x = p.x;
                        var y = p.y;
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.io.Serializable"] });
                        this.x = 0;
                        this.y = 0;
                        (function () {
                            _this.x = x;
                            _this.y = y;
                        })();
                    }
                    (function () {
                    })();
                }
                else if (x === undefined && y === undefined) {
                    {
                        var x = 0;
                        var y = 0;
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.io.Serializable"] });
                        this.x = 0;
                        this.y = 0;
                        (function () {
                            _this.x = x;
                            _this.y = y;
                        })();
                    }
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * {@inheritDoc}
             * @since 1.2
             */
            Point.prototype.getX = function () {
                return this.x;
            };
            /**
             * {@inheritDoc}
             * @since 1.2
             */
            Point.prototype.getY = function () {
                return this.y;
            };
            /**
             * Returns the location of this point.
             * This method is included for completeness, to parallel the
             * <code>getLocation</code> method of <code>Component</code>.
             * @return      a copy of this point, at the same location
             * @see         java.awt.Component#getLocation
             * @see         java.awt.Point#setLocation(java.awt.Point)
             * @see         java.awt.Point#setLocation(int, int)
             * @since       1.1
             */
            Point.prototype.getLocation = function () {
                return new Point(this.x, this.y);
            };
            /**
             * Sets the location of the point to the specified location.
             * This method is included for completeness, to parallel the
             * <code>setLocation</code> method of <code>Component</code>.
             * @param       p  a point, the new location for this point
             * @see         java.awt.Component#setLocation(java.awt.Point)
             * @see         java.awt.Point#getLocation
             * @since       1.1
             */
            Point.prototype.setLocation$java_awt_Point = function (p) {
                this.setLocation(p.x, p.y);
            };
            /**
             * Changes the point to have the specified location.
             * <p>
             * This method is included for completeness, to parallel the
             * <code>setLocation</code> method of <code>Component</code>.
             * Its behavior is identical with <code>move(int,&nbsp;int)</code>.
             * @param       x the X coordinate of the new location
             * @param       y the Y coordinate of the new location
             * @see         java.awt.Component#setLocation(int, int)
             * @see         java.awt.Point#getLocation
             * @see         java.awt.Point#move(int, int)
             * @since       1.1
             */
            Point.prototype.setLocation = function (x, y) {
                var _this = this;
                if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return (function () {
                        _this.move(x, y);
                    })();
                }
                else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return this.setLocation$double$double(x, y);
                }
                else if (((x != null && x instanceof java.awt.Point) || x === null) && y === undefined) {
                    return this.setLocation$java_awt_Point(x);
                }
                else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined) {
                    return this.setLocation$java_awt_geom_Point2D(x);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Sets the location of this point to the specified double coordinates.
             * The double values will be rounded to integer values.
             * Any number smaller than <code>Integer.MIN_VALUE</code>
             * will be reset to <code>MIN_VALUE</code>, and any number
             * larger than <code>Integer.MAX_VALUE</code> will be
             * reset to <code>MAX_VALUE</code>.
             *
             * @param x the X coordinate of the new location
             * @param y the Y coordinate of the new location
             * @see #getLocation
             */
            Point.prototype.setLocation$double$double = function (x, y) {
                this.x = (Math.floor(x + 0.5) | 0);
                this.y = (Math.floor(y + 0.5) | 0);
            };
            /**
             * Moves this point to the specified location in the
             * {@code (x,y)} coordinate plane. This method
             * is identical with <code>setLocation(int,&nbsp;int)</code>.
             * @param       x the X coordinate of the new location
             * @param       y the Y coordinate of the new location
             * @see         java.awt.Component#setLocation(int, int)
             */
            Point.prototype.move = function (x, y) {
                this.x = x;
                this.y = y;
            };
            /**
             * Translates this point, at location {@code (x,y)},
             * by {@code dx} along the {@code x} axis and {@code dy}
             * along the {@code y} axis so that it now represents the point
             * {@code (x+dx,y+dy)}.
             *
             * @param       dx   the distance to move this point
             * along the X axis
             * @param       dy    the distance to move this point
             * along the Y axis
             */
            Point.prototype.translate = function (dx, dy) {
                this.x += dx;
                this.y += dy;
            };
            /**
             * Determines whether or not two points are equal. Two instances of
             * <code>Point2D</code> are equal if the values of their
             * <code>x</code> and <code>y</code> member fields, representing
             * their position in the coordinate space, are the same.
             * @param obj an object to be compared with this <code>Point2D</code>
             * @return <code>true</code> if the object to be compared is
             * an instance of <code>Point2D</code> and has
             * the same values; <code>false</code> otherwise.
             */
            Point.prototype.equals = function (obj) {
                if (obj != null && obj instanceof java.awt.Point) {
                    var pt = obj;
                    return (this.x === pt.x) && (this.y === pt.y);
                }
                return _super.prototype.equals.call(this, obj);
            };
            /**
             * Returns a string representation of this point and its location
             * in the {@code (x,y)} coordinate space. This method is
             * intended to be used only for debugging purposes, and the content
             * and format of the returned string may vary between implementations.
             * The returned string may be empty but may not be <code>null</code>.
             *
             * @return  a string representation of this point
             */
            Point.prototype.toString = function () {
                return "java.awt.Point" + "[x=" + this.x + ",y=" + this.y + "]";
            };
            Point.serialVersionUID = -5276940640259749850;
            return Point;
        }(java.awt.geom.Point2D));
        awt.Point = Point;
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * <CODE>Arc2D</CODE> is the abstract superclass for all objects that
             * store a 2D arc defined by a framing rectangle,
             * start angle, angular extent (length of the arc), and a closure type
             * (<CODE>OPEN</CODE>, <CODE>CHORD</CODE>, or <CODE>PIE</CODE>).
             * <p>
             * <a name="inscribes">
             * The arc is a partial section of a full ellipse which
             * inscribes the framing rectangle of its parent {@link RectangularShape}.
             * </a>
             * <a name="angles">
             * The angles are specified relative to the non-square
             * framing rectangle such that 45 degrees always falls on the line from
             * the center of the ellipse to the upper right corner of the framing
             * rectangle.
             * As a result, if the framing rectangle is noticeably longer along one
             * axis than the other, the angles to the start and end of the arc segment
             * will be skewed farther along the longer axis of the frame.
             * </a>
             * <p>
             * The actual storage representation of the coordinates is left to
             * the subclass.
             *
             * @author      Jim Graham
             * @since 1.2
             */
            var Arc2D = (function (_super) {
                __extends(Arc2D, _super);
                /**
                 * This is an abstract class that cannot be instantiated directly.
                 * Type-specific implementation subclasses are available for
                 * instantiation and provide a number of formats for storing
                 * the information necessary to satisfy the various accessor
                 * methods below.
                 *
                 * @param type The closure type of this arc:
                 * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.
                 * @see java.awt.geom.Arc2D.Float
                 * @see java.awt.geom.Arc2D.Double
                 * @since 1.2
                 */
                function Arc2D(type) {
                    if (type === void 0) { type = Arc2D.OPEN; }
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable"] });
                    this.type = 0;
                    this.setArcType(type);
                }
                /**
                 * Returns the arc closure type of the arc: {@link #OPEN},
                 * {@link #CHORD}, or {@link #PIE}.
                 * @return One of the integer constant closure types defined
                 * in this class.
                 * @see #setArcType
                 * @since 1.2
                 */
                Arc2D.prototype.getArcType = function () {
                    return this.type;
                };
                /**
                 * Returns the starting point of the arc.  This point is the
                 * intersection of the ray from the center defined by the
                 * starting angle and the elliptical boundary of the arc.
                 *
                 * @return A <CODE>Point2D</CODE> object representing the
                 * x,y coordinates of the starting point of the arc.
                 * @since 1.2
                 */
                Arc2D.prototype.getStartPoint = function () {
                    var angle = (function (x) { return x * Math.PI / 180; })(-this.getAngleStart());
                    var x = this.getX() + (Math.cos(angle) * 0.5 + 0.5) * this.getWidth();
                    var y = this.getY() + (Math.sin(angle) * 0.5 + 0.5) * this.getHeight();
                    return new java.awt.geom.Point2D.Double(x, y);
                };
                /**
                 * Returns the ending point of the arc.  This point is the
                 * intersection of the ray from the center defined by the
                 * starting angle plus the angular extent of the arc and the
                 * elliptical boundary of the arc.
                 *
                 * @return A <CODE>Point2D</CODE> object representing the
                 * x,y coordinates  of the ending point of the arc.
                 * @since 1.2
                 */
                Arc2D.prototype.getEndPoint = function () {
                    var angle = (function (x) { return x * Math.PI / 180; })(-this.getAngleStart() - this.getAngleExtent());
                    var x = this.getX() + (Math.cos(angle) * 0.5 + 0.5) * this.getWidth();
                    var y = this.getY() + (Math.sin(angle) * 0.5 + 0.5) * this.getHeight();
                    return new java.awt.geom.Point2D.Double(x, y);
                };
                /**
                 * Sets the location, size, angular extents, and closure type of
                 * this arc to the specified double values.
                 *
                 * @param x The X coordinate of the upper-left corner of the arc.
                 * @param y The Y coordinate of the upper-left corner of the arc.
                 * @param w The overall width of the full ellipse of which
                 * this arc is a partial section.
                 * @param h The overall height of the full ellipse of which
                 * this arc is a partial section.
                 * @param angSt The starting angle of the arc in degrees.
                 * @param angExt The angular extent of the arc in degrees.
                 * @param closure The closure type for the arc:
                 * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.
                 * @since 1.2
                 */
                Arc2D.prototype.setArc = function (x, y, w, h, angSt, angExt, closure) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof angSt === 'number') || angSt === null) && ((typeof angExt === 'number') || angExt === null) && ((typeof closure === 'number') || closure === null)) {
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && ((y != null && y instanceof java.awt.geom.Dimension2D) || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof angSt === 'number') || angSt === null) && angExt === undefined && closure === undefined) {
                        return this.setArc$java_awt_geom_Point2D$java_awt_geom_Dimension2D$double$double$int(x, y, w, h, angSt);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && angSt === undefined && angExt === undefined && closure === undefined) {
                        return this.setArc$java_awt_geom_Rectangle2D$double$double$int(x, y, w, h);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Arc2D) || x === null) && y === undefined && w === undefined && h === undefined && angSt === undefined && angExt === undefined && closure === undefined) {
                        return this.setArc$java_awt_geom_Arc2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets the location, size, angular extents, and closure type of
                 * this arc to the specified values.
                 *
                 * @param loc The <CODE>Point2D</CODE> representing the coordinates of
                 * the upper-left corner of the arc.
                 * @param size The <CODE>Dimension2D</CODE> representing the width
                 * and height of the full ellipse of which this arc is
                 * a partial section.
                 * @param angSt The starting angle of the arc in degrees.
                 * @param angExt The angular extent of the arc in degrees.
                 * @param closure The closure type for the arc:
                 * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.
                 * @since 1.2
                 */
                Arc2D.prototype.setArc$java_awt_geom_Point2D$java_awt_geom_Dimension2D$double$double$int = function (loc, size, angSt, angExt, closure) {
                    this.setArc(loc.getX(), loc.getY(), size.getWidth(), size.getHeight(), angSt, angExt, closure);
                };
                /**
                 * Sets the location, size, angular extents, and closure type of
                 * this arc to the specified values.
                 *
                 * @param rect The framing rectangle that defines the
                 * outer boundary of the full ellipse of which this arc is a
                 * partial section.
                 * @param angSt The starting angle of the arc in degrees.
                 * @param angExt The angular extent of the arc in degrees.
                 * @param closure The closure type for the arc:
                 * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.
                 * @since 1.2
                 */
                Arc2D.prototype.setArc$java_awt_geom_Rectangle2D$double$double$int = function (rect, angSt, angExt, closure) {
                    this.setArc(rect.getX(), rect.getY(), rect.getWidth(), rect.getHeight(), angSt, angExt, closure);
                };
                /**
                 * Sets this arc to be the same as the specified arc.
                 *
                 * @param a The <CODE>Arc2D</CODE> to use to set the arc's values.
                 * @since 1.2
                 */
                Arc2D.prototype.setArc$java_awt_geom_Arc2D = function (a) {
                    this.setArc(a.getX(), a.getY(), a.getWidth(), a.getHeight(), a.getAngleStart(), a.getAngleExtent(), a.type);
                };
                /**
                 * Sets the position, bounds, angular extents, and closure type of
                 * this arc to the specified values. The arc is defined by a center
                 * point and a radius rather than a framing rectangle for the full ellipse.
                 *
                 * @param x The X coordinate of the center of the arc.
                 * @param y The Y coordinate of the center of the arc.
                 * @param radius The radius of the arc.
                 * @param angSt The starting angle of the arc in degrees.
                 * @param angExt The angular extent of the arc in degrees.
                 * @param closure The closure type for the arc:
                 * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.
                 * @since 1.2
                 */
                Arc2D.prototype.setArcByCenter = function (x, y, radius, angSt, angExt, closure) {
                    this.setArc(x - radius, y - radius, radius * 2.0, radius * 2.0, angSt, angExt, closure);
                };
                /**
                 * Sets the position, bounds, and angular extents of this arc to the
                 * specified value. The starting angle of the arc is tangent to the
                 * line specified by points (p1, p2), the ending angle is tangent to
                 * the line specified by points (p2, p3), and the arc has the
                 * specified radius.
                 *
                 * @param p1 The first point that defines the arc. The starting
                 * angle of the arc is tangent to the line specified by points (p1, p2).
                 * @param p2 The second point that defines the arc. The starting
                 * angle of the arc is tangent to the line specified by points (p1, p2).
                 * The ending angle of the arc is tangent to the line specified by
                 * points (p2, p3).
                 * @param p3 The third point that defines the arc. The ending angle
                 * of the arc is tangent to the line specified by points (p2, p3).
                 * @param radius The radius of the arc.
                 * @since 1.2
                 */
                Arc2D.prototype.setArcByTangent = function (p1, p2, p3, radius) {
                    var ang1 = Math.atan2(p1.getY() - p2.getY(), p1.getX() - p2.getX());
                    var ang2 = Math.atan2(p3.getY() - p2.getY(), p3.getX() - p2.getX());
                    var diff = ang2 - ang1;
                    if (diff > Math.PI) {
                        ang2 -= Math.PI * 2.0;
                    }
                    else if (diff < -Math.PI) {
                        ang2 += Math.PI * 2.0;
                    }
                    var bisect = (ang1 + ang2) / 2.0;
                    var theta = Math.abs(ang2 - bisect);
                    var dist = radius / Math.sin(theta);
                    var x = p2.getX() + dist * Math.cos(bisect);
                    var y = p2.getY() + dist * Math.sin(bisect);
                    if (ang1 < ang2) {
                        ang1 -= Math.PI / 2.0;
                        ang2 += Math.PI / 2.0;
                    }
                    else {
                        ang1 += Math.PI / 2.0;
                        ang2 -= Math.PI / 2.0;
                    }
                    ang1 = (function (x) { return x * 180 / Math.PI; })(-ang1);
                    ang2 = (function (x) { return x * 180 / Math.PI; })(-ang2);
                    diff = ang2 - ang1;
                    if (diff < 0) {
                        diff += 360;
                    }
                    else {
                        diff -= 360;
                    }
                    this.setArcByCenter(x, y, radius, ang1, diff, this.type);
                };
                /**
                 * Sets the starting angle of this arc to the specified double
                 * value.
                 *
                 * @param angSt The starting angle of the arc in degrees.
                 * @see #getAngleStart
                 * @since 1.2
                 */
                Arc2D.prototype.setAngleStart$double = function (angSt) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Sets the starting angle of this arc to the angle that the
                 * specified point defines relative to the center of this arc.
                 * The angular extent of the arc will remain the same.
                 *
                 * @param p The <CODE>Point2D</CODE> that defines the starting angle.
                 * @see #getAngleStart
                 * @since 1.2
                 */
                Arc2D.prototype.setAngleStart = function (p) {
                    var _this = this;
                    if (((p != null && p instanceof java.awt.geom.Point2D) || p === null)) {
                        return (function () {
                            var dx = _this.getHeight() * (p.getX() - _this.getCenterX());
                            var dy = _this.getWidth() * (p.getY() - _this.getCenterY());
                            _this.setAngleStart(-(function (x) { return x * 180 / Math.PI; })(Math.atan2(dy, dx)));
                        })();
                    }
                    else if (((typeof p === 'number') || p === null)) {
                        return this.setAngleStart$double(p);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets the starting angle and angular extent of this arc using two
                 * sets of coordinates. The first set of coordinates is used to
                 * determine the angle of the starting point relative to the arc's
                 * center. The second set of coordinates is used to determine the
                 * angle of the end point relative to the arc's center.
                 * The arc will always be non-empty and extend counterclockwise
                 * from the first point around to the second point.
                 *
                 * @param x1 The X coordinate of the arc's starting point.
                 * @param y1 The Y coordinate of the arc's starting point.
                 * @param x2 The X coordinate of the arc's ending point.
                 * @param y2 The Y coordinate of the arc's ending point.
                 * @since 1.2
                 */
                Arc2D.prototype.setAngles = function (x1, y1, x2, y2) {
                    var _this = this;
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        return (function () {
                            var x = _this.getCenterX();
                            var y = _this.getCenterY();
                            var w = _this.getWidth();
                            var h = _this.getHeight();
                            var ang1 = Math.atan2(w * (y - y1), h * (x1 - x));
                            var ang2 = Math.atan2(w * (y - y2), h * (x2 - x));
                            ang2 -= ang1;
                            if (ang2 <= 0.0) {
                                ang2 += Math.PI * 2.0;
                            }
                            _this.setAngleStart(/* toDegrees */ (function (x) { return x * 180 / Math.PI; })(ang1));
                            _this.setAngleExtent(/* toDegrees */ (function (x) { return x * 180 / Math.PI; })(ang2));
                        })();
                    }
                    else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && x2 === undefined && y2 === undefined) {
                        return this.setAngles$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets the starting angle and angular extent of this arc using
                 * two points. The first point is used to determine the angle of
                 * the starting point relative to the arc's center.
                 * The second point is used to determine the angle of the end point
                 * relative to the arc's center.
                 * The arc will always be non-empty and extend counterclockwise
                 * from the first point around to the second point.
                 *
                 * @param p1 The <CODE>Point2D</CODE> that defines the arc's
                 * starting point.
                 * @param p2 The <CODE>Point2D</CODE> that defines the arc's
                 * ending point.
                 * @since 1.2
                 */
                Arc2D.prototype.setAngles$java_awt_geom_Point2D$java_awt_geom_Point2D = function (p1, p2) {
                    this.setAngles(p1.getX(), p1.getY(), p2.getX(), p2.getY());
                };
                /**
                 * Sets the closure type of this arc to the specified value:
                 * <CODE>OPEN</CODE>, <CODE>CHORD</CODE>, or <CODE>PIE</CODE>.
                 *
                 * @param type The integer constant that represents the closure
                 * type of this arc: {@link #OPEN}, {@link #CHORD}, or
                 * {@link #PIE}.
                 *
                 * @throws IllegalArgumentException if <code>type</code> is not
                 * 0, 1, or 2.+
                 * @see #getArcType
                 * @since 1.2
                 */
                Arc2D.prototype.setArcType = function (type) {
                    if (type < Arc2D.OPEN || type > Arc2D.PIE) {
                        throw new java.lang.IllegalArgumentException("invalid type for Arc: " + type);
                    }
                    this.type = type;
                };
                /**
                 * {@inheritDoc}
                 * Note that the arc
                 * <a href="Arc2D.html#inscribes">partially inscribes</a>
                 * the framing rectangle of this {@code RectangularShape}.
                 *
                 * @since 1.2
                 */
                Arc2D.prototype.setFrame = function (x, y, w, h) {
                    var _this = this;
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return (function () {
                            _this.setArc(x, y, w, h, _this.getAngleStart(), _this.getAngleExtent(), _this.type);
                        })();
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && ((y != null && y instanceof java.awt.geom.Dimension2D) || y === null) && w === undefined && h === undefined) {
                        return this.setFrame$java_awt_geom_Point2D$java_awt_geom_Dimension2D(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.setFrame$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the high-precision framing rectangle of the arc.  The framing
                 * rectangle contains only the part of this <code>Arc2D</code> that is
                 * in between the starting and ending angles and contains the pie
                 * wedge, if this <code>Arc2D</code> has a <code>PIE</code> closure type.
                 * <p>
                 * This method differs from the
                 * {@link RectangularShape#getBounds() getBounds} in that the
                 * <code>getBounds</code> method only returns the bounds of the
                 * enclosing ellipse of this <code>Arc2D</code> without considering
                 * the starting and ending angles of this <code>Arc2D</code>.
                 *
                 * @return the <CODE>Rectangle2D</CODE> that represents the arc's
                 * framing rectangle.
                 * @since 1.2
                 */
                Arc2D.prototype.getBounds2D = function () {
                    if (this.isEmpty()) {
                        return this.makeBounds(this.getX(), this.getY(), this.getWidth(), this.getHeight());
                    }
                    var x1;
                    var y1;
                    var x2;
                    var y2;
                    if (this.getArcType() === Arc2D.PIE) {
                        x1 = y1 = x2 = y2 = 0.0;
                    }
                    else {
                        x1 = y1 = 1.0;
                        x2 = y2 = -1.0;
                    }
                    var angle = 0.0;
                    for (var i = 0; i < 6; i++) {
                        if (i < 4) {
                            angle += 90.0;
                            if (!this.containsAngle(angle)) {
                                continue;
                            }
                        }
                        else if (i === 4) {
                            angle = this.getAngleStart();
                        }
                        else {
                            angle += this.getAngleExtent();
                        }
                        var rads = (function (x) { return x * Math.PI / 180; })(-angle);
                        var xe = Math.cos(rads);
                        var ye = Math.sin(rads);
                        x1 = Math.min(x1, xe);
                        y1 = Math.min(y1, ye);
                        x2 = Math.max(x2, xe);
                        y2 = Math.max(y2, ye);
                    }
                    var w = this.getWidth();
                    var h = this.getHeight();
                    x2 = (x2 - x1) * 0.5 * w;
                    y2 = (y2 - y1) * 0.5 * h;
                    x1 = this.getX() + (x1 * 0.5 + 0.5) * w;
                    y1 = this.getY() + (y1 * 0.5 + 0.5) * h;
                    return this.makeBounds(x1, y1, x2, y2);
                };
                Arc2D.normalizeDegrees = function (angle) {
                    if (angle > 180.0) {
                        if (angle <= (180.0 + 360.0)) {
                            angle = angle - 360.0;
                        }
                        else {
                            angle = javaemul.internal.MathHelper.IEEEremainder(angle, 360.0);
                            if (angle === -180.0) {
                                angle = 180.0;
                            }
                        }
                    }
                    else if (angle <= -180.0) {
                        if (angle > (-180.0 - 360.0)) {
                            angle = angle + 360.0;
                        }
                        else {
                            angle = javaemul.internal.MathHelper.IEEEremainder(angle, 360.0);
                            if (angle === -180.0) {
                                angle = 180.0;
                            }
                        }
                    }
                    return angle;
                };
                /**
                 * Determines whether or not the specified angle is within the
                 * angular extents of the arc.
                 *
                 * @param angle The angle to test.
                 *
                 * @return <CODE>true</CODE> if the arc contains the angle,
                 * <CODE>false</CODE> if the arc doesn't contain the angle.
                 * @since 1.2
                 */
                Arc2D.prototype.containsAngle = function (angle) {
                    var angExt = this.getAngleExtent();
                    var backwards = (angExt < 0.0);
                    if (backwards) {
                        angExt = -angExt;
                    }
                    if (angExt >= 360.0) {
                        return true;
                    }
                    angle = Arc2D.normalizeDegrees(angle) - Arc2D.normalizeDegrees(this.getAngleStart());
                    if (backwards) {
                        angle = -angle;
                    }
                    if (angle < 0.0) {
                        angle += 360.0;
                    }
                    return (angle >= 0.0) && (angle < angExt);
                };
                /**
                 * Determines whether or not the specified point is inside the boundary
                 * of the arc.
                 *
                 * @param x The X coordinate of the point to test.
                 * @param y The Y coordinate of the point to test.
                 *
                 * @return <CODE>true</CODE> if the point lies within the bound of
                 * the arc, <CODE>false</CODE> if the point lies outside of the
                 * arc's bounds.
                 * @since 1.2
                 */
                Arc2D.prototype.contains$double$double = function (x, y) {
                    var ellw = this.getWidth();
                    if (ellw <= 0.0) {
                        return false;
                    }
                    var normx = (x - this.getX()) / ellw - 0.5;
                    var ellh = this.getHeight();
                    if (ellh <= 0.0) {
                        return false;
                    }
                    var normy = (y - this.getY()) / ellh - 0.5;
                    var distSq = (normx * normx + normy * normy);
                    if (distSq >= 0.25) {
                        return false;
                    }
                    var angExt = Math.abs(this.getAngleExtent());
                    if (angExt >= 360.0) {
                        return true;
                    }
                    var inarc = this.containsAngle(-(function (x) { return x * 180 / Math.PI; })(Math.atan2(normy, normx)));
                    if (this.type === Arc2D.PIE) {
                        return inarc;
                    }
                    if (inarc) {
                        if (angExt >= 180.0) {
                            return true;
                        }
                    }
                    else {
                        if (angExt <= 180.0) {
                            return false;
                        }
                    }
                    var angle = (function (x) { return x * Math.PI / 180; })(-this.getAngleStart());
                    var x1 = Math.cos(angle);
                    var y1 = Math.sin(angle);
                    angle += (function (x) { return x * Math.PI / 180; })(-this.getAngleExtent());
                    var x2 = Math.cos(angle);
                    var y2 = Math.sin(angle);
                    var inside = (java.awt.geom.Line2D.relativeCCW(x1, y1, x2, y2, 2 * normx, 2 * normy) * java.awt.geom.Line2D.relativeCCW(x1, y1, x2, y2, 0, 0) >= 0);
                    return inarc ? !inside : inside;
                };
                /**
                 * Determines whether or not the interior of the arc intersects
                 * the interior of the specified rectangle.
                 *
                 * @param x The X coordinate of the rectangle's upper-left corner.
                 * @param y The Y coordinate of the rectangle's upper-left corner.
                 * @param w The width of the rectangle.
                 * @param h The height of the rectangle.
                 *
                 * @return <CODE>true</CODE> if the arc intersects the rectangle,
                 * <CODE>false</CODE> if the arc doesn't intersect the rectangle.
                 * @since 1.2
                 */
                Arc2D.prototype.intersects = function (x, y, w, h) {
                    var _this = this;
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return (function () {
                            var aw = _this.getWidth();
                            var ah = _this.getHeight();
                            if (w <= 0 || h <= 0 || aw <= 0 || ah <= 0) {
                                return false;
                            }
                            var ext = _this.getAngleExtent();
                            if (ext === 0) {
                                return false;
                            }
                            var ax = _this.getX();
                            var ay = _this.getY();
                            var axw = ax + aw;
                            var ayh = ay + ah;
                            var xw = x + w;
                            var yh = y + h;
                            if (x >= axw || y >= ayh || xw <= ax || yh <= ay) {
                                return false;
                            }
                            var axc = _this.getCenterX();
                            var ayc = _this.getCenterY();
                            var sp = _this.getStartPoint();
                            var ep = _this.getEndPoint();
                            var sx = sp.getX();
                            var sy = sp.getY();
                            var ex = ep.getX();
                            var ey = ep.getY();
                            if (ayc >= y && ayc <= yh) {
                                if ((sx < xw && ex < xw && axc < xw && axw > x && _this.containsAngle(0)) || (sx > x && ex > x && axc > x && ax < xw && _this.containsAngle(180))) {
                                    return true;
                                }
                            }
                            if (axc >= x && axc <= xw) {
                                if ((sy > y && ey > y && ayc > y && ay < yh && _this.containsAngle(90)) || (sy < yh && ey < yh && ayc < yh && ayh > y && _this.containsAngle(270))) {
                                    return true;
                                }
                            }
                            var rect = new java.awt.geom.Rectangle2D.Double(x, y, w, h);
                            if (_this.type === Arc2D.PIE || Math.abs(ext) > 180) {
                                if (rect.intersectsLine(axc, ayc, sx, sy) || rect.intersectsLine(axc, ayc, ex, ey)) {
                                    return true;
                                }
                            }
                            else {
                                if (rect.intersectsLine(sx, sy, ex, ey)) {
                                    return true;
                                }
                            }
                            if (_this.contains(x, y) || _this.contains(x + w, y) || _this.contains(x, y + h) || _this.contains(x + w, y + h)) {
                                return true;
                            }
                            return false;
                        })();
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.intersects$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Determines whether or not the interior of the arc entirely contains
                 * the specified rectangle.
                 *
                 * @param x The X coordinate of the rectangle's upper-left corner.
                 * @param y The Y coordinate of the rectangle's upper-left corner.
                 * @param w The width of the rectangle.
                 * @param h The height of the rectangle.
                 *
                 * @return <CODE>true</CODE> if the arc contains the rectangle,
                 * <CODE>false</CODE> if the arc doesn't contain the rectangle.
                 * @since 1.2
                 */
                Arc2D.prototype.contains$double$double$double$double = function (x, y, w, h) {
                    return this.contains(x, y, w, h, null);
                };
                /**
                 * Determines whether or not the interior of the arc entirely contains
                 * the specified rectangle.
                 *
                 * @param r The <CODE>Rectangle2D</CODE> to test.
                 *
                 * @return <CODE>true</CODE> if the arc contains the rectangle,
                 * <CODE>false</CODE> if the arc doesn't contain the rectangle.
                 * @since 1.2
                 */
                Arc2D.prototype.contains$java_awt_geom_Rectangle2D = function (r) {
                    return this.contains(r.getX(), r.getY(), r.getWidth(), r.getHeight(), r);
                };
                Arc2D.prototype.contains = function (x, y, w, h, origrect) {
                    var _this = this;
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((origrect != null && origrect instanceof java.awt.geom.Rectangle2D) || origrect === null)) {
                        return (function () {
                            if (!(_this.contains(x, y) && _this.contains(x + w, y) && _this.contains(x, y + h) && _this.contains(x + w, y + h))) {
                                return false;
                            }
                            if (_this.type !== Arc2D.PIE || Math.abs(_this.getAngleExtent()) <= 180.0) {
                                return true;
                            }
                            if (origrect == null) {
                                origrect = new java.awt.geom.Rectangle2D.Double(x, y, w, h);
                            }
                            var halfW = _this.getWidth() / 2.0;
                            var halfH = _this.getHeight() / 2.0;
                            var xc = _this.getX() + halfW;
                            var yc = _this.getY() + halfH;
                            var angle = (function (x) { return x * Math.PI / 180; })(-_this.getAngleStart());
                            var xe = xc + halfW * Math.cos(angle);
                            var ye = yc + halfH * Math.sin(angle);
                            if (origrect.intersectsLine(xc, yc, xe, ye)) {
                                return false;
                            }
                            angle += (function (x) { return x * Math.PI / 180; })(-_this.getAngleExtent());
                            xe = xc + halfW * Math.cos(angle);
                            ye = yc + halfH * Math.sin(angle);
                            return !origrect.intersectsLine(xc, yc, xe, ye);
                        })();
                    }
                    else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && origrect === undefined) {
                        return this.contains$double$double$double$double(x, y, w, h);
                    }
                    else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$double$double(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$java_awt_geom_Rectangle2D(x);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$java_awt_geom_Point2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns an iteration object that defines the boundary of the
                 * arc.
                 * This iterator is multithread safe.
                 * <code>Arc2D</code> guarantees that
                 * modifications to the geometry of the arc
                 * do not affect any iterations of that geometry that
                 * are already in process.
                 *
                 * @param at an optional <CODE>AffineTransform</CODE> to be applied
                 * to the coordinates as they are returned in the iteration, or null
                 * if the untransformed coordinates are desired.
                 *
                 * @return A <CODE>PathIterator</CODE> that defines the arc's boundary.
                 * @since 1.2
                 */
                Arc2D.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
                    return new java.awt.geom.ArcIterator(this, at);
                };
                /**
                 * Returns the hashcode for this <code>Arc2D</code>.
                 * @return the hashcode for this <code>Arc2D</code>.
                 * @since 1.6
                 */
                Arc2D.prototype.hashCode = function () {
                    var bits = javaemul.internal.DoubleHelper.doubleToLongBits(this.getX());
                    bits += javaemul.internal.DoubleHelper.doubleToLongBits(this.getY()) * 37;
                    bits += javaemul.internal.DoubleHelper.doubleToLongBits(this.getWidth()) * 43;
                    bits += javaemul.internal.DoubleHelper.doubleToLongBits(this.getHeight()) * 47;
                    bits += javaemul.internal.DoubleHelper.doubleToLongBits(this.getAngleStart()) * 53;
                    bits += javaemul.internal.DoubleHelper.doubleToLongBits(this.getAngleExtent()) * 59;
                    bits += this.getArcType() * 61;
                    return (((bits | 0)) ^ (((bits >> 32) | 0)));
                };
                /**
                 * Determines whether or not the specified <code>Object</code> is
                 * equal to this <code>Arc2D</code>.  The specified
                 * <code>Object</code> is equal to this <code>Arc2D</code>
                 * if it is an instance of <code>Arc2D</code> and if its
                 * location, size, arc extents and type are the same as this
                 * <code>Arc2D</code>.
                 * @param obj  an <code>Object</code> to be compared with this
                 * <code>Arc2D</code>.
                 * @return  <code>true</code> if <code>obj</code> is an instance
                 * of <code>Arc2D</code> and has the same values;
                 * <code>false</code> otherwise.
                 * @since 1.6
                 */
                Arc2D.prototype.equals = function (obj) {
                    if (obj === this) {
                        return true;
                    }
                    if (obj != null && obj instanceof java.awt.geom.Arc2D) {
                        var a2d = obj;
                        return ((this.getX() === a2d.getX()) && (this.getY() === a2d.getY()) && (this.getWidth() === a2d.getWidth()) && (this.getHeight() === a2d.getHeight()) && (this.getAngleStart() === a2d.getAngleStart()) && (this.getAngleExtent() === a2d.getAngleExtent()) && (this.getArcType() === a2d.getArcType()));
                    }
                    return false;
                };
                /**
                 * The closure type for an open arc with no path segments
                 * connecting the two ends of the arc segment.
                 * @since 1.2
                 */
                Arc2D.OPEN = 0;
                /**
                 * The closure type for an arc closed by drawing a straight
                 * line segment from the start of the arc segment to the end of the
                 * arc segment.
                 * @since 1.2
                 */
                Arc2D.CHORD = 1;
                /**
                 * The closure type for an arc closed by drawing straight line
                 * segments from the start of the arc segment to the center
                 * of the full ellipse and from that point to the end of the arc segment.
                 * @since 1.2
                 */
                Arc2D.PIE = 2;
                return Arc2D;
            }(java.awt.geom.RectangularShape));
            geom.Arc2D = Arc2D;
            var Arc2D;
            (function (Arc2D) {
                /**
                 * This class defines an arc specified in {@code float} precision.
                 * @since 1.2
                 */
                var Float = (function (_super) {
                    __extends(Float, _super);
                    /**
                     * Constructs a new arc, initialized to the specified location,
                     * size, angular extents, and closure type.
                     *
                     * @param x The X coordinate of the upper-left corner of
                     * the arc's framing rectangle.
                     * @param y The Y coordinate of the upper-left corner of
                     * the arc's framing rectangle.
                     * @param w The overall width of the full ellipse of which
                     * this arc is a partial section.
                     * @param h The overall height of the full ellipse of which this
                     * arc is a partial section.
                     * @param start The starting angle of the arc in degrees.
                     * @param extent The angular extent of the arc in degrees.
                     * @param type The closure type for the arc:
                     * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.
                     * @since 1.2
                     */
                    function Float(x, y, w, h, start, extent, type) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof start === 'number') || start === null) && ((typeof extent === 'number') || extent === null) && ((typeof type === 'number') || type === null)) {
                            _super.call(this, type);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            this.start = 0;
                            this.extent = 0;
                            (function () {
                                _this.x = x;
                                _this.y = y;
                                _this.width = w;
                                _this.height = h;
                                _this.start = start;
                                _this.extent = extent;
                            })();
                        }
                        else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && start === undefined && extent === undefined && type === undefined) {
                            var ellipseBounds = x;
                            var start = y;
                            var extent = w;
                            var type = h;
                            _super.call(this, type);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            this.start = 0;
                            this.extent = 0;
                            (function () {
                                _this.x = ellipseBounds.getX();
                                _this.y = ellipseBounds.getY();
                                _this.width = ellipseBounds.getWidth();
                                _this.height = ellipseBounds.getHeight();
                                _this.start = start;
                                _this.extent = extent;
                            })();
                        }
                        else if (((typeof x === 'number') || x === null) && y === undefined && w === undefined && h === undefined && start === undefined && extent === undefined && type === undefined) {
                            var type = x;
                            _super.call(this, type);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            this.start = 0;
                            this.extent = 0;
                            (function () {
                            })();
                        }
                        else if (x === undefined && y === undefined && w === undefined && h === undefined && start === undefined && extent === undefined && type === undefined) {
                            _super.call(this, java.awt.geom.Arc2D.OPEN);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            this.start = 0;
                            this.extent = 0;
                            (function () {
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * {@inheritDoc}
                     * Note that the arc
                     * <a href="Arc2D.html#inscribes">partially inscribes</a>
                     * the framing rectangle of this {@code RectangularShape}.
                     *
                     * @since 1.2
                     */
                    Float.prototype.getX = function () {
                        return this.x;
                    };
                    /**
                     * {@inheritDoc}
                     * Note that the arc
                     * <a href="Arc2D.html#inscribes">partially inscribes</a>
                     * the framing rectangle of this {@code RectangularShape}.
                     *
                     * @since 1.2
                     */
                    Float.prototype.getY = function () {
                        return this.y;
                    };
                    /**
                     * {@inheritDoc}
                     * Note that the arc
                     * <a href="Arc2D.html#inscribes">partially inscribes</a>
                     * the framing rectangle of this {@code RectangularShape}.
                     *
                     * @since 1.2
                     */
                    Float.prototype.getWidth = function () {
                        return this.width;
                    };
                    /**
                     * {@inheritDoc}
                     * Note that the arc
                     * <a href="Arc2D.html#inscribes">partially inscribes</a>
                     * the framing rectangle of this {@code RectangularShape}.
                     *
                     * @since 1.2
                     */
                    Float.prototype.getHeight = function () {
                        return this.height;
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     */
                    Float.prototype.getAngleStart = function () {
                        return this.start;
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     */
                    Float.prototype.getAngleExtent = function () {
                        return this.extent;
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     */
                    Float.prototype.isEmpty = function () {
                        return (this.width <= 0.0 || this.height <= 0.0);
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     */
                    Float.prototype.setArc = function (x, y, w, h, angSt, angExt, closure) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof angSt === 'number') || angSt === null) && ((typeof angExt === 'number') || angExt === null) && ((typeof closure === 'number') || closure === null)) {
                            return (function () {
                                _this.setArcType(closure);
                                _this.x = x;
                                _this.y = y;
                                _this.width = w;
                                _this.height = h;
                                _this.start = angSt;
                                _this.extent = angExt;
                            })();
                        }
                        else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && ((y != null && y instanceof java.awt.geom.Dimension2D) || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof angSt === 'number') || angSt === null) && angExt === undefined && closure === undefined) {
                            return this.setArc$java_awt_geom_Point2D$java_awt_geom_Dimension2D$double$double$int(x, y, w, h, angSt);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && angSt === undefined && angExt === undefined && closure === undefined) {
                            return this.setArc$java_awt_geom_Rectangle2D$double$double$int(x, y, w, h);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Arc2D) || x === null) && y === undefined && w === undefined && h === undefined && angSt === undefined && angExt === undefined && closure === undefined) {
                            return this.setArc$java_awt_geom_Arc2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     */
                    Float.prototype.setAngleStart$double = function (angSt) {
                        this.start = angSt;
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     */
                    Float.prototype.setAngleExtent = function (angExt) {
                        this.extent = angExt;
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     */
                    Float.prototype.makeBounds = function (x, y, w, h) {
                        return new java.awt.geom.Rectangle2D.Float(x, y, w, h);
                    };
                    Float.serialVersionUID = 9130893014586380278;
                    return Float;
                }(java.awt.geom.Arc2D));
                Arc2D.Float = Float;
                /**
                 * This class defines an arc specified in {@code double} precision.
                 * @since 1.2
                 */
                var Double = (function (_super) {
                    __extends(Double, _super);
                    /**
                     * Constructs a new arc, initialized to the specified location,
                     * size, angular extents, and closure type.
                     *
                     * @param x The X coordinate of the upper-left corner
                     * of the arc's framing rectangle.
                     * @param y The Y coordinate of the upper-left corner
                     * of the arc's framing rectangle.
                     * @param w The overall width of the full ellipse of which this
                     * arc is a partial section.
                     * @param h The overall height of the full ellipse of which this
                     * arc is a partial section.
                     * @param start The starting angle of the arc in degrees.
                     * @param extent The angular extent of the arc in degrees.
                     * @param type The closure type for the arc:
                     * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.
                     * @since 1.2
                     */
                    function Double(x, y, w, h, start, extent, type) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof start === 'number') || start === null) && ((typeof extent === 'number') || extent === null) && ((typeof type === 'number') || type === null)) {
                            _super.call(this, type);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            this.start = 0;
                            this.extent = 0;
                            (function () {
                                _this.x = x;
                                _this.y = y;
                                _this.width = w;
                                _this.height = h;
                                _this.start = start;
                                _this.extent = extent;
                            })();
                        }
                        else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && start === undefined && extent === undefined && type === undefined) {
                            var ellipseBounds = x;
                            var start = y;
                            var extent = w;
                            var type = h;
                            _super.call(this, type);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            this.start = 0;
                            this.extent = 0;
                            (function () {
                                _this.x = ellipseBounds.getX();
                                _this.y = ellipseBounds.getY();
                                _this.width = ellipseBounds.getWidth();
                                _this.height = ellipseBounds.getHeight();
                                _this.start = start;
                                _this.extent = extent;
                            })();
                        }
                        else if (((typeof x === 'number') || x === null) && y === undefined && w === undefined && h === undefined && start === undefined && extent === undefined && type === undefined) {
                            var type = x;
                            _super.call(this, type);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            this.start = 0;
                            this.extent = 0;
                            (function () {
                            })();
                        }
                        else if (x === undefined && y === undefined && w === undefined && h === undefined && start === undefined && extent === undefined && type === undefined) {
                            _super.call(this, java.awt.geom.Arc2D.OPEN);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            this.start = 0;
                            this.extent = 0;
                            (function () {
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * {@inheritDoc}
                     * Note that the arc
                     * <a href="Arc2D.html#inscribes">partially inscribes</a>
                     * the framing rectangle of this {@code RectangularShape}.
                     *
                     * @since 1.2
                     */
                    Double.prototype.getX = function () {
                        return this.x;
                    };
                    /**
                     * {@inheritDoc}
                     * Note that the arc
                     * <a href="Arc2D.html#inscribes">partially inscribes</a>
                     * the framing rectangle of this {@code RectangularShape}.
                     *
                     * @since 1.2
                     */
                    Double.prototype.getY = function () {
                        return this.y;
                    };
                    /**
                     * {@inheritDoc}
                     * Note that the arc
                     * <a href="Arc2D.html#inscribes">partially inscribes</a>
                     * the framing rectangle of this {@code RectangularShape}.
                     *
                     * @since 1.2
                     */
                    Double.prototype.getWidth = function () {
                        return this.width;
                    };
                    /**
                     * {@inheritDoc}
                     * Note that the arc
                     * <a href="Arc2D.html#inscribes">partially inscribes</a>
                     * the framing rectangle of this {@code RectangularShape}.
                     *
                     * @since 1.2
                     */
                    Double.prototype.getHeight = function () {
                        return this.height;
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     */
                    Double.prototype.getAngleStart = function () {
                        return this.start;
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     */
                    Double.prototype.getAngleExtent = function () {
                        return this.extent;
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     */
                    Double.prototype.isEmpty = function () {
                        return (this.width <= 0.0 || this.height <= 0.0);
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     */
                    Double.prototype.setArc = function (x, y, w, h, angSt, angExt, closure) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof angSt === 'number') || angSt === null) && ((typeof angExt === 'number') || angExt === null) && ((typeof closure === 'number') || closure === null)) {
                            return (function () {
                                _this.setArcType(closure);
                                _this.x = x;
                                _this.y = y;
                                _this.width = w;
                                _this.height = h;
                                _this.start = angSt;
                                _this.extent = angExt;
                            })();
                        }
                        else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && ((y != null && y instanceof java.awt.geom.Dimension2D) || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof angSt === 'number') || angSt === null) && angExt === undefined && closure === undefined) {
                            return this.setArc$java_awt_geom_Point2D$java_awt_geom_Dimension2D$double$double$int(x, y, w, h, angSt);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && angSt === undefined && angExt === undefined && closure === undefined) {
                            return this.setArc$java_awt_geom_Rectangle2D$double$double$int(x, y, w, h);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Arc2D) || x === null) && y === undefined && w === undefined && h === undefined && angSt === undefined && angExt === undefined && closure === undefined) {
                            return this.setArc$java_awt_geom_Arc2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     */
                    Double.prototype.setAngleStart$double = function (angSt) {
                        this.start = angSt;
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     */
                    Double.prototype.setAngleExtent = function (angExt) {
                        this.extent = angExt;
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     */
                    Double.prototype.makeBounds = function (x, y, w, h) {
                        return new java.awt.geom.Rectangle2D.Double(x, y, w, h);
                    };
                    Double.serialVersionUID = 728264085846882001;
                    return Double;
                }(java.awt.geom.Arc2D));
                Arc2D.Double = Double;
            })(Arc2D = geom.Arc2D || (geom.Arc2D = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The <code>Ellipse2D</code> class describes an ellipse that is defined by a
             * framing rectangle.
             * <p>
             * This class is only the abstract superclass for all objects which store a 2D
             * ellipse. The actual storage representation of the coordinates is left to the
             * subclass.
             *
             * @author Jim Graham
             * @since 1.2
             */
            var Ellipse2D = (function (_super) {
                __extends(Ellipse2D, _super);
                /**
                 * This is an abstract class that cannot be instantiated directly.
                 * Type-specific implementation subclasses are available for instantiation
                 * and provide a number of formats for storing the information necessary to
                 * satisfy the various accessor methods below.
                 *
                 * @see java.awt.geom.Ellipse2D.Float
                 * @see java.awt.geom.Ellipse2D.Double
                 * @since 1.2
                 */
                function Ellipse2D() {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable"] });
                }
                Ellipse2D.prototype.contains = function (x, y, w, h, origrect) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && origrect === undefined) {
                        return this.contains$double$double$double$double(x, y, w, h);
                    }
                    else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$double$double(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$java_awt_geom_Point2D(x);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                Ellipse2D.prototype.contains$double$double = function (x, y) {
                    var ellw = this.getWidth();
                    if (ellw <= 0.0) {
                        return false;
                    }
                    var normx = (x - this.getX()) / ellw - 0.5;
                    var ellh = this.getHeight();
                    if (ellh <= 0.0) {
                        return false;
                    }
                    var normy = (y - this.getY()) / ellh - 0.5;
                    return (normx * normx + normy * normy) < 0.25;
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                Ellipse2D.prototype.intersects = function (x, y, w, h) {
                    var _this = this;
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return (function () {
                            if (w <= 0.0 || h <= 0.0) {
                                return false;
                            }
                            var ellw = _this.getWidth();
                            if (ellw <= 0.0) {
                                return false;
                            }
                            var normx0 = (x - _this.getX()) / ellw - 0.5;
                            var normx1 = normx0 + w / ellw;
                            var ellh = _this.getHeight();
                            if (ellh <= 0.0) {
                                return false;
                            }
                            var normy0 = (y - _this.getY()) / ellh - 0.5;
                            var normy1 = normy0 + h / ellh;
                            var nearx;
                            var neary;
                            if (normx0 > 0.0) {
                                nearx = normx0;
                            }
                            else if (normx1 < 0.0) {
                                nearx = normx1;
                            }
                            else {
                                nearx = 0.0;
                            }
                            if (normy0 > 0.0) {
                                neary = normy0;
                            }
                            else if (normy1 < 0.0) {
                                neary = normy1;
                            }
                            else {
                                neary = 0.0;
                            }
                            return (nearx * nearx + neary * neary) < 0.25;
                        })();
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.intersects$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                Ellipse2D.prototype.contains$double$double$double$double = function (x, y, w, h) {
                    return (this.contains(x, y) && this.contains(x + w, y) && this.contains(x, y + h) && this.contains(x + w, y + h));
                };
                /**
                 * Returns an iteration object that defines the boundary of this
                 * <code>Ellipse2D</code>. The iterator for this class is multi-threaded
                 * safe, which means that this <code>Ellipse2D</code> class guarantees that
                 * modifications to the geometry of this <code>Ellipse2D</code> object do
                 * not affect any iterations of that geometry that are already in process.
                 *
                 * @param at
                 * an optional <code>AffineTransform</code> to be applied to the
                 * coordinates as they are returned in the iteration, or
                 * <code>null</code> if untransformed coordinates are desired
                 * @return the <code>PathIterator</code> object that returns the geometry of
                 * the outline of this <code>Ellipse2D</code>, one segment at a
                 * time.
                 * @since 1.2
                 */
                Ellipse2D.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
                    return new java.awt.geom.EllipseIterator(this, at);
                };
                /**
                 * Returns the hashcode for this <code>Ellipse2D</code>.
                 *
                 * @return the hashcode for this <code>Ellipse2D</code>.
                 * @since 1.6
                 */
                Ellipse2D.prototype.hashCode = function () {
                    var bits = javaemul.internal.DoubleHelper.doubleToLongBits(this.getX());
                    bits += javaemul.internal.DoubleHelper.doubleToLongBits(this.getY()) * 37;
                    bits += javaemul.internal.DoubleHelper.doubleToLongBits(this.getWidth()) * 43;
                    bits += javaemul.internal.DoubleHelper.doubleToLongBits(this.getHeight()) * 47;
                    return (((bits | 0)) ^ (((bits >> 32) | 0)));
                };
                /**
                 * Determines whether or not the specified <code>Object</code> is equal to
                 * this <code>Ellipse2D</code>. The specified <code>Object</code> is equal
                 * to this <code>Ellipse2D</code> if it is an instance of
                 * <code>Ellipse2D</code> and if its location and size are the same as this
                 * <code>Ellipse2D</code>.
                 *
                 * @param obj
                 * an <code>Object</code> to be compared with this
                 * <code>Ellipse2D</code>.
                 * @return <code>true</code> if <code>obj</code> is an instance of
                 * <code>Ellipse2D</code> and has the same values;
                 * <code>false</code> otherwise.
                 * @since 1.6
                 */
                Ellipse2D.prototype.equals = function (obj) {
                    if (obj === this) {
                        return true;
                    }
                    if (obj != null && obj instanceof java.awt.geom.Ellipse2D) {
                        var e2d = obj;
                        return ((this.getX() === e2d.getX()) && (this.getY() === e2d.getY()) && (this.getWidth() === e2d.getWidth()) && (this.getHeight() === e2d.getHeight()));
                    }
                    return false;
                };
                return Ellipse2D;
            }(java.awt.geom.RectangularShape));
            geom.Ellipse2D = Ellipse2D;
            var Ellipse2D;
            (function (Ellipse2D) {
                /**
                 * The <code>Float</code> class defines an ellipse specified in
                 * <code>float</code> precision.
                 *
                 * @since 1.2
                 */
                var Float = (function (_super) {
                    __extends(Float, _super);
                    /**
                     * Constructs and initializes an <code>Ellipse2D</code> from the
                     * specified coordinates.
                     *
                     * @param x
                     * the X coordinate of the upper-left corner of the framing
                     * rectangle
                     * @param y
                     * the Y coordinate of the upper-left corner of the framing
                     * rectangle
                     * @param w
                     * the width of the framing rectangle
                     * @param h
                     * the height of the framing rectangle
                     * @since 1.2
                     */
                    function Float(x, y, w, h) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            (function () {
                                _this.setFrame(x, y, w, h);
                            })();
                        }
                        else if (x === undefined && y === undefined && w === undefined && h === undefined) {
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            (function () {
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getX = function () {
                        return this.x;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getY = function () {
                        return this.y;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getWidth = function () {
                        return this.width;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getHeight = function () {
                        return this.height;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.isEmpty = function () {
                        return (this.width <= 0.0 || this.height <= 0.0);
                    };
                    /**
                     * Sets the location and size of the framing rectangle of this
                     * <code>Shape</code> to the specified rectangular values.
                     *
                     * @param x
                     * the X coordinate of the upper-left corner of the specified
                     * rectangular shape
                     * @param y
                     * the Y coordinate of the upper-left corner of the specified
                     * rectangular shape
                     * @param w
                     * the width of the specified rectangular shape
                     * @param h
                     * the height of the specified rectangular shape
                     * @since 1.2
                     */
                    Float.prototype.setFrame = function (x, y, w, h) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                            return (function () {
                                _this.x = x;
                                _this.y = y;
                                _this.width = w;
                                _this.height = h;
                            })();
                        }
                        else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                            return this.setFrame$double$double$double$double(x, y, w, h);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && ((y != null && y instanceof java.awt.geom.Dimension2D) || y === null) && w === undefined && h === undefined) {
                            return this.setFrame$java_awt_geom_Point2D$java_awt_geom_Dimension2D(x, y);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                            return this.setFrame$java_awt_geom_Rectangle2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.setFrame$double$double$double$double = function (x, y, w, h) {
                        this.x = x;
                        this.y = y;
                        this.width = w;
                        this.height = h;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getBounds2D = function () {
                        return new java.awt.geom.Rectangle2D.Float(this.x, this.y, this.width, this.height);
                    };
                    Float.serialVersionUID = -6633761252372475977;
                    return Float;
                }(java.awt.geom.Ellipse2D));
                Ellipse2D.Float = Float;
                /**
                 * The <code>Double</code> class defines an ellipse specified in
                 * <code>double</code> precision.
                 *
                 * @since 1.2
                 */
                var Double = (function (_super) {
                    __extends(Double, _super);
                    /**
                     * Constructs and initializes an <code>Ellipse2D</code> from the
                     * specified coordinates.
                     *
                     * @param x
                     * the X coordinate of the upper-left corner of the framing
                     * rectangle
                     * @param y
                     * the Y coordinate of the upper-left corner of the framing
                     * rectangle
                     * @param w
                     * the width of the framing rectangle
                     * @param h
                     * the height of the framing rectangle
                     * @since 1.2
                     */
                    function Double(x, y, w, h) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            (function () {
                                _this.setFrame(x, y, w, h);
                            })();
                        }
                        else if (x === undefined && y === undefined && w === undefined && h === undefined) {
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            (function () {
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getX = function () {
                        return this.x;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getY = function () {
                        return this.y;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getWidth = function () {
                        return this.width;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getHeight = function () {
                        return this.height;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.isEmpty = function () {
                        return (this.width <= 0.0 || this.height <= 0.0);
                    };
                    /**
                     * Sets the location and size of the framing rectangle of this
                     * <code>Shape</code> to the specified rectangular values.
                     *
                     * @param x
                     * the X coordinate of the upper-left corner of the specified
                     * rectangular shape
                     * @param y
                     * the Y coordinate of the upper-left corner of the specified
                     * rectangular shape
                     * @param w
                     * the width of the specified rectangular shape
                     * @param h
                     * the height of the specified rectangular shape
                     * @since 1.2
                     */
                    Double.prototype.setFrame = function (x, y, w, h) {
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                            return this.setFrame$double$double$double$double(x, y, w, h);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && ((y != null && y instanceof java.awt.geom.Dimension2D) || y === null) && w === undefined && h === undefined) {
                            return this.setFrame$java_awt_geom_Point2D$java_awt_geom_Dimension2D(x, y);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                            return this.setFrame$java_awt_geom_Rectangle2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.setFrame$double$double$double$double = function (x, y, w, h) {
                        this.x = x;
                        this.y = y;
                        this.width = w;
                        this.height = h;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getBounds2D = function () {
                        return new java.awt.geom.Rectangle2D.Double(this.x, this.y, this.width, this.height);
                    };
                    Double.serialVersionUID = 5555464816372320683;
                    return Double;
                }(java.awt.geom.Ellipse2D));
                Ellipse2D.Double = Double;
            })(Ellipse2D = geom.Ellipse2D || (geom.Ellipse2D = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The <code>Rectangle2D</code> class describes a rectangle defined by a
             * location {@code (x,y)} and dimension {@code (w x h)}.
             * <p>
             * This class is only the abstract superclass for all objects that store a 2D
             * rectangle. The actual storage representation of the coordinates is left to
             * the subclass.
             *
             * @author Jim Graham
             * @since 1.2
             */
            var Rectangle2D = (function (_super) {
                __extends(Rectangle2D, _super);
                /**
                 * This is an abstract class that cannot be instantiated directly.
                 * Type-specific implementation subclasses are available for instantiation
                 * and provide a number of formats for storing the information necessary to
                 * satisfy the various accessor methods below.
                 *
                 * @see java.awt.geom.Rectangle2D.Float
                 * @see java.awt.geom.Rectangle2D.Double
                 * @see java.awt.Rectangle
                 * @since 1.2
                 */
                function Rectangle2D() {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable"] });
                }
                /**
                 * Sets the location and size of this <code>Rectangle2D</code> to the
                 * specified <code>float</code> values.
                 *
                 * @param x
                 * the X coordinate of the upper-left corner of this
                 * <code>Rectangle2D</code>
                 * @param y
                 * the Y coordinate of the upper-left corner of this
                 * <code>Rectangle2D</code>
                 * @param w
                 * the width of this <code>Rectangle2D</code>
                 * @param h
                 * the height of this <code>Rectangle2D</code>
                 * @since 1.2
                 */
                Rectangle2D.prototype.setRect = function (x, y, w, h) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return this.setRect$double$double$double$double(x, y, w, h);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.setRect$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets the location and size of this <code>Rectangle2D</code> to the
                 * specified <code>double</code> values.
                 *
                 * @param x
                 * the X coordinate of the upper-left corner of this
                 * <code>Rectangle2D</code>
                 * @param y
                 * the Y coordinate of the upper-left corner of this
                 * <code>Rectangle2D</code>
                 * @param w
                 * the width of this <code>Rectangle2D</code>
                 * @param h
                 * the height of this <code>Rectangle2D</code>
                 * @since 1.2
                 */
                Rectangle2D.prototype.setRect$double$double$double$double = function (x, y, w, h) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Sets this <code>Rectangle2D</code> to be the same as the specified
                 * <code>Rectangle2D</code>.
                 *
                 * @param r
                 * the specified <code>Rectangle2D</code>
                 * @since 1.2
                 */
                Rectangle2D.prototype.setRect$java_awt_geom_Rectangle2D = function (r) {
                    this.setRect(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                /**
                 * Tests if the specified line segment intersects the interior of this
                 * <code>Rectangle2D</code>.
                 *
                 * @param x1
                 * the X coordinate of the start point of the specified line
                 * segment
                 * @param y1
                 * the Y coordinate of the start point of the specified line
                 * segment
                 * @param x2
                 * the X coordinate of the end point of the specified line
                 * segment
                 * @param y2
                 * the Y coordinate of the end point of the specified line
                 * segment
                 * @return <code>true</code> if the specified line segment intersects the
                 * interior of this <code>Rectangle2D</code>; <code>false</code>
                 * otherwise.
                 * @since 1.2
                 */
                Rectangle2D.prototype.intersectsLine = function (x1, y1, x2, y2) {
                    var _this = this;
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        return (function () {
                            var out1;
                            var out2;
                            if ((out2 = _this.outcode(x2, y2)) === 0) {
                                return true;
                            }
                            while (((out1 = _this.outcode(x1, y1)) !== 0)) {
                                if ((out1 & out2) !== 0) {
                                    return false;
                                }
                                if ((out1 & (Rectangle2D.OUT_LEFT | Rectangle2D.OUT_RIGHT)) !== 0) {
                                    var x = _this.getX();
                                    if ((out1 & Rectangle2D.OUT_RIGHT) !== 0) {
                                        x += _this.getWidth();
                                    }
                                    y1 = y1 + (x - x1) * (y2 - y1) / (x2 - x1);
                                    x1 = x;
                                }
                                else {
                                    var y = _this.getY();
                                    if ((out1 & Rectangle2D.OUT_BOTTOM) !== 0) {
                                        y += _this.getHeight();
                                    }
                                    x1 = x1 + (y - y1) * (x2 - x1) / (y2 - y1);
                                    y1 = y;
                                }
                            }
                            ;
                            return true;
                        })();
                    }
                    else if (((x1 != null && x1 instanceof java.awt.geom.Line2D) || x1 === null) && y1 === undefined && x2 === undefined && y2 === undefined) {
                        return this.intersectsLine$java_awt_geom_Line2D(x1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Tests if the specified line segment intersects the interior of this
                 * <code>Rectangle2D</code>.
                 *
                 * @param l
                 * the specified {@link Line2D} to test for intersection with the
                 * interior of this <code>Rectangle2D</code>
                 * @return <code>true</code> if the specified <code>Line2D</code> intersects
                 * the interior of this <code>Rectangle2D</code>; <code>false</code>
                 * otherwise.
                 * @since 1.2
                 */
                Rectangle2D.prototype.intersectsLine$java_awt_geom_Line2D = function (l) {
                    return this.intersectsLine(l.getX1(), l.getY1(), l.getX2(), l.getY2());
                };
                /**
                 * Determines where the specified coordinates lie with respect to this
                 * <code>Rectangle2D</code>. This method computes a binary OR of the
                 * appropriate mask values indicating, for each side of this
                 * <code>Rectangle2D</code>, whether or not the specified coordinates are on
                 * the same side of the edge as the rest of this <code>Rectangle2D</code>.
                 *
                 * @param x
                 * the specified X coordinate
                 * @param y
                 * the specified Y coordinate
                 * @return the logical OR of all appropriate out codes.
                 * @see #OUT_LEFT
                 * @see #OUT_TOP
                 * @see #OUT_RIGHT
                 * @see #OUT_BOTTOM
                 * @since 1.2
                 */
                Rectangle2D.prototype.outcode = function (x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return 0;
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined) {
                        return this.outcode$java_awt_geom_Point2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Determines where the specified {@link Point2D} lies with respect to this
                 * <code>Rectangle2D</code>. This method computes a binary OR of the
                 * appropriate mask values indicating, for each side of this
                 * <code>Rectangle2D</code>, whether or not the specified
                 * <code>Point2D</code> is on the same side of the edge as the rest of this
                 * <code>Rectangle2D</code>.
                 *
                 * @param p
                 * the specified <code>Point2D</code>
                 * @return the logical OR of all appropriate out codes.
                 * @see #OUT_LEFT
                 * @see #OUT_TOP
                 * @see #OUT_RIGHT
                 * @see #OUT_BOTTOM
                 * @since 1.2
                 */
                Rectangle2D.prototype.outcode$java_awt_geom_Point2D = function (p) {
                    return this.outcode(p.getX(), p.getY());
                };
                Rectangle2D.prototype.setFrame = function (x, y, w, h) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return this.setFrame$double$double$double$double(x, y, w, h);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && ((y != null && y instanceof java.awt.geom.Dimension2D) || y === null) && w === undefined && h === undefined) {
                        return this.setFrame$java_awt_geom_Point2D$java_awt_geom_Dimension2D(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.setFrame$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets the location and size of the outer bounds of this
                 * <code>Rectangle2D</code> to the specified rectangular values.
                 *
                 * @param x
                 * the X coordinate of the upper-left corner of this
                 * <code>Rectangle2D</code>
                 * @param y
                 * the Y coordinate of the upper-left corner of this
                 * <code>Rectangle2D</code>
                 * @param w
                 * the width of this <code>Rectangle2D</code>
                 * @param h
                 * the height of this <code>Rectangle2D</code>
                 * @since 1.2
                 */
                Rectangle2D.prototype.setFrame$double$double$double$double = function (x, y, w, h) {
                    this.setRect(x, y, w, h);
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                Rectangle2D.prototype.getBounds2D = function () {
                    return this.clone();
                };
                Rectangle2D.prototype.contains = function (x, y, w, h, origrect) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && origrect === undefined) {
                        return this.contains$double$double$double$double(x, y, w, h);
                    }
                    else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$double$double(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$java_awt_geom_Point2D(x);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                Rectangle2D.prototype.contains$double$double = function (x, y) {
                    var x0 = this.getX();
                    var y0 = this.getY();
                    return (x >= x0 && y >= y0 && x < x0 + this.getWidth() && y < y0 + this.getHeight());
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                Rectangle2D.prototype.intersects = function (x, y, w, h) {
                    var _this = this;
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return (function () {
                            if (_this.isEmpty() || w <= 0 || h <= 0) {
                                return false;
                            }
                            var x0 = _this.getX();
                            var y0 = _this.getY();
                            return (x + w > x0 && y + h > y0 && x < x0 + _this.getWidth() && y < y0 + _this.getHeight());
                        })();
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.intersects$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                Rectangle2D.prototype.contains$double$double$double$double = function (x, y, w, h) {
                    if (this.isEmpty() || w <= 0 || h <= 0) {
                        return false;
                    }
                    var x0 = this.getX();
                    var y0 = this.getY();
                    return (x >= x0 && y >= y0 && (x + w) <= x0 + this.getWidth() && (y + h) <= y0 + this.getHeight());
                };
                /**
                 * Intersects the pair of specified source <code>Rectangle2D</code> objects
                 * and puts the result into the specified destination
                 * <code>Rectangle2D</code> object. One of the source rectangles can also be
                 * the destination to avoid creating a third Rectangle2D object, but in this
                 * case the original points of this source rectangle will be overwritten by
                 * this method.
                 *
                 * @param src1
                 * the first of a pair of <code>Rectangle2D</code> objects to be
                 * intersected with each other
                 * @param src2
                 * the second of a pair of <code>Rectangle2D</code> objects to be
                 * intersected with each other
                 * @param dest
                 * the <code>Rectangle2D</code> that holds the results of the
                 * intersection of <code>src1</code> and <code>src2</code>
                 * @since 1.2
                 */
                Rectangle2D.intersect = function (src1, src2, dest) {
                    var x1 = Math.max(src1.getMinX(), src2.getMinX());
                    var y1 = Math.max(src1.getMinY(), src2.getMinY());
                    var x2 = Math.min(src1.getMaxX(), src2.getMaxX());
                    var y2 = Math.min(src1.getMaxY(), src2.getMaxY());
                    dest.setFrame(x1, y1, x2 - x1, y2 - y1);
                };
                /**
                 * Unions the pair of source <code>Rectangle2D</code> objects and puts the
                 * result into the specified destination <code>Rectangle2D</code> object.
                 * One of the source rectangles can also be the destination to avoid
                 * creating a third Rectangle2D object, but in this case the original points
                 * of this source rectangle will be overwritten by this method.
                 *
                 * @param src1
                 * the first of a pair of <code>Rectangle2D</code> objects to be
                 * combined with each other
                 * @param src2
                 * the second of a pair of <code>Rectangle2D</code> objects to be
                 * combined with each other
                 * @param dest
                 * the <code>Rectangle2D</code> that holds the results of the
                 * union of <code>src1</code> and <code>src2</code>
                 * @since 1.2
                 */
                Rectangle2D.union = function (src1, src2, dest) {
                    var x1 = Math.min(src1.getMinX(), src2.getMinX());
                    var y1 = Math.min(src1.getMinY(), src2.getMinY());
                    var x2 = Math.max(src1.getMaxX(), src2.getMaxX());
                    var y2 = Math.max(src1.getMaxY(), src2.getMaxY());
                    dest.setFrameFromDiagonal(x1, y1, x2, y2);
                };
                Rectangle2D.prototype.add = function (newx, newy) {
                    if (((typeof newx === 'number') || newx === null) && ((typeof newy === 'number') || newy === null)) {
                        return this.add$double$double(newx, newy);
                    }
                    else if (((newx != null && newx instanceof java.awt.geom.Point2D) || newx === null) && newy === undefined) {
                        return this.add$java_awt_geom_Point2D(newx);
                    }
                    else if (((newx != null && newx instanceof java.awt.geom.Rectangle2D) || newx === null) && newy === undefined) {
                        return this.add$java_awt_geom_Rectangle2D(newx);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Adds a point, specified by the double precision arguments
                 * <code>newx</code> and <code>newy</code>, to this <code>Rectangle2D</code>
                 * . The resulting <code>Rectangle2D</code> is the smallest
                 * <code>Rectangle2D</code> that contains both the original
                 * <code>Rectangle2D</code> and the specified point.
                 * <p>
                 * After adding a point, a call to <code>contains</code> with the added
                 * point as an argument does not necessarily return <code>true</code>. The
                 * <code>contains</code> method does not return <code>true</code> for points
                 * on the right or bottom edges of a rectangle. Therefore, if the added
                 * point falls on the left or bottom edge of the enlarged rectangle,
                 * <code>contains</code> returns <code>false</code> for that point.
                 *
                 * @param newx
                 * the X coordinate of the new point
                 * @param newy
                 * the Y coordinate of the new point
                 * @since 1.2
                 */
                Rectangle2D.prototype.add$double$double = function (newx, newy) {
                    var x1 = Math.min(this.getMinX(), newx);
                    var x2 = Math.max(this.getMaxX(), newx);
                    var y1 = Math.min(this.getMinY(), newy);
                    var y2 = Math.max(this.getMaxY(), newy);
                    this.setRect(x1, y1, x2 - x1, y2 - y1);
                };
                /**
                 * Adds the <code>Point2D</code> object <code>pt</code> to this
                 * <code>Rectangle2D</code>. The resulting <code>Rectangle2D</code> is the
                 * smallest <code>Rectangle2D</code> that contains both the original
                 * <code>Rectangle2D</code> and the specified <code>Point2D</code>.
                 * <p>
                 * After adding a point, a call to <code>contains</code> with the added
                 * point as an argument does not necessarily return <code>true</code>. The
                 * <code>contains</code> method does not return <code>true</code> for points
                 * on the right or bottom edges of a rectangle. Therefore, if the added
                 * point falls on the left or bottom edge of the enlarged rectangle,
                 * <code>contains</code> returns <code>false</code> for that point.
                 *
                 * @param pt
                 * the new <code>Point2D</code> to add to this
                 * <code>Rectangle2D</code>.
                 * @since 1.2
                 */
                Rectangle2D.prototype.add$java_awt_geom_Point2D = function (pt) {
                    this.add(pt.getX(), pt.getY());
                };
                /**
                 * Adds a <code>Rectangle2D</code> object to this <code>Rectangle2D</code>.
                 * The resulting <code>Rectangle2D</code> is the union of the two
                 * <code>Rectangle2D</code> objects.
                 *
                 * @param r
                 * the <code>Rectangle2D</code> to add to this
                 * <code>Rectangle2D</code>.
                 * @since 1.2
                 */
                Rectangle2D.prototype.add$java_awt_geom_Rectangle2D = function (r) {
                    var x1 = Math.min(this.getMinX(), r.getMinX());
                    var x2 = Math.max(this.getMaxX(), r.getMaxX());
                    var y1 = Math.min(this.getMinY(), r.getMinY());
                    var y2 = Math.max(this.getMaxY(), r.getMaxY());
                    this.setRect(x1, y1, x2 - x1, y2 - y1);
                };
                /**
                 * Returns an iteration object that defines the boundary of this
                 * <code>Rectangle2D</code>. The iterator for this class is multi-threaded
                 * safe, which means that this <code>Rectangle2D</code> class guarantees
                 * that modifications to the geometry of this <code>Rectangle2D</code>
                 * object do not affect any iterations of that geometry that are already in
                 * process.
                 *
                 * @param at
                 * an optional <code>AffineTransform</code> to be applied to the
                 * coordinates as they are returned in the iteration, or
                 * <code>null</code> if untransformed coordinates are desired
                 * @return the <code>PathIterator</code> object that returns the geometry of
                 * the outline of this <code>Rectangle2D</code>, one segment at a
                 * time.
                 * @since 1.2
                 */
                Rectangle2D.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
                    return new java.awt.geom.RectIterator(this, at);
                };
                /**
                 * Returns an iteration object that defines the boundary of the flattened
                 * <code>Rectangle2D</code>. Since rectangles are already flat, the
                 * <code>flatness</code> parameter is ignored. The iterator for this class
                 * is multi-threaded safe, which means that this <code>Rectangle2D</code>
                 * class guarantees that modifications to the geometry of this
                 * <code>Rectangle2D</code> object do not affect any iterations of that
                 * geometry that are already in process.
                 *
                 * @param at
                 * an optional <code>AffineTransform</code> to be applied to the
                 * coordinates as they are returned in the iteration, or
                 * <code>null</code> if untransformed coordinates are desired
                 * @param flatness
                 * the maximum distance that the line segments used to
                 * approximate the curved segments are allowed to deviate from
                 * any point on the original curve. Since rectangles are already
                 * flat, the <code>flatness</code> parameter is ignored.
                 * @return the <code>PathIterator</code> object that returns the geometry of
                 * the outline of this <code>Rectangle2D</code>, one segment at a
                 * time.
                 * @since 1.2
                 */
                Rectangle2D.prototype.getPathIterator = function (at, flatness) {
                    var _this = this;
                    if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
                        return (function () {
                            return new java.awt.geom.RectIterator(_this, at);
                        })();
                    }
                    else if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && flatness === undefined) {
                        return this.getPathIterator$java_awt_geom_AffineTransform(at);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the hashcode for this <code>Rectangle2D</code>.
                 *
                 * @return the hashcode for this <code>Rectangle2D</code>.
                 * @since 1.2
                 */
                Rectangle2D.prototype.hashCode = function () {
                    var bits = javaemul.internal.DoubleHelper.doubleToLongBits(this.getX());
                    bits += javaemul.internal.DoubleHelper.doubleToLongBits(this.getY()) * 37;
                    bits += javaemul.internal.DoubleHelper.doubleToLongBits(this.getWidth()) * 43;
                    bits += javaemul.internal.DoubleHelper.doubleToLongBits(this.getHeight()) * 47;
                    return (((bits | 0)) ^ (((bits >> 32) | 0)));
                };
                /**
                 * Determines whether or not the specified <code>Object</code> is equal to
                 * this <code>Rectangle2D</code>. The specified <code>Object</code> is equal
                 * to this <code>Rectangle2D</code> if it is an instance of
                 * <code>Rectangle2D</code> and if its location and size are the same as
                 * this <code>Rectangle2D</code>.
                 *
                 * @param obj
                 * an <code>Object</code> to be compared with this
                 * <code>Rectangle2D</code>.
                 * @return <code>true</code> if <code>obj</code> is an instance of
                 * <code>Rectangle2D</code> and has the same values;
                 * <code>false</code> otherwise.
                 * @since 1.2
                 */
                Rectangle2D.prototype.equals = function (obj) {
                    if (obj === this) {
                        return true;
                    }
                    if (obj != null && obj instanceof java.awt.geom.Rectangle2D) {
                        var r2d = obj;
                        return ((this.getX() === r2d.getX()) && (this.getY() === r2d.getY()) && (this.getWidth() === r2d.getWidth()) && (this.getHeight() === r2d.getHeight()));
                    }
                    return false;
                };
                /**
                 * The bitmask that indicates that a point lies to the left of this
                 * <code>Rectangle2D</code>.
                 *
                 * @since 1.2
                 */
                Rectangle2D.OUT_LEFT = 1;
                /**
                 * The bitmask that indicates that a point lies above this
                 * <code>Rectangle2D</code>.
                 *
                 * @since 1.2
                 */
                Rectangle2D.OUT_TOP = 2;
                /**
                 * The bitmask that indicates that a point lies to the right of this
                 * <code>Rectangle2D</code>.
                 *
                 * @since 1.2
                 */
                Rectangle2D.OUT_RIGHT = 4;
                /**
                 * The bitmask that indicates that a point lies below this
                 * <code>Rectangle2D</code>.
                 *
                 * @since 1.2
                 */
                Rectangle2D.OUT_BOTTOM = 8;
                return Rectangle2D;
            }(java.awt.geom.RectangularShape));
            geom.Rectangle2D = Rectangle2D;
            var Rectangle2D;
            (function (Rectangle2D) {
                /**
                 * The <code>Float</code> class defines a rectangle specified in float
                 * coordinates.
                 *
                 * @since 1.2
                 */
                var Float = (function (_super) {
                    __extends(Float, _super);
                    /**
                     * Constructs and initializes a <code>Rectangle2D</code> from the
                     * specified <code>float</code> coordinates.
                     *
                     * @param x
                     * the X coordinate of the upper-left corner of the newly
                     * constructed <code>Rectangle2D</code>
                     * @param y
                     * the Y coordinate of the upper-left corner of the newly
                     * constructed <code>Rectangle2D</code>
                     * @param w
                     * the width of the newly constructed
                     * <code>Rectangle2D</code>
                     * @param h
                     * the height of the newly constructed
                     * <code>Rectangle2D</code>
                     * @since 1.2
                     */
                    function Float(x, y, w, h) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            (function () {
                                _this.setRect(x, y, w, h);
                            })();
                        }
                        else if (x === undefined && y === undefined && w === undefined && h === undefined) {
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            (function () {
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getX = function () {
                        return this.x;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getY = function () {
                        return this.y;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getWidth = function () {
                        return this.width;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getHeight = function () {
                        return this.height;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.isEmpty = function () {
                        return (this.width <= 0.0) || (this.height <= 0.0);
                    };
                    /**
                     * Sets the location and size of this <code>Rectangle2D</code> to the
                     * specified <code>float</code> values.
                     *
                     * @param x
                     * the X coordinate of the upper-left corner of this
                     * <code>Rectangle2D</code>
                     * @param y
                     * the Y coordinate of the upper-left corner of this
                     * <code>Rectangle2D</code>
                     * @param w
                     * the width of this <code>Rectangle2D</code>
                     * @param h
                     * the height of this <code>Rectangle2D</code>
                     * @since 1.2
                     */
                    Float.prototype.setRect = function (x, y, w, h) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                            return (function () {
                                _this.x = x;
                                _this.y = y;
                                _this.width = w;
                                _this.height = h;
                            })();
                        }
                        else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                            return this.setRect$double$double$double$double(x, y, w, h);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                            return this.setRect$java_awt_geom_Rectangle2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.setRect$double$double$double$double = function (x, y, w, h) {
                        this.x = x;
                        this.y = y;
                        this.width = w;
                        this.height = h;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.setRect$java_awt_geom_Rectangle2D = function (r) {
                        this.x = r.getX();
                        this.y = r.getY();
                        this.width = r.getWidth();
                        this.height = r.getHeight();
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.outcode = function (x, y) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            return (function () {
                                var out = 0;
                                if (_this.width <= 0) {
                                    out |= java.awt.geom.Rectangle2D.OUT_LEFT | java.awt.geom.Rectangle2D.OUT_RIGHT;
                                }
                                else if (x < _this.x) {
                                    out |= java.awt.geom.Rectangle2D.OUT_LEFT;
                                }
                                else if (x > _this.x + _this.width) {
                                    out |= java.awt.geom.Rectangle2D.OUT_RIGHT;
                                }
                                if (_this.height <= 0) {
                                    out |= java.awt.geom.Rectangle2D.OUT_TOP | java.awt.geom.Rectangle2D.OUT_BOTTOM;
                                }
                                else if (y < _this.y) {
                                    out |= java.awt.geom.Rectangle2D.OUT_TOP;
                                }
                                else if (y > _this.y + _this.height) {
                                    out |= java.awt.geom.Rectangle2D.OUT_BOTTOM;
                                }
                                return out;
                            })();
                        }
                        else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined) {
                            return this.outcode$java_awt_geom_Point2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getBounds2D = function () {
                        return new Rectangle2D.Float(this.x, this.y, this.width, this.height);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.createIntersection = function (r) {
                        var dest;
                        if (r != null && r instanceof java.awt.geom.Rectangle2D.Float) {
                            dest = new java.awt.geom.Rectangle2D.Float();
                        }
                        else {
                            dest = new java.awt.geom.Rectangle2D.Double();
                        }
                        java.awt.geom.Rectangle2D.intersect(this, r, dest);
                        return dest;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.createUnion = function (r) {
                        var dest;
                        if (r != null && r instanceof java.awt.geom.Rectangle2D.Float) {
                            dest = new java.awt.geom.Rectangle2D.Float();
                        }
                        else {
                            dest = new java.awt.geom.Rectangle2D.Double();
                        }
                        java.awt.geom.Rectangle2D.union(this, r, dest);
                        return dest;
                    };
                    /**
                     * Returns the <code>String</code> representation of this
                     * <code>Rectangle2D</code>.
                     *
                     * @return a <code>String</code> representing this
                     * <code>Rectangle2D</code>.
                     * @since 1.2
                     */
                    Float.prototype.toString = function () {
                        return "java.awt.geom.Rectangle2D.Float" + "[x=" + this.x + ",y=" + this.y + ",w=" + this.width + ",h=" + this.height + "]";
                    };
                    Float.serialVersionUID = 3798716824173675777;
                    return Float;
                }(java.awt.geom.Rectangle2D));
                Rectangle2D.Float = Float;
                /**
                 * The <code>Double</code> class defines a rectangle specified in double
                 * coordinates.
                 *
                 * @since 1.2
                 */
                var Double = (function (_super) {
                    __extends(Double, _super);
                    /**
                     * Constructs and initializes a <code>Rectangle2D</code> from the
                     * specified <code>double</code> coordinates.
                     *
                     * @param x
                     * the X coordinate of the upper-left corner of the newly
                     * constructed <code>Rectangle2D</code>
                     * @param y
                     * the Y coordinate of the upper-left corner of the newly
                     * constructed <code>Rectangle2D</code>
                     * @param w
                     * the width of the newly constructed
                     * <code>Rectangle2D</code>
                     * @param h
                     * the height of the newly constructed
                     * <code>Rectangle2D</code>
                     * @since 1.2
                     */
                    function Double(x, y, w, h) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            (function () {
                                _this.setRect(x, y, w, h);
                            })();
                        }
                        else if (x === undefined && y === undefined && w === undefined && h === undefined) {
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            (function () {
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getX = function () {
                        return this.x;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getY = function () {
                        return this.y;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getWidth = function () {
                        return this.width;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getHeight = function () {
                        return this.height;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.isEmpty = function () {
                        return (this.width <= 0.0) || (this.height <= 0.0);
                    };
                    /**
                     * Sets the location and size of this <code>Rectangle2D</code> to the
                     * specified <code>float</code> values.
                     *
                     * @param x
                     * the X coordinate of the upper-left corner of this
                     * <code>Rectangle2D</code>
                     * @param y
                     * the Y coordinate of the upper-left corner of this
                     * <code>Rectangle2D</code>
                     * @param w
                     * the width of this <code>Rectangle2D</code>
                     * @param h
                     * the height of this <code>Rectangle2D</code>
                     * @since 1.2
                     */
                    Double.prototype.setRect = function (x, y, w, h) {
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                            return this.setRect$double$double$double$double(x, y, w, h);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                            return this.setRect$java_awt_geom_Rectangle2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.setRect$double$double$double$double = function (x, y, w, h) {
                        this.x = x;
                        this.y = y;
                        this.width = w;
                        this.height = h;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.setRect$java_awt_geom_Rectangle2D = function (r) {
                        this.x = r.getX();
                        this.y = r.getY();
                        this.width = r.getWidth();
                        this.height = r.getHeight();
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.outcode = function (x, y) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            return (function () {
                                var out = 0;
                                if (_this.width <= 0) {
                                    out |= java.awt.geom.Rectangle2D.OUT_LEFT | java.awt.geom.Rectangle2D.OUT_RIGHT;
                                }
                                else if (x < _this.x) {
                                    out |= java.awt.geom.Rectangle2D.OUT_LEFT;
                                }
                                else if (x > _this.x + _this.width) {
                                    out |= java.awt.geom.Rectangle2D.OUT_RIGHT;
                                }
                                if (_this.height <= 0) {
                                    out |= java.awt.geom.Rectangle2D.OUT_TOP | java.awt.geom.Rectangle2D.OUT_BOTTOM;
                                }
                                else if (y < _this.y) {
                                    out |= java.awt.geom.Rectangle2D.OUT_TOP;
                                }
                                else if (y > _this.y + _this.height) {
                                    out |= java.awt.geom.Rectangle2D.OUT_BOTTOM;
                                }
                                return out;
                            })();
                        }
                        else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined) {
                            return this.outcode$java_awt_geom_Point2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getBounds2D = function () {
                        return new Rectangle2D.Double(this.x, this.y, this.width, this.height);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.createIntersection = function (r) {
                        var dest = new java.awt.geom.Rectangle2D.Double();
                        java.awt.geom.Rectangle2D.intersect(this, r, dest);
                        return dest;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.createUnion = function (r) {
                        var dest = new java.awt.geom.Rectangle2D.Double();
                        java.awt.geom.Rectangle2D.union(this, r, dest);
                        return dest;
                    };
                    /**
                     * Returns the <code>String</code> representation of this
                     * <code>Rectangle2D</code>.
                     *
                     * @return a <code>String</code> representing this
                     * <code>Rectangle2D</code>.
                     * @since 1.2
                     */
                    Double.prototype.toString = function () {
                        return "java.awt.geom.Rectangle2D.Double" + "[x=" + this.x + ",y=" + this.y + ",w=" + this.width + ",h=" + this.height + "]";
                    };
                    Double.serialVersionUID = 7771313791441850493;
                    return Double;
                }(java.awt.geom.Rectangle2D));
                Rectangle2D.Double = Double;
            })(Rectangle2D = geom.Rectangle2D || (geom.Rectangle2D = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The <code>RoundRectangle2D</code> class defines a rectangle with rounded
             * corners defined by a location {@code (x,y)}, a dimension {@code (w x h)}, and
             * the width and height of an arc with which to round the corners.
             * <p>
             * This class is the abstract superclass for all objects that store a 2D rounded
             * rectangle. The actual storage representation of the coordinates is left to
             * the subclass.
             *
             * @author Jim Graham
             * @since 1.2
             */
            var RoundRectangle2D = (function (_super) {
                __extends(RoundRectangle2D, _super);
                /**
                 * This is an abstract class that cannot be instantiated directly.
                 * Type-specific implementation subclasses are available for instantiation
                 * and provide a number of formats for storing the information necessary to
                 * satisfy the various accessor methods below.
                 *
                 * @see java.awt.geom.RoundRectangle2D.Float
                 * @see java.awt.geom.RoundRectangle2D.Double
                 * @since 1.2
                 */
                function RoundRectangle2D() {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable"] });
                }
                /**
                 * Sets the location, size, and corner radii of this
                 * <code>RoundRectangle2D</code> to the specified <code>float</code>
                 * values.
                 *
                 * @param x
                 * the X coordinate to which to set the location of this
                 * <code>RoundRectangle2D</code>
                 * @param y
                 * the Y coordinate to which to set the location of this
                 * <code>RoundRectangle2D</code>
                 * @param w
                 * the width to which to set this
                 * <code>RoundRectangle2D</code>
                 * @param h
                 * the height to which to set this
                 * <code>RoundRectangle2D</code>
                 * @param arcw
                 * the width to which to set the arc of this
                 * <code>RoundRectangle2D</code>
                 * @param arch
                 * the height to which to set the arc of this
                 * <code>RoundRectangle2D</code>
                 * @since 1.2
                 */
                RoundRectangle2D.prototype.setRoundRect = function (x, y, w, h, arcw, arch) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof arcw === 'number') || arcw === null) && ((typeof arch === 'number') || arch === null)) {
                        return this.setRoundRect$double$double$double$double$double$double(x, y, w, h, arcw, arch);
                    }
                    else if (((x != null && x instanceof java.awt.geom.RoundRectangle2D) || x === null) && y === undefined && w === undefined && h === undefined && arcw === undefined && arch === undefined) {
                        return this.setRoundRect$java_awt_geom_RoundRectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets the location, size, and corner radii of this
                 * <code>RoundRectangle2D</code> to the specified <code>double</code>
                 * values.
                 *
                 * @param x
                 * the X coordinate to which to set the location of this
                 * <code>RoundRectangle2D</code>
                 * @param y
                 * the Y coordinate to which to set the location of this
                 * <code>RoundRectangle2D</code>
                 * @param w
                 * the width to which to set this <code>RoundRectangle2D</code>
                 * @param h
                 * the height to which to set this <code>RoundRectangle2D</code>
                 * @param arcWidth
                 * the width to which to set the arc of this
                 * <code>RoundRectangle2D</code>
                 * @param arcHeight
                 * the height to which to set the arc of this
                 * <code>RoundRectangle2D</code>
                 * @since 1.2
                 */
                RoundRectangle2D.prototype.setRoundRect$double$double$double$double$double$double = function (x, y, w, h, arcWidth, arcHeight) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Sets this <code>RoundRectangle2D</code> to be the same as the specified
                 * <code>RoundRectangle2D</code>.
                 *
                 * @param rr
                 * the specified <code>RoundRectangle2D</code>
                 * @since 1.2
                 */
                RoundRectangle2D.prototype.setRoundRect$java_awt_geom_RoundRectangle2D = function (rr) {
                    this.setRoundRect(rr.getX(), rr.getY(), rr.getWidth(), rr.getHeight(), rr.getArcWidth(), rr.getArcHeight());
                };
                RoundRectangle2D.prototype.setFrame = function (x, y, w, h) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return this.setFrame$double$double$double$double(x, y, w, h);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && ((y != null && y instanceof java.awt.geom.Dimension2D) || y === null) && w === undefined && h === undefined) {
                        return this.setFrame$java_awt_geom_Point2D$java_awt_geom_Dimension2D(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.setFrame$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                RoundRectangle2D.prototype.setFrame$double$double$double$double = function (x, y, w, h) {
                    this.setRoundRect(x, y, w, h, this.getArcWidth(), this.getArcHeight());
                };
                RoundRectangle2D.prototype.contains = function (x, y, w, h, origrect) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && origrect === undefined) {
                        return this.contains$double$double$double$double(x, y, w, h);
                    }
                    else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$double$double(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$java_awt_geom_Point2D(x);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                RoundRectangle2D.prototype.contains$double$double = function (x, y) {
                    if (this.isEmpty()) {
                        return false;
                    }
                    var rrx0 = this.getX();
                    var rry0 = this.getY();
                    var rrx1 = rrx0 + this.getWidth();
                    var rry1 = rry0 + this.getHeight();
                    if (x < rrx0 || y < rry0 || x >= rrx1 || y >= rry1) {
                        return false;
                    }
                    var aw = Math.min(this.getWidth(), Math.abs(this.getArcWidth())) / 2.0;
                    var ah = Math.min(this.getHeight(), Math.abs(this.getArcHeight())) / 2.0;
                    if (x >= (rrx0 += aw) && x < (rrx0 = rrx1 - aw)) {
                        return true;
                    }
                    if (y >= (rry0 += ah) && y < (rry0 = rry1 - ah)) {
                        return true;
                    }
                    x = (x - rrx0) / aw;
                    y = (y - rry0) / ah;
                    return (x * x + y * y <= 1.0);
                };
                RoundRectangle2D.prototype.classify = function (coord, left, right, arcsize) {
                    if (coord < left) {
                        return 0;
                    }
                    else if (coord < left + arcsize) {
                        return 1;
                    }
                    else if (coord < right - arcsize) {
                        return 2;
                    }
                    else if (coord < right) {
                        return 3;
                    }
                    else {
                        return 4;
                    }
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                RoundRectangle2D.prototype.intersects = function (x, y, w, h) {
                    var _this = this;
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return (function () {
                            if (_this.isEmpty() || w <= 0 || h <= 0) {
                                return false;
                            }
                            var rrx0 = _this.getX();
                            var rry0 = _this.getY();
                            var rrx1 = rrx0 + _this.getWidth();
                            var rry1 = rry0 + _this.getHeight();
                            if (x + w <= rrx0 || x >= rrx1 || y + h <= rry0 || y >= rry1) {
                                return false;
                            }
                            var aw = Math.min(_this.getWidth(), Math.abs(_this.getArcWidth())) / 2.0;
                            var ah = Math.min(_this.getHeight(), Math.abs(_this.getArcHeight())) / 2.0;
                            var x0class = _this.classify(x, rrx0, rrx1, aw);
                            var x1class = _this.classify(x + w, rrx0, rrx1, aw);
                            var y0class = _this.classify(y, rry0, rry1, ah);
                            var y1class = _this.classify(y + h, rry0, rry1, ah);
                            if (x0class === 2 || x1class === 2 || y0class === 2 || y1class === 2) {
                                return true;
                            }
                            if ((x0class < 2 && x1class > 2) || (y0class < 2 && y1class > 2)) {
                                return true;
                            }
                            x = (x1class === 1) ? (x = x + w - (rrx0 + aw)) : (x = x - (rrx1 - aw));
                            y = (y1class === 1) ? (y = y + h - (rry0 + ah)) : (y = y - (rry1 - ah));
                            x = x / aw;
                            y = y / ah;
                            return (x * x + y * y <= 1.0);
                        })();
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.intersects$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                RoundRectangle2D.prototype.contains$double$double$double$double = function (x, y, w, h) {
                    if (this.isEmpty() || w <= 0 || h <= 0) {
                        return false;
                    }
                    return (this.contains(x, y) && this.contains(x + w, y) && this.contains(x, y + h) && this.contains(x + w, y + h));
                };
                /**
                 * Returns an iteration object that defines the boundary of this
                 * <code>RoundRectangle2D</code>. The iterator for this class is
                 * multi-threaded safe, which means that this <code>RoundRectangle2D</code>
                 * class guarantees that modifications to the geometry of this
                 * <code>RoundRectangle2D</code> object do not affect any iterations of that
                 * geometry that are already in process.
                 *
                 * @param at
                 * an optional <code>AffineTransform</code> to be applied to the
                 * coordinates as they are returned in the iteration, or
                 * <code>null</code> if untransformed coordinates are desired
                 * @return the <code>PathIterator</code> object that returns the geometry of
                 * the outline of this <code>RoundRectangle2D</code>, one segment at
                 * a time.
                 * @since 1.2
                 */
                RoundRectangle2D.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
                    return new java.awt.geom.RoundRectIterator(this, at);
                };
                /**
                 * Returns the hashcode for this <code>RoundRectangle2D</code>.
                 *
                 * @return the hashcode for this <code>RoundRectangle2D</code>.
                 * @since 1.6
                 */
                RoundRectangle2D.prototype.hashCode = function () {
                    var bits = javaemul.internal.DoubleHelper.doubleToLongBits(this.getX());
                    bits += javaemul.internal.DoubleHelper.doubleToLongBits(this.getY()) * 37;
                    bits += javaemul.internal.DoubleHelper.doubleToLongBits(this.getWidth()) * 43;
                    bits += javaemul.internal.DoubleHelper.doubleToLongBits(this.getHeight()) * 47;
                    bits += javaemul.internal.DoubleHelper.doubleToLongBits(this.getArcWidth()) * 53;
                    bits += javaemul.internal.DoubleHelper.doubleToLongBits(this.getArcHeight()) * 59;
                    return (((bits | 0)) ^ (((bits >> 32) | 0)));
                };
                /**
                 * Determines whether or not the specified <code>Object</code> is equal to
                 * this <code>RoundRectangle2D</code>. The specified <code>Object</code> is
                 * equal to this <code>RoundRectangle2D</code> if it is an instance of
                 * <code>RoundRectangle2D</code> and if its location, size, and corner arc
                 * dimensions are the same as this <code>RoundRectangle2D</code>.
                 *
                 * @param obj
                 * an <code>Object</code> to be compared with this
                 * <code>RoundRectangle2D</code>.
                 * @return <code>true</code> if <code>obj</code> is an instance of
                 * <code>RoundRectangle2D</code> and has the same values;
                 * <code>false</code> otherwise.
                 * @since 1.6
                 */
                RoundRectangle2D.prototype.equals = function (obj) {
                    if (obj === this) {
                        return true;
                    }
                    if (obj != null && obj instanceof java.awt.geom.RoundRectangle2D) {
                        var rr2d = obj;
                        return ((this.getX() === rr2d.getX()) && (this.getY() === rr2d.getY()) && (this.getWidth() === rr2d.getWidth()) && (this.getHeight() === rr2d.getHeight()) && (this.getArcWidth() === rr2d.getArcWidth()) && (this.getArcHeight() === rr2d.getArcHeight()));
                    }
                    return false;
                };
                return RoundRectangle2D;
            }(java.awt.geom.RectangularShape));
            geom.RoundRectangle2D = RoundRectangle2D;
            var RoundRectangle2D;
            (function (RoundRectangle2D) {
                /**
                 * The <code>Float</code> class defines a rectangle with rounded corners all
                 * specified in <code>float</code> coordinates.
                 *
                 * @since 1.2
                 */
                var Float = (function (_super) {
                    __extends(Float, _super);
                    /**
                     * Constructs and initializes a <code>RoundRectangle2D</code> from the
                     * specified <code>float</code> coordinates.
                     *
                     * @param x
                     * the X coordinate of the newly constructed
                     * <code>RoundRectangle2D</code>
                     * @param y
                     * the Y coordinate of the newly constructed
                     * <code>RoundRectangle2D</code>
                     * @param w
                     * the width to which to set the newly constructed
                     * <code>RoundRectangle2D</code>
                     * @param h
                     * the height to which to set the newly constructed
                     * <code>RoundRectangle2D</code>
                     * @param arcw
                     * the width of the arc to use to round off the corners of
                     * the newly constructed <code>RoundRectangle2D</code>
                     * @param arch
                     * the height of the arc to use to round off the corners of
                     * the newly constructed <code>RoundRectangle2D</code>
                     * @since 1.2
                     */
                    function Float(x, y, w, h, arcw, arch) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof arcw === 'number') || arcw === null) && ((typeof arch === 'number') || arch === null)) {
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            this.arcwidth = 0;
                            this.archeight = 0;
                            (function () {
                                _this.setRoundRect(x, y, w, h, arcw, arch);
                            })();
                        }
                        else if (x === undefined && y === undefined && w === undefined && h === undefined && arcw === undefined && arch === undefined) {
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            this.arcwidth = 0;
                            this.archeight = 0;
                            (function () {
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getX = function () {
                        return this.x;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getY = function () {
                        return this.y;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getWidth = function () {
                        return this.width;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getHeight = function () {
                        return this.height;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getArcWidth = function () {
                        return this.arcwidth;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getArcHeight = function () {
                        return this.archeight;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.isEmpty = function () {
                        return (this.width <= 0.0) || (this.height <= 0.0);
                    };
                    /**
                     * Sets the location, size, and corner radii of this
                     * <code>RoundRectangle2D</code> to the specified <code>float</code>
                     * values.
                     *
                     * @param x
                     * the X coordinate to which to set the location of this
                     * <code>RoundRectangle2D</code>
                     * @param y
                     * the Y coordinate to which to set the location of this
                     * <code>RoundRectangle2D</code>
                     * @param w
                     * the width to which to set this
                     * <code>RoundRectangle2D</code>
                     * @param h
                     * the height to which to set this
                     * <code>RoundRectangle2D</code>
                     * @param arcw
                     * the width to which to set the arc of this
                     * <code>RoundRectangle2D</code>
                     * @param arch
                     * the height to which to set the arc of this
                     * <code>RoundRectangle2D</code>
                     * @since 1.2
                     */
                    Float.prototype.setRoundRect = function (x, y, w, h, arcw, arch) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof arcw === 'number') || arcw === null) && ((typeof arch === 'number') || arch === null)) {
                            return (function () {
                                _this.x = x;
                                _this.y = y;
                                _this.width = w;
                                _this.height = h;
                                _this.arcwidth = arcw;
                                _this.archeight = arch;
                            })();
                        }
                        else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof arcw === 'number') || arcw === null) && ((typeof arch === 'number') || arch === null)) {
                            return this.setRoundRect$double$double$double$double$double$double(x, y, w, h, arcw, arch);
                        }
                        else if (((x != null && x instanceof java.awt.geom.RoundRectangle2D) || x === null) && y === undefined && w === undefined && h === undefined && arcw === undefined && arch === undefined) {
                            return this.setRoundRect$java_awt_geom_RoundRectangle2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.setRoundRect$double$double$double$double$double$double = function (x, y, w, h, arcw, arch) {
                        this.x = x;
                        this.y = y;
                        this.width = w;
                        this.height = h;
                        this.arcwidth = arcw;
                        this.archeight = arch;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.setRoundRect$java_awt_geom_RoundRectangle2D = function (rr) {
                        this.x = rr.getX();
                        this.y = rr.getY();
                        this.width = rr.getWidth();
                        this.height = rr.getHeight();
                        this.arcwidth = rr.getArcWidth();
                        this.archeight = rr.getArcHeight();
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getBounds2D = function () {
                        return new java.awt.geom.Rectangle2D.Float(this.x, this.y, this.width, this.height);
                    };
                    Float.serialVersionUID = -3423150618393866922;
                    return Float;
                }(java.awt.geom.RoundRectangle2D));
                RoundRectangle2D.Float = Float;
                /**
                 * The <code>Double</code> class defines a rectangle with rounded corners
                 * all specified in <code>double</code> coordinates.
                 *
                 * @since 1.2
                 */
                var Double = (function (_super) {
                    __extends(Double, _super);
                    /**
                     * Constructs and initializes a <code>RoundRectangle2D</code> from the
                     * specified <code>double</code> coordinates.
                     *
                     * @param x
                     * the X coordinate of the newly constructed
                     * <code>RoundRectangle2D</code>
                     * @param y
                     * the Y coordinate of the newly constructed
                     * <code>RoundRectangle2D</code>
                     * @param w
                     * the width to which to set the newly constructed
                     * <code>RoundRectangle2D</code>
                     * @param h
                     * the height to which to set the newly constructed
                     * <code>RoundRectangle2D</code>
                     * @param arcw
                     * the width of the arc to use to round off the corners of
                     * the newly constructed <code>RoundRectangle2D</code>
                     * @param arch
                     * the height of the arc to use to round off the corners of
                     * the newly constructed <code>RoundRectangle2D</code>
                     * @since 1.2
                     */
                    function Double(x, y, w, h, arcw, arch) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof arcw === 'number') || arcw === null) && ((typeof arch === 'number') || arch === null)) {
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            this.arcwidth = 0;
                            this.archeight = 0;
                            (function () {
                                _this.setRoundRect(x, y, w, h, arcw, arch);
                            })();
                        }
                        else if (x === undefined && y === undefined && w === undefined && h === undefined && arcw === undefined && arch === undefined) {
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            this.arcwidth = 0;
                            this.archeight = 0;
                            (function () {
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getX = function () {
                        return this.x;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getY = function () {
                        return this.y;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getWidth = function () {
                        return this.width;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getHeight = function () {
                        return this.height;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getArcWidth = function () {
                        return this.arcwidth;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getArcHeight = function () {
                        return this.archeight;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.isEmpty = function () {
                        return (this.width <= 0.0) || (this.height <= 0.0);
                    };
                    /**
                     * Sets the location, size, and corner radii of this
                     * <code>RoundRectangle2D</code> to the specified <code>float</code>
                     * values.
                     *
                     * @param x
                     * the X coordinate to which to set the location of this
                     * <code>RoundRectangle2D</code>
                     * @param y
                     * the Y coordinate to which to set the location of this
                     * <code>RoundRectangle2D</code>
                     * @param w
                     * the width to which to set this
                     * <code>RoundRectangle2D</code>
                     * @param h
                     * the height to which to set this
                     * <code>RoundRectangle2D</code>
                     * @param arcw
                     * the width to which to set the arc of this
                     * <code>RoundRectangle2D</code>
                     * @param arch
                     * the height to which to set the arc of this
                     * <code>RoundRectangle2D</code>
                     * @since 1.2
                     */
                    Double.prototype.setRoundRect = function (x, y, w, h, arcw, arch) {
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof arcw === 'number') || arcw === null) && ((typeof arch === 'number') || arch === null)) {
                            return this.setRoundRect$double$double$double$double$double$double(x, y, w, h, arcw, arch);
                        }
                        else if (((x != null && x instanceof java.awt.geom.RoundRectangle2D) || x === null) && y === undefined && w === undefined && h === undefined && arcw === undefined && arch === undefined) {
                            return this.setRoundRect$java_awt_geom_RoundRectangle2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.setRoundRect$double$double$double$double$double$double = function (x, y, w, h, arcw, arch) {
                        this.x = x;
                        this.y = y;
                        this.width = w;
                        this.height = h;
                        this.arcwidth = arcw;
                        this.archeight = arch;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.setRoundRect$java_awt_geom_RoundRectangle2D = function (rr) {
                        this.x = rr.getX();
                        this.y = rr.getY();
                        this.width = rr.getWidth();
                        this.height = rr.getHeight();
                        this.arcwidth = rr.getArcWidth();
                        this.archeight = rr.getArcHeight();
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getBounds2D = function () {
                        return new java.awt.geom.Rectangle2D.Double(this.x, this.y, this.width, this.height);
                    };
                    Double.serialVersionUID = 1048939333485206117;
                    return Double;
                }(java.awt.geom.RoundRectangle2D));
                RoundRectangle2D.Double = Double;
            })(RoundRectangle2D = geom.RoundRectangle2D || (geom.RoundRectangle2D = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        var WebGraphics2D = (function (_super) {
            __extends(WebGraphics2D, _super);
            function WebGraphics2D(canvas) {
                _super.call(this);
                this.canvas = canvas;
                this.context = canvas.getContext("2d");
            }
            WebGraphics2D.prototype.drawString = function (s, x, y) {
                this.context.fillText(s, x, y);
            };
            WebGraphics2D.prototype.getCanvas = function () {
                return this.canvas;
            };
            WebGraphics2D.prototype.getContext = function () {
                return this.context;
            };
            return WebGraphics2D;
        }(java.awt.Graphics));
        awt.WebGraphics2D = WebGraphics2D;
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var io;
    (function (io) {
        var LocalStorageFileSystem = (function (_super) {
            __extends(LocalStorageFileSystem, _super);
            function LocalStorageFileSystem() {
                _super.call(this);
                this.PREFIX = "LSFS://";
            }
            LocalStorageFileSystem.prototype.getSeparator = function () {
                return '/';
            };
            LocalStorageFileSystem.prototype.getPathSeparator = function () {
                return ':';
            };
            LocalStorageFileSystem.prototype.normalize = function (pathname, len, off) {
                if (((typeof pathname === 'string') || pathname === null) && ((typeof len === 'number') || len === null) && ((typeof off === 'number') || off === null)) {
                    return (function () {
                        if (len === 0)
                            return pathname;
                        var n = len;
                        while (((n > 0) && (pathname.charAt(n - 1) === '/')))
                            n--;
                        if (n === 0)
                            return "/";
                        var sb = new java.lang.StringBuffer(pathname.length);
                        if (off > 0)
                            sb.append(pathname.substring(0, off));
                        var prevChar = String.fromCharCode(0);
                        for (var i = off; i < n; i++) {
                            var c = pathname.charAt(i);
                            if ((prevChar === '/') && (c === '/'))
                                continue;
                            sb.append(c);
                            prevChar = c;
                        }
                        return sb.toString();
                    })();
                }
                else if (((typeof pathname === 'string') || pathname === null) && len === undefined && off === undefined) {
                    return this.normalize$java_lang_String(pathname);
                }
                else
                    throw new Error('invalid overload');
            };
            LocalStorageFileSystem.prototype.normalize$java_lang_String = function (pathname) {
                var n = pathname.length;
                var prevChar = String.fromCharCode(0);
                for (var i = 0; i < n; i++) {
                    var c = pathname.charAt(i);
                    if ((prevChar === '/') && (c === '/'))
                        return this.normalize(pathname, n, i - 1);
                    prevChar = c;
                }
                if (prevChar === '/')
                    return this.normalize(pathname, n, n - 1);
                return pathname;
            };
            LocalStorageFileSystem.prototype.prefixLength = function (pathname) {
                if (pathname.length === 0)
                    return 0;
                return (pathname.charAt(0) === '/') ? 1 : 0;
            };
            LocalStorageFileSystem.prototype.resolve = function (parent, child) {
                if (((typeof parent === 'string') || parent === null) && ((typeof child === 'string') || child === null)) {
                    return (function () {
                        if ((child === ""))
                            return parent;
                        if (child.charAt(0) === '/') {
                            if ((parent === "/"))
                                return child;
                            return parent + child;
                        }
                        if ((parent === "/"))
                            return parent + child;
                        return parent + '/' + child;
                    })();
                }
                else if (((parent != null && parent instanceof java.io.File) || parent === null) && child === undefined) {
                    return this.resolve$java_io_File(parent);
                }
                else
                    throw new Error('invalid overload');
            };
            LocalStorageFileSystem.prototype.getDefaultParent = function () {
                return "/";
            };
            LocalStorageFileSystem.prototype.fromURIPath = function (path) {
                var p = path;
                if ((function (str, searchString) { var pos = str.length - searchString.length; var lastIndex = str.indexOf(searchString, pos); return lastIndex !== -1 && lastIndex === pos; })(p, "/") && (p.length > 1)) {
                    p = p.substring(0, p.length - 1);
                }
                return p;
            };
            LocalStorageFileSystem.prototype.isAbsolute = function (f) {
                return (f.getPrefixLength() !== 0);
            };
            LocalStorageFileSystem.prototype.resolve$java_io_File = function (f) {
                if (this.isAbsolute(f))
                    return f.getPath();
                return this.resolve(java.lang.System.getProperty("user.dir"), f.getPath());
            };
            LocalStorageFileSystem.prototype.canonicalize = function (path) {
                return this.normalize(path);
            };
            LocalStorageFileSystem.prototype.getBooleanAttributes = function (f) {
                var e = this.getEntry(f.getAbsolutePath());
                return e == null ? 0 : e.attributes;
            };
            LocalStorageFileSystem.prototype.checkAccess = function (f, access) {
                return (this.getEntry(f.getAbsolutePath()).access & access) !== 0;
            };
            LocalStorageFileSystem.prototype.setPermission = function (f, access, enable, owneronly) {
                return false;
            };
            LocalStorageFileSystem.prototype.getLastModifiedTime = function (f) {
                return this.getEntry(f.getAbsolutePath()).lastModifiedTime;
            };
            LocalStorageFileSystem.prototype.getLength = function (f) {
                return this.getEntry(f.getAbsolutePath()).length;
            };
            LocalStorageFileSystem.prototype.clear = function () {
                for (var i = 0; i < localStorage.length; i++) {
                    var key = localStorage.key(i);
                    if ((function (str, searchString, position) {
                        if (position === void 0) { position = 0; }
                        return str.substr(position, searchString.length) === searchString;
                    })(key, this.PREFIX)) {
                        localStorage.removeItem(key);
                    }
                }
            };
            LocalStorageFileSystem.prototype.getKey = function (pathname) {
                return this.PREFIX + pathname;
            };
            LocalStorageFileSystem.prototype.createFileExclusively = function (pathname) {
                var f = new java.io.File(pathname);
                pathname = f.getAbsolutePath();
                if (this.hasEntry(pathname)) {
                    return false;
                }
                var parent = f.getParentFile();
                if (parent != null) {
                    var parentPath = parent.getAbsolutePath();
                    var directoryEntry = this.getDirectoryEntry(parentPath);
                    if (directoryEntry == null) {
                        throw new java.io.IOException("directory does not exist: " + parentPath);
                    }
                    var entries = directoryEntry.entries;
                    entries.push(f.getName());
                    this.putEntry(parentPath, directoryEntry);
                }
                this.putEntry(pathname, Object.defineProperty({
                    lastModifiedTime: java.lang.System.currentTimeMillis(),
                    length: 0,
                    data: "",
                    attributes: java.io.FileSystem.BA_EXISTS | java.io.FileSystem.BA_REGULAR,
                    access: java.io.FileSystem.ACCESS_READ | java.io.FileSystem.ACCESS_WRITE
                }, '__interfaces', { configurable: true, value: ["java.io.LocalStorageFileSystem.Entry"] }));
                return true;
            };
            LocalStorageFileSystem.prototype.hasEntry = function (pathname) {
                return localStorage.getItem(this.getKey(pathname)) != null;
            };
            LocalStorageFileSystem.prototype.getEntry = function (pathname) {
                return JSON.parse(localStorage.getItem(this.getKey(pathname)));
            };
            LocalStorageFileSystem.prototype.getDirectoryEntry = function (pathname) {
                return JSON.parse(localStorage.getItem(this.getKey(pathname)));
            };
            LocalStorageFileSystem.prototype.putEntry = function (pathname, entry) {
                localStorage.setItem(this.getKey(pathname), JSON.stringify(entry));
            };
            LocalStorageFileSystem.prototype.getChildEntries = function (pathname) {
                var directoryEntry = this.getDirectoryEntry(pathname);
                if (directoryEntry != null) {
                    return directoryEntry.entries;
                }
                else {
                    return new Array();
                }
            };
            LocalStorageFileSystem.prototype.removeEntry = function (pathname) {
                {
                    var array130 = this.getChildEntries(pathname);
                    for (var index129 = 0; index129 < array130.length; index129++) {
                        var e = array130[index129];
                        {
                            this.removeEntry(pathname + "/" + e);
                        }
                    }
                }
                localStorage.removeItem(this.getKey(pathname));
            };
            LocalStorageFileSystem.prototype.delete = function (f) {
                if (this.hasEntry(f.getAbsolutePath())) {
                    this.removeEntry(f.getAbsolutePath());
                    var parentPath = f.getParentFile().getAbsolutePath();
                    var directoryEntry = this.getDirectoryEntry(parentPath);
                    var entries = directoryEntry.entries;
                    directoryEntry.entries = entries.splice(entries.indexOf(f.getName()), 1);
                    this.putEntry(parentPath, directoryEntry);
                    return true;
                }
                return false;
            };
            LocalStorageFileSystem.prototype.list = function (f) {
                return this.getChildEntries(f.getAbsolutePath());
            };
            LocalStorageFileSystem.prototype.createDirectory = function (f) {
                if (this.hasEntry(f.getAbsolutePath())) {
                    return false;
                }
                var parent = f.getParentFile();
                if (parent != null) {
                    var parentPath = parent.getAbsolutePath();
                    var directoryEntry = this.getDirectoryEntry(parentPath);
                    if (directoryEntry == null) {
                        return false;
                    }
                    var entries = directoryEntry.entries;
                    entries.push(f.getName());
                    this.putEntry(parentPath, directoryEntry);
                }
                this.putEntry(f.getAbsolutePath(), Object.defineProperty({
                    attributes: java.io.FileSystem.BA_DIRECTORY | java.io.FileSystem.BA_EXISTS,
                    access: java.io.FileSystem.ACCESS_READ | java.io.FileSystem.ACCESS_WRITE,
                    entries: new Array(0)
                }, '__interfaces', { configurable: true, value: ["java.io.LocalStorageFileSystem.DirectoryEntry", "java.io.LocalStorageFileSystem.Entry"] }));
                return true;
            };
            LocalStorageFileSystem.prototype.rename = function (f1, f2) {
                var e1 = this.getEntry(f1.getAbsolutePath());
                var e2 = this.getEntry(f2.getAbsolutePath());
                if (e1 == null || e2 != null) {
                    return false;
                }
                this.delete(f1);
                try {
                    this.createFileExclusively(f2.getAbsolutePath());
                }
                catch (e) {
                    return false;
                }
                ;
                this.putEntry(f2.getAbsolutePath(), e1);
                return true;
            };
            LocalStorageFileSystem.prototype.setLastModifiedTime = function (f, time) {
                var e = this.getEntry(f.getAbsolutePath());
                if (e != null) {
                    e.lastModifiedTime = time;
                    return true;
                }
                else {
                    return false;
                }
            };
            LocalStorageFileSystem.prototype.setReadOnly = function (f) {
                this.getEntry(f.getAbsolutePath()).access &= ~java.io.FileSystem.ACCESS_WRITE;
                return true;
            };
            LocalStorageFileSystem.prototype.listRoots = function () {
                if (this.roots == null) {
                    this.roots = [new java.io.File("/")];
                }
                return this.roots;
            };
            LocalStorageFileSystem.prototype.getSpace = function (f, t) {
                return 0;
            };
            LocalStorageFileSystem.prototype.compare = function (f1, f2) {
                return f1.getAbsolutePath().localeCompare(f2.getAbsolutePath());
            };
            LocalStorageFileSystem.prototype.hashCode = function (f) {
                return f.getAbsolutePath().toString();
            };
            return LocalStorageFileSystem;
        }(java.io.FileSystem));
        io.LocalStorageFileSystem = LocalStorageFileSystem;
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var io;
    (function (io) {
        /**
         * A specialized {@link InputStream } for reading the contents of a byte array.
         *
         * @see ByteArrayOutputStream
         */
        var ByteArrayInputStream = (function (_super) {
            __extends(ByteArrayInputStream, _super);
            /**
             * Constructs a new {@code ByteArrayInputStream} on the byte array
             * {@code buf} with the initial position set to {@code offset} and the
             * number of bytes available set to {@code offset} + {@code length}.
             *
             * @param buf
             * the byte array to stream over.
             * @param offset
             * the initial position in {@code buf} to start streaming from.
             * @param length
             * the number of bytes available for streaming.
             */
            function ByteArrayInputStream(buf, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                _super.call(this);
                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Closeable", "java.lang.AutoCloseable"] });
                this.pos = 0;
                this._mark = 0;
                this.count = 0;
                if (length === -1) {
                    length = buf.length;
                }
                this.buf = buf;
                this.pos = offset;
                this._mark = offset;
                this.count = offset + length > buf.length ? buf.length : offset + length;
            }
            /**
             * Returns the number of remaining bytes.
             *
             * @return {@code count - pos}
             */
            ByteArrayInputStream.prototype.available = function () {
                return this.count - this.pos;
            };
            /**
             * Closes this stream and frees resources associated with this stream.
             *
             * @throws IOException
             * if an I/O error occurs while closing this stream.
             */
            ByteArrayInputStream.prototype.close = function () {
            };
            /**
             * Sets a mark position in this ByteArrayInputStream. The parameter
             * {@code readlimit} is ignored. Sending {@code reset()} will reposition the
             * stream back to the marked position.
             *
             * @param readlimit
             * ignored.
             * @see #markSupported()
             * @see #reset()
             */
            ByteArrayInputStream.prototype.mark = function (readlimit) {
                this._mark = this.pos;
            };
            /**
             * Indicates whether this stream supports the {@code mark()} and
             * {@code reset()} methods. Returns {@code true} since this class supports
             * these methods.
             *
             * @return always {@code true}.
             * @see #mark(int)
             * @see #reset()
             */
            ByteArrayInputStream.prototype.markSupported = function () {
                return true;
            };
            /**
             * Reads a single byte from the source byte array and returns it as an
             * integer in the range from 0 to 255. Returns -1 if the end of the source
             * array has been reached.
             *
             * @return the byte read or -1 if the end of this stream has been reached.
             */
            ByteArrayInputStream.prototype.read$ = function () {
                return this.read(null, 0, 0);
            };
            ByteArrayInputStream.prototype.read = function (buffer, byteOffset, byteCount) {
                var _this = this;
                if (((buffer != null && buffer instanceof Array) || buffer === null) && ((typeof byteOffset === 'number') || byteOffset === null) && ((typeof byteCount === 'number') || byteCount === null)) {
                    return (function () {
                        if (buffer == null) {
                            return _this.pos < _this.count ? _this.buf[_this.pos++] & 255 : -1;
                        }
                        java.io.IOUtils.checkOffsetAndCount(buffer, byteOffset, byteCount);
                        if (_this.pos >= _this.count) {
                            return -1;
                        }
                        if (byteCount === 0) {
                            return 0;
                        }
                        var copylen = _this.count - _this.pos < byteCount ? _this.count - _this.pos : byteCount;
                        java.lang.System.arraycopy(_this.buf, _this.pos, buffer, byteOffset, copylen);
                        _this.pos += copylen;
                        return copylen;
                    })();
                }
                else if (((buffer != null && buffer instanceof Array) || buffer === null) && byteOffset === undefined && byteCount === undefined) {
                    return this.read$byte_A(buffer);
                }
                else if (buffer === undefined && byteOffset === undefined && byteCount === undefined) {
                    return this.read$();
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Resets this stream to the last marked location. This implementation
             * resets the position to either the marked position, the start position
             * supplied in the constructor or 0 if neither has been provided.
             *
             * @see #mark(int)
             */
            ByteArrayInputStream.prototype.reset = function () {
                this.pos = this._mark;
            };
            /**
             * Skips {@code byteCount} bytes in this InputStream. Subsequent calls to
             * {@code read} will not return these bytes unless {@code reset} is used.
             * This implementation skips {@code byteCount} number of bytes in the target
             * stream. It does nothing and returns 0 if {@code byteCount} is negative.
             *
             * @return the number of bytes actually skipped.
             */
            ByteArrayInputStream.prototype.skip = function (byteCount) {
                if (byteCount <= 0) {
                    return 0;
                }
                var temp = this.pos;
                this.pos = this.count - this.pos < byteCount ? this.count : ((this.pos + byteCount) | 0);
                return this.pos - temp;
            };
            return ByteArrayInputStream;
        }(java.io.InputStream));
        io.ByteArrayInputStream = ByteArrayInputStream;
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var io;
    (function (io) {
        /**
         * JSweet implementation based on a local storage FS.
         */
        var FileInputStream = (function (_super) {
            __extends(FileInputStream, _super);
            function FileInputStream(name) {
                var _this = this;
                if (((typeof name === 'string') || name === null)) {
                    {
                        var file = name != null ? new java.io.File(name) : null;
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Closeable", "java.lang.AutoCloseable"] });
                        this.index = 0;
                        (function () {
                            var name = (file != null ? file.getPath() : null);
                            if (name == null) {
                                throw new java.lang.NullPointerException();
                            }
                            if (file.isInvalid()) {
                                throw new java.io.FileNotFoundException("Invalid file path");
                            }
                            if (!file.exists()) {
                                throw new java.io.FileNotFoundException();
                            }
                            _this.content = atob(java.io.File.fs_$LI$().getEntry(file.getAbsolutePath()).data);
                            _this.index = 0;
                        })();
                    }
                    (function () {
                    })();
                }
                else if (((name != null && name instanceof java.io.File) || name === null)) {
                    var file = name;
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Closeable", "java.lang.AutoCloseable"] });
                    this.index = 0;
                    (function () {
                        var name = (file != null ? file.getPath() : null);
                        if (name == null) {
                            throw new java.lang.NullPointerException();
                        }
                        if (file.isInvalid()) {
                            throw new java.io.FileNotFoundException("Invalid file path");
                        }
                        if (!file.exists()) {
                            throw new java.io.FileNotFoundException();
                        }
                        _this.content = atob(java.io.File.fs_$LI$().getEntry(file.getAbsolutePath()).data);
                        _this.index = 0;
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            FileInputStream.prototype.read$ = function () {
                if (this.index >= this.content.length) {
                    return -1;
                }
                return this.content[this.index++];
            };
            FileInputStream.prototype.readBytes = function (b, off, len) {
                if (this.index >= this.content.length) {
                    return -1;
                }
                var count = 0;
                for (var i = off; i < off + len; i++) {
                    if (this.index >= this.content.length) {
                        break;
                    }
                    b[i] = this.content[this.index++];
                    count++;
                }
                return count;
            };
            FileInputStream.prototype.read$byte_A = function (b) {
                return this.readBytes(b, 0, b.length);
            };
            FileInputStream.prototype.read = function (b, off, len) {
                var _this = this;
                if (((b != null && b instanceof Array) || b === null) && ((typeof off === 'number') || off === null) && ((typeof len === 'number') || len === null)) {
                    return (function () {
                        return _this.readBytes(b, off, len);
                    })();
                }
                else if (((b != null && b instanceof Array) || b === null) && off === undefined && len === undefined) {
                    return this.read$byte_A(b);
                }
                else if (b === undefined && off === undefined && len === undefined) {
                    return this.read$();
                }
                else
                    throw new Error('invalid overload');
            };
            FileInputStream.prototype.skip = function (n) {
                this.index += n;
                return n;
            };
            FileInputStream.prototype.available = function () {
                return this.content.length - this.index;
            };
            FileInputStream.prototype.close = function () {
            };
            return FileInputStream;
        }(java.io.InputStream));
        io.FileInputStream = FileInputStream;
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var io;
    (function (io) {
        /**
         * Wraps an existing {@link InputStream} and performs some transformation on
         * the input data while it is being read. Transformations can be anything from a
         * simple byte-wise filtering input data to an on-the-fly compression or
         * decompression of the underlying stream. Input streams that wrap another input
         * stream and provide some additional functionality on top of it usually inherit
         * from this class.
         *
         * @see FilterOutputStream
         */
        var FilterInputStream = (function (_super) {
            __extends(FilterInputStream, _super);
            /**
             * Constructs a new {@code FilterInputStream} with the specified input
             * stream as source.
             *
             * <p><strong>Warning:</strong> passing a null source creates an invalid
             * {@code FilterInputStream}, that fails on every method that is not
             * overridden. Subclasses should check for null in their constructors.
             *
             * @param in the input stream to filter reads on.
             */
            function FilterInputStream(__in) {
                _super.call(this);
                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Closeable", "java.lang.AutoCloseable"] });
                this.in = __in;
            }
            FilterInputStream.prototype.available = function () {
                return this.in.available();
            };
            /**
             * Closes this stream. This implementation closes the filtered stream.
             *
             * @throws IOException
             * if an error occurs while closing this stream.
             */
            FilterInputStream.prototype.close = function () {
                this.in.close();
            };
            /**
             * Sets a mark position in this stream. The parameter {@code readlimit}
             * indicates how many bytes can be read before the mark is invalidated.
             * Sending {@code reset()} will reposition this stream back to the marked
             * position, provided that {@code readlimit} has not been surpassed.
             * <p>
             * This implementation sets a mark in the filtered stream.
             *
             * @param readlimit
             * the number of bytes that can be read from this stream before
             * the mark is invalidated.
             * @see #markSupported()
             * @see #reset()
             */
            FilterInputStream.prototype.mark = function (readlimit) {
                this.in.mark(readlimit);
            };
            /**
             * Indicates whether this stream supports {@code mark()} and {@code reset()}.
             * This implementation returns whether or not the filtered stream supports
             * marking.
             *
             * @return {@code true} if {@code mark()} and {@code reset()} are supported,
             * {@code false} otherwise.
             * @see #mark(int)
             * @see #reset()
             * @see #skip(long)
             */
            FilterInputStream.prototype.markSupported = function () {
                return this.in.markSupported();
            };
            /**
             * Reads a single byte from the filtered stream and returns it as an integer
             * in the range from 0 to 255. Returns -1 if the end of this stream has been
             * reached.
             *
             * @return the byte read or -1 if the end of the filtered stream has been
             * reached.
             * @throws IOException
             * if the stream is closed or another IOException occurs.
             */
            FilterInputStream.prototype.read$ = function () {
                return this.in.read();
            };
            FilterInputStream.prototype.read = function (buffer, byteOffset, byteCount) {
                var _this = this;
                if (((buffer != null && buffer instanceof Array) || buffer === null) && ((typeof byteOffset === 'number') || byteOffset === null) && ((typeof byteCount === 'number') || byteCount === null)) {
                    return (function () {
                        return _this.in.read(buffer, byteOffset, byteCount);
                    })();
                }
                else if (((buffer != null && buffer instanceof Array) || buffer === null) && byteOffset === undefined && byteCount === undefined) {
                    return this.read$byte_A(buffer);
                }
                else if (buffer === undefined && byteOffset === undefined && byteCount === undefined) {
                    return this.read$();
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Resets this stream to the last marked location. This implementation
             * resets the target stream.
             *
             * @throws IOException
             * if this stream is already closed, no mark has been set or the
             * mark is no longer valid because more than {@code readlimit}
             * bytes have been read since setting the mark.
             * @see #mark(int)
             * @see #markSupported()
             */
            FilterInputStream.prototype.reset = function () {
                this.in.reset();
            };
            /**
             * Skips {@code byteCount} bytes in this stream. Subsequent
             * calls to {@code read} will not return these bytes unless {@code reset} is
             * used. This implementation skips {@code byteCount} bytes in the
             * filtered stream.
             *
             * @return the number of bytes actually skipped.
             * @throws IOException
             * if this stream is closed or another IOException occurs.
             * @see #mark(int)
             * @see #reset()
             */
            FilterInputStream.prototype.skip = function (byteCount) {
                return this.in.skip(byteCount);
            };
            return FilterInputStream;
        }(java.io.InputStream));
        io.FilterInputStream = FilterInputStream;
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var io;
    (function (io) {
        /**
         * A specialized {@link OutputStream} for class for writing content to an
         * (internal) byte array. As bytes are written to this stream, the byte array
         * may be expanded to hold more bytes. When the writing is considered to be
         * finished, a copy of the byte array can be requested from the class.
         *
         * @see ByteArrayInputStream
         */
        var ByteArrayOutputStream = (function (_super) {
            __extends(ByteArrayOutputStream, _super);
            /**
             * Constructs a new {@code ByteArrayOutputStream} with a default size of
             * {@code size} bytes. If more than {@code size} bytes are written to this
             * instance, the underlying byte array will expand.
             *
             * @param size
             * initial size for the underlying byte array, must be
             * non-negative.
             * @throws IllegalArgumentException
             * if {@code size} < 0.
             */
            function ByteArrayOutputStream(size) {
                var _this = this;
                if (((typeof size === 'number') || size === null)) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Closeable", "java.lang.AutoCloseable", "java.io.Flushable"] });
                    this.count = 0;
                    (function () {
                        if (size >= 0) {
                            _this.buf = new Array(size);
                        }
                        else {
                            throw new java.lang.IllegalArgumentException("size < 0");
                        }
                    })();
                }
                else if (size === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Closeable", "java.lang.AutoCloseable", "java.io.Flushable"] });
                    this.count = 0;
                    (function () {
                        _this.buf = new Array(32);
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * Closes this stream. This releases system resources used for this stream.
             *
             * @throws IOException
             * if an error occurs while attempting to close this stream.
             */
            ByteArrayOutputStream.prototype.close = function () {
                _super.prototype.close.call(this);
            };
            ByteArrayOutputStream.prototype.expand = function (i) {
                if (this.count + i <= this.buf.length) {
                    return;
                }
                var newbuf = new Array((this.count + i) * 2);
                java.lang.System.arraycopy(this.buf, 0, newbuf, 0, this.count);
                this.buf = newbuf;
            };
            /**
             * Resets this stream to the beginning of the underlying byte array. All
             * subsequent writes will overwrite any bytes previously stored in this
             * stream.
             */
            ByteArrayOutputStream.prototype.reset = function () {
                this.count = 0;
            };
            /**
             * Returns the total number of bytes written to this stream so far.
             *
             * @return the number of bytes written to this stream.
             */
            ByteArrayOutputStream.prototype.size = function () {
                return this.count;
            };
            /**
             * Returns the contents of this ByteArrayOutputStream as a byte array. Any
             * changes made to the receiver after returning will not be reflected in the
             * byte array returned to the caller.
             *
             * @return this stream's current contents as a byte array.
             */
            ByteArrayOutputStream.prototype.toByteArray = function () {
                var newArray = new Array(this.count);
                java.lang.System.arraycopy(this.buf, 0, newArray, 0, this.count);
                return newArray;
            };
            /**
             * Returns the contents of this ByteArrayOutputStream as a string. Any
             * changes made to the receiver after returning will not be reflected in the
             * string returned to the caller.
             *
             * @return this stream's current contents as a string.
             */
            ByteArrayOutputStream.prototype.toString$ = function () {
                return (function (str, index, len) { return str.substring(index, index + len); })((this.buf).map(function (s) { return String.fromCharCode(s); }).join(''), 0, this.count);
            };
            /**
             * Returns the contents of this ByteArrayOutputStream as a string. Each byte
             * {@code b} in this stream is converted to a character {@code c} using the
             * following function:
             * {@code c == (char)(((hibyte & 0xff) << 8) | (b & 0xff))}. This method is
             * deprecated and either {@link #toString()} or {@link #toString(String)}
             * should be used.
             *
             * @param hibyte
             * the high byte of each resulting Unicode character.
             * @return this stream's current contents as a string with the high byte set
             * to {@code hibyte}.
             * @deprecated Use {@link #toString()} instead.
             */
            ByteArrayOutputStream.prototype.toString$int = function (hibyte) {
                var newBuf = new Array(this.size());
                for (var i = 0; i < newBuf.length; i++) {
                    newBuf[i] = String.fromCharCode((((hibyte & 255) << 8) | (this.buf[i] & 255)));
                }
                return new String(newBuf);
            };
            /**
             * Returns the contents of this ByteArrayOutputStream as a string converted
             * according to the encoding declared in {@code charsetName}.
             *
             * @param charsetName
             * a string representing the encoding to use when translating
             * this stream to a string.
             * @return this stream's current contents as an encoded string.
             * @throws UnsupportedEncodingException
             * if the provided encoding is not supported.
             */
            ByteArrayOutputStream.prototype.toString = function (charsetName) {
                var _this = this;
                if (((typeof charsetName === 'string') || charsetName === null)) {
                    return (function () {
                        return (function (str, index, len) { return str.substring(index, index + len); })((_this.buf).map(function (s) { return String.fromCharCode(s); }).join(''), 0, _this.count);
                    })();
                }
                else if (((typeof charsetName === 'number') || charsetName === null)) {
                    return this.toString$int(charsetName);
                }
                else if (charsetName === undefined) {
                    return this.toString$();
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Writes {@code count} bytes from the byte array {@code buffer} starting at
             * offset {@code index} to this stream.
             *
             * @param buffer
             * the buffer to be written.
             * @param offset
             * the initial position in {@code buffer} to retrieve bytes.
             * @param len
             * the number of bytes of {@code buffer} to write.
             * @throws NullPointerException
             * if {@code buffer} is {@code null}.
             * @throws IndexOutOfBoundsException
             * if {@code offset < 0} or {@code len < 0}, or if
             * {@code offset + len} is greater than the length of
             * {@code buffer}.
             */
            ByteArrayOutputStream.prototype.write = function (buffer, offset, len) {
                var _this = this;
                if (((buffer != null && buffer instanceof Array) || buffer === null) && ((typeof offset === 'number') || offset === null) && ((typeof len === 'number') || len === null)) {
                    return (function () {
                        java.io.IOUtils.checkOffsetAndCount(buffer, offset, len);
                        if (len === 0) {
                            return;
                        }
                        _this.expand(len);
                        java.lang.System.arraycopy(buffer, offset, _this.buf, _this.count, len);
                        _this.count += len;
                    })();
                }
                else if (((buffer != null && buffer instanceof Array) || buffer === null) && offset === undefined && len === undefined) {
                    return this.write$byte_A(buffer);
                }
                else if (((typeof buffer === 'number') || buffer === null) && offset === undefined && len === undefined) {
                    return this.write$int(buffer);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Writes the specified byte {@code oneByte} to the OutputStream. Only the
             * low order byte of {@code oneByte} is written.
             *
             * @param oneByte
             * the byte to be written.
             */
            ByteArrayOutputStream.prototype.write$int = function (oneByte) {
                if (this.count === this.buf.length) {
                    this.expand(1);
                }
                this.buf[this.count++] = (oneByte | 0);
            };
            /**
             * Takes the contents of this stream and writes it to the output stream
             * {@code out}.
             *
             * @param out
             * an OutputStream on which to write the contents of this stream.
             * @throws IOException
             * if an error occurs while writing to {@code out}.
             */
            ByteArrayOutputStream.prototype.writeTo = function (out) {
                out.write(this.buf, 0, this.count);
            };
            return ByteArrayOutputStream;
        }(java.io.OutputStream));
        io.ByteArrayOutputStream = ByteArrayOutputStream;
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var io;
    (function (io) {
        /**
         * JSweet partial implementation based on a local storage FS.
         */
        var FileOutputStream = (function (_super) {
            __extends(FileOutputStream, _super);
            function FileOutputStream(name, append) {
                var _this = this;
                if (((typeof name === 'string') || name === null) && ((typeof append === 'boolean') || append === null)) {
                    {
                        var file = name != null ? new java.io.File(name) : null;
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Closeable", "java.lang.AutoCloseable", "java.io.Flushable"] });
                        this.append = false;
                        (function () {
                            if (!file.exists()) {
                                throw new java.io.FileNotFoundException();
                            }
                            _this.file = file;
                            _this.append = append;
                            _this.entry = java.io.File.fs_$LI$().getEntry(file.getAbsolutePath());
                            _this.content = append ? (_this.entry.data).split('').map(function (s) { return s.charCodeAt(0); }) : new Array(0);
                        })();
                    }
                    (function () {
                    })();
                }
                else if (((name != null && name instanceof java.io.File) || name === null) && ((typeof append === 'boolean') || append === null)) {
                    var file = name;
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Closeable", "java.lang.AutoCloseable", "java.io.Flushable"] });
                    this.append = false;
                    (function () {
                        if (!file.exists()) {
                            throw new java.io.FileNotFoundException();
                        }
                        _this.file = file;
                        _this.append = append;
                        _this.entry = java.io.File.fs_$LI$().getEntry(file.getAbsolutePath());
                        _this.content = append ? (_this.entry.data).split('').map(function (s) { return s.charCodeAt(0); }) : new Array(0);
                    })();
                }
                else if (((typeof name === 'string') || name === null) && append === undefined) {
                    {
                        var file = name != null ? new java.io.File(name) : null;
                        var append = false;
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Closeable", "java.lang.AutoCloseable", "java.io.Flushable"] });
                        this.append = false;
                        (function () {
                            if (!file.exists()) {
                                throw new java.io.FileNotFoundException();
                            }
                            _this.file = file;
                            _this.append = append;
                            _this.entry = java.io.File.fs_$LI$().getEntry(file.getAbsolutePath());
                            _this.content = append ? (_this.entry.data).split('').map(function (s) { return s.charCodeAt(0); }) : new Array(0);
                        })();
                    }
                    (function () {
                    })();
                }
                else if (((name != null && name instanceof java.io.File) || name === null) && append === undefined) {
                    var file = name;
                    {
                        var append = false;
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Closeable", "java.lang.AutoCloseable", "java.io.Flushable"] });
                        this.append = false;
                        (function () {
                            if (!file.exists()) {
                                throw new java.io.FileNotFoundException();
                            }
                            _this.file = file;
                            _this.append = append;
                            _this.entry = java.io.File.fs_$LI$().getEntry(file.getAbsolutePath());
                            _this.content = append ? (_this.entry.data).split('').map(function (s) { return s.charCodeAt(0); }) : new Array(0);
                        })();
                    }
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            FileOutputStream.prototype.write$int$boolean = function (b, append) {
                (this.content).push((b | 0));
            };
            FileOutputStream.prototype.write$int = function (b) {
                this.write(b, this.append);
            };
            FileOutputStream.prototype.writeBytes = function (b, off, len, append) {
                for (var i = off; i < off + len; i++) {
                    (this.content).push(b[i]);
                }
            };
            FileOutputStream.prototype.write$byte_A = function (b) {
                this.writeBytes(b, 0, b.length, this.append);
            };
            FileOutputStream.prototype.write = function (b, off, len) {
                var _this = this;
                if (((b != null && b instanceof Array) || b === null) && ((typeof off === 'number') || off === null) && ((typeof len === 'number') || len === null)) {
                    return (function () {
                        _this.writeBytes(b, off, len, _this.append);
                    })();
                }
                else if (((typeof b === 'number') || b === null) && ((typeof off === 'boolean') || off === null) && len === undefined) {
                    return this.write$int$boolean(b, off);
                }
                else if (((b != null && b instanceof Array) || b === null) && off === undefined && len === undefined) {
                    return this.write$byte_A(b);
                }
                else if (((typeof b === 'number') || b === null) && off === undefined && len === undefined) {
                    return this.write$int(b);
                }
                else
                    throw new Error('invalid overload');
            };
            FileOutputStream.prototype.flush = function () {
                this.entry.data = btoa(((this.content).map(function (b, __, ___) {
                    return String.fromCharCode(b);
                })).join(""));
                java.io.File.fs_$LI$().putEntry(this.file.getAbsolutePath(), this.entry);
            };
            FileOutputStream.prototype.close = function () {
                this.flush();
            };
            return FileOutputStream;
        }(java.io.OutputStream));
        io.FileOutputStream = FileOutputStream;
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var io;
    (function (io) {
        /**
         * Wraps an existing {@link OutputStream} and performs some transformation on
         * the output data while it is being written. Transformations can be anything
         * from a simple byte-wise filtering output data to an on-the-fly compression or
         * decompression of the underlying stream. Output streams that wrap another
         * output stream and provide some additional functionality on top of it usually
         * inherit from this class.
         *
         * @see FilterOutputStream
         */
        var FilterOutputStream = (function (_super) {
            __extends(FilterOutputStream, _super);
            /**
             * Constructs a new {@code FilterOutputStream} with {@code out} as its
             * target stream.
             *
             * @param out
             * the target stream that this stream writes to.
             */
            function FilterOutputStream(out) {
                _super.call(this);
                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Closeable", "java.lang.AutoCloseable", "java.io.Flushable"] });
                this.out = out;
            }
            /**
             * Closes this stream. This implementation closes the target stream.
             *
             * @throws IOException
             * if an error occurs attempting to close this stream.
             */
            FilterOutputStream.prototype.close = function () {
                var thrown = null;
                try {
                    this.flush();
                }
                catch (e) {
                    thrown = e;
                }
                ;
                try {
                    this.out.close();
                }
                catch (e) {
                    if (thrown == null) {
                        thrown = e;
                    }
                }
                ;
                if (thrown != null) {
                    throw new java.io.IOException(thrown);
                }
            };
            /**
             * Ensures that all pending data is sent out to the target stream. This
             * implementation flushes the target stream.
             *
             * @throws IOException
             * if an error occurs attempting to flush this stream.
             */
            FilterOutputStream.prototype.flush = function () {
                this.out.flush();
            };
            /**
             * Writes {@code count} bytes from the byte array {@code buffer} starting at
             * {@code offset} to the target stream.
             *
             * @param buffer
             * the buffer to write.
             * @param offset
             * the index of the first byte in {@code buffer} to write.
             * @param length
             * the number of bytes in {@code buffer} to write.
             * @throws IndexOutOfBoundsException
             * if {@code offset < 0} or {@code count < 0}, or if
             * {@code offset + count} is bigger than the length of
             * {@code buffer}.
             * @throws IOException
             * if an I/O error occurs while writing to this stream.
             */
            FilterOutputStream.prototype.write = function (buffer, offset, length) {
                var _this = this;
                if (((buffer != null && buffer instanceof Array) || buffer === null) && ((typeof offset === 'number') || offset === null) && ((typeof length === 'number') || length === null)) {
                    return (function () {
                        java.io.IOUtils.checkOffsetAndCount(buffer, offset, length);
                        for (var i = 0; i < length; i++) {
                            _this.write(buffer[offset + i]);
                        }
                    })();
                }
                else if (((buffer != null && buffer instanceof Array) || buffer === null) && offset === undefined && length === undefined) {
                    return this.write$byte_A(buffer);
                }
                else if (((typeof buffer === 'number') || buffer === null) && offset === undefined && length === undefined) {
                    return this.write$int(buffer);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Writes one byte to the target stream. Only the low order byte of the
             * integer {@code oneByte} is written.
             *
             * @param oneByte
             * the byte to be written.
             * @throws IOException
             * if an I/O error occurs while writing to this stream.
             */
            FilterOutputStream.prototype.write$int = function (oneByte) {
                this.out.write(oneByte);
            };
            return FilterOutputStream;
        }(java.io.OutputStream));
        io.FilterOutputStream = FilterOutputStream;
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var io;
    (function (io) {
        /**
         * JSweet implementation.
         */
        var BufferedReader = (function (_super) {
            __extends(BufferedReader, _super);
            function BufferedReader(__in, sz) {
                var _this = this;
                if (((__in != null && __in instanceof java.io.Reader) || __in === null) && ((typeof sz === 'number') || sz === null)) {
                    _super.call(this, __in);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Closeable", "java.lang.AutoCloseable"] });
                    this.nChars = 0;
                    this.nextChar = 0;
                    this.markedChar = 0;
                    this.readAheadLimit = 0;
                    this.skipLF = false;
                    this.markedSkipLF = false;
                    (function () {
                        _this.markedChar = BufferedReader.UNMARKED;
                        _this.readAheadLimit = 0;
                        _this.skipLF = false;
                        _this.markedSkipLF = false;
                        if (sz <= 0)
                            throw new java.lang.IllegalArgumentException("Buffer size <= 0");
                        _this.in = __in;
                        _this.cb = new Array(sz);
                        _this.nextChar = _this.nChars = 0;
                    })();
                }
                else if (((__in != null && __in instanceof java.io.Reader) || __in === null) && sz === undefined) {
                    {
                        var sz = BufferedReader.defaultCharBufferSize;
                        _super.call(this, __in);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Closeable", "java.lang.AutoCloseable"] });
                        this.nChars = 0;
                        this.nextChar = 0;
                        this.markedChar = 0;
                        this.readAheadLimit = 0;
                        this.skipLF = false;
                        this.markedSkipLF = false;
                        (function () {
                            _this.markedChar = BufferedReader.UNMARKED;
                            _this.readAheadLimit = 0;
                            _this.skipLF = false;
                            _this.markedSkipLF = false;
                            if (sz <= 0)
                                throw new java.lang.IllegalArgumentException("Buffer size <= 0");
                            _this.in = __in;
                            _this.cb = new Array(sz);
                            _this.nextChar = _this.nChars = 0;
                        })();
                    }
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * Checks to make sure that the stream has not been closed
             */
            BufferedReader.prototype.ensureOpen = function () {
                if (this.in == null)
                    throw new java.io.IOException("Stream closed");
            };
            /**
             * Fills the input buffer, taking the mark into account if it is valid.
             */
            BufferedReader.prototype.fill = function () {
                var dst;
                if (this.markedChar <= BufferedReader.UNMARKED) {
                    dst = 0;
                }
                else {
                    var delta = this.nextChar - this.markedChar;
                    if (delta >= this.readAheadLimit) {
                        this.markedChar = BufferedReader.INVALIDATED;
                        this.readAheadLimit = 0;
                        dst = 0;
                    }
                    else {
                        if (this.readAheadLimit <= this.cb.length) {
                            java.lang.System.arraycopy(this.cb, this.markedChar, this.cb, 0, delta);
                            this.markedChar = 0;
                            dst = delta;
                        }
                        else {
                            var ncb = new Array(this.readAheadLimit);
                            java.lang.System.arraycopy(this.cb, this.markedChar, ncb, 0, delta);
                            this.cb = ncb;
                            this.markedChar = 0;
                            dst = delta;
                        }
                        this.nextChar = this.nChars = delta;
                    }
                }
                var n;
                do {
                    n = this.in.read(this.cb, dst, this.cb.length - dst);
                } while ((n === 0));
                if (n > 0) {
                    this.nChars = dst + n;
                    this.nextChar = dst;
                }
            };
            BufferedReader.prototype.read$ = function () {
                {
                    this.ensureOpen();
                    for (;;) {
                        if (this.nextChar >= this.nChars) {
                            this.fill();
                            if (this.nextChar >= this.nChars)
                                return -1;
                        }
                        if (this.skipLF) {
                            this.skipLF = false;
                            if (this.cb[this.nextChar] === '\n') {
                                this.nextChar++;
                                continue;
                            }
                        }
                        return (this.cb[this.nextChar++]).charCodeAt(0);
                    }
                }
                ;
            };
            BufferedReader.prototype.read1 = function (cbuf, off, len) {
                if (this.nextChar >= this.nChars) {
                    if (len >= this.cb.length && this.markedChar <= BufferedReader.UNMARKED && !this.skipLF) {
                        return this.in.read(cbuf, off, len);
                    }
                    this.fill();
                }
                if (this.nextChar >= this.nChars)
                    return -1;
                if (this.skipLF) {
                    this.skipLF = false;
                    if (this.cb[this.nextChar] === '\n') {
                        this.nextChar++;
                        if (this.nextChar >= this.nChars)
                            this.fill();
                        if (this.nextChar >= this.nChars)
                            return -1;
                    }
                }
                var n = Math.min(len, this.nChars - this.nextChar);
                java.lang.System.arraycopy(this.cb, this.nextChar, cbuf, off, n);
                this.nextChar += n;
                return n;
            };
            BufferedReader.prototype.read = function (cbuf, off, len) {
                var _this = this;
                if (((cbuf != null && cbuf instanceof Array) || cbuf === null) && ((typeof off === 'number') || off === null) && ((typeof len === 'number') || len === null)) {
                    return (function () {
                        {
                            _this.ensureOpen();
                            if ((off < 0) || (off > cbuf.length) || (len < 0) || ((off + len) > cbuf.length) || ((off + len) < 0)) {
                                throw new java.lang.IndexOutOfBoundsException();
                            }
                            else if (len === 0) {
                                return 0;
                            }
                            var n = _this.read1(cbuf, off, len);
                            if (n <= 0)
                                return n;
                            while (((n < len) && _this.in.ready())) {
                                var n1 = _this.read1(cbuf, off + n, len - n);
                                if (n1 <= 0)
                                    break;
                                n += n1;
                            }
                            ;
                            return n;
                        }
                        ;
                    })();
                }
                else if (((cbuf != null && cbuf instanceof Array) || cbuf === null) && off === undefined && len === undefined) {
                    return this.read$char_A(cbuf);
                }
                else if (cbuf === undefined && off === undefined && len === undefined) {
                    return this.read$();
                }
                else
                    throw new Error('invalid overload');
            };
            BufferedReader.prototype.readLine = function (ignoreLF) {
                if (ignoreLF === void 0) { ignoreLF = false; }
                var s = null;
                var startChar;
                {
                    this.ensureOpen();
                    var omitLF = ignoreLF || this.skipLF;
                    for (;;) {
                        if (this.nextChar >= this.nChars)
                            this.fill();
                        if (this.nextChar >= this.nChars) {
                            if (s != null && s.length() > 0)
                                return s.toString();
                            else
                                return null;
                        }
                        var eol = false;
                        var c = String.fromCharCode(0);
                        var i;
                        if (omitLF && (this.cb[this.nextChar] === '\n'))
                            this.nextChar++;
                        this.skipLF = false;
                        omitLF = false;
                        charLoop: for (i = this.nextChar; i < this.nChars; i++) {
                            c = this.cb[i];
                            if ((c === '\n') || (c === '\r')) {
                                eol = true;
                                break charLoop;
                            }
                        }
                        startChar = this.nextChar;
                        this.nextChar = i;
                        if (eol) {
                            var str;
                            if (s == null) {
                                str = (function (str, index, len) { return str.substring(index, index + len); })((this.cb).join(''), startChar, i - startChar);
                            }
                            else {
                                s.append(this.cb, startChar, i - startChar);
                                str = s.toString();
                            }
                            this.nextChar++;
                            if (c === '\r') {
                                this.skipLF = true;
                            }
                            return str;
                        }
                        if (s == null)
                            s = new java.lang.StringBuffer(BufferedReader.defaultExpectedLineLength);
                        s.append(this.cb, startChar, i - startChar);
                    }
                }
                ;
            };
            BufferedReader.prototype.skip = function (n) {
                if (n < 0) {
                    throw new java.lang.IllegalArgumentException("skip value is negative");
                }
                {
                    this.ensureOpen();
                    var r = n;
                    while ((r > 0)) {
                        if (this.nextChar >= this.nChars)
                            this.fill();
                        if (this.nextChar >= this.nChars)
                            break;
                        if (this.skipLF) {
                            this.skipLF = false;
                            if (this.cb[this.nextChar] === '\n') {
                                this.nextChar++;
                            }
                        }
                        var d = this.nChars - this.nextChar;
                        if (r <= d) {
                            this.nextChar += r;
                            r = 0;
                            break;
                        }
                        else {
                            r -= d;
                            this.nextChar = this.nChars;
                        }
                    }
                    ;
                    return n - r;
                }
                ;
            };
            BufferedReader.prototype.ready = function () {
                {
                    this.ensureOpen();
                    if (this.skipLF) {
                        if (this.nextChar >= this.nChars && this.in.ready()) {
                            this.fill();
                        }
                        if (this.nextChar < this.nChars) {
                            if (this.cb[this.nextChar] === '\n')
                                this.nextChar++;
                            this.skipLF = false;
                        }
                    }
                    return (this.nextChar < this.nChars) || this.in.ready();
                }
                ;
            };
            BufferedReader.prototype.markSupported = function () {
                return true;
            };
            BufferedReader.prototype.mark = function (readAheadLimit) {
                if (readAheadLimit < 0) {
                    throw new java.lang.IllegalArgumentException("Read-ahead limit < 0");
                }
                {
                    this.ensureOpen();
                    this.readAheadLimit = readAheadLimit;
                    this.markedChar = this.nextChar;
                    this.markedSkipLF = this.skipLF;
                }
                ;
            };
            BufferedReader.prototype.reset = function () {
                {
                    this.ensureOpen();
                    if (this.markedChar < 0)
                        throw new java.io.IOException((this.markedChar === BufferedReader.INVALIDATED) ? "Mark invalid" : "Stream not marked");
                    this.nextChar = this.markedChar;
                    this.skipLF = this.markedSkipLF;
                }
                ;
            };
            BufferedReader.prototype.close = function () {
                {
                    if (this.in == null)
                        return;
                    try {
                        this.in.close();
                    }
                    finally {
                        this.in = null;
                        this.cb = null;
                    }
                    ;
                }
                ;
            };
            BufferedReader.INVALIDATED = -2;
            BufferedReader.UNMARKED = -1;
            BufferedReader.defaultCharBufferSize = 8192;
            BufferedReader.defaultExpectedLineLength = 80;
            return BufferedReader;
        }(java.io.Reader));
        io.BufferedReader = BufferedReader;
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var io;
    (function (io) {
        /**
         * JSweet implementation.
         */
        var InputStreamReader = (function (_super) {
            __extends(InputStreamReader, _super);
            function InputStreamReader(__in, charsetName) {
                var _this = this;
                if (((__in != null && __in instanceof java.io.InputStream) || __in === null) && ((typeof charsetName === 'string') || charsetName === null)) {
                    _super.call(this, __in);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Closeable", "java.lang.AutoCloseable"] });
                    (function () {
                        _this.in = __in;
                    })();
                }
                else if (((__in != null && __in instanceof java.io.InputStream) || __in === null) && ((charsetName != null && charsetName instanceof java.nio.charset.Charset) || charsetName === null)) {
                    var cs = charsetName;
                    _super.call(this, __in);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Closeable", "java.lang.AutoCloseable"] });
                    (function () {
                        _this.in = __in;
                        if (cs == null)
                            throw new java.lang.NullPointerException("charset");
                    })();
                }
                else if (((__in != null && __in instanceof java.io.InputStream) || __in === null) && charsetName === undefined) {
                    _super.call(this, __in);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Closeable", "java.lang.AutoCloseable"] });
                    (function () {
                        _this.in = __in;
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            InputStreamReader.prototype.read = function (cbuf, offset, length) {
                var _this = this;
                if (((cbuf != null && cbuf instanceof Array) || cbuf === null) && ((typeof offset === 'number') || offset === null) && ((typeof length === 'number') || length === null)) {
                    return (function () {
                        var buf = cbuf;
                        return _this.in.read(buf, offset, length);
                    })();
                }
                else if (((cbuf != null && cbuf instanceof Array) || cbuf === null) && offset === undefined && length === undefined) {
                    return this.read$char_A(cbuf);
                }
                else if (cbuf === undefined && offset === undefined && length === undefined) {
                    return this.read$();
                }
                else
                    throw new Error('invalid overload');
            };
            InputStreamReader.prototype.ready = function () {
                return this.in.available() > 0;
            };
            InputStreamReader.prototype.close = function () {
                this.in.close();
            };
            return InputStreamReader;
        }(java.io.Reader));
        io.InputStreamReader = InputStreamReader;
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var io;
    (function (io) {
        /**
         * JSweet implementation (partial).
         *
         * TODO: actual support of charsets.
         */
        var OutputStreamWriter = (function (_super) {
            __extends(OutputStreamWriter, _super);
            function OutputStreamWriter(out, charsetName) {
                var _this = this;
                if (((out != null && out instanceof java.io.OutputStream) || out === null) && ((typeof charsetName === 'string') || charsetName === null)) {
                    _super.call(this, out);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Appendable", "java.io.Closeable", "java.lang.AutoCloseable", "java.io.Flushable"] });
                    (function () {
                        if (charsetName == null)
                            throw new java.lang.NullPointerException("charsetName");
                        _this.out = out;
                    })();
                }
                else if (((out != null && out instanceof java.io.OutputStream) || out === null) && ((charsetName != null && charsetName instanceof java.nio.charset.Charset) || charsetName === null)) {
                    var cs = charsetName;
                    _super.call(this, out);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Appendable", "java.io.Closeable", "java.lang.AutoCloseable", "java.io.Flushable"] });
                    (function () {
                        if (cs == null)
                            throw new java.lang.NullPointerException("charset");
                        _this.out = out;
                    })();
                }
                else if (((out != null && out instanceof java.io.OutputStream) || out === null) && charsetName === undefined) {
                    _super.call(this, out);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Appendable", "java.io.Closeable", "java.lang.AutoCloseable", "java.io.Flushable"] });
                    (function () {
                        _this.out = out;
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            OutputStreamWriter.prototype.flushBuffer = function () {
                this.out.flush();
            };
            OutputStreamWriter.prototype.write$int = function (c) {
                this.out.write(c);
            };
            OutputStreamWriter.prototype.write = function (cbuf, off, len) {
                var _this = this;
                if (((cbuf != null && cbuf instanceof Array) || cbuf === null) && ((typeof off === 'number') || off === null) && ((typeof len === 'number') || len === null)) {
                    return (function () {
                        var buf = cbuf;
                        _this.out.write(buf, off, len);
                    })();
                }
                else if (((typeof cbuf === 'string') || cbuf === null) && ((typeof off === 'number') || off === null) && ((typeof len === 'number') || len === null)) {
                    return this.write$java_lang_String$int$int(cbuf, off, len);
                }
                else if (((cbuf != null && cbuf instanceof Array) || cbuf === null) && off === undefined && len === undefined) {
                    return this.write$char_A(cbuf);
                }
                else if (((typeof cbuf === 'string') || cbuf === null) && off === undefined && len === undefined) {
                    return this.write$java_lang_String(cbuf);
                }
                else if (((typeof cbuf === 'number') || cbuf === null) && off === undefined && len === undefined) {
                    return this.write$int(cbuf);
                }
                else
                    throw new Error('invalid overload');
            };
            OutputStreamWriter.prototype.write$java_lang_String$int$int = function (str, off, len) {
                this.out.write(/* getBytes */ (str).split('').map(function (s) { return s.charCodeAt(0); }), off, len);
            };
            OutputStreamWriter.prototype.flush = function () {
                this.out.flush();
            };
            OutputStreamWriter.prototype.close = function () {
                this.out.close();
            };
            return OutputStreamWriter;
        }(java.io.Writer));
        io.OutputStreamWriter = OutputStreamWriter;
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var lang;
    (function (lang) {
        /**
         * A fast way to create strings using multiple appends.
         *
         * This class is an exact clone of {@link StringBuilder} except for the name.
         * Any change made to one should be mirrored in the other.
         */
        var StringBuffer = (function (_super) {
            __extends(StringBuffer, _super);
            function StringBuffer(s) {
                if (((typeof s === 'string') || s === null)) {
                    _super.call(this, s);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.CharSequence", "java.lang.Appendable"] });
                    (function () {
                    })();
                }
                else if (((s != null && (s["__interfaces"] != null && s["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof s === "string")) || s === null)) {
                    _super.call(this, /* valueOf */ new String(s).toString());
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.CharSequence", "java.lang.Appendable"] });
                    (function () {
                    })();
                }
                else if (((typeof s === 'number') || s === null)) {
                    var ignoredCapacity = s;
                    _super.call(this, "");
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.CharSequence", "java.lang.Appendable"] });
                    (function () {
                    })();
                }
                else if (s === undefined) {
                    _super.call(this, "");
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.CharSequence", "java.lang.Appendable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            StringBuffer.prototype.append$boolean = function (x) {
                this.string += x;
                return this;
            };
            StringBuffer.prototype.append$char = function (x) {
                this.string += x;
                return this;
            };
            StringBuffer.prototype.append$char_A = function (x) {
                this.string += new String(x).toString();
                return this;
            };
            StringBuffer.prototype.append = function (x, start, len) {
                var _this = this;
                if (((x != null && x instanceof Array) || x === null) && ((typeof start === 'number') || start === null) && ((typeof len === 'number') || len === null)) {
                    return (function () {
                        _this.string += (function (str, index, len) { return str.join('').substring(index, index + len); })(x, start, len);
                        return _this;
                    })();
                }
                else if (((x != null && (x["__interfaces"] != null && x["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof x === "string")) || x === null) && ((typeof start === 'number') || start === null) && ((typeof len === 'number') || len === null)) {
                    return this.append$java_lang_CharSequence$int$int(x, start, len);
                }
                else if (((x != null && x instanceof Array) || x === null) && start === undefined && len === undefined) {
                    return this.append$char_A(x);
                }
                else if (((typeof x === 'string') || x === null) && start === undefined && len === undefined) {
                    return this.append$java_lang_String(x);
                }
                else if (((x != null && x instanceof java.lang.StringBuffer) || x === null) && start === undefined && len === undefined) {
                    return this.append$java_lang_StringBuffer(x);
                }
                else if (((x != null && (x["__interfaces"] != null && x["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof x === "string")) || x === null) && start === undefined && len === undefined) {
                    return this.append$java_lang_CharSequence(x);
                }
                else if (((typeof x === 'boolean') || x === null) && start === undefined && len === undefined) {
                    return this.append$boolean(x);
                }
                else if (((typeof x === 'string') || x === null) && start === undefined && len === undefined) {
                    return this.append$char(x);
                }
                else if (((typeof x === 'number') || x === null) && start === undefined && len === undefined) {
                    return this.append$int(x);
                }
                else if (((typeof x === 'number') || x === null) && start === undefined && len === undefined) {
                    return this.append$long(x);
                }
                else if (((typeof x === 'number') || x === null) && start === undefined && len === undefined) {
                    return this.append$float(x);
                }
                else if (((typeof x === 'number') || x === null) && start === undefined && len === undefined) {
                    return this.append$double(x);
                }
                else if (((x != null) || x === null) && start === undefined && len === undefined) {
                    return this.append$java_lang_Object(x);
                }
                else
                    throw new Error('invalid overload');
            };
            StringBuffer.prototype.append$java_lang_CharSequence = function (x) {
                this.string += x;
                return this;
            };
            StringBuffer.prototype.append$java_lang_CharSequence$int$int = function (x, start, end) {
                this.append0(x, start, end);
                return this;
            };
            StringBuffer.prototype.append$double = function (x) {
                this.string += x;
                return this;
            };
            StringBuffer.prototype.append$float = function (x) {
                this.string += x;
                return this;
            };
            StringBuffer.prototype.append$int = function (x) {
                this.string += x;
                return this;
            };
            StringBuffer.prototype.append$long = function (x) {
                this.string += x;
                return this;
            };
            StringBuffer.prototype.append$java_lang_Object = function (x) {
                this.string += x;
                return this;
            };
            StringBuffer.prototype.append$java_lang_String = function (x) {
                this.string += x;
                return this;
            };
            StringBuffer.prototype.append$java_lang_StringBuffer = function (x) {
                this.string += x;
                return this;
            };
            StringBuffer.prototype.appendCodePoint = function (x) {
                this.appendCodePoint0(x);
                return this;
            };
            StringBuffer.prototype.delete = function (start, end) {
                this.replace0(start, end, "");
                return this;
            };
            StringBuffer.prototype.deleteCharAt = function (start) {
                this.replace0(start, start + 1, "");
                return this;
            };
            StringBuffer.prototype.insert$int$boolean = function (index, x) {
                return this.insert(index, /* valueOf */ new String(x).toString());
            };
            StringBuffer.prototype.insert$int$char = function (index, x) {
                return this.insert(index, /* valueOf */ new String(x).toString());
            };
            StringBuffer.prototype.insert$int$char_A = function (index, x) {
                return this.insert(index, /* valueOf */ new String(x).toString());
            };
            StringBuffer.prototype.insert = function (index, x, offset, len) {
                var _this = this;
                if (((typeof index === 'number') || index === null) && ((x != null && x instanceof Array) || x === null) && ((typeof offset === 'number') || offset === null) && ((typeof len === 'number') || len === null)) {
                    return (function () {
                        return _this.insert(index, /* valueOf */ (function (str, index, len) { return str.join('').substring(index, index + len); })(x, offset, len));
                    })();
                }
                else if (((typeof index === 'number') || index === null) && ((x != null && (x["__interfaces"] != null && x["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof x === "string")) || x === null) && ((typeof offset === 'number') || offset === null) && ((typeof len === 'number') || len === null)) {
                    return this.insert$int$java_lang_CharSequence$int$int(index, x, offset, len);
                }
                else if (((typeof index === 'number') || index === null) && ((x != null && x instanceof Array) || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$char_A(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((typeof x === 'string') || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$java_lang_String(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((x != null && (x["__interfaces"] != null && x["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof x === "string")) || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$java_lang_CharSequence(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((typeof x === 'boolean') || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$boolean(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((typeof x === 'string') || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$char(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((typeof x === 'number') || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$int(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((typeof x === 'number') || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$long(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((typeof x === 'number') || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$float(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((typeof x === 'number') || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$double(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((x != null) || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$java_lang_Object(index, x);
                }
                else
                    throw new Error('invalid overload');
            };
            StringBuffer.prototype.insert$int$java_lang_CharSequence = function (index, chars) {
                return this.insert(index, chars.toString());
            };
            StringBuffer.prototype.insert$int$java_lang_CharSequence$int$int = function (index, chars, start, end) {
                return this.insert(index, /* subSequence */ chars.substring(start, end).toString());
            };
            StringBuffer.prototype.insert$int$double = function (index, x) {
                return this.insert(index, /* valueOf */ new String(x).toString());
            };
            StringBuffer.prototype.insert$int$float = function (index, x) {
                return this.insert(index, /* valueOf */ new String(x).toString());
            };
            StringBuffer.prototype.insert$int$int = function (index, x) {
                return this.insert(index, /* valueOf */ new String(x).toString());
            };
            StringBuffer.prototype.insert$int$long = function (index, x) {
                return this.insert(index, /* valueOf */ new String(x).toString());
            };
            StringBuffer.prototype.insert$int$java_lang_Object = function (index, x) {
                return this.insert(index, /* valueOf */ new String(x).toString());
            };
            StringBuffer.prototype.insert$int$java_lang_String = function (index, x) {
                this.replace0(index, index, x);
                return this;
            };
            StringBuffer.prototype.replace = function (start, end, toInsert) {
                this.replace0(start, end, toInsert);
                return this;
            };
            StringBuffer.prototype.reverse = function () {
                this.reverse0();
                return this;
            };
            return StringBuffer;
        }(java.lang.AbstractStringBuilder));
        lang.StringBuffer = StringBuffer;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var lang;
    (function (lang) {
        /**
         * A fast way to create strings using multiple appends.
         *
         * This class is an exact clone of {@link StringBuffer} except for the name. Any
         * change made to one should be mirrored in the other.
         */
        var StringBuilder = (function (_super) {
            __extends(StringBuilder, _super);
            function StringBuilder(s) {
                if (((typeof s === 'string') || s === null)) {
                    _super.call(this, s);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.CharSequence", "java.lang.Appendable"] });
                    (function () {
                    })();
                }
                else if (((s != null && (s["__interfaces"] != null && s["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof s === "string")) || s === null)) {
                    _super.call(this, /* valueOf */ new String(s).toString());
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.CharSequence", "java.lang.Appendable"] });
                    (function () {
                    })();
                }
                else if (((typeof s === 'number') || s === null)) {
                    var ignoredCapacity = s;
                    _super.call(this, "");
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.CharSequence", "java.lang.Appendable"] });
                    (function () {
                    })();
                }
                else if (s === undefined) {
                    _super.call(this, "");
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.CharSequence", "java.lang.Appendable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            StringBuilder.prototype.append$boolean = function (x) {
                this.string += x;
                return this;
            };
            StringBuilder.prototype.append$char = function (x) {
                this.string += x;
                return this;
            };
            StringBuilder.prototype.append$char_A = function (x) {
                this.string += new String(x).toString();
                return this;
            };
            StringBuilder.prototype.append = function (x, start, len) {
                var _this = this;
                if (((x != null && x instanceof Array) || x === null) && ((typeof start === 'number') || start === null) && ((typeof len === 'number') || len === null)) {
                    return (function () {
                        _this.string += (function (str, index, len) { return str.join('').substring(index, index + len); })(x, start, len);
                        return _this;
                    })();
                }
                else if (((x != null && (x["__interfaces"] != null && x["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof x === "string")) || x === null) && ((typeof start === 'number') || start === null) && ((typeof len === 'number') || len === null)) {
                    return this.append$java_lang_CharSequence$int$int(x, start, len);
                }
                else if (((x != null && x instanceof Array) || x === null) && start === undefined && len === undefined) {
                    return this.append$char_A(x);
                }
                else if (((typeof x === 'string') || x === null) && start === undefined && len === undefined) {
                    return this.append$java_lang_String(x);
                }
                else if (((x != null && x instanceof java.lang.StringBuffer) || x === null) && start === undefined && len === undefined) {
                    return this.append$java_lang_StringBuffer(x);
                }
                else if (((x != null && (x["__interfaces"] != null && x["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof x === "string")) || x === null) && start === undefined && len === undefined) {
                    return this.append$java_lang_CharSequence(x);
                }
                else if (((typeof x === 'boolean') || x === null) && start === undefined && len === undefined) {
                    return this.append$boolean(x);
                }
                else if (((typeof x === 'string') || x === null) && start === undefined && len === undefined) {
                    return this.append$char(x);
                }
                else if (((typeof x === 'number') || x === null) && start === undefined && len === undefined) {
                    return this.append$int(x);
                }
                else if (((typeof x === 'number') || x === null) && start === undefined && len === undefined) {
                    return this.append$long(x);
                }
                else if (((typeof x === 'number') || x === null) && start === undefined && len === undefined) {
                    return this.append$float(x);
                }
                else if (((typeof x === 'number') || x === null) && start === undefined && len === undefined) {
                    return this.append$double(x);
                }
                else if (((x != null) || x === null) && start === undefined && len === undefined) {
                    return this.append$java_lang_Object(x);
                }
                else
                    throw new Error('invalid overload');
            };
            StringBuilder.prototype.append$java_lang_CharSequence = function (x) {
                this.string += x;
                return this;
            };
            StringBuilder.prototype.append$java_lang_CharSequence$int$int = function (x, start, end) {
                this.append0(x, start, end);
                return this;
            };
            StringBuilder.prototype.append$double = function (x) {
                this.string += x;
                return this;
            };
            StringBuilder.prototype.append$float = function (x) {
                this.string += x;
                return this;
            };
            StringBuilder.prototype.append$int = function (x) {
                this.string += x;
                return this;
            };
            StringBuilder.prototype.append$long = function (x) {
                this.string += x;
                return this;
            };
            StringBuilder.prototype.append$java_lang_Object = function (x) {
                this.string += x;
                return this;
            };
            StringBuilder.prototype.append$java_lang_String = function (x) {
                this.string += x;
                return this;
            };
            StringBuilder.prototype.append$java_lang_StringBuffer = function (x) {
                this.string += x;
                return this;
            };
            StringBuilder.prototype.appendCodePoint = function (x) {
                this.appendCodePoint0(x);
                return this;
            };
            StringBuilder.prototype.delete = function (start, end) {
                this.replace0(start, end, "");
                return this;
            };
            StringBuilder.prototype.deleteCharAt = function (start) {
                this.replace0(start, start + 1, "");
                return this;
            };
            StringBuilder.prototype.insert$int$boolean = function (index, x) {
                return this.insert(index, /* valueOf */ new String(x).toString());
            };
            StringBuilder.prototype.insert$int$char = function (index, x) {
                this.replace0(index, index, /* valueOf */ new String(x).toString());
                return this;
            };
            StringBuilder.prototype.insert$int$char_A = function (index, x) {
                return this.insert(index, /* valueOf */ new String(x).toString());
            };
            StringBuilder.prototype.insert = function (index, x, offset, len) {
                var _this = this;
                if (((typeof index === 'number') || index === null) && ((x != null && x instanceof Array) || x === null) && ((typeof offset === 'number') || offset === null) && ((typeof len === 'number') || len === null)) {
                    return (function () {
                        return _this.insert(index, /* valueOf */ (function (str, index, len) { return str.join('').substring(index, index + len); })(x, offset, len));
                    })();
                }
                else if (((typeof index === 'number') || index === null) && ((x != null && (x["__interfaces"] != null && x["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof x === "string")) || x === null) && ((typeof offset === 'number') || offset === null) && ((typeof len === 'number') || len === null)) {
                    return this.insert$int$java_lang_CharSequence$int$int(index, x, offset, len);
                }
                else if (((typeof index === 'number') || index === null) && ((x != null && x instanceof Array) || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$char_A(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((typeof x === 'string') || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$java_lang_String(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((x != null && (x["__interfaces"] != null && x["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof x === "string")) || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$java_lang_CharSequence(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((typeof x === 'boolean') || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$boolean(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((typeof x === 'string') || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$char(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((typeof x === 'number') || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$int(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((typeof x === 'number') || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$long(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((typeof x === 'number') || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$float(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((typeof x === 'number') || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$double(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((x != null) || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$java_lang_Object(index, x);
                }
                else
                    throw new Error('invalid overload');
            };
            StringBuilder.prototype.insert$int$java_lang_CharSequence = function (index, chars) {
                return this.insert(index, chars.toString());
            };
            StringBuilder.prototype.insert$int$java_lang_CharSequence$int$int = function (index, chars, start, end) {
                return this.insert(index, /* subSequence */ chars.substring(start, end).toString());
            };
            StringBuilder.prototype.insert$int$double = function (index, x) {
                return this.insert(index, /* valueOf */ new String(x).toString());
            };
            StringBuilder.prototype.insert$int$float = function (index, x) {
                return this.insert(index, /* valueOf */ new String(x).toString());
            };
            StringBuilder.prototype.insert$int$int = function (index, x) {
                return this.insert(index, /* valueOf */ new String(x).toString());
            };
            StringBuilder.prototype.insert$int$long = function (index, x) {
                return this.insert(index, /* valueOf */ new String(x).toString());
            };
            StringBuilder.prototype.insert$int$java_lang_Object = function (index, x) {
                return this.insert(index, /* valueOf */ new String(x).toString());
            };
            StringBuilder.prototype.insert$int$java_lang_String = function (index, x) {
                this.replace0(index, index, x);
                return this;
            };
            StringBuilder.prototype.replace = function (start, end, toInsert) {
                this.replace0(start, end, toInsert);
                return this;
            };
            StringBuilder.prototype.reverse = function () {
                this.reverse0();
                return this;
            };
            return StringBuilder;
        }(java.lang.AbstractStringBuilder));
        lang.StringBuilder = StringBuilder;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The <code>NoninvertibleTransformException</code> class represents an
             * exception that is thrown if an operation is performed requiring the inverse
             * of an {@link AffineTransform} object but the <code>AffineTransform</code> is
             * in a non-invertible state.
             */
            var NoninvertibleTransformException = (function (_super) {
                __extends(NoninvertibleTransformException, _super);
                /**
                 * Constructs an instance of <code>NoninvertibleTransformException</code>
                 * with the specified detail message.
                 *
                 * @param s
                 * the detail message
                 * @since 1.2
                 */
                function NoninvertibleTransformException(s) {
                    _super.call(this, s);
                    this.message = s;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                }
                return NoninvertibleTransformException;
            }(java.lang.Exception));
            geom.NoninvertibleTransformException = NoninvertibleTransformException;
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var io;
    (function (io) {
        /**
         * See <a
         * href="http://java.sun.com/javase/6/docs/api/java/io/IOException.html">the
         * official Java API doc</a> for details.
         */
        var IOException = (function (_super) {
            __extends(IOException, _super);
            function IOException(message, throwable) {
                if (((typeof message === 'string') || message === null) && ((throwable != null && throwable instanceof Error) || throwable === null)) {
                    _super.call(this, message);
                    this.message = message;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (((typeof message === 'string') || message === null) && throwable === undefined) {
                    _super.call(this, message);
                    this.message = message;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (((message != null && message instanceof Error) || message === null) && throwable === undefined) {
                    var throwable = message;
                    _super.call(this, throwable);
                    this.message = throwable;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (message === undefined && throwable === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            return IOException;
        }(Error));
        io.IOException = IOException;
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var lang;
    (function (lang) {
        /**
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/CloneNotSupportedException.html">
         * the official Java API doc</a> for details.
         */
        var CloneNotSupportedException = (function (_super) {
            __extends(CloneNotSupportedException, _super);
            function CloneNotSupportedException(msg) {
                if (((typeof msg === 'string') || msg === null)) {
                    _super.call(this, msg);
                    this.message = msg;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (msg === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            return CloneNotSupportedException;
        }(Error));
        lang.CloneNotSupportedException = CloneNotSupportedException;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var lang;
    (function (lang) {
        /**
         * See <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/NoSuchMethodException.html">the
         * official Java API doc</a> for details.
         *
         * This exception is never thrown by GWT or GWT's libraries, as GWT does not support reflection. It
         * is provided in GWT only for compatibility with user code that explicitly throws or catches it for
         * non-reflection purposes.
         */
        var NoSuchMethodException = (function (_super) {
            __extends(NoSuchMethodException, _super);
            function NoSuchMethodException(message) {
                if (((typeof message === 'string') || message === null)) {
                    _super.call(this, message);
                    this.message = message;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (message === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            return NoSuchMethodException;
        }(Error));
        lang.NoSuchMethodException = NoSuchMethodException;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var lang;
    (function (lang) {
        /**
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/RuntimeException.html">the
         * official Java API doc</a> for details.
         */
        var RuntimeException = (function (_super) {
            __extends(RuntimeException, _super);
            function RuntimeException(message, cause, enableSuppression, writableStackTrace) {
                if (((typeof message === 'string') || message === null) && ((cause != null && cause instanceof Error) || cause === null) && ((typeof enableSuppression === 'boolean') || enableSuppression === null) && ((typeof writableStackTrace === 'boolean') || writableStackTrace === null)) {
                    _super.call(this, message);
                    this.message = message;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (((typeof message === 'string') || message === null) && ((cause != null && cause instanceof Error) || cause === null) && enableSuppression === undefined && writableStackTrace === undefined) {
                    _super.call(this, message);
                    this.message = message;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (((typeof message === 'string') || message === null) && cause === undefined && enableSuppression === undefined && writableStackTrace === undefined) {
                    _super.call(this, message);
                    this.message = message;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (((message != null && message instanceof Error) || message === null) && cause === undefined && enableSuppression === undefined && writableStackTrace === undefined) {
                    var cause = message;
                    _super.call(this, cause);
                    this.message = cause;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (message === undefined && cause === undefined && enableSuppression === undefined && writableStackTrace === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            return RuntimeException;
        }(Error));
        lang.RuntimeException = RuntimeException;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var security;
    (function (security) {
        /**
         * A generic security exception type - <a
         * href="http://java.sun.com/j2se/1.4.2/docs/api/java/security/GeneralSecurityException.html">[Sun's
         * docs]</a>.
         */
        var GeneralSecurityException = (function (_super) {
            __extends(GeneralSecurityException, _super);
            function GeneralSecurityException(msg) {
                if (((typeof msg === 'string') || msg === null)) {
                    _super.call(this, msg);
                    this.message = msg;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (msg === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            return GeneralSecurityException;
        }(Error));
        security.GeneralSecurityException = GeneralSecurityException;
    })(security = java.security || (java.security = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var text;
    (function (text) {
        /**
         * Emulation of {@code java.text.ParseException}.
         */
        var ParseException = (function (_super) {
            __extends(ParseException, _super);
            function ParseException(s, errorOffset) {
                _super.call(this, s);
                this.message = s;
                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                this.errorOffset = 0;
                this.errorOffset = errorOffset;
            }
            ParseException.prototype.getErrorOffset = function () {
                return this.errorOffset;
            };
            return ParseException;
        }(Error));
        text.ParseException = ParseException;
    })(text = java.text || (java.text = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * Thrown when the subject of an observer cannot support additional observers.
         *
         */
        var TooManyListenersException = (function (_super) {
            __extends(TooManyListenersException, _super);
            function TooManyListenersException(message) {
                if (((typeof message === 'string') || message === null)) {
                    _super.call(this, message);
                    this.message = message;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (message === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            return TooManyListenersException;
        }(Error));
        util.TooManyListenersException = TooManyListenersException;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var lang;
    (function (lang) {
        /**
         * Thrown to indicate some unexpected internal error has occurred in
         * the Java Virtual Machine.
         *
         * @author  unascribed
         * @since   JDK1.0
         */
        var InternalError = (function (_super) {
            __extends(InternalError, _super);
            /**
             * Constructs an {@code InternalError} with the specified detail
             * message and cause.  <p>Note that the detail message associated
             * with {@code cause} is <i>not</i> automatically incorporated in
             * this error's detail message.
             *
             * @param  message the detail message (which is saved for later retrieval
             * by the {@link #getMessage()} method).
             * @param  cause the cause (which is saved for later retrieval by the
             * {@link #getCause()} method).  (A {@code null} value is
             * permitted, and indicates that the cause is nonexistent or
             * unknown.)
             * @since  1.8
             */
            function InternalError(message, cause) {
                if (((typeof message === 'string') || message === null) && ((cause != null && cause instanceof Error) || cause === null)) {
                    _super.call(this, message, cause);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (((typeof message === 'string') || message === null) && cause === undefined) {
                    _super.call(this, message);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (((message != null && message instanceof Error) || message === null) && cause === undefined) {
                    var cause = message;
                    _super.call(this, cause);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (message === undefined && cause === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            InternalError.serialVersionUID = -9062593416125562365;
            return InternalError;
        }(java.lang.VirtualMachineError));
        lang.InternalError = InternalError;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var javaemul;
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Provides Charset implementations.
         */
        var EmulatedCharset = (function (_super) {
            __extends(EmulatedCharset, _super);
            function EmulatedCharset(name) {
                _super.call(this, name, null);
                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Comparable"] });
            }
            EmulatedCharset.UTF_8_$LI$ = function () { if (EmulatedCharset.UTF_8 == null)
                EmulatedCharset.UTF_8 = new EmulatedCharset.UtfCharset("UTF-8"); return EmulatedCharset.UTF_8; };
            ;
            EmulatedCharset.ISO_LATIN_1_$LI$ = function () { if (EmulatedCharset.ISO_LATIN_1 == null)
                EmulatedCharset.ISO_LATIN_1 = new EmulatedCharset.LatinCharset("ISO-LATIN-1"); return EmulatedCharset.ISO_LATIN_1; };
            ;
            EmulatedCharset.ISO_8859_1_$LI$ = function () { if (EmulatedCharset.ISO_8859_1 == null)
                EmulatedCharset.ISO_8859_1 = new EmulatedCharset.LatinCharset("ISO-8859-1"); return EmulatedCharset.ISO_8859_1; };
            ;
            return EmulatedCharset;
        }(java.nio.charset.Charset));
        internal.EmulatedCharset = EmulatedCharset;
        var EmulatedCharset;
        (function (EmulatedCharset) {
            var LatinCharset = (function (_super) {
                __extends(LatinCharset, _super);
                function LatinCharset(name) {
                    _super.call(this, name);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Comparable"] });
                }
                LatinCharset.prototype.getBytes = function (str) {
                    var n = str.length;
                    var bytes = new Array(n);
                    for (var i = 0; i < n; ++i) {
                        bytes[i] = (((str.charAt(i)).charCodeAt(0) & 255) | 0);
                    }
                    return bytes;
                };
                LatinCharset.prototype.decodeString = function (bytes, ofs, len) {
                    var chars = new Array(len);
                    for (var i = 0; i < len; ++i) {
                        chars[i] = String.fromCharCode((bytes[ofs + i] & 255));
                    }
                    return chars;
                };
                return LatinCharset;
            }(javaemul.internal.EmulatedCharset));
            EmulatedCharset.LatinCharset = LatinCharset;
            var UtfCharset = (function (_super) {
                __extends(UtfCharset, _super);
                function UtfCharset(name) {
                    _super.call(this, name);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Comparable"] });
                }
                UtfCharset.prototype.decodeString = function (bytes, ofs, len) {
                    var charCount = 0;
                    for (var i = 0; i < len;) {
                        ++charCount;
                        var ch = bytes[ofs + i];
                        if ((ch & 192) === 128) {
                            throw new java.lang.IllegalArgumentException("Invalid UTF8 sequence");
                        }
                        else if ((ch & 128) === 0) {
                            ++i;
                        }
                        else if ((ch & 224) === 192) {
                            i += 2;
                        }
                        else if ((ch & 240) === 224) {
                            i += 3;
                        }
                        else if ((ch & 248) === 240) {
                            i += 4;
                        }
                        else {
                            throw new java.lang.IllegalArgumentException("Invalid UTF8 sequence");
                        }
                        if (i > len) {
                            throw new java.lang.IndexOutOfBoundsException("Invalid UTF8 sequence");
                        }
                    }
                    var chars = new Array(charCount);
                    var outIdx = 0;
                    var count = 0;
                    for (var i = 0; i < len;) {
                        var ch = bytes[ofs + i++];
                        if ((ch & 128) === 0) {
                            count = 1;
                            ch &= 127;
                        }
                        else if ((ch & 224) === 192) {
                            count = 2;
                            ch &= 31;
                        }
                        else if ((ch & 240) === 224) {
                            count = 3;
                            ch &= 15;
                        }
                        else if ((ch & 248) === 240) {
                            count = 4;
                            ch &= 7;
                        }
                        else if ((ch & 252) === 248) {
                            count = 5;
                            ch &= 3;
                        }
                        while ((--count > 0)) {
                            var b = bytes[ofs + i++];
                            if ((b & 192) !== 128) {
                                throw new java.lang.IllegalArgumentException("Invalid UTF8 sequence at " + (ofs + i - 1) + ", byte=" + javaemul.internal.IntegerHelper.toHexString(b));
                            }
                            ch = (ch << 6) | (b & 63);
                        }
                        ;
                        outIdx += javaemul.internal.CharacterHelper.toChars(ch, chars, outIdx);
                    }
                    return chars;
                };
                UtfCharset.prototype.getBytes = function (str) {
                    var n = str.length;
                    var byteCount = 0;
                    for (var i = 0; i < n;) {
                        var ch = str.charCodeAt(i);
                        i += javaemul.internal.CharacterHelper.charCount(ch);
                        if (ch < (1 << 7)) {
                            byteCount++;
                        }
                        else if (ch < (1 << 11)) {
                            byteCount += 2;
                        }
                        else if (ch < (1 << 16)) {
                            byteCount += 3;
                        }
                        else if (ch < (1 << 21)) {
                            byteCount += 4;
                        }
                        else if (ch < (1 << 26)) {
                            byteCount += 5;
                        }
                    }
                    var bytes = new Array(byteCount);
                    var out = 0;
                    for (var i = 0; i < n;) {
                        var ch = str.charCodeAt(i);
                        i += javaemul.internal.CharacterHelper.charCount(ch);
                        out += this.encodeUtf8(bytes, out, ch);
                    }
                    return bytes;
                };
                /**
                 * Encode a single character in UTF8.
                 *
                 * @param bytes byte array to store character in
                 * @param ofs offset into byte array to store first byte
                 * @param codePoint character to encode
                 * @return number of bytes consumed by encoding the character
                 * @throws IllegalArgumentException if codepoint >= 2^26
                 */
                UtfCharset.prototype.encodeUtf8 = function (bytes, ofs, codePoint) {
                    if (codePoint < (1 << 7)) {
                        bytes[ofs] = ((codePoint & 127) | 0);
                        return 1;
                    }
                    else if (codePoint < (1 << 11)) {
                        bytes[ofs++] = ((((codePoint >> 6) & 31) | 192) | 0);
                        bytes[ofs] = (((codePoint & 63) | 128) | 0);
                        return 2;
                    }
                    else if (codePoint < (1 << 16)) {
                        bytes[ofs++] = ((((codePoint >> 12) & 15) | 224) | 0);
                        bytes[ofs++] = ((((codePoint >> 6) & 63) | 128) | 0);
                        bytes[ofs] = (((codePoint & 63) | 128) | 0);
                        return 3;
                    }
                    else if (codePoint < (1 << 21)) {
                        bytes[ofs++] = ((((codePoint >> 18) & 7) | 240) | 0);
                        bytes[ofs++] = ((((codePoint >> 12) & 63) | 128) | 0);
                        bytes[ofs++] = ((((codePoint >> 6) & 63) | 128) | 0);
                        bytes[ofs] = (((codePoint & 63) | 128) | 0);
                        return 4;
                    }
                    else if (codePoint < (1 << 26)) {
                        bytes[ofs++] = ((((codePoint >> 24) & 3) | 248) | 0);
                        bytes[ofs++] = ((((codePoint >> 18) & 63) | 128) | 0);
                        bytes[ofs++] = ((((codePoint >> 12) & 63) | 128) | 0);
                        bytes[ofs++] = ((((codePoint >> 6) & 63) | 128) | 0);
                        bytes[ofs] = (((codePoint & 63) | 128) | 0);
                        return 5;
                    }
                    throw new java.lang.IllegalArgumentException("Character out of range: " + codePoint);
                };
                return UtfCharset;
            }(javaemul.internal.EmulatedCharset));
            EmulatedCharset.UtfCharset = UtfCharset;
        })(EmulatedCharset = internal.EmulatedCharset || (internal.EmulatedCharset = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var security;
    (function (security) {
        /**
         * Message Digest algorithm - <a href=
         * "http://java.sun.com/j2se/1.4.2/docs/api/java/security/MessageDigest.html"
         * >[Sun's docs]</a>.
         */
        var MessageDigest = (function (_super) {
            __extends(MessageDigest, _super);
            function MessageDigest(algorithm) {
                _super.call(this);
                this.algorithm = algorithm;
            }
            MessageDigest.getInstance = function (algorithm) {
                if (("MD5" === algorithm)) {
                    return new MessageDigest.Md5Digest();
                }
                throw new java.security.NoSuchAlgorithmException(algorithm + " not supported");
            };
            MessageDigest.isEqual = function (digestA, digestB) {
                var n = digestA.length;
                if (n !== digestB.length) {
                    return false;
                }
                for (var i = 0; i < n; ++i) {
                    if (digestA[i] !== digestB[i]) {
                        return false;
                    }
                }
                return true;
            };
            MessageDigest.prototype.digest$ = function () {
                return this.engineDigest();
            };
            MessageDigest.prototype.digest$byte_A = function (input) {
                this.update(input);
                return this.digest();
            };
            MessageDigest.prototype.digest = function (buf, offset, len) {
                var _this = this;
                if (((buf != null && buf instanceof Array) || buf === null) && ((typeof offset === 'number') || offset === null) && ((typeof len === 'number') || len === null)) {
                    return (function () {
                        return _this.engineDigest(buf, offset, len);
                    })();
                }
                else if (((buf != null && buf instanceof Array) || buf === null) && offset === undefined && len === undefined) {
                    return this.digest$byte_A(buf);
                }
                else if (buf === undefined && offset === undefined && len === undefined) {
                    return this.digest$();
                }
                else
                    throw new Error('invalid overload');
            };
            MessageDigest.prototype.getAlgorithm = function () {
                return this.algorithm;
            };
            MessageDigest.prototype.getDigestLength = function () {
                return this.engineGetDigestLength();
            };
            MessageDigest.prototype.reset = function () {
                this.engineReset();
            };
            MessageDigest.prototype.update$byte = function (input) {
                this.engineUpdate(input);
            };
            MessageDigest.prototype.update$byte_A = function (input) {
                this.engineUpdate(input, 0, input.length);
            };
            MessageDigest.prototype.update = function (input, offset, len) {
                var _this = this;
                if (((input != null && input instanceof Array) || input === null) && ((typeof offset === 'number') || offset === null) && ((typeof len === 'number') || len === null)) {
                    return (function () {
                        _this.engineUpdate(input, offset, len);
                    })();
                }
                else if (((input != null && input instanceof Array) || input === null) && offset === undefined && len === undefined) {
                    return this.update$byte_A(input);
                }
                else if (((typeof input === 'number') || input === null) && offset === undefined && len === undefined) {
                    return this.update$byte(input);
                }
                else
                    throw new Error('invalid overload');
            };
            return MessageDigest;
        }(java.security.MessageDigestSpi));
        security.MessageDigest = MessageDigest;
        var MessageDigest;
        (function (MessageDigest) {
            var Md5Digest = (function (_super) {
                __extends(Md5Digest, _super);
                function Md5Digest() {
                    _super.call(this, "MD5");
                    this.oneByte = new Array(1);
                    this.counter = 0;
                    this.remainder = 0;
                    this.engineReset();
                }
                Md5Digest.padding_$LI$ = function () { if (Md5Digest.padding == null)
                    Md5Digest.padding = [(128 | 0), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; return Md5Digest.padding; };
                ;
                /**
                 * Converts a long to a 8-byte array using low order first.
                 *
                 * @param n A long.
                 * @return A byte[].
                 */
                Md5Digest.toBytes = function (n) {
                    var b = new Array(8);
                    b[0] = ((n) | 0);
                    n >>>= 8;
                    b[1] = ((n) | 0);
                    n >>>= 8;
                    b[2] = ((n) | 0);
                    n >>>= 8;
                    b[3] = ((n) | 0);
                    n >>>= 8;
                    b[4] = ((n) | 0);
                    n >>>= 8;
                    b[5] = ((n) | 0);
                    n >>>= 8;
                    b[6] = ((n) | 0);
                    n >>>= 8;
                    b[7] = ((n) | 0);
                    return b;
                };
                /**
                 * Converts a 64-byte array into a 16-int array.
                 *
                 * @param in A byte[].
                 * @param out An int[].
                 */
                Md5Digest.byte2int = function (__in, out) {
                    for (var inpos = 0, outpos = 0; outpos < 16; outpos++) {
                        out[outpos] = ((__in[inpos++] & 255) | ((__in[inpos++] & 255) << 8) | ((__in[inpos++] & 255) << 16) | ((__in[inpos++] & 255) << 24));
                    }
                };
                Md5Digest.f = function (x, y, z) {
                    return (z ^ (x & (y ^ z)));
                };
                Md5Digest.ff = function (a, b, c, d, x, s, ac) {
                    a += x + ac + Md5Digest.f(b, c, d);
                    a = (a << s | a >>> -s);
                    return a + b;
                };
                Md5Digest.g = function (x, y, z) {
                    return (y ^ (z & (x ^ y)));
                };
                Md5Digest.gg = function (a, b, c, d, x, s, ac) {
                    a += x + ac + Md5Digest.g(b, c, d);
                    a = (a << s | a >>> -s);
                    return a + b;
                };
                Md5Digest.h = function (x, y, z) {
                    return (x ^ y ^ z);
                };
                Md5Digest.hh = function (a, b, c, d, x, s, ac) {
                    a += x + ac + Md5Digest.h(b, c, d);
                    a = (a << s | a >>> -s);
                    return a + b;
                };
                Md5Digest.i = function (x, y, z) {
                    return (y ^ (x | ~z));
                };
                Md5Digest.ii = function (a, b, c, d, x, s, ac) {
                    a += x + ac + Md5Digest.i(b, c, d);
                    a = (a << s | a >>> -s);
                    return a + b;
                };
                /**
                 * Converts a 4-int array into a 16-byte array.
                 *
                 * @param in An int[].
                 * @param out A byte[].
                 */
                Md5Digest.int2byte = function (__in, out) {
                    for (var inpos = 0, outpos = 0; inpos < 4; inpos++) {
                        out[outpos++] = ((__in[inpos] & 255) | 0);
                        out[outpos++] = (((__in[inpos] >>> 8) & 255) | 0);
                        out[outpos++] = (((__in[inpos] >>> 16) & 255) | 0);
                        out[outpos++] = (((__in[inpos] >>> 24) & 255) | 0);
                    }
                };
                Md5Digest.prototype.engineDigest$ = function () {
                    var bits = Md5Digest.toBytes(this.counter << 3);
                    var digest = new Array(16);
                    if (this.remainder > 8) {
                        this.engineUpdate(Md5Digest.padding_$LI$(), 0, this.remainder - 8);
                    }
                    else {
                        this.engineUpdate(Md5Digest.padding_$LI$(), 0, 64 + (this.remainder - 8));
                    }
                    this.engineUpdate(bits, 0, 8);
                    Md5Digest.int2byte(this.state, digest);
                    this.reset();
                    return digest;
                };
                Md5Digest.prototype.engineGetDigestLength = function () {
                    return 16;
                };
                Md5Digest.prototype.engineReset = function () {
                    this.buffer = new Array(64);
                    this.state = new Array(4);
                    this.x = new Array(16);
                    this.state[0] = 1732584193;
                    this.state[1] = -271733879;
                    this.state[2] = -1732584194;
                    this.state[3] = 271733878;
                    this.counter = 0;
                    this.remainder = 64;
                };
                Md5Digest.prototype.engineUpdate$byte = function (input) {
                    this.oneByte[0] = input;
                    this.engineUpdate(this.oneByte, 0, 1);
                };
                Md5Digest.prototype.engineUpdate = function (input, offset, len) {
                    var _this = this;
                    if (((input != null && input instanceof Array) || input === null) && ((typeof offset === 'number') || offset === null) && ((typeof len === 'number') || len === null)) {
                        return (function () {
                            while ((true)) {
                                if (len >= _this.remainder) {
                                    java.lang.System.arraycopy(input, offset, _this.buffer, ((_this.counter & 63) | 0), _this.remainder);
                                    _this.transform(_this.buffer);
                                    _this.counter += _this.remainder;
                                    offset += _this.remainder;
                                    len -= _this.remainder;
                                    _this.remainder = 64;
                                }
                                else {
                                    java.lang.System.arraycopy(input, offset, _this.buffer, ((_this.counter & 63) | 0), len);
                                    _this.counter += len;
                                    _this.remainder -= len;
                                    break;
                                }
                            }
                            ;
                        })();
                    }
                    else if (((typeof input === 'number') || input === null) && offset === undefined && len === undefined) {
                        return this.engineUpdate$byte(input);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Md5Digest.prototype.transform = function (buffer) {
                    var a;
                    var b;
                    var c;
                    var d;
                    Md5Digest.byte2int(buffer, this.x);
                    a = this.state[0];
                    b = this.state[1];
                    c = this.state[2];
                    d = this.state[3];
                    a = Md5Digest.ff(a, b, c, d, this.x[0], 7, -680876936);
                    d = Md5Digest.ff(d, a, b, c, this.x[1], 12, -389564586);
                    c = Md5Digest.ff(c, d, a, b, this.x[2], 17, 606105819);
                    b = Md5Digest.ff(b, c, d, a, this.x[3], 22, -1044525330);
                    a = Md5Digest.ff(a, b, c, d, this.x[4], 7, -176418897);
                    d = Md5Digest.ff(d, a, b, c, this.x[5], 12, 1200080426);
                    c = Md5Digest.ff(c, d, a, b, this.x[6], 17, -1473231341);
                    b = Md5Digest.ff(b, c, d, a, this.x[7], 22, -45705983);
                    a = Md5Digest.ff(a, b, c, d, this.x[8], 7, 1770035416);
                    d = Md5Digest.ff(d, a, b, c, this.x[9], 12, -1958414417);
                    c = Md5Digest.ff(c, d, a, b, this.x[10], 17, -42063);
                    b = Md5Digest.ff(b, c, d, a, this.x[11], 22, -1990404162);
                    a = Md5Digest.ff(a, b, c, d, this.x[12], 7, 1804603682);
                    d = Md5Digest.ff(d, a, b, c, this.x[13], 12, -40341101);
                    c = Md5Digest.ff(c, d, a, b, this.x[14], 17, -1502002290);
                    b = Md5Digest.ff(b, c, d, a, this.x[15], 22, 1236535329);
                    a = Md5Digest.gg(a, b, c, d, this.x[1], 5, -165796510);
                    d = Md5Digest.gg(d, a, b, c, this.x[6], 9, -1069501632);
                    c = Md5Digest.gg(c, d, a, b, this.x[11], 14, 643717713);
                    b = Md5Digest.gg(b, c, d, a, this.x[0], 20, -373897302);
                    a = Md5Digest.gg(a, b, c, d, this.x[5], 5, -701558691);
                    d = Md5Digest.gg(d, a, b, c, this.x[10], 9, 38016083);
                    c = Md5Digest.gg(c, d, a, b, this.x[15], 14, -660478335);
                    b = Md5Digest.gg(b, c, d, a, this.x[4], 20, -405537848);
                    a = Md5Digest.gg(a, b, c, d, this.x[9], 5, 568446438);
                    d = Md5Digest.gg(d, a, b, c, this.x[14], 9, -1019803690);
                    c = Md5Digest.gg(c, d, a, b, this.x[3], 14, -187363961);
                    b = Md5Digest.gg(b, c, d, a, this.x[8], 20, 1163531501);
                    a = Md5Digest.gg(a, b, c, d, this.x[13], 5, -1444681467);
                    d = Md5Digest.gg(d, a, b, c, this.x[2], 9, -51403784);
                    c = Md5Digest.gg(c, d, a, b, this.x[7], 14, 1735328473);
                    b = Md5Digest.gg(b, c, d, a, this.x[12], 20, -1926607734);
                    a = Md5Digest.hh(a, b, c, d, this.x[5], 4, -378558);
                    d = Md5Digest.hh(d, a, b, c, this.x[8], 11, -2022574463);
                    c = Md5Digest.hh(c, d, a, b, this.x[11], 16, 1839030562);
                    b = Md5Digest.hh(b, c, d, a, this.x[14], 23, -35309556);
                    a = Md5Digest.hh(a, b, c, d, this.x[1], 4, -1530992060);
                    d = Md5Digest.hh(d, a, b, c, this.x[4], 11, 1272893353);
                    c = Md5Digest.hh(c, d, a, b, this.x[7], 16, -155497632);
                    b = Md5Digest.hh(b, c, d, a, this.x[10], 23, -1094730640);
                    a = Md5Digest.hh(a, b, c, d, this.x[13], 4, 681279174);
                    d = Md5Digest.hh(d, a, b, c, this.x[0], 11, -358537222);
                    c = Md5Digest.hh(c, d, a, b, this.x[3], 16, -722521979);
                    b = Md5Digest.hh(b, c, d, a, this.x[6], 23, 76029189);
                    a = Md5Digest.hh(a, b, c, d, this.x[9], 4, -640364487);
                    d = Md5Digest.hh(d, a, b, c, this.x[12], 11, -421815835);
                    c = Md5Digest.hh(c, d, a, b, this.x[15], 16, 530742520);
                    b = Md5Digest.hh(b, c, d, a, this.x[2], 23, -995338651);
                    a = Md5Digest.ii(a, b, c, d, this.x[0], 6, -198630844);
                    d = Md5Digest.ii(d, a, b, c, this.x[7], 10, 1126891415);
                    c = Md5Digest.ii(c, d, a, b, this.x[14], 15, -1416354905);
                    b = Md5Digest.ii(b, c, d, a, this.x[5], 21, -57434055);
                    a = Md5Digest.ii(a, b, c, d, this.x[12], 6, 1700485571);
                    d = Md5Digest.ii(d, a, b, c, this.x[3], 10, -1894986606);
                    c = Md5Digest.ii(c, d, a, b, this.x[10], 15, -1051523);
                    b = Md5Digest.ii(b, c, d, a, this.x[1], 21, -2054922799);
                    a = Md5Digest.ii(a, b, c, d, this.x[8], 6, 1873313359);
                    d = Md5Digest.ii(d, a, b, c, this.x[15], 10, -30611744);
                    c = Md5Digest.ii(c, d, a, b, this.x[6], 15, -1560198380);
                    b = Md5Digest.ii(b, c, d, a, this.x[13], 21, 1309151649);
                    a = Md5Digest.ii(a, b, c, d, this.x[4], 6, -145523070);
                    d = Md5Digest.ii(d, a, b, c, this.x[11], 10, -1120210379);
                    c = Md5Digest.ii(c, d, a, b, this.x[2], 15, 718787259);
                    b = Md5Digest.ii(b, c, d, a, this.x[9], 21, -343485551);
                    this.state[0] = javaemul.internal.Coercions.ensureInt(this.state[0] + a);
                    this.state[1] = javaemul.internal.Coercions.ensureInt(this.state[1] + b);
                    this.state[2] = javaemul.internal.Coercions.ensureInt(this.state[2] + c);
                    this.state[3] = javaemul.internal.Coercions.ensureInt(this.state[3] + d);
                };
                return Md5Digest;
            }(java.security.MessageDigest));
            MessageDigest.Md5Digest = Md5Digest;
        })(MessageDigest = security.MessageDigest || (security.MessageDigest = {}));
    })(security = java.security || (java.security = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * Skeletal implementation of the List interface. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractList.html">[Sun
         * docs]</a>
         *
         * @param <E> the element type.
         */
        var AbstractList = (function (_super) {
            __extends(AbstractList, _super);
            function AbstractList() {
                _super.call(this);
                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.List", "java.util.Collection", "java.lang.Iterable"] });
                this.modCount = 0;
            }
            AbstractList.prototype.forEach = function (action) {
                javaemul.internal.InternalPreconditions.checkNotNull(action);
                for (var index131 = this.iterator(); index131.hasNext();) {
                    var t = index131.next();
                    {
                        action(t);
                    }
                }
            };
            AbstractList.prototype.add$java_lang_Object = function (obj) {
                this.add(this.size(), obj);
                return true;
            };
            AbstractList.prototype.add = function (index, element) {
                if (((typeof index === 'number') || index === null) && ((element != null) || element === null)) {
                    return (function () {
                        throw new java.lang.UnsupportedOperationException("Add not supported on this list");
                    })();
                }
                else if (((index != null) || index === null) && element === undefined) {
                    return this.add$java_lang_Object(index);
                }
                else
                    throw new Error('invalid overload');
            };
            AbstractList.prototype.addAll = function (index, c) {
                var _this = this;
                if (((typeof index === 'number') || index === null) && ((c != null && c["__interfaces"] != null && c["__interfaces"].indexOf("java.util.Collection") >= 0) || c === null)) {
                    return (function () {
                        javaemul.internal.InternalPreconditions.checkNotNull(c);
                        var changed = false;
                        for (var index132 = c.iterator(); index132.hasNext();) {
                            var e = index132.next();
                            {
                                _this.add(index++, e);
                                changed = true;
                            }
                        }
                        return changed;
                    })();
                }
                else if (((index != null && index["__interfaces"] != null && index["__interfaces"].indexOf("java.util.Collection") >= 0) || index === null) && c === undefined) {
                    return this.addAll$java_util_Collection(index);
                }
                else
                    throw new Error('invalid overload');
            };
            AbstractList.prototype.clear = function () {
                this.removeRange(0, this.size());
            };
            AbstractList.prototype.equals = function (o) {
                if (o === this) {
                    return true;
                }
                if (!(o != null && o["__interfaces"] != null && o["__interfaces"].indexOf("java.util.List") >= 0)) {
                    return false;
                }
                var other = o;
                if (this.size() !== other.size()) {
                    return false;
                }
                var iterOther = other.iterator();
                for (var index133 = this.iterator(); index133.hasNext();) {
                    var elem = index133.next();
                    {
                        var elemOther = iterOther.next();
                        if (!java.util.Objects.equals(elem, elemOther)) {
                            return false;
                        }
                    }
                }
                return true;
            };
            AbstractList.prototype.hashCode = function () {
                return java.util.Collections.hashCode(this);
            };
            AbstractList.prototype.indexOf = function (o, index) {
                if (((o != null) || o === null) && index === undefined) {
                    return this.indexOf$java_lang_Object(o);
                }
                else
                    throw new Error('invalid overload');
            };
            AbstractList.prototype.indexOf$java_lang_Object = function (toFind) {
                for (var i = 0, n = this.size(); i < n; ++i) {
                    if (java.util.Objects.equals(toFind, this.get(i))) {
                        return i;
                    }
                }
                return -1;
            };
            AbstractList.prototype.iterator = function () {
                return new AbstractList.IteratorImpl(this);
            };
            AbstractList.prototype.lastIndexOf = function (o, index) {
                if (((o != null) || o === null) && index === undefined) {
                    return this.lastIndexOf$java_lang_Object(o);
                }
                else
                    throw new Error('invalid overload');
            };
            AbstractList.prototype.lastIndexOf$java_lang_Object = function (toFind) {
                for (var i = this.size() - 1; i > -1; --i) {
                    if (java.util.Objects.equals(toFind, this.get(i))) {
                        return i;
                    }
                }
                return -1;
            };
            AbstractList.prototype.listIterator$ = function () {
                return this.listIterator(0);
            };
            AbstractList.prototype.listIterator = function (from) {
                var _this = this;
                if (((typeof from === 'number') || from === null)) {
                    return (function () {
                        return new AbstractList.ListIteratorImpl(_this, from);
                    })();
                }
                else if (from === undefined) {
                    return this.listIterator$();
                }
                else
                    throw new Error('invalid overload');
            };
            AbstractList.prototype.remove = function (index) {
                if (((typeof index === 'number') || index === null)) {
                    return (function () {
                        throw new java.lang.UnsupportedOperationException("Remove not supported on this list");
                    })();
                }
                else if (((index != null) || index === null)) {
                    return this.remove$java_lang_Object(index);
                }
                else
                    throw new Error('invalid overload');
            };
            AbstractList.prototype.set = function (index, o) {
                throw new java.lang.UnsupportedOperationException("Set not supported on this list");
            };
            AbstractList.prototype.subList = function (fromIndex, toIndex) {
                return new AbstractList.SubList(this, fromIndex, toIndex);
            };
            AbstractList.prototype.removeRange = function (fromIndex, endIndex) {
                var iter = this.listIterator(fromIndex);
                for (var i = fromIndex; i < endIndex; ++i) {
                    iter.next();
                    iter.remove();
                }
            };
            return AbstractList;
        }(java.util.AbstractCollection));
        util.AbstractList = AbstractList;
        var AbstractList;
        (function (AbstractList) {
            var IteratorImpl = (function () {
                function IteratorImpl(__parent) {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Iterator"] });
                    this.__parent = __parent;
                    this.i = 0;
                    this.last = 0;
                    this.i = 0;
                    this.last = -1;
                }
                IteratorImpl.prototype.forEachRemaining = function (consumer) {
                    javaemul.internal.InternalPreconditions.checkNotNull(consumer);
                    while ((this.hasNext())) {
                        consumer(this.next());
                    }
                    ;
                };
                IteratorImpl.prototype.hasNext = function () {
                    return this.i < this.__parent.size();
                };
                IteratorImpl.prototype.next = function () {
                    javaemul.internal.InternalPreconditions.checkElement(this.hasNext());
                    return this.__parent.get(this.last = this.i++);
                };
                IteratorImpl.prototype.remove = function () {
                    javaemul.internal.InternalPreconditions.checkState(this.last !== -1);
                    this.__parent.remove(this.last);
                    this.i = this.last;
                    this.last = -1;
                };
                return IteratorImpl;
            }());
            AbstractList.IteratorImpl = IteratorImpl;
            /**
             * Implementation of <code>ListIterator</code> for abstract lists.
             */
            var ListIteratorImpl = (function (_super) {
                __extends(ListIteratorImpl, _super);
                function ListIteratorImpl(__parent, start) {
                    var _this = this;
                    if (((typeof start === 'number') || start === null)) {
                        _super.call(this, __parent);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Iterator", "java.util.ListIterator"] });
                        this.__parent = __parent;
                        (function () {
                            javaemul.internal.InternalPreconditions.checkPositionIndex(start, _this.__parent.size());
                            _this.i = start;
                        })();
                    }
                    else if (start === undefined) {
                        _super.call(this, __parent);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Iterator", "java.util.ListIterator"] });
                        this.__parent = __parent;
                        (function () {
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                }
                ListIteratorImpl.prototype.forEachRemaining = function (consumer) {
                    javaemul.internal.InternalPreconditions.checkNotNull(consumer);
                    while ((this.hasNext())) {
                        consumer(this.next());
                    }
                    ;
                };
                ListIteratorImpl.prototype.add = function (o) {
                    this.__parent.add(this.i, o);
                    this.i++;
                    this.last = -1;
                };
                ListIteratorImpl.prototype.hasPrevious = function () {
                    return this.i > 0;
                };
                ListIteratorImpl.prototype.nextIndex = function () {
                    return this.i;
                };
                ListIteratorImpl.prototype.previous = function () {
                    javaemul.internal.InternalPreconditions.checkElement(this.hasPrevious());
                    return this.__parent.get(this.last = --this.i);
                };
                ListIteratorImpl.prototype.previousIndex = function () {
                    return this.i - 1;
                };
                ListIteratorImpl.prototype.set = function (o) {
                    javaemul.internal.InternalPreconditions.checkState(this.last !== -1);
                    this.__parent.set(this.last, o);
                };
                return ListIteratorImpl;
            }(AbstractList.IteratorImpl));
            AbstractList.ListIteratorImpl = ListIteratorImpl;
            var SubList = (function (_super) {
                __extends(SubList, _super);
                function SubList(wrapped, fromIndex, toIndex) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.List", "java.util.Collection", "java.lang.Iterable"] });
                    this.fromIndex = 0;
                    this.__size = 0;
                    javaemul.internal.InternalPreconditions.checkCriticalPositionIndexes(fromIndex, toIndex, wrapped.size());
                    this.wrapped = wrapped;
                    this.fromIndex = fromIndex;
                    this.__size = toIndex - fromIndex;
                }
                SubList.prototype.add = function (index, element) {
                    var _this = this;
                    if (((typeof index === 'number') || index === null) && ((element != null) || element === null)) {
                        return (function () {
                            javaemul.internal.InternalPreconditions.checkPositionIndex(index, _this.__size);
                            _this.wrapped.add(_this.fromIndex + index, element);
                            _this.__size++;
                        })();
                    }
                    else if (((index != null) || index === null) && element === undefined) {
                        return this.add$java_lang_Object(index);
                    }
                    else
                        throw new Error('invalid overload');
                };
                SubList.prototype.get = function (index) {
                    javaemul.internal.InternalPreconditions.checkElementIndex(index, this.__size);
                    return this.wrapped.get(this.fromIndex + index);
                };
                SubList.prototype.remove = function (index) {
                    var _this = this;
                    if (((typeof index === 'number') || index === null)) {
                        return (function () {
                            javaemul.internal.InternalPreconditions.checkElementIndex(index, _this.__size);
                            var result = _this.wrapped.remove(_this.fromIndex + index);
                            _this.__size--;
                            return result;
                        })();
                    }
                    else if (((index != null) || index === null)) {
                        return this.remove$java_lang_Object(index);
                    }
                    else
                        throw new Error('invalid overload');
                };
                SubList.prototype.set = function (index, element) {
                    javaemul.internal.InternalPreconditions.checkElementIndex(index, this.__size);
                    return this.wrapped.set(this.fromIndex + index, element);
                };
                SubList.prototype.size = function () {
                    return this.__size;
                };
                return SubList;
            }(java.util.AbstractList));
            AbstractList.SubList = SubList;
        })(AbstractList = util.AbstractList || (util.AbstractList = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * Skeletal implementation of the Queue interface. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractQueue.html">[Sun
         * docs]</a>
         *
         * @param <E> element type.
         */
        var AbstractQueue = (function (_super) {
            __extends(AbstractQueue, _super);
            function AbstractQueue() {
                _super.call(this);
                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Collection", "java.util.Queue", "java.lang.Iterable"] });
            }
            AbstractQueue.prototype.forEach = function (action) {
                javaemul.internal.InternalPreconditions.checkNotNull(action);
                for (var index134 = this.iterator(); index134.hasNext();) {
                    var t = index134.next();
                    {
                        action(t);
                    }
                }
            };
            AbstractQueue.prototype.add = function (index, element) {
                if (((index != null) || index === null) && element === undefined) {
                    return this.add$java_lang_Object(index);
                }
                else
                    throw new Error('invalid overload');
            };
            AbstractQueue.prototype.add$java_lang_Object = function (o) {
                javaemul.internal.InternalPreconditions.checkState(this.offer(o), "Unable to add element to queue");
                return true;
            };
            AbstractQueue.prototype.addAll = function (index, c) {
                if (((index != null && index["__interfaces"] != null && index["__interfaces"].indexOf("java.util.Collection") >= 0) || index === null) && c === undefined) {
                    return this.addAll$java_util_Collection(index);
                }
                else
                    throw new Error('invalid overload');
            };
            AbstractQueue.prototype.addAll$java_util_Collection = function (c) {
                javaemul.internal.InternalPreconditions.checkNotNull(c);
                javaemul.internal.InternalPreconditions.checkArgument(c !== this, "Can\'t add a queue to itself");
                return _super.prototype.addAll.call(this, c);
            };
            AbstractQueue.prototype.clear = function () {
                while ((this.poll() != null)) {
                }
                ;
            };
            AbstractQueue.prototype.element = function () {
                var e = this.peek();
                javaemul.internal.InternalPreconditions.checkElement(e != null, "Queue is empty");
                return e;
            };
            AbstractQueue.prototype.remove = function (index) {
                if (((index != null) || index === null)) {
                    return this.remove$java_lang_Object(index);
                }
                else if (index === undefined) {
                    return this.remove$();
                }
                else
                    throw new Error('invalid overload');
            };
            AbstractQueue.prototype.remove$ = function () {
                var e = this.poll();
                javaemul.internal.InternalPreconditions.checkElement(e != null, "Queue is empty");
                return e;
            };
            return AbstractQueue;
        }(java.util.AbstractCollection));
        util.AbstractQueue = AbstractQueue;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * Skeletal implementation of the Set interface. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractSet.html">[Sun
         * docs]</a>
         *
         * @param <E> the element type.
         */
        var AbstractSet = (function (_super) {
            __extends(AbstractSet, _super);
            function AbstractSet() {
                _super.call(this);
                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Collection", "java.util.Set", "java.lang.Iterable"] });
            }
            AbstractSet.prototype.forEach = function (action) {
                javaemul.internal.InternalPreconditions.checkNotNull(action);
                for (var index135 = this.iterator(); index135.hasNext();) {
                    var t = index135.next();
                    {
                        action(t);
                    }
                }
            };
            AbstractSet.prototype.equals = function (o) {
                if (o === this) {
                    return true;
                }
                if (!(o != null && o["__interfaces"] != null && o["__interfaces"].indexOf("java.util.Set") >= 0)) {
                    return false;
                }
                var other = o;
                if (other.size() !== this.size()) {
                    return false;
                }
                return this.containsAll(other);
            };
            AbstractSet.prototype.hashCode = function () {
                return java.util.Collections.hashCode(this);
            };
            AbstractSet.prototype.removeAll = function (c) {
                javaemul.internal.InternalPreconditions.checkNotNull(c);
                var size = this.size();
                if (size < c.size()) {
                    for (var iter = this.iterator(); iter.hasNext();) {
                        var o = iter.next();
                        if (c.contains(o)) {
                            iter.remove();
                        }
                    }
                }
                else {
                    for (var index136 = c.iterator(); index136.hasNext();) {
                        var o1 = index136.next();
                        {
                            this.remove(o1);
                        }
                    }
                }
                return (size !== this.size());
            };
            return AbstractSet;
        }(java.util.AbstractCollection));
        util.AbstractSet = AbstractSet;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * A simple wrapper around JavaScript Map for key type is string.
         */
        var InternalStringMap = (function () {
            function InternalStringMap(host) {
                this.backingMap = java.util.InternalJsMapFactory.newJsMap();
                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Iterable"] });
                this.size = 0;
                this.valueMod = 0;
                this.host = host;
            }
            InternalStringMap.prototype.forEach = function (action) {
                javaemul.internal.InternalPreconditions.checkNotNull(action);
                for (var index137 = this.iterator(); index137.hasNext();) {
                    var t = index137.next();
                    {
                        action(t);
                    }
                }
            };
            InternalStringMap.prototype.contains = function (key) {
                return !javaemul.internal.JsUtils.isUndefined(this.backingMap.get(key));
            };
            InternalStringMap.prototype.get = function (key) {
                return this.backingMap.get(key);
            };
            InternalStringMap.prototype.put = function (key, value) {
                var oldValue = this.backingMap.get(key);
                this.backingMap.set(key, InternalStringMap.toNullIfUndefined(value));
                if (javaemul.internal.JsUtils.isUndefined(oldValue)) {
                    this.size++;
                    java.util.ConcurrentModificationDetector.structureChanged(this.host);
                }
                else {
                    this.valueMod++;
                }
                return oldValue;
            };
            InternalStringMap.prototype.remove = function (key) {
                var value = this.backingMap.get(key);
                if (!javaemul.internal.JsUtils.isUndefined(value)) {
                    this.backingMap.delete(key);
                    this.size--;
                    java.util.ConcurrentModificationDetector.structureChanged(this.host);
                }
                else {
                    this.valueMod++;
                }
                return value;
            };
            InternalStringMap.prototype.getSize = function () {
                return this.size;
            };
            InternalStringMap.prototype.iterator = function () {
                return new InternalStringMap.InternalStringMap$0(this);
            };
            InternalStringMap.prototype.newMapEntry = function (entry, lastValueMod) {
                return new InternalStringMap.InternalStringMap$1(this, entry, lastValueMod);
            };
            InternalStringMap.toNullIfUndefined = function (value) {
                return javaemul.internal.JsUtils.isUndefined(value) ? null : value;
            };
            return InternalStringMap;
        }());
        util.InternalStringMap = InternalStringMap;
        var InternalStringMap;
        (function (InternalStringMap) {
            var InternalStringMap$0 = (function () {
                function InternalStringMap$0(__parent) {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Iterator"] });
                    this.__parent = __parent;
                    this.entries = this.__parent.backingMap.entries();
                    this.current = this.entries.next();
                }
                InternalStringMap$0.prototype.forEachRemaining = function (consumer) {
                    javaemul.internal.InternalPreconditions.checkNotNull(consumer);
                    while ((this.hasNext())) {
                        consumer(this.next());
                    }
                    ;
                };
                InternalStringMap$0.prototype.hasNext = function () {
                    return !this.current.done;
                };
                InternalStringMap$0.prototype.next = function () {
                    this.last = this.current;
                    this.current = this.entries.next();
                    return this.__parent.newMapEntry(this.last, this.__parent.valueMod);
                };
                InternalStringMap$0.prototype.remove = function () {
                    this.__parent.remove(this.last.value[0]);
                };
                return InternalStringMap$0;
            }());
            InternalStringMap.InternalStringMap$0 = InternalStringMap$0;
            var InternalStringMap$1 = (function (_super) {
                __extends(InternalStringMap$1, _super);
                function InternalStringMap$1(__parent, entry, lastValueMod) {
                    _super.call(this);
                    this.entry = entry;
                    this.lastValueMod = lastValueMod;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Map.Entry"] });
                    this.__parent = __parent;
                }
                InternalStringMap$1.prototype.getKey = function () {
                    return this.entry.value[0];
                };
                InternalStringMap$1.prototype.getValue = function () {
                    if (this.__parent.valueMod !== this.lastValueMod) {
                        return this.__parent.get(this.entry.value[0]);
                    }
                    return this.entry.value[1];
                };
                InternalStringMap$1.prototype.setValue = function (object) {
                    return this.__parent.put(this.entry.value[0], object);
                };
                return InternalStringMap$1;
            }(java.util.AbstractMapEntry));
            InternalStringMap.InternalStringMap$1 = InternalStringMap$1;
        })(InternalStringMap = util.InternalStringMap || (util.InternalStringMap = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var javaemul;
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Intrinsic string class.
         */
        var StringHelper = (function () {
            function StringHelper() {
            }
            StringHelper.CASE_INSENSITIVE_ORDER_$LI$ = function () { if (StringHelper.CASE_INSENSITIVE_ORDER == null)
                StringHelper.CASE_INSENSITIVE_ORDER = new StringHelper.StringHelper$0(); return StringHelper.CASE_INSENSITIVE_ORDER; };
            ;
            StringHelper.copyValueOf$char_A = function (v) {
                return StringHelper.valueOf(v);
            };
            StringHelper.copyValueOf = function (v, offset, count) {
                if (((v != null && v instanceof Array) || v === null) && ((typeof offset === 'number') || offset === null) && ((typeof count === 'number') || count === null)) {
                    return (function () {
                        return StringHelper.valueOf(v, offset, count);
                    })();
                }
                else if (((v != null && v instanceof Array) || v === null) && offset === undefined && count === undefined) {
                    return javaemul.internal.StringHelper.copyValueOf$char_A(v);
                }
                else
                    throw new Error('invalid overload');
            };
            StringHelper.valueOf$boolean = function (x) {
                return "" + x;
            };
            StringHelper.valueOf$char = function (x) {
                return "" + x;
            };
            StringHelper.valueOf = function (x, offset, count) {
                if (((x != null && x instanceof Array) || x === null) && ((typeof offset === 'number') || offset === null) && ((typeof count === 'number') || count === null)) {
                    return (function () {
                        var end = offset + count;
                        javaemul.internal.InternalPreconditions.checkStringBounds(offset, end, x.length);
                        var batchSize = javaemul.internal.ArrayHelper.ARRAY_PROCESS_BATCH_SIZE;
                        var s = "";
                        for (var batchStart = offset; batchStart < end;) {
                            var batchEnd = Math.min(batchStart + batchSize, end);
                            s += StringHelper.fromCharCode(javaemul.internal.ArrayHelper.unsafeClone(x, batchStart, batchEnd));
                            batchStart = batchEnd;
                        }
                        return s;
                    })();
                }
                else if (((x != null && x instanceof Array) || x === null) && offset === undefined && count === undefined) {
                    return javaemul.internal.StringHelper.valueOf$char_A(x);
                }
                else if (((typeof x === 'boolean') || x === null) && offset === undefined && count === undefined) {
                    return javaemul.internal.StringHelper.valueOf$boolean(x);
                }
                else if (((typeof x === 'string') || x === null) && offset === undefined && count === undefined) {
                    return javaemul.internal.StringHelper.valueOf$char(x);
                }
                else if (((typeof x === 'number') || x === null) && offset === undefined && count === undefined) {
                    return javaemul.internal.StringHelper.valueOf$int(x);
                }
                else if (((typeof x === 'number') || x === null) && offset === undefined && count === undefined) {
                    return javaemul.internal.StringHelper.valueOf$long(x);
                }
                else if (((typeof x === 'number') || x === null) && offset === undefined && count === undefined) {
                    return javaemul.internal.StringHelper.valueOf$float(x);
                }
                else if (((typeof x === 'number') || x === null) && offset === undefined && count === undefined) {
                    return javaemul.internal.StringHelper.valueOf$double(x);
                }
                else if (((x != null) || x === null) && offset === undefined && count === undefined) {
                    return javaemul.internal.StringHelper.valueOf$java_lang_Object(x);
                }
                else
                    throw new Error('invalid overload');
            };
            StringHelper.fromCharCode = function (array) {
                return String.fromCharCode(array);
            };
            StringHelper.valueOf$char_A = function (x) {
                return StringHelper.valueOf(x, 0, x.length);
            };
            StringHelper.valueOf$double = function (x) {
                return "" + x;
            };
            StringHelper.valueOf$float = function (x) {
                return "" + x;
            };
            StringHelper.valueOf$int = function (x) {
                return "" + x;
            };
            StringHelper.valueOf$long = function (x) {
                return "" + x;
            };
            StringHelper.valueOf$java_lang_Object = function (x) {
                return x == null ? "null" : x.toString();
            };
            /**
             * This method converts Java-escaped dollar signs "\$" into
             * JavaScript-escaped dollar signs "$$", and removes all other lone
             * backslashes, which serve as escapes in Java but are passed through
             * literally in JavaScript.
             *
             * @skip
             */
            StringHelper.translateReplaceString = function (replaceStr) {
                var pos = 0;
                while ((0 <= (pos = replaceStr.indexOf("\\", pos)))) {
                    if (replaceStr.charAt(pos + 1) === '$') {
                        replaceStr = replaceStr.substring(0, pos) + "$" + replaceStr.substring(++pos);
                    }
                    else {
                        replaceStr = replaceStr.substring(0, pos) + replaceStr.substring(++pos);
                    }
                }
                ;
                return replaceStr;
            };
            StringHelper.compareTo = function (thisStr, otherStr) {
                if (thisStr == otherStr) {
                    return 0;
                }
                return thisStr < otherStr ? -1 : 1;
            };
            StringHelper.getCharset = function (charsetName) {
                try {
                    return java.nio.charset.Charset.forName(charsetName);
                }
                catch (e) {
                    throw new java.io.UnsupportedEncodingException(charsetName);
                }
                ;
            };
            StringHelper.fromCodePoint = function (codePoint) {
                if (codePoint >= javaemul.internal.CharacterHelper.MIN_SUPPLEMENTARY_CODE_POINT) {
                    var hiSurrogate = javaemul.internal.CharacterHelper.getHighSurrogate(codePoint);
                    var loSurrogate = javaemul.internal.CharacterHelper.getLowSurrogate(codePoint);
                    return new String(hiSurrogate).toString() + new String(loSurrogate).toString();
                }
                else {
                    return new String(String.fromCharCode(codePoint)).toString();
                }
            };
            StringHelper.format = function (formatString) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                return sprintf(formatString, args);
            };
            return StringHelper;
        }());
        internal.StringHelper = StringHelper;
        var StringHelper;
        (function (StringHelper) {
            var StringHelper$0 = (function () {
                function StringHelper$0() {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Comparator"] });
                }
                StringHelper$0.prototype.compare = function (a, b) {
                    return a.toUpperCase().localeCompare(b.toUpperCase());
                };
                return StringHelper$0;
            }());
            StringHelper.StringHelper$0 = StringHelper$0;
        })(StringHelper = internal.StringHelper || (internal.StringHelper = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var sql;
    (function (sql) {
        /**
         * An implementation of java.sql.Date. Derived from
         * http://java.sun.com/j2se/1.5.0/docs/api/java/sql/Date.html
         */
        var Date = (function (_super) {
            __extends(Date, _super);
            function Date(year, month, day) {
                if (((typeof year === 'number') || year === null) && ((typeof month === 'number') || month === null) && ((typeof day === 'number') || day === null)) {
                    _super.call(this, year, month, day);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.lang.Comparable", "java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (((typeof year === 'number') || year === null) && month === undefined && day === undefined) {
                    var date = year;
                    _super.call(this, date);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.lang.Comparable", "java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            Date.valueOf = function (s) {
                var split = s.split("-");
                if (split.length !== 3) {
                    throw new java.lang.IllegalArgumentException("Invalid escape format: " + s);
                }
                try {
                    var y = javaemul.internal.IntegerHelper.parseInt(split[0]) - 1900;
                    var m = javaemul.internal.IntegerHelper.parseInt(split[1]) - 1;
                    var d = javaemul.internal.IntegerHelper.parseInt(split[2]);
                    return new Date(y, m, d);
                }
                catch (e) {
                    throw new java.lang.IllegalArgumentException("Invalid escape format: " + s);
                }
                ;
            };
            Date.prototype.getHours = function () {
                throw new java.lang.IllegalArgumentException();
            };
            Date.prototype.getMinutes = function () {
                throw new java.lang.IllegalArgumentException();
            };
            Date.prototype.getSeconds = function () {
                throw new java.lang.IllegalArgumentException();
            };
            Date.prototype.setHours = function (i) {
                throw new java.lang.IllegalArgumentException();
            };
            Date.prototype.setMinutes = function (i) {
                throw new java.lang.IllegalArgumentException();
            };
            Date.prototype.setSeconds = function (i) {
                throw new java.lang.IllegalArgumentException();
            };
            return Date;
        }(java.util.Date));
        sql.Date = Date;
    })(sql = java.sql || (java.sql = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var sql;
    (function (sql) {
        /**
         * An implementation of java.sql.Time. Derived from
         * http://java.sun.com/j2se/1.5.0/docs/api/java/sql/Time.html
         */
        var Time = (function (_super) {
            __extends(Time, _super);
            function Time(hour, minute, second) {
                if (((typeof hour === 'number') || hour === null) && ((typeof minute === 'number') || minute === null) && ((typeof second === 'number') || second === null)) {
                    _super.call(this, 70, 0, 1, hour, minute, second);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.lang.Comparable", "java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (((typeof hour === 'number') || hour === null) && minute === undefined && second === undefined) {
                    var time = hour;
                    _super.call(this, time);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.lang.Comparable", "java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            Time.valueOf = function (s) {
                var split = s.split(":");
                if (split.length !== 3) {
                    throw new java.lang.IllegalArgumentException("Invalid escape format: " + s);
                }
                try {
                    var hh = javaemul.internal.IntegerHelper.parseInt(split[0]);
                    var mm = javaemul.internal.IntegerHelper.parseInt(split[1]);
                    var ss = javaemul.internal.IntegerHelper.parseInt(split[2]);
                    return new Time(hh, mm, ss);
                }
                catch (e) {
                    throw new java.lang.IllegalArgumentException("Invalid escape format: " + s);
                }
                ;
            };
            Time.prototype.getDate = function () {
                throw new java.lang.IllegalArgumentException();
            };
            Time.prototype.getDay = function () {
                throw new java.lang.IllegalArgumentException();
            };
            Time.prototype.getMonth = function () {
                throw new java.lang.IllegalArgumentException();
            };
            Time.prototype.getYear = function () {
                throw new java.lang.IllegalArgumentException();
            };
            Time.prototype.setDate = function (i) {
                throw new java.lang.IllegalArgumentException();
            };
            Time.prototype.setMonth = function (i) {
                throw new java.lang.IllegalArgumentException();
            };
            Time.prototype.setYear = function (i) {
                throw new java.lang.IllegalArgumentException();
            };
            return Time;
        }(java.util.Date));
        sql.Time = Time;
    })(sql = java.sql || (java.sql = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var sql;
    (function (sql) {
        /**
         * An implementation of java.sql.Timestame. Derived from
         * http://java.sun.com/j2se/1.5.0/docs/api/java/sql/Timestamp.html. This is
         * basically just regular Date decorated with a nanoseconds field.
         */
        var Timestamp = (function (_super) {
            __extends(Timestamp, _super);
            function Timestamp(year, month, date, hour, minute, second, nano) {
                var _this = this;
                if (((typeof year === 'number') || year === null) && ((typeof month === 'number') || month === null) && ((typeof date === 'number') || date === null) && ((typeof hour === 'number') || hour === null) && ((typeof minute === 'number') || minute === null) && ((typeof second === 'number') || second === null) && ((typeof nano === 'number') || nano === null)) {
                    _super.call(this, year, month, date, hour, minute, second);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.lang.Comparable", "java.io.Serializable"] });
                    this.nanos = 0;
                    (function () {
                        _this.setNanos(nano);
                    })();
                }
                else if (((typeof year === 'number') || year === null) && month === undefined && date === undefined && hour === undefined && minute === undefined && second === undefined && nano === undefined) {
                    var time = year;
                    _super.call(this, time);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.lang.Comparable", "java.io.Serializable"] });
                    this.nanos = 0;
                    (function () {
                        _this.nanos = ((((time % 1000) | 0)) * 1000000);
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            Timestamp.valueOf = function (s) {
                var components = s.split(" ");
                if (components.length !== 2) {
                    throw new java.lang.IllegalArgumentException("Invalid escape format: " + s);
                }
                var timeComponents = components[1].split("\\.");
                var hasNanos = true;
                var nanos = 0;
                if (timeComponents.length === 1) {
                    hasNanos = false;
                }
                else if (timeComponents.length !== 2) {
                    throw new java.lang.IllegalArgumentException("Invalid escape format: " + s);
                }
                var d = java.sql.Date.valueOf(components[0]);
                var t = java.sql.Time.valueOf(timeComponents[0]);
                if (hasNanos) {
                    var nanosString = timeComponents[1];
                    var len = nanosString.length;
                    if (len > 9) {
                        throw new java.lang.IllegalArgumentException("Invalid escape format: " + s);
                    }
                    if (len < 9) {
                        nanosString += "00000000".substring(len - 1);
                    }
                    try {
                        nanos = javaemul.internal.IntegerHelper.valueOf(nanosString);
                    }
                    catch (e) {
                        throw new java.lang.IllegalArgumentException("Invalid escape format: " + s);
                    }
                    ;
                }
                return new Timestamp(d.getYear(), d.getMonth(), d.getDate(), t.getHours(), t.getMinutes(), t.getSeconds(), nanos);
            };
            Timestamp.padNine = function (value) {
                var toReturn = new java.lang.StringBuilder("000000000");
                var asString = new String(value).toString();
                toReturn = toReturn.replace(9 - asString.length, 9, asString);
                return toReturn.toString();
            };
            Timestamp.prototype.after = function (ts) {
                var _this = this;
                if (((ts != null && ts instanceof java.sql.Timestamp) || ts === null)) {
                    return (function () {
                        return (_this.getTime() > ts.getTime()) || (_this.getTime() === ts.getTime() && _this.getNanos() > ts.getNanos());
                    })();
                }
                else if (((ts != null && ts instanceof java.util.Date) || ts === null)) {
                    return this.after$java_util_Date(ts);
                }
                else
                    throw new Error('invalid overload');
            };
            Timestamp.prototype.before = function (ts) {
                var _this = this;
                if (((ts != null && ts instanceof java.sql.Timestamp) || ts === null)) {
                    return (function () {
                        return (_this.getTime() < ts.getTime()) || (_this.getTime() === ts.getTime() && _this.getNanos() < ts.getNanos());
                    })();
                }
                else if (((ts != null && ts instanceof java.util.Date) || ts === null)) {
                    return this.before$java_util_Date(ts);
                }
                else
                    throw new Error('invalid overload');
            };
            Timestamp.prototype.compareTo$java_util_Date = function (o) {
                if (o != null && o instanceof java.sql.Timestamp) {
                    return this.compareTo(o);
                }
                else {
                    return this.compareTo(new Timestamp(o.getTime()));
                }
            };
            Timestamp.prototype.compareTo = function (o) {
                var _this = this;
                if (((o != null && o instanceof java.sql.Timestamp) || o === null)) {
                    return (function () {
                        var cmp = javaemul.internal.LongHelper.compare(_this.getTime(), o.getTime());
                        return cmp === 0 ? javaemul.internal.IntegerHelper.compare(_this.getNanos(), o.getNanos()) : cmp;
                    })();
                }
                else if (((o != null && o instanceof java.util.Date) || o === null)) {
                    return this.compareTo$java_util_Date(o);
                }
                else
                    throw new Error('invalid overload');
            };
            Timestamp.prototype.equals$java_lang_Object = function (ts) {
                return (ts != null && ts instanceof java.sql.Timestamp) && this.equals(ts);
            };
            Timestamp.prototype.equals = function (ts) {
                var _this = this;
                if (((ts != null && ts instanceof java.sql.Timestamp) || ts === null)) {
                    return (function () {
                        return ts != null && _this.getTime() === ts.getTime() && _this.getNanos() === ts.getNanos();
                    })();
                }
                else if (((ts != null) || ts === null)) {
                    return this.equals$java_lang_Object(ts);
                }
                else
                    throw new Error('invalid overload');
            };
            Timestamp.prototype.getNanos = function () {
                return this.nanos;
            };
            Timestamp.prototype.getTime = function () {
                return _super.prototype.getTime.call(this);
            };
            Timestamp.prototype.hashCode = function () {
                return _super.prototype.hashCode.call(this);
            };
            Timestamp.prototype.setNanos = function (n) {
                if (n < 0 || n > 999999999) {
                    throw new java.lang.IllegalArgumentException("nanos out of range " + n);
                }
                this.nanos = n;
                _super.prototype.setTime.call(this, (Math.round(this.getTime() / 1000)) * 1000 + ((this.nanos / 1000000 | 0)));
            };
            Timestamp.prototype.setTime = function (time) {
                _super.prototype.setTime.call(this, time);
                this.nanos = ((((time % 1000) | 0)) * 1000000);
            };
            return Timestamp;
        }(java.util.Date));
        sql.Timestamp = Timestamp;
    })(sql = java.sql || (java.sql = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        var logging;
        (function (logging) {
            /**
             * A simple console logger used in super dev mode.
             */
            var SimpleConsoleLogHandler = (function (_super) {
                __extends(SimpleConsoleLogHandler, _super);
                function SimpleConsoleLogHandler() {
                    _super.apply(this, arguments);
                }
                SimpleConsoleLogHandler.prototype.publish = function (record) {
                    if (!this.isLoggable(record)) {
                        return;
                    }
                    var level = this.toConsoleLogLevel(record.getLevel());
                    console.log(level, record.getMessage());
                    if (record.getThrown() != null) {
                        console.log(level, record.getThrown());
                    }
                };
                SimpleConsoleLogHandler.prototype.toConsoleLogLevel = function (level) {
                    var val = level.intValue();
                    if (val >= java.util.logging.Level.SEVERE_$LI$().intValue()) {
                        return "error";
                    }
                    else if (val >= java.util.logging.Level.WARNING_$LI$().intValue()) {
                        return "warn";
                    }
                    else if (val >= java.util.logging.Level.INFO_$LI$().intValue()) {
                        return "info";
                    }
                    else {
                        return "log";
                    }
                };
                SimpleConsoleLogHandler.prototype.close = function () {
                };
                SimpleConsoleLogHandler.prototype.flush = function () {
                };
                return SimpleConsoleLogHandler;
            }(java.util.logging.Handler));
            logging.SimpleConsoleLogHandler = SimpleConsoleLogHandler;
        })(logging = util.logging || (util.logging = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var javaemul;
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Wraps native <code>byte</code> as an object.
         */
        var ByteHelper = (function (_super) {
            __extends(ByteHelper, _super);
            function ByteHelper(s) {
                var _this = this;
                if (((typeof s === 'string') || s === null)) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Comparable", "java.io.Serializable"] });
                    this.value = 0;
                    (function () {
                        _this.value = ByteHelper.parseByte(s);
                    })();
                }
                else if (((typeof s === 'number') || s === null)) {
                    var value = s;
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Comparable", "java.io.Serializable"] });
                    this.value = 0;
                    (function () {
                        _this.value = value;
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            ByteHelper.MIN_VALUE_$LI$ = function () { if (ByteHelper.MIN_VALUE == null)
                ByteHelper.MIN_VALUE = (128 | 0); return ByteHelper.MIN_VALUE; };
            ;
            ByteHelper.MAX_VALUE_$LI$ = function () { if (ByteHelper.MAX_VALUE == null)
                ByteHelper.MAX_VALUE = (127 | 0); return ByteHelper.MAX_VALUE; };
            ;
            ByteHelper.TYPE_$LI$ = function () { if (ByteHelper.TYPE == null)
                ByteHelper.TYPE = Number; return ByteHelper.TYPE; };
            ;
            ByteHelper.compare = function (x, y) {
                return x - y;
            };
            ByteHelper.decode = function (s) {
                return ByteHelper.valueOf((internal.NumberHelper.__decodeAndValidateInt(s, ByteHelper.MIN_VALUE_$LI$(), ByteHelper.MAX_VALUE_$LI$()) | 0));
            };
            /**
             * @skip
             *
             * Here for shared implementation with Arrays.hashCode
             */
            ByteHelper.hashCode = function (b) {
                return b;
            };
            ByteHelper.parseByte = function (s, radix) {
                if (radix === void 0) { radix = 10; }
                return (internal.NumberHelper.__parseAndValidateInt(s, radix, ByteHelper.MIN_VALUE_$LI$(), ByteHelper.MAX_VALUE_$LI$()) | 0);
            };
            ByteHelper.toString = function (b) {
                return new String(b).toString();
            };
            ByteHelper.valueOf$byte = function (b) {
                var rebase = b + 128;
                var result = ByteHelper.BoxedValues.boxedValues_$LI$()[rebase];
                if (result == null) {
                    result = ByteHelper.BoxedValues.boxedValues_$LI$()[rebase] = new ByteHelper(b);
                }
                return result;
            };
            ByteHelper.valueOf$java_lang_String = function (s) {
                return ByteHelper.valueOf(s, 10);
            };
            ByteHelper.valueOf = function (s, radix) {
                if (((typeof s === 'string') || s === null) && ((typeof radix === 'number') || radix === null)) {
                    return (function () {
                        return ByteHelper.valueOf(ByteHelper.parseByte(s, radix));
                    })();
                }
                else if (((typeof s === 'string') || s === null) && radix === undefined) {
                    return javaemul.internal.ByteHelper.valueOf$java_lang_String(s);
                }
                else if (((typeof s === 'number') || s === null) && radix === undefined) {
                    return javaemul.internal.ByteHelper.valueOf$byte(s);
                }
                else
                    throw new Error('invalid overload');
            };
            ByteHelper.prototype.byteValue = function () {
                return this.value;
            };
            ByteHelper.prototype.compareTo = function (b) {
                var _this = this;
                if (((b != null && b instanceof javaemul.internal.ByteHelper) || b === null)) {
                    return (function () {
                        return ByteHelper.compare(_this.value, b.value);
                    })();
                }
                else
                    throw new Error('invalid overload');
            };
            ByteHelper.prototype.doubleValue = function () {
                return this.value;
            };
            ByteHelper.prototype.equals = function (o) {
                return (o != null && o instanceof javaemul.internal.ByteHelper) && (o.value === this.value);
            };
            ByteHelper.prototype.floatValue = function () {
                return this.value;
            };
            ByteHelper.prototype.hashCode = function () {
                return ByteHelper.hashCode(this.value);
            };
            ByteHelper.prototype.intValue = function () {
                return this.value;
            };
            ByteHelper.prototype.longValue = function () {
                return this.value;
            };
            ByteHelper.prototype.shortValue = function () {
                return this.value;
            };
            ByteHelper.prototype.toString = function () {
                return ByteHelper.toString(this.value);
            };
            ByteHelper.SIZE = 8;
            return ByteHelper;
        }(javaemul.internal.NumberHelper));
        internal.ByteHelper = ByteHelper;
        var ByteHelper;
        (function (ByteHelper) {
            /**
             * Use nested class to avoid clinit on outer.
             */
            var BoxedValues = (function () {
                function BoxedValues() {
                }
                BoxedValues.boxedValues_$LI$ = function () { if (BoxedValues.boxedValues == null)
                    BoxedValues.boxedValues = new Array(256); return BoxedValues.boxedValues; };
                ;
                return BoxedValues;
            }());
            ByteHelper.BoxedValues = BoxedValues;
        })(ByteHelper = internal.ByteHelper || (internal.ByteHelper = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var javaemul;
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Wraps a primitive <code>double</code> as an object.
         */
        var DoubleHelper = (function (_super) {
            __extends(DoubleHelper, _super);
            function DoubleHelper(s) {
                if (((typeof s === 'string') || s === null)) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Comparable", "java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (((typeof s === 'number') || s === null)) {
                    var value = s;
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Comparable", "java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            DoubleHelper.NaN_$LI$ = function () { if (DoubleHelper.NaN == null)
                DoubleHelper.NaN = 0.0 / 0.0; return DoubleHelper.NaN; };
            ;
            DoubleHelper.NEGATIVE_INFINITY_$LI$ = function () { if (DoubleHelper.NEGATIVE_INFINITY == null)
                DoubleHelper.NEGATIVE_INFINITY = -1.0 / 0.0; return DoubleHelper.NEGATIVE_INFINITY; };
            ;
            DoubleHelper.POSITIVE_INFINITY_$LI$ = function () { if (DoubleHelper.POSITIVE_INFINITY == null)
                DoubleHelper.POSITIVE_INFINITY = 1.0 / 0.0; return DoubleHelper.POSITIVE_INFINITY; };
            ;
            DoubleHelper.compare = function (x, y) {
                if (x < y) {
                    return -1;
                }
                if (x > y) {
                    return 1;
                }
                if (x === y) {
                    return 0;
                }
                if (DoubleHelper.isNaN(x)) {
                    if (DoubleHelper.isNaN(y)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                else {
                    return -1;
                }
            };
            DoubleHelper.doubleToLongBits = function (value) {
                if (DoubleHelper.isNaN(value)) {
                    return 9221120237041090560;
                }
                var negative = false;
                if (value === 0.0) {
                    if (1.0 / value === DoubleHelper.NEGATIVE_INFINITY_$LI$()) {
                        return -9223372036854775808;
                    }
                    else {
                        return 0;
                    }
                }
                if (value < 0.0) {
                    negative = true;
                    value = -value;
                }
                if (DoubleHelper.isInfinite(value)) {
                    if (negative) {
                        return -4503599627370496;
                    }
                    else {
                        return 9218868437227405312;
                    }
                }
                var exp = 0;
                if (value < 1.0) {
                    var bit = 512;
                    for (var i = 0; i < 10; i++, bit >>= 1) {
                        if (value < DoubleHelper.PowersTable.invPowers_$LI$()[i] && exp - bit >= -1023) {
                            value *= DoubleHelper.PowersTable.powers_$LI$()[i];
                            exp -= bit;
                        }
                    }
                    if (value < 1.0 && exp - 1 >= -1023) {
                        value *= 2.0;
                        exp--;
                    }
                }
                else if (value >= 2.0) {
                    var bit = 512;
                    for (var i = 0; i < 10; i++, bit >>= 1) {
                        if (value >= DoubleHelper.PowersTable.powers_$LI$()[i]) {
                            value *= DoubleHelper.PowersTable.invPowers_$LI$()[i];
                            exp += bit;
                        }
                    }
                }
                if (exp > -1023) {
                    value -= 1.0;
                }
                else {
                    value *= 0.5;
                }
                var ihi = Math.round((value * DoubleHelper.POWER_20));
                value -= ihi * DoubleHelper.POWER_MINUS_20;
                var ilo = Math.round((value * DoubleHelper.POWER_52));
                ihi |= (exp + 1023) << 20;
                if (negative) {
                    ihi |= 2147483648;
                }
                return (ihi << 32) | ilo;
            };
            /**
             * @skip Here for shared implementation with Arrays.hashCode
             */
            DoubleHelper.hashCode = function (d) {
                return (d | 0);
            };
            DoubleHelper.isInfinite = function (x) {
                return x === javaemul.internal.JsUtils.getInfinity() || x === -javaemul.internal.JsUtils.getInfinity();
            };
            DoubleHelper.isNaN = function (x) {
                return isNaN(x);
            };
            DoubleHelper.longBitsToDouble = function (bits) {
                var ihi = Math.round((bits >> 32));
                var ilo = Math.round((bits & 4294967295));
                if (ihi < 0) {
                    ihi += 4294967296;
                }
                if (ilo < 0) {
                    ilo += 4294967296;
                }
                var negative = (ihi & -2147483648) !== 0;
                var exp = (((ihi >> 20) & 2047) | 0);
                ihi &= 1048575;
                if (exp === 0) {
                    var d = (ihi * DoubleHelper.POWER_MINUS_20) + (ilo * DoubleHelper.POWER_MINUS_52);
                    d *= DoubleHelper.POWER_MINUS_1022;
                    return negative ? (d === 0.0 ? -0.0 : -d) : d;
                }
                else if (exp === 2047) {
                    if (ihi === 0 && ilo === 0) {
                        return negative ? DoubleHelper.NEGATIVE_INFINITY_$LI$() : DoubleHelper.POSITIVE_INFINITY_$LI$();
                    }
                    else {
                        return DoubleHelper.NaN_$LI$();
                    }
                }
                exp -= 1023;
                var d = 1.0 + (ihi * DoubleHelper.POWER_MINUS_20) + (ilo * DoubleHelper.POWER_MINUS_52);
                if (exp > 0) {
                    var bit = 512;
                    for (var i = 0; i < 10; i++, bit >>= 1) {
                        if (exp >= bit) {
                            d *= DoubleHelper.PowersTable.powers_$LI$()[i];
                            exp -= bit;
                        }
                    }
                }
                else if (exp < 0) {
                    while ((exp < 0)) {
                        var bit = 512;
                        for (var i = 0; i < 10; i++, bit >>= 1) {
                            if (exp <= -bit) {
                                d *= DoubleHelper.PowersTable.invPowers_$LI$()[i];
                                exp += bit;
                            }
                        }
                    }
                    ;
                }
                return negative ? -d : d;
            };
            DoubleHelper.parseDouble = function (s) {
                return internal.NumberHelper.__parseAndValidateDouble(s);
            };
            DoubleHelper.toString = function (b) {
                return new String(b).toString();
            };
            DoubleHelper.valueOf$double = function (d) {
                return new DoubleHelper(d);
            };
            DoubleHelper.valueOf = function (s) {
                if (((typeof s === 'string') || s === null)) {
                    return (function () {
                        return new DoubleHelper(s);
                    })();
                }
                else if (((typeof s === 'number') || s === null)) {
                    return javaemul.internal.DoubleHelper.valueOf$double(s);
                }
                else
                    throw new Error('invalid overload');
            };
            DoubleHelper.prototype.byteValue = function () {
                return (this.doubleValue() | 0);
            };
            DoubleHelper.prototype.compareTo = function (b) {
                var _this = this;
                if (((b != null && b instanceof javaemul.internal.DoubleHelper) || b === null)) {
                    return (function () {
                        return DoubleHelper.compare(_this.doubleValue(), b.doubleValue());
                    })();
                }
                else
                    throw new Error('invalid overload');
            };
            DoubleHelper.prototype.doubleValue = function () {
                return DoubleHelper.unsafeCast(javaemul.internal.InternalPreconditions.checkNotNull(this));
            };
            DoubleHelper.unsafeCast = function (instance) {
                return instance;
            };
            DoubleHelper.prototype.equals = function (o) {
                return javaemul.internal.InternalPreconditions.checkNotNull(this) === o;
            };
            DoubleHelper.prototype.floatValue = function () {
                return this.doubleValue();
            };
            /**
             * Performance caution: using Double objects as map keys is not recommended.
             * Using double values as keys is generally a bad idea due to difficulty
             * determining exact equality. In addition, there is no efficient JavaScript
             * equivalent of <code>doubleToIntBits</code>. As a result, this method
             * computes a hash code by truncating the whole number portion of the
             * double, which may lead to poor performance for certain value sets if
             * Doubles are used as keys in a {@link java.util.HashMap}.
             */
            DoubleHelper.prototype.hashCode = function () {
                return DoubleHelper.hashCode(this.doubleValue());
            };
            DoubleHelper.prototype.intValue = function () {
                return (this.doubleValue() | 0);
            };
            DoubleHelper.prototype.isInfinite = function () {
                return DoubleHelper.isInfinite(this.doubleValue());
            };
            DoubleHelper.prototype.isNaN = function () {
                return DoubleHelper.isNaN(this.doubleValue());
            };
            DoubleHelper.prototype.longValue = function () {
                return Math.round(this.doubleValue());
            };
            DoubleHelper.prototype.shortValue = function () {
                return (this.doubleValue() | 0);
            };
            DoubleHelper.prototype.toString = function () {
                return DoubleHelper.toString(this.doubleValue());
            };
            DoubleHelper.MAX_VALUE = 1.7976931348623157E308;
            DoubleHelper.MIN_VALUE = 4.9E-324;
            DoubleHelper.MIN_NORMAL = 2.2250738585072014E-308;
            DoubleHelper.MAX_EXPONENT = 1023;
            DoubleHelper.MIN_EXPONENT = -1022;
            DoubleHelper.SIZE = 64;
            DoubleHelper.POWER_512 = 1.3407807929942597E154;
            DoubleHelper.POWER_MINUS_512 = 7.458340731200207E-155;
            DoubleHelper.POWER_256 = 1.157920892373162E77;
            DoubleHelper.POWER_MINUS_256 = 8.636168555094445E-78;
            DoubleHelper.POWER_128 = 3.4028236692093846E38;
            DoubleHelper.POWER_MINUS_128 = 2.9387358770557188E-39;
            DoubleHelper.POWER_64 = 1.8446744073709552E19;
            DoubleHelper.POWER_MINUS_64 = 5.421010862427522E-20;
            DoubleHelper.POWER_52 = 4.503599627370496E15;
            DoubleHelper.POWER_MINUS_52 = 2.220446049250313E-16;
            DoubleHelper.POWER_32 = 4.294967296E9;
            DoubleHelper.POWER_MINUS_32 = 2.3283064365386963E-10;
            DoubleHelper.POWER_31 = 2.147483648E9;
            DoubleHelper.POWER_20 = 1048576.0;
            DoubleHelper.POWER_MINUS_20 = 9.5367431640625E-7;
            DoubleHelper.POWER_16 = 65536.0;
            DoubleHelper.POWER_MINUS_16 = 1.52587890625E-5;
            DoubleHelper.POWER_8 = 256.0;
            DoubleHelper.POWER_MINUS_8 = 0.00390625;
            DoubleHelper.POWER_4 = 16.0;
            DoubleHelper.POWER_MINUS_4 = 0.0625;
            DoubleHelper.POWER_2 = 4.0;
            DoubleHelper.POWER_MINUS_2 = 0.25;
            DoubleHelper.POWER_1 = 2.0;
            DoubleHelper.POWER_MINUS_1 = 0.5;
            DoubleHelper.POWER_MINUS_1022 = 2.2250738585072014E-308;
            return DoubleHelper;
        }(javaemul.internal.NumberHelper));
        internal.DoubleHelper = DoubleHelper;
        var DoubleHelper;
        (function (DoubleHelper) {
            var PowersTable = (function () {
                function PowersTable() {
                }
                PowersTable.powers_$LI$ = function () { if (PowersTable.powers == null)
                    PowersTable.powers = [javaemul.internal.DoubleHelper.POWER_512, javaemul.internal.DoubleHelper.POWER_256, javaemul.internal.DoubleHelper.POWER_128, javaemul.internal.DoubleHelper.POWER_64, javaemul.internal.DoubleHelper.POWER_32, javaemul.internal.DoubleHelper.POWER_16, javaemul.internal.DoubleHelper.POWER_8, javaemul.internal.DoubleHelper.POWER_4, javaemul.internal.DoubleHelper.POWER_2, javaemul.internal.DoubleHelper.POWER_1]; return PowersTable.powers; };
                ;
                PowersTable.invPowers_$LI$ = function () { if (PowersTable.invPowers == null)
                    PowersTable.invPowers = [javaemul.internal.DoubleHelper.POWER_MINUS_512, javaemul.internal.DoubleHelper.POWER_MINUS_256, javaemul.internal.DoubleHelper.POWER_MINUS_128, javaemul.internal.DoubleHelper.POWER_MINUS_64, javaemul.internal.DoubleHelper.POWER_MINUS_32, javaemul.internal.DoubleHelper.POWER_MINUS_16, javaemul.internal.DoubleHelper.POWER_MINUS_8, javaemul.internal.DoubleHelper.POWER_MINUS_4, javaemul.internal.DoubleHelper.POWER_MINUS_2, javaemul.internal.DoubleHelper.POWER_MINUS_1]; return PowersTable.invPowers; };
                ;
                return PowersTable;
            }());
            DoubleHelper.PowersTable = PowersTable;
        })(DoubleHelper = internal.DoubleHelper || (internal.DoubleHelper = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var javaemul;
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Wraps a primitive <code>float</code> as an object.
         */
        var FloatHelper = (function (_super) {
            __extends(FloatHelper, _super);
            function FloatHelper(s) {
                var _this = this;
                if (((typeof s === 'string') || s === null)) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Comparable", "java.io.Serializable"] });
                    this.value = 0;
                    (function () {
                        _this.value = FloatHelper.parseFloat(s);
                    })();
                }
                else if (((typeof s === 'number') || s === null)) {
                    var value = s;
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Comparable", "java.io.Serializable"] });
                    this.value = 0;
                    (function () {
                        _this.value = value;
                    })();
                }
                else if (((typeof s === 'number') || s === null)) {
                    var value = s;
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Comparable", "java.io.Serializable"] });
                    this.value = 0;
                    (function () {
                        _this.value = value;
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            FloatHelper.NaN_$LI$ = function () { if (FloatHelper.NaN == null)
                FloatHelper.NaN = 0.0 / 0.0; return FloatHelper.NaN; };
            ;
            FloatHelper.NEGATIVE_INFINITY_$LI$ = function () { if (FloatHelper.NEGATIVE_INFINITY == null)
                FloatHelper.NEGATIVE_INFINITY = -1.0 / 0.0; return FloatHelper.NEGATIVE_INFINITY; };
            ;
            FloatHelper.POSITIVE_INFINITY_$LI$ = function () { if (FloatHelper.POSITIVE_INFINITY == null)
                FloatHelper.POSITIVE_INFINITY = 1.0 / 0.0; return FloatHelper.POSITIVE_INFINITY; };
            ;
            FloatHelper.compare = function (x, y) {
                return javaemul.internal.DoubleHelper.compare(x, y);
            };
            FloatHelper.floatToIntBits = function (value) {
                if (FloatHelper.isNaN(value)) {
                    return 2143289344;
                }
                if (value === 0.0) {
                    if (1.0 / value === FloatHelper.NEGATIVE_INFINITY_$LI$()) {
                        return -2147483648;
                    }
                    else {
                        return 0;
                    }
                }
                var negative = false;
                if (value < 0.0) {
                    negative = true;
                    value = -value;
                }
                if (FloatHelper.isInfinite(value)) {
                    if (negative) {
                        return -8388608;
                    }
                    else {
                        return 2139095040;
                    }
                }
                var l = javaemul.internal.DoubleHelper.doubleToLongBits(value);
                var exp = ((((l >> 52) & 2047) - 1023) | 0);
                var mantissa = (((l & 4503599627370495) >> 29) | 0);
                if (exp <= -127) {
                    mantissa = (8388608 | mantissa) >> (-127 - exp + 1);
                    exp = -127;
                }
                var bits = negative ? FloatHelper.POWER_31_INT : 0;
                bits |= (exp + 127) << 23;
                bits |= mantissa;
                return (bits | 0);
            };
            /**
             * @skip Here for shared implementation with Arrays.hashCode.
             * @param f
             * @return hash value of float (currently just truncated to int)
             */
            FloatHelper.hashCode = function (f) {
                return (f | 0);
            };
            FloatHelper.intBitsToFloat = function (bits) {
                var negative = (bits & -2147483648) !== 0;
                var exp = (bits >> 23) & 255;
                bits &= 8388607;
                if (exp === 0) {
                    if (bits === 0) {
                        return negative ? -0.0 : 0.0;
                    }
                }
                else if (exp === 255) {
                    if (bits === 0) {
                        return negative ? FloatHelper.NEGATIVE_INFINITY_$LI$() : FloatHelper.POSITIVE_INFINITY_$LI$();
                    }
                    else {
                        return FloatHelper.NaN_$LI$();
                    }
                }
                if (exp === 0) {
                    exp = 1;
                    while (((bits & 8388608) === 0)) {
                        bits <<= 1;
                        exp--;
                    }
                    ;
                    bits &= 8388607;
                }
                var bits64 = negative ? -9223372036854775808 : 0;
                bits64 |= (Math.round((exp + 896))) << 52;
                bits64 |= (Math.round(bits)) << 29;
                return javaemul.internal.DoubleHelper.longBitsToDouble(bits64);
            };
            FloatHelper.isInfinite = function (x) {
                return javaemul.internal.DoubleHelper.isInfinite(x);
            };
            FloatHelper.isNaN = function (x) {
                return javaemul.internal.DoubleHelper.isNaN(x);
            };
            FloatHelper.parseFloat = function (s) {
                var doubleValue = internal.NumberHelper.__parseAndValidateDouble(s);
                if (doubleValue > FloatHelper.MAX_VALUE) {
                    return FloatHelper.POSITIVE_INFINITY_$LI$();
                }
                else if (doubleValue < -FloatHelper.MAX_VALUE) {
                    return FloatHelper.NEGATIVE_INFINITY_$LI$();
                }
                return doubleValue;
            };
            FloatHelper.toString = function (b) {
                return new String(b).toString();
            };
            FloatHelper.valueOf$float = function (f) {
                return new FloatHelper(f);
            };
            FloatHelper.valueOf = function (s) {
                if (((typeof s === 'string') || s === null)) {
                    return (function () {
                        return new FloatHelper(s);
                    })();
                }
                else if (((typeof s === 'number') || s === null)) {
                    return javaemul.internal.FloatHelper.valueOf$float(s);
                }
                else
                    throw new Error('invalid overload');
            };
            FloatHelper.prototype.byteValue = function () {
                return (this.value | 0);
            };
            FloatHelper.prototype.compareTo = function (b) {
                var _this = this;
                if (((b != null && b instanceof javaemul.internal.FloatHelper) || b === null)) {
                    return (function () {
                        return FloatHelper.compare(_this.value, b.value);
                    })();
                }
                else
                    throw new Error('invalid overload');
            };
            FloatHelper.prototype.doubleValue = function () {
                return this.value;
            };
            FloatHelper.prototype.equals = function (o) {
                return (o != null && o instanceof javaemul.internal.FloatHelper) && (o.value === this.value);
            };
            FloatHelper.prototype.floatValue = function () {
                return this.value;
            };
            /**
             * Performance caution: using Float objects as map keys is not recommended.
             * Using floating point values as keys is generally a bad idea due to
             * difficulty determining exact equality. In addition, there is no efficient
             * JavaScript equivalent of <code>floatToIntBits</code>. As a result, this
             * method computes a hash code by truncating the whole number portion of the
             * float, which may lead to poor performance for certain value sets if
             * Floats are used as keys in a {@link java.util.HashMap}.
             */
            FloatHelper.prototype.hashCode = function () {
                return FloatHelper.hashCode(this.value);
            };
            FloatHelper.prototype.intValue = function () {
                return (this.value | 0);
            };
            FloatHelper.prototype.isInfinite = function () {
                return FloatHelper.isInfinite(this.value);
            };
            FloatHelper.prototype.isNaN = function () {
                return FloatHelper.isNaN(this.value);
            };
            FloatHelper.prototype.longValue = function () {
                return Math.round(this.value);
            };
            FloatHelper.prototype.shortValue = function () {
                return (this.value | 0);
            };
            FloatHelper.prototype.toString = function () {
                return FloatHelper.toString(this.value);
            };
            FloatHelper.MAX_VALUE = 3.4028235E38;
            FloatHelper.MIN_VALUE = 1.4E-45;
            FloatHelper.MAX_EXPONENT = 127;
            FloatHelper.MIN_EXPONENT = -126;
            FloatHelper.MIN_NORMAL = 1.17549435E-38;
            FloatHelper.SIZE = 32;
            FloatHelper.POWER_31_INT = 2147483648;
            return FloatHelper;
        }(javaemul.internal.NumberHelper));
        internal.FloatHelper = FloatHelper;
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var javaemul;
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Wraps a primitive <code>int</code> as an object.
         */
        var IntegerHelper = (function (_super) {
            __extends(IntegerHelper, _super);
            function IntegerHelper(s) {
                var _this = this;
                if (((typeof s === 'string') || s === null)) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Comparable", "java.io.Serializable"] });
                    this.value = 0;
                    (function () {
                        _this.value = IntegerHelper.parseInt(s);
                    })();
                }
                else if (((typeof s === 'number') || s === null)) {
                    var value = s;
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Comparable", "java.io.Serializable"] });
                    this.value = 0;
                    (function () {
                        _this.value = value;
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            IntegerHelper.bitCount = function (x) {
                x -= ((x >> 1) & 1431655765);
                x = (((x >> 2) & 858993459) + (x & 858993459));
                x = (((x >> 4) + x) & 252645135);
                x += (x >> 8);
                x += (x >> 16);
                return x & 63;
            };
            IntegerHelper.compare = function (x, y) {
                if (x < y) {
                    return -1;
                }
                else if (x > y) {
                    return 1;
                }
                else {
                    return 0;
                }
            };
            IntegerHelper.decode = function (s) {
                return IntegerHelper.valueOf(internal.NumberHelper.__decodeAndValidateInt(s, IntegerHelper.MIN_VALUE, IntegerHelper.MAX_VALUE));
            };
            /**
             * @skip
             *
             * Here for shared implementation with Arrays.hashCode
             */
            IntegerHelper.hashCode = function (i) {
                return i;
            };
            IntegerHelper.highestOneBit = function (i) {
                if (i < 0) {
                    return IntegerHelper.MIN_VALUE;
                }
                else if (i === 0) {
                    return 0;
                }
                else {
                    var rtn;
                    for (rtn = 1073741824; (rtn & i) === 0; rtn >>= 1) {
                    }
                    return rtn;
                }
            };
            IntegerHelper.lowestOneBit = function (i) {
                return i & -i;
            };
            IntegerHelper.numberOfLeadingZeros = function (i) {
                if (i < 0) {
                    return 0;
                }
                else if (i === 0) {
                    return IntegerHelper.SIZE;
                }
                else {
                    var y;
                    var m;
                    var n;
                    y = -(i >> 16);
                    m = (y >> 16) & 16;
                    n = 16 - m;
                    i = i >> m;
                    y = i - 256;
                    m = (y >> 16) & 8;
                    n += m;
                    i <<= m;
                    y = i - 4096;
                    m = (y >> 16) & 4;
                    n += m;
                    i <<= m;
                    y = i - 16384;
                    m = (y >> 16) & 2;
                    n += m;
                    i <<= m;
                    y = i >> 14;
                    m = y & ~(y >> 1);
                    return n + 2 - m;
                }
            };
            IntegerHelper.numberOfTrailingZeros = function (i) {
                if (i === 0) {
                    return IntegerHelper.SIZE;
                }
                else {
                    var rtn = 0;
                    for (var r = 1; (r & i) === 0; r <<= 1) {
                        rtn++;
                    }
                    return rtn;
                }
            };
            IntegerHelper.parseInt = function (s, radix) {
                if (radix === void 0) { radix = 10; }
                return internal.NumberHelper.__parseAndValidateInt(s, radix, IntegerHelper.MIN_VALUE, IntegerHelper.MAX_VALUE);
            };
            IntegerHelper.reverse = function (i) {
                var nibbles = IntegerHelper.ReverseNibbles.reverseNibbles_$LI$();
                return (nibbles[i >>> 28]) | (nibbles[(i >> 24) & 15] << 4) | (nibbles[(i >> 20) & 15] << 8) | (nibbles[(i >> 16) & 15] << 12) | (nibbles[(i >> 12) & 15] << 16) | (nibbles[(i >> 8) & 15] << 20) | (nibbles[(i >> 4) & 15] << 24) | (nibbles[i & 15] << 28);
            };
            IntegerHelper.reverseBytes = function (i) {
                return ((i & 255) << 24) | ((i & 65280) << 8) | ((i & 16711680) >> 8) | ((i & -16777216) >>> 24);
            };
            IntegerHelper.rotateLeft = function (i, distance) {
                while ((distance-- > 0)) {
                    i = i << 1 | ((i < 0) ? 1 : 0);
                }
                ;
                return i;
            };
            IntegerHelper.rotateRight = function (i, distance) {
                var ui = i & IntegerHelper.MAX_VALUE;
                var carry = (i < 0) ? 1073741824 : 0;
                while ((distance-- > 0)) {
                    var nextcarry = ui & 1;
                    ui = carry | (ui >> 1);
                    carry = (nextcarry === 0) ? 0 : 1073741824;
                }
                ;
                if (carry !== 0) {
                    ui = ui | IntegerHelper.MIN_VALUE;
                }
                return ui;
            };
            IntegerHelper.signum = function (i) {
                if (i === 0) {
                    return 0;
                }
                else if (i < 0) {
                    return -1;
                }
                else {
                    return 1;
                }
            };
            IntegerHelper.toBinaryString = function (value) {
                return IntegerHelper.toUnsignedRadixString(value, 2);
            };
            IntegerHelper.toHexString = function (value) {
                return IntegerHelper.toUnsignedRadixString(value, 16);
            };
            IntegerHelper.toOctalString = function (value) {
                return IntegerHelper.toUnsignedRadixString(value, 8);
            };
            IntegerHelper.toString$int = function (value) {
                return new String(value).toString();
            };
            IntegerHelper.toString = function (value, radix) {
                if (((typeof value === 'number') || value === null) && ((typeof radix === 'number') || radix === null)) {
                    return (function () {
                        if (radix === 10 || radix < javaemul.internal.CharacterHelper.MIN_RADIX || radix > javaemul.internal.CharacterHelper.MAX_RADIX) {
                            return new String(value).toString();
                        }
                        return IntegerHelper.toRadixString(value, radix);
                    })();
                }
                else if (((typeof value === 'number') || value === null) && radix === undefined) {
                    return javaemul.internal.IntegerHelper.toString$int(value);
                }
                else
                    throw new Error('invalid overload');
            };
            IntegerHelper.valueOf$int = function (i) {
                if (i > -129 && i < 128) {
                    var rebase = i + 128;
                    var result = IntegerHelper.BoxedValues.boxedValues_$LI$()[rebase];
                    if (result == null) {
                        result = IntegerHelper.BoxedValues.boxedValues_$LI$()[rebase] = new IntegerHelper(i);
                    }
                    return result;
                }
                return new IntegerHelper(i);
            };
            IntegerHelper.valueOf$java_lang_String = function (s) {
                return IntegerHelper.valueOf(s, 10);
            };
            IntegerHelper.valueOf = function (s, radix) {
                if (((typeof s === 'string') || s === null) && ((typeof radix === 'number') || radix === null)) {
                    return (function () {
                        return IntegerHelper.valueOf(IntegerHelper.parseInt(s, radix));
                    })();
                }
                else if (((typeof s === 'string') || s === null) && radix === undefined) {
                    return javaemul.internal.IntegerHelper.valueOf$java_lang_String(s);
                }
                else if (((typeof s === 'number') || s === null) && radix === undefined) {
                    return javaemul.internal.IntegerHelper.valueOf$int(s);
                }
                else
                    throw new Error('invalid overload');
            };
            IntegerHelper.toRadixString = function (value, radix) {
                return value.toString(radix);
            };
            IntegerHelper.toUnsignedRadixString = function (value, radix) {
                // ">>> 0" converts the value to unsigned number.
                return (value >>> 0).toString(radix);
            };
            IntegerHelper.prototype.byteValue = function () {
                return (this.value | 0);
            };
            IntegerHelper.prototype.compareTo = function (b) {
                var _this = this;
                if (((b != null && b instanceof javaemul.internal.IntegerHelper) || b === null)) {
                    return (function () {
                        return IntegerHelper.compare(_this.value, b.value);
                    })();
                }
                else
                    throw new Error('invalid overload');
            };
            IntegerHelper.prototype.doubleValue = function () {
                return this.value;
            };
            IntegerHelper.prototype.equals = function (o) {
                return (o != null && o instanceof javaemul.internal.IntegerHelper) && (o.value === this.value);
            };
            IntegerHelper.prototype.floatValue = function () {
                return this.value;
            };
            IntegerHelper.prototype.hashCode = function () {
                return IntegerHelper.hashCode(this.value);
            };
            IntegerHelper.prototype.intValue = function () {
                return this.value;
            };
            IntegerHelper.prototype.longValue = function () {
                return this.value;
            };
            IntegerHelper.prototype.shortValue = function () {
                return (this.value | 0);
            };
            IntegerHelper.prototype.toString = function () {
                return IntegerHelper.toString(this.value);
            };
            IntegerHelper.MAX_VALUE = 2147483647;
            IntegerHelper.MIN_VALUE = -2147483648;
            IntegerHelper.SIZE = 32;
            return IntegerHelper;
        }(javaemul.internal.NumberHelper));
        internal.IntegerHelper = IntegerHelper;
        var IntegerHelper;
        (function (IntegerHelper) {
            /**
             * Use nested class to avoid clinit on outer.
             */
            var BoxedValues = (function () {
                function BoxedValues() {
                }
                BoxedValues.boxedValues_$LI$ = function () { if (BoxedValues.boxedValues == null)
                    BoxedValues.boxedValues = new Array(256); return BoxedValues.boxedValues; };
                ;
                return BoxedValues;
            }());
            IntegerHelper.BoxedValues = BoxedValues;
            /**
             * Use nested class to avoid clinit on outer.
             */
            var ReverseNibbles = (function () {
                function ReverseNibbles() {
                }
                ReverseNibbles.reverseNibbles_$LI$ = function () { if (ReverseNibbles.reverseNibbles == null)
                    ReverseNibbles.reverseNibbles = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]; return ReverseNibbles.reverseNibbles; };
                ;
                return ReverseNibbles;
            }());
            IntegerHelper.ReverseNibbles = ReverseNibbles;
        })(IntegerHelper = internal.IntegerHelper || (internal.IntegerHelper = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var javaemul;
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Wraps a primitive <code>long</code> as an object.
         */
        var LongHelper = (function (_super) {
            __extends(LongHelper, _super);
            function LongHelper(s) {
                var _this = this;
                if (((typeof s === 'string') || s === null)) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Comparable", "java.io.Serializable"] });
                    this.value = 0;
                    (function () {
                        _this.value = LongHelper.parseLong(s);
                    })();
                }
                else if (((typeof s === 'number') || s === null)) {
                    var value = s;
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Comparable", "java.io.Serializable"] });
                    this.value = 0;
                    (function () {
                        _this.value = value;
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            LongHelper.bitCount = function (i) {
                var high = ((i >> 32) | 0);
                var low = (i | 0);
                return javaemul.internal.IntegerHelper.bitCount(high) + javaemul.internal.IntegerHelper.bitCount(low);
            };
            LongHelper.compare = function (x, y) {
                if (x < y) {
                    return -1;
                }
                else if (x > y) {
                    return 1;
                }
                else {
                    return 0;
                }
            };
            LongHelper.decode = function (s) {
                var decode = internal.NumberHelper.__decodeNumberString(s);
                return LongHelper.valueOf(decode.payload, decode.radix);
            };
            /**
             * @skip Here for shared implementation with Arrays.hashCode
             */
            LongHelper.hashCode = function (l) {
                return (l | 0);
            };
            LongHelper.highestOneBit = function (i) {
                var high = ((i >> 32) | 0);
                if (high !== 0) {
                    return (Math.round(javaemul.internal.IntegerHelper.highestOneBit(high))) << 32;
                }
                else {
                    return javaemul.internal.IntegerHelper.highestOneBit((i | 0)) & 4294967295;
                }
            };
            LongHelper.lowestOneBit = function (i) {
                return i & -i;
            };
            LongHelper.numberOfLeadingZeros = function (i) {
                var high = ((i >> 32) | 0);
                if (high !== 0) {
                    return javaemul.internal.IntegerHelper.numberOfLeadingZeros(high);
                }
                else {
                    return javaemul.internal.IntegerHelper.numberOfLeadingZeros((i | 0)) + 32;
                }
            };
            LongHelper.numberOfTrailingZeros = function (i) {
                var low = (i | 0);
                if (low !== 0) {
                    return javaemul.internal.IntegerHelper.numberOfTrailingZeros(low);
                }
                else {
                    return javaemul.internal.IntegerHelper.numberOfTrailingZeros(((i >> 32) | 0)) + 32;
                }
            };
            LongHelper.parseLong = function (s, radix) {
                if (radix === void 0) { radix = 10; }
                return internal.NumberHelper.__parseAndValidateLong(s, radix);
            };
            LongHelper.reverse = function (i) {
                var high = ((i >>> 32) | 0);
                var low = (i | 0);
                return (Math.round(javaemul.internal.IntegerHelper.reverse(low)) << 32) | (javaemul.internal.IntegerHelper.reverse(high) & 4294967295);
            };
            LongHelper.reverseBytes = function (i) {
                var high = ((i >>> 32) | 0);
                var low = (i | 0);
                return (Math.round(javaemul.internal.IntegerHelper.reverseBytes(low)) << 32) | (javaemul.internal.IntegerHelper.reverseBytes(high) & 4294967295);
            };
            LongHelper.rotateLeft = function (i, distance) {
                while ((distance-- > 0)) {
                    i = i << 1 | ((i < 0) ? 1 : 0);
                }
                ;
                return i;
            };
            LongHelper.rotateRight = function (i, distance) {
                var ui = i & LongHelper.MAX_VALUE;
                var carry = (i < 0) ? 4611686018427387904 : 0;
                while ((distance-- > 0)) {
                    var nextcarry = ui & 1;
                    ui = carry | (ui >> 1);
                    carry = (nextcarry === 0) ? 0 : 4611686018427387904;
                }
                ;
                if (carry !== 0) {
                    ui = ui | LongHelper.MIN_VALUE;
                }
                return ui;
            };
            LongHelper.signum = function (i) {
                if (i === 0) {
                    return 0;
                }
                else if (i < 0) {
                    return -1;
                }
                else {
                    return 1;
                }
            };
            LongHelper.toBinaryString = function (value) {
                return LongHelper.toPowerOfTwoUnsignedString(value, 1);
            };
            LongHelper.toHexString = function (value) {
                return LongHelper.toPowerOfTwoUnsignedString(value, 4);
            };
            LongHelper.toOctalString = function (value) {
                return LongHelper.toPowerOfTwoUnsignedString(value, 3);
            };
            LongHelper.toString$long = function (value) {
                return new String(value).toString();
            };
            LongHelper.toString = function (value, intRadix) {
                if (((typeof value === 'number') || value === null) && ((typeof intRadix === 'number') || intRadix === null)) {
                    return (function () {
                        if (intRadix === 10 || intRadix < javaemul.internal.CharacterHelper.MIN_RADIX || intRadix > javaemul.internal.CharacterHelper.MAX_RADIX) {
                            return new String(value).toString();
                        }
                        var intValue = (value | 0);
                        if (intValue === value) {
                            return javaemul.internal.IntegerHelper.toString(intValue, intRadix);
                        }
                        var negative = value < 0;
                        if (!negative) {
                            value = -value;
                        }
                        var bufLen = intRadix < 8 ? 65 : 23;
                        var buf = new Array(bufLen);
                        var cursor = bufLen;
                        var radix = intRadix;
                        do {
                            var q = Math.round(value / radix);
                            buf[--cursor] = javaemul.internal.CharacterHelper.forDigit(((radix * q - value) | 0));
                            value = q;
                        } while ((value !== 0));
                        if (negative) {
                            buf[--cursor] = '-';
                        }
                        return (function (str, index, len) { return str.join('').substring(index, index + len); })(buf, cursor, bufLen - cursor);
                    })();
                }
                else if (((typeof value === 'number') || value === null) && intRadix === undefined) {
                    return javaemul.internal.LongHelper.toString$long(value);
                }
                else
                    throw new Error('invalid overload');
            };
            LongHelper.valueOf$long = function (i) {
                if (i > -129 && i < 128) {
                    var rebase = (i | 0) + 128;
                    var result = LongHelper.BoxedValues.boxedValues_$LI$()[rebase];
                    if (result == null) {
                        result = LongHelper.BoxedValues.boxedValues_$LI$()[rebase] = new LongHelper(i);
                    }
                    return result;
                }
                return new LongHelper(i);
            };
            LongHelper.valueOf$java_lang_String = function (s) {
                return LongHelper.valueOf(s, 10);
            };
            LongHelper.valueOf = function (s, radix) {
                if (((typeof s === 'string') || s === null) && ((typeof radix === 'number') || radix === null)) {
                    return (function () {
                        return LongHelper.valueOf(LongHelper.parseLong(s, radix));
                    })();
                }
                else if (((typeof s === 'string') || s === null) && radix === undefined) {
                    return javaemul.internal.LongHelper.valueOf$java_lang_String(s);
                }
                else if (((typeof s === 'number') || s === null) && radix === undefined) {
                    return javaemul.internal.LongHelper.valueOf$long(s);
                }
                else
                    throw new Error('invalid overload');
            };
            LongHelper.toPowerOfTwoUnsignedString = function (value, shift) {
                var radix = 1 << shift;
                if (javaemul.internal.IntegerHelper.MIN_VALUE <= value && value <= javaemul.internal.IntegerHelper.MAX_VALUE) {
                    return javaemul.internal.IntegerHelper.toString((value | 0), radix);
                }
                var mask = radix - 1;
                var bufSize = (64 / shift | 0) + 1;
                var buf = new Array(bufSize);
                var pos = bufSize;
                do {
                    buf[--pos] = javaemul.internal.CharacterHelper.forDigit(((value | 0)) & mask);
                    value >>>= shift;
                } while ((value !== 0));
                return (function (str, index, len) { return str.join('').substring(index, index + len); })(buf, pos, bufSize - pos);
            };
            LongHelper.prototype.byteValue = function () {
                return (this.value | 0);
            };
            LongHelper.prototype.compareTo = function (b) {
                var _this = this;
                if (((b != null && b instanceof javaemul.internal.LongHelper) || b === null)) {
                    return (function () {
                        return LongHelper.compare(_this.value, b.value);
                    })();
                }
                else
                    throw new Error('invalid overload');
            };
            LongHelper.prototype.doubleValue = function () {
                return this.value;
            };
            LongHelper.prototype.equals = function (o) {
                return (o != null && o instanceof javaemul.internal.LongHelper) && (o.value === this.value);
            };
            LongHelper.prototype.floatValue = function () {
                return this.value;
            };
            LongHelper.prototype.hashCode = function () {
                return LongHelper.hashCode(this.value);
            };
            LongHelper.prototype.intValue = function () {
                return (this.value | 0);
            };
            LongHelper.prototype.longValue = function () {
                return this.value;
            };
            LongHelper.prototype.shortValue = function () {
                return (this.value | 0);
            };
            LongHelper.prototype.toString = function () {
                return LongHelper.toString(this.value);
            };
            LongHelper.MAX_VALUE = 9223372036854775807;
            LongHelper.MIN_VALUE = -9223372036854775808;
            LongHelper.SIZE = 64;
            return LongHelper;
        }(javaemul.internal.NumberHelper));
        internal.LongHelper = LongHelper;
        var LongHelper;
        (function (LongHelper) {
            /**
             * Use nested class to avoid clinit on outer.
             */
            var BoxedValues = (function () {
                function BoxedValues() {
                }
                BoxedValues.boxedValues_$LI$ = function () { if (BoxedValues.boxedValues == null)
                    BoxedValues.boxedValues = new Array(256); return BoxedValues.boxedValues; };
                ;
                return BoxedValues;
            }());
            LongHelper.BoxedValues = BoxedValues;
        })(LongHelper = internal.LongHelper || (internal.LongHelper = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var javaemul;
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Wraps a primitive <code>short</code> as an object.
         */
        var ShortHelper = (function (_super) {
            __extends(ShortHelper, _super);
            function ShortHelper(s) {
                var _this = this;
                if (((typeof s === 'string') || s === null)) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Comparable", "java.io.Serializable"] });
                    this.value = 0;
                    (function () {
                        _this.value = ShortHelper.parseShort(s);
                    })();
                }
                else if (((typeof s === 'number') || s === null)) {
                    var value = s;
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Comparable", "java.io.Serializable"] });
                    this.value = 0;
                    (function () {
                        _this.value = value;
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            ShortHelper.MIN_VALUE_$LI$ = function () { if (ShortHelper.MIN_VALUE == null)
                ShortHelper.MIN_VALUE = (32768 | 0); return ShortHelper.MIN_VALUE; };
            ;
            ShortHelper.MAX_VALUE_$LI$ = function () { if (ShortHelper.MAX_VALUE == null)
                ShortHelper.MAX_VALUE = (32767 | 0); return ShortHelper.MAX_VALUE; };
            ;
            ShortHelper.TYPE_$LI$ = function () { if (ShortHelper.TYPE == null)
                ShortHelper.TYPE = Number; return ShortHelper.TYPE; };
            ;
            ShortHelper.compare = function (x, y) {
                return x - y;
            };
            ShortHelper.decode = function (s) {
                return ShortHelper.valueOf((internal.NumberHelper.__decodeAndValidateInt(s, ShortHelper.MIN_VALUE_$LI$(), ShortHelper.MAX_VALUE_$LI$()) | 0));
            };
            /**
             * @skip Here for shared implementation with Arrays.hashCode
             */
            ShortHelper.hashCode = function (s) {
                return s;
            };
            ShortHelper.parseShort = function (s, radix) {
                if (radix === void 0) { radix = 10; }
                return (internal.NumberHelper.__parseAndValidateInt(s, radix, ShortHelper.MIN_VALUE_$LI$(), ShortHelper.MAX_VALUE_$LI$()) | 0);
            };
            ShortHelper.reverseBytes = function (s) {
                return ((((s & 255) << 8) | ((s & 65280) >> 8)) | 0);
            };
            ShortHelper.toString = function (b) {
                return new String(b).toString();
            };
            ShortHelper.valueOf$short = function (s) {
                if (s > -129 && s < 128) {
                    var rebase = s + 128;
                    var result = ShortHelper.BoxedValues.boxedValues_$LI$()[rebase];
                    if (result == null) {
                        result = ShortHelper.BoxedValues.boxedValues_$LI$()[rebase] = new ShortHelper(s);
                    }
                    return result;
                }
                return new ShortHelper(s);
            };
            ShortHelper.valueOf$java_lang_String = function (s) {
                return ShortHelper.valueOf(s, 10);
            };
            ShortHelper.valueOf = function (s, radix) {
                if (((typeof s === 'string') || s === null) && ((typeof radix === 'number') || radix === null)) {
                    return (function () {
                        return ShortHelper.valueOf(ShortHelper.parseShort(s, radix));
                    })();
                }
                else if (((typeof s === 'string') || s === null) && radix === undefined) {
                    return javaemul.internal.ShortHelper.valueOf$java_lang_String(s);
                }
                else if (((typeof s === 'number') || s === null) && radix === undefined) {
                    return javaemul.internal.ShortHelper.valueOf$short(s);
                }
                else
                    throw new Error('invalid overload');
            };
            ShortHelper.prototype.byteValue = function () {
                return (this.value | 0);
            };
            ShortHelper.prototype.compareTo = function (b) {
                var _this = this;
                if (((b != null && b instanceof javaemul.internal.ShortHelper) || b === null)) {
                    return (function () {
                        return ShortHelper.compare(_this.value, b.value);
                    })();
                }
                else
                    throw new Error('invalid overload');
            };
            ShortHelper.prototype.doubleValue = function () {
                return this.value;
            };
            ShortHelper.prototype.equals = function (o) {
                return (o != null && o instanceof javaemul.internal.ShortHelper) && (o.value === this.value);
            };
            ShortHelper.prototype.floatValue = function () {
                return this.value;
            };
            ShortHelper.prototype.hashCode = function () {
                return ShortHelper.hashCode(this.value);
            };
            ShortHelper.prototype.intValue = function () {
                return this.value;
            };
            ShortHelper.prototype.longValue = function () {
                return this.value;
            };
            ShortHelper.prototype.shortValue = function () {
                return this.value;
            };
            ShortHelper.prototype.toString = function () {
                return ShortHelper.toString(this.value);
            };
            ShortHelper.SIZE = 16;
            return ShortHelper;
        }(javaemul.internal.NumberHelper));
        internal.ShortHelper = ShortHelper;
        var ShortHelper;
        (function (ShortHelper) {
            /**
             * Use nested class to avoid clinit on outer.
             */
            var BoxedValues = (function () {
                function BoxedValues() {
                }
                BoxedValues.boxedValues_$LI$ = function () { if (BoxedValues.boxedValues == null)
                    BoxedValues.boxedValues = new Array(256); return BoxedValues.boxedValues; };
                ;
                return BoxedValues;
            }());
            ShortHelper.BoxedValues = BoxedValues;
        })(ShortHelper = internal.ShortHelper || (internal.ShortHelper = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var sun;
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var Order0 = (function (_super) {
                __extends(Order0, _super);
                function Order0(x, y) {
                    _super.call(this, sun.awt.geom.Curve.INCREASING);
                    this.x = 0;
                    this.y = 0;
                    this.x = x;
                    this.y = y;
                }
                Order0.prototype.getOrder = function () {
                    return 0;
                };
                Order0.prototype.getXTop = function () {
                    return this.x;
                };
                Order0.prototype.getYTop = function () {
                    return this.y;
                };
                Order0.prototype.getXBot = function () {
                    return this.x;
                };
                Order0.prototype.getYBot = function () {
                    return this.y;
                };
                Order0.prototype.getXMin = function () {
                    return this.x;
                };
                Order0.prototype.getXMax = function () {
                    return this.x;
                };
                Order0.prototype.getX0 = function () {
                    return this.x;
                };
                Order0.prototype.getY0 = function () {
                    return this.y;
                };
                Order0.prototype.getX1 = function () {
                    return this.x;
                };
                Order0.prototype.getY1 = function () {
                    return this.y;
                };
                Order0.prototype.XforY = function (y) {
                    return y;
                };
                Order0.prototype.TforY = function (y) {
                    return 0;
                };
                Order0.prototype.XforT = function (t) {
                    return this.x;
                };
                Order0.prototype.YforT = function (t) {
                    return this.y;
                };
                Order0.prototype.dXforT = function (t, deriv) {
                    return 0;
                };
                Order0.prototype.dYforT = function (t, deriv) {
                    return 0;
                };
                Order0.prototype.nextVertical = function (t0, t1) {
                    return t1;
                };
                Order0.prototype.crossingsFor = function (x, y) {
                    return 0;
                };
                Order0.prototype.accumulateCrossings = function (c) {
                    return (this.x > c.getXLo() && this.x < c.getXHi() && this.y > c.getYLo() && this.y < c.getYHi());
                };
                Order0.prototype.enlarge = function (r) {
                    r.add(this.x, this.y);
                };
                Order0.prototype.getSubCurve = function (ystart, yend, dir) {
                    var _this = this;
                    if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && ((typeof dir === 'number') || dir === null)) {
                        return (function () {
                            return _this;
                        })();
                    }
                    else if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && dir === undefined) {
                        return this.getSubCurve$double$double(ystart, yend);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Order0.prototype.getReversedCurve = function () {
                    return this;
                };
                Order0.prototype.getSegment = function (coords) {
                    coords[0] = this.x;
                    coords[1] = this.y;
                    return java.awt.geom.PathIterator.SEG_MOVETO;
                };
                return Order0;
            }(sun.awt.geom.Curve));
            geom.Order0 = Order0;
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var sun;
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var Order1 = (function (_super) {
                __extends(Order1, _super);
                function Order1(x0, y0, x1, y1, direction) {
                    _super.call(this, direction);
                    this.x0 = 0;
                    this.y0 = 0;
                    this.x1 = 0;
                    this.y1 = 0;
                    this.xmin = 0;
                    this.xmax = 0;
                    this.x0 = x0;
                    this.y0 = y0;
                    this.x1 = x1;
                    this.y1 = y1;
                    if (x0 < x1) {
                        this.xmin = x0;
                        this.xmax = x1;
                    }
                    else {
                        this.xmin = x1;
                        this.xmax = x0;
                    }
                }
                Order1.prototype.getOrder = function () {
                    return 1;
                };
                Order1.prototype.getXTop = function () {
                    return this.x0;
                };
                Order1.prototype.getYTop = function () {
                    return this.y0;
                };
                Order1.prototype.getXBot = function () {
                    return this.x1;
                };
                Order1.prototype.getYBot = function () {
                    return this.y1;
                };
                Order1.prototype.getXMin = function () {
                    return this.xmin;
                };
                Order1.prototype.getXMax = function () {
                    return this.xmax;
                };
                Order1.prototype.getX0 = function () {
                    return (this.direction === sun.awt.geom.Curve.INCREASING) ? this.x0 : this.x1;
                };
                Order1.prototype.getY0 = function () {
                    return (this.direction === sun.awt.geom.Curve.INCREASING) ? this.y0 : this.y1;
                };
                Order1.prototype.getX1 = function () {
                    return (this.direction === sun.awt.geom.Curve.DECREASING) ? this.x0 : this.x1;
                };
                Order1.prototype.getY1 = function () {
                    return (this.direction === sun.awt.geom.Curve.DECREASING) ? this.y0 : this.y1;
                };
                Order1.prototype.XforY = function (y) {
                    if (this.x0 === this.x1 || y <= this.y0) {
                        return this.x0;
                    }
                    if (y >= this.y1) {
                        return this.x1;
                    }
                    return (this.x0 + (y - this.y0) * (this.x1 - this.x0) / (this.y1 - this.y0));
                };
                Order1.prototype.TforY = function (y) {
                    if (y <= this.y0) {
                        return 0;
                    }
                    if (y >= this.y1) {
                        return 1;
                    }
                    return (y - this.y0) / (this.y1 - this.y0);
                };
                Order1.prototype.XforT = function (t) {
                    return this.x0 + t * (this.x1 - this.x0);
                };
                Order1.prototype.YforT = function (t) {
                    return this.y0 + t * (this.y1 - this.y0);
                };
                Order1.prototype.dXforT = function (t, deriv) {
                    switch ((deriv)) {
                        case 0:
                            return this.x0 + t * (this.x1 - this.x0);
                        case 1:
                            return (this.x1 - this.x0);
                        default:
                            return 0;
                    }
                };
                Order1.prototype.dYforT = function (t, deriv) {
                    switch ((deriv)) {
                        case 0:
                            return this.y0 + t * (this.y1 - this.y0);
                        case 1:
                            return (this.y1 - this.y0);
                        default:
                            return 0;
                    }
                };
                Order1.prototype.nextVertical = function (t0, t1) {
                    return t1;
                };
                Order1.prototype.accumulateCrossings = function (c) {
                    var xlo = c.getXLo();
                    var ylo = c.getYLo();
                    var xhi = c.getXHi();
                    var yhi = c.getYHi();
                    if (this.xmin >= xhi) {
                        return false;
                    }
                    var xstart;
                    var ystart;
                    var xend;
                    var yend;
                    if (this.y0 < ylo) {
                        if (this.y1 <= ylo) {
                            return false;
                        }
                        ystart = ylo;
                        xstart = this.XforY(ylo);
                    }
                    else {
                        if (this.y0 >= yhi) {
                            return false;
                        }
                        ystart = this.y0;
                        xstart = this.x0;
                    }
                    if (this.y1 > yhi) {
                        yend = yhi;
                        xend = this.XforY(yhi);
                    }
                    else {
                        yend = this.y1;
                        xend = this.x1;
                    }
                    if (xstart >= xhi && xend >= xhi) {
                        return false;
                    }
                    if (xstart > xlo || xend > xlo) {
                        return true;
                    }
                    c.record(ystart, yend, this.direction);
                    return false;
                };
                Order1.prototype.enlarge = function (r) {
                    r.add(this.x0, this.y0);
                    r.add(this.x1, this.y1);
                };
                Order1.prototype.getSubCurve = function (ystart, yend, dir) {
                    var _this = this;
                    if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && ((typeof dir === 'number') || dir === null)) {
                        return (function () {
                            if (ystart === _this.y0 && yend === _this.y1) {
                                return _this.getWithDirection(dir);
                            }
                            if (_this.x0 === _this.x1) {
                                return new Order1(_this.x0, ystart, _this.x1, yend, dir);
                            }
                            var num = _this.x0 - _this.x1;
                            var denom = _this.y0 - _this.y1;
                            var xstart = (_this.x0 + (ystart - _this.y0) * num / denom);
                            var xend = (_this.x0 + (yend - _this.y0) * num / denom);
                            return new Order1(xstart, ystart, xend, yend, dir);
                        })();
                    }
                    else if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && dir === undefined) {
                        return this.getSubCurve$double$double(ystart, yend);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Order1.prototype.getReversedCurve = function () {
                    return new Order1(this.x0, this.y0, this.x1, this.y1, -this.direction);
                };
                Order1.prototype.compareTo = function (other, yrange) {
                    if (!(other != null && other instanceof sun.awt.geom.Order1)) {
                        return _super.prototype.compareTo.call(this, other, yrange);
                    }
                    var c1 = other;
                    if (yrange[1] <= yrange[0]) {
                        throw new java.lang.InternalError("yrange already screwed up...");
                    }
                    yrange[1] = Math.min(Math.min(yrange[1], this.y1), c1.y1);
                    if (yrange[1] <= yrange[0]) {
                        throw new java.lang.InternalError("backstepping from " + yrange[0] + " to " + yrange[1]);
                    }
                    if (this.xmax <= c1.xmin) {
                        return (this.xmin === c1.xmax) ? 0 : -1;
                    }
                    if (this.xmin >= c1.xmax) {
                        return 1;
                    }
                    var dxa = this.x1 - this.x0;
                    var dya = this.y1 - this.y0;
                    var dxb = c1.x1 - c1.x0;
                    var dyb = c1.y1 - c1.y0;
                    var denom = dxb * dya - dxa * dyb;
                    var y;
                    if (denom !== 0) {
                        var num = ((this.x0 - c1.x0) * dya * dyb - this.y0 * dxa * dyb + c1.y0 * dxb * dya);
                        y = num / denom;
                        if (y <= yrange[0]) {
                            y = Math.min(this.y1, c1.y1);
                        }
                        else {
                            if (y < yrange[1]) {
                                yrange[1] = y;
                            }
                            y = Math.max(this.y0, c1.y0);
                        }
                    }
                    else {
                        y = Math.max(this.y0, c1.y0);
                    }
                    return geom.Curve.orderof(this.XforY(y), c1.XforY(y));
                };
                Order1.prototype.getSegment = function (coords) {
                    if (this.direction === sun.awt.geom.Curve.INCREASING) {
                        coords[0] = this.x1;
                        coords[1] = this.y1;
                    }
                    else {
                        coords[0] = this.x0;
                        coords[1] = this.y0;
                    }
                    return java.awt.geom.PathIterator.SEG_LINETO;
                };
                return Order1;
            }(sun.awt.geom.Curve));
            geom.Order1 = Order1;
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var sun;
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var Order2 = (function (_super) {
                __extends(Order2, _super);
                function Order2(x0, y0, cx0, cy0, x1, y1, direction) {
                    _super.call(this, direction);
                    this.x0 = 0;
                    this.y0 = 0;
                    this.cx0 = 0;
                    this.cy0 = 0;
                    this.x1 = 0;
                    this.y1 = 0;
                    this.xmin = 0;
                    this.xmax = 0;
                    this.xcoeff0 = 0;
                    this.xcoeff1 = 0;
                    this.xcoeff2 = 0;
                    this.ycoeff0 = 0;
                    this.ycoeff1 = 0;
                    this.ycoeff2 = 0;
                    if (cy0 < y0) {
                        cy0 = y0;
                    }
                    else if (cy0 > y1) {
                        cy0 = y1;
                    }
                    this.x0 = x0;
                    this.y0 = y0;
                    this.cx0 = cx0;
                    this.cy0 = cy0;
                    this.x1 = x1;
                    this.y1 = y1;
                    this.xmin = Math.min(Math.min(x0, x1), cx0);
                    this.xmax = Math.max(Math.max(x0, x1), cx0);
                    this.xcoeff0 = x0;
                    this.xcoeff1 = cx0 + cx0 - x0 - x0;
                    this.xcoeff2 = x0 - cx0 - cx0 + x1;
                    this.ycoeff0 = y0;
                    this.ycoeff1 = cy0 + cy0 - y0 - y0;
                    this.ycoeff2 = y0 - cy0 - cy0 + y1;
                }
                Order2.insert = function (curves, tmp, x0, y0, cx0, cy0, x1, y1, direction) {
                    var numparams = Order2.getHorizontalParams(y0, cy0, y1, tmp);
                    if (numparams === 0) {
                        Order2.addInstance(curves, x0, y0, cx0, cy0, x1, y1, direction);
                        return;
                    }
                    var t = tmp[0];
                    tmp[0] = x0;
                    tmp[1] = y0;
                    tmp[2] = cx0;
                    tmp[3] = cy0;
                    tmp[4] = x1;
                    tmp[5] = y1;
                    Order2.split(tmp, 0, t);
                    var i0 = (direction === sun.awt.geom.Curve.INCREASING) ? 0 : 4;
                    var i1 = 4 - i0;
                    Order2.addInstance(curves, tmp[i0], tmp[i0 + 1], tmp[i0 + 2], tmp[i0 + 3], tmp[i0 + 4], tmp[i0 + 5], direction);
                    Order2.addInstance(curves, tmp[i1], tmp[i1 + 1], tmp[i1 + 2], tmp[i1 + 3], tmp[i1 + 4], tmp[i1 + 5], direction);
                };
                Order2.addInstance = function (curves, x0, y0, cx0, cy0, x1, y1, direction) {
                    if (y0 > y1) {
                        curves.add(new Order2(x1, y1, cx0, cy0, x0, y0, -direction));
                    }
                    else if (y1 > y0) {
                        curves.add(new Order2(x0, y0, cx0, cy0, x1, y1, direction));
                    }
                };
                Order2.getHorizontalParams = function (c0, cp, c1, ret) {
                    if (c0 <= cp && cp <= c1) {
                        return 0;
                    }
                    c0 -= cp;
                    c1 -= cp;
                    var denom = c0 + c1;
                    if (denom === 0) {
                        return 0;
                    }
                    var t = c0 / denom;
                    if (t <= 0 || t >= 1) {
                        return 0;
                    }
                    ret[0] = t;
                    return 1;
                };
                Order2.split = function (coords, pos, t) {
                    var x0;
                    var y0;
                    var cx;
                    var cy;
                    var x1;
                    var y1;
                    coords[pos + 8] = x1 = coords[pos + 4];
                    coords[pos + 9] = y1 = coords[pos + 5];
                    cx = coords[pos + 2];
                    cy = coords[pos + 3];
                    x1 = cx + (x1 - cx) * t;
                    y1 = cy + (y1 - cy) * t;
                    x0 = coords[pos + 0];
                    y0 = coords[pos + 1];
                    x0 = x0 + (cx - x0) * t;
                    y0 = y0 + (cy - y0) * t;
                    cx = x0 + (x1 - x0) * t;
                    cy = y0 + (y1 - y0) * t;
                    coords[pos + 2] = x0;
                    coords[pos + 3] = y0;
                    coords[pos + 4] = cx;
                    coords[pos + 5] = cy;
                    coords[pos + 6] = x1;
                    coords[pos + 7] = y1;
                };
                Order2.prototype.getOrder = function () {
                    return 2;
                };
                Order2.prototype.getXTop = function () {
                    return this.x0;
                };
                Order2.prototype.getYTop = function () {
                    return this.y0;
                };
                Order2.prototype.getXBot = function () {
                    return this.x1;
                };
                Order2.prototype.getYBot = function () {
                    return this.y1;
                };
                Order2.prototype.getXMin = function () {
                    return this.xmin;
                };
                Order2.prototype.getXMax = function () {
                    return this.xmax;
                };
                Order2.prototype.getX0 = function () {
                    return (this.direction === sun.awt.geom.Curve.INCREASING) ? this.x0 : this.x1;
                };
                Order2.prototype.getY0 = function () {
                    return (this.direction === sun.awt.geom.Curve.INCREASING) ? this.y0 : this.y1;
                };
                Order2.prototype.getCX0 = function () {
                    return this.cx0;
                };
                Order2.prototype.getCY0 = function () {
                    return this.cy0;
                };
                Order2.prototype.getX1 = function () {
                    return (this.direction === sun.awt.geom.Curve.DECREASING) ? this.x0 : this.x1;
                };
                Order2.prototype.getY1 = function () {
                    return (this.direction === sun.awt.geom.Curve.DECREASING) ? this.y0 : this.y1;
                };
                Order2.prototype.XforY = function (y) {
                    if (y <= this.y0) {
                        return this.x0;
                    }
                    if (y >= this.y1) {
                        return this.x1;
                    }
                    return this.XforT(this.TforY(y));
                };
                Order2.prototype.TforY = function (y) {
                    if (y <= this.y0) {
                        return 0;
                    }
                    if (y >= this.y1) {
                        return 1;
                    }
                    return Order2.TforY(y, this.ycoeff0, this.ycoeff1, this.ycoeff2);
                };
                Order2.TforY = function (y, ycoeff0, ycoeff1, ycoeff2) {
                    ycoeff0 -= y;
                    if (ycoeff2 === 0.0) {
                        var root = -ycoeff0 / ycoeff1;
                        if (root >= 0 && root <= 1) {
                            return root;
                        }
                    }
                    else {
                        var d = ycoeff1 * ycoeff1 - 4.0 * ycoeff2 * ycoeff0;
                        if (d >= 0.0) {
                            d = Math.sqrt(d);
                            if (ycoeff1 < 0.0) {
                                d = -d;
                            }
                            var q = (ycoeff1 + d) / -2.0;
                            var root = q / ycoeff2;
                            if (root >= 0 && root <= 1) {
                                return root;
                            }
                            if (q !== 0.0) {
                                root = ycoeff0 / q;
                                if (root >= 0 && root <= 1) {
                                    return root;
                                }
                            }
                        }
                    }
                    var y0 = ycoeff0;
                    var y1 = ycoeff0 + ycoeff1 + ycoeff2;
                    return (0 < (y0 + y1) / 2) ? 0.0 : 1.0;
                };
                Order2.prototype.XforT = function (t) {
                    return (this.xcoeff2 * t + this.xcoeff1) * t + this.xcoeff0;
                };
                Order2.prototype.YforT = function (t) {
                    return (this.ycoeff2 * t + this.ycoeff1) * t + this.ycoeff0;
                };
                Order2.prototype.dXforT = function (t, deriv) {
                    switch ((deriv)) {
                        case 0:
                            return (this.xcoeff2 * t + this.xcoeff1) * t + this.xcoeff0;
                        case 1:
                            return 2 * this.xcoeff2 * t + this.xcoeff1;
                        case 2:
                            return 2 * this.xcoeff2;
                        default:
                            return 0;
                    }
                };
                Order2.prototype.dYforT = function (t, deriv) {
                    switch ((deriv)) {
                        case 0:
                            return (this.ycoeff2 * t + this.ycoeff1) * t + this.ycoeff0;
                        case 1:
                            return 2 * this.ycoeff2 * t + this.ycoeff1;
                        case 2:
                            return 2 * this.ycoeff2;
                        default:
                            return 0;
                    }
                };
                Order2.prototype.nextVertical = function (t0, t1) {
                    var t = -this.xcoeff1 / (2 * this.xcoeff2);
                    if (t > t0 && t < t1) {
                        return t;
                    }
                    return t1;
                };
                Order2.prototype.enlarge = function (r) {
                    r.add(this.x0, this.y0);
                    var t = -this.xcoeff1 / (2 * this.xcoeff2);
                    if (t > 0 && t < 1) {
                        r.add(this.XforT(t), this.YforT(t));
                    }
                    r.add(this.x1, this.y1);
                };
                Order2.prototype.getSubCurve = function (ystart, yend, dir) {
                    var _this = this;
                    if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && ((typeof dir === 'number') || dir === null)) {
                        return (function () {
                            var t0;
                            var t1;
                            if (ystart <= _this.y0) {
                                if (yend >= _this.y1) {
                                    return _this.getWithDirection(dir);
                                }
                                t0 = 0;
                            }
                            else {
                                t0 = Order2.TforY(ystart, _this.ycoeff0, _this.ycoeff1, _this.ycoeff2);
                            }
                            if (yend >= _this.y1) {
                                t1 = 1;
                            }
                            else {
                                t1 = Order2.TforY(yend, _this.ycoeff0, _this.ycoeff1, _this.ycoeff2);
                            }
                            var eqn = new Array(10);
                            eqn[0] = _this.x0;
                            eqn[1] = _this.y0;
                            eqn[2] = _this.cx0;
                            eqn[3] = _this.cy0;
                            eqn[4] = _this.x1;
                            eqn[5] = _this.y1;
                            if (t1 < 1) {
                                Order2.split(eqn, 0, t1);
                            }
                            var i;
                            if (t0 <= 0) {
                                i = 0;
                            }
                            else {
                                Order2.split(eqn, 0, t0 / t1);
                                i = 4;
                            }
                            return new Order2(eqn[i + 0], ystart, eqn[i + 2], eqn[i + 3], eqn[i + 4], yend, dir);
                        })();
                    }
                    else if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && dir === undefined) {
                        return this.getSubCurve$double$double(ystart, yend);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Order2.prototype.getReversedCurve = function () {
                    return new Order2(this.x0, this.y0, this.cx0, this.cy0, this.x1, this.y1, -this.direction);
                };
                Order2.prototype.getSegment = function (coords) {
                    coords[0] = this.cx0;
                    coords[1] = this.cy0;
                    if (this.direction === sun.awt.geom.Curve.INCREASING) {
                        coords[2] = this.x1;
                        coords[3] = this.y1;
                    }
                    else {
                        coords[2] = this.x0;
                        coords[3] = this.y0;
                    }
                    return java.awt.geom.PathIterator.SEG_QUADTO;
                };
                Order2.prototype.controlPointString = function () {
                    return ("(" + geom.Curve.round(this.cx0) + ", " + geom.Curve.round(this.cy0) + "), ");
                };
                return Order2;
            }(sun.awt.geom.Curve));
            geom.Order2 = Order2;
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var sun;
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var Order3 = (function (_super) {
                __extends(Order3, _super);
                function Order3(x0, y0, cx0, cy0, cx1, cy1, x1, y1, direction) {
                    _super.call(this, direction);
                    this.x0 = 0;
                    this.y0 = 0;
                    this.cx0 = 0;
                    this.cy0 = 0;
                    this.cx1 = 0;
                    this.cy1 = 0;
                    this.x1 = 0;
                    this.y1 = 0;
                    this.xmin = 0;
                    this.xmax = 0;
                    this.xcoeff0 = 0;
                    this.xcoeff1 = 0;
                    this.xcoeff2 = 0;
                    this.xcoeff3 = 0;
                    this.ycoeff0 = 0;
                    this.ycoeff1 = 0;
                    this.ycoeff2 = 0;
                    this.ycoeff3 = 0;
                    this.TforY1 = 0;
                    this.YforT1 = 0;
                    this.TforY2 = 0;
                    this.YforT2 = 0;
                    this.TforY3 = 0;
                    this.YforT3 = 0;
                    if (cy0 < y0)
                        cy0 = y0;
                    if (cy1 > y1)
                        cy1 = y1;
                    this.x0 = x0;
                    this.y0 = y0;
                    this.cx0 = cx0;
                    this.cy0 = cy0;
                    this.cx1 = cx1;
                    this.cy1 = cy1;
                    this.x1 = x1;
                    this.y1 = y1;
                    this.xmin = Math.min(Math.min(x0, x1), Math.min(cx0, cx1));
                    this.xmax = Math.max(Math.max(x0, x1), Math.max(cx0, cx1));
                    this.xcoeff0 = x0;
                    this.xcoeff1 = (cx0 - x0) * 3.0;
                    this.xcoeff2 = (cx1 - cx0 - cx0 + x0) * 3.0;
                    this.xcoeff3 = x1 - (cx1 - cx0) * 3.0 - x0;
                    this.ycoeff0 = y0;
                    this.ycoeff1 = (cy0 - y0) * 3.0;
                    this.ycoeff2 = (cy1 - cy0 - cy0 + y0) * 3.0;
                    this.ycoeff3 = y1 - (cy1 - cy0) * 3.0 - y0;
                    this.YforT1 = this.YforT2 = this.YforT3 = y0;
                }
                Order3.insert = function (curves, tmp, x0, y0, cx0, cy0, cx1, cy1, x1, y1, direction) {
                    var numparams = Order3.getHorizontalParams(y0, cy0, cy1, y1, tmp);
                    if (numparams === 0) {
                        Order3.addInstance(curves, x0, y0, cx0, cy0, cx1, cy1, x1, y1, direction);
                        return;
                    }
                    tmp[3] = x0;
                    tmp[4] = y0;
                    tmp[5] = cx0;
                    tmp[6] = cy0;
                    tmp[7] = cx1;
                    tmp[8] = cy1;
                    tmp[9] = x1;
                    tmp[10] = y1;
                    var t = tmp[0];
                    if (numparams > 1 && t > tmp[1]) {
                        tmp[0] = tmp[1];
                        tmp[1] = t;
                        t = tmp[0];
                    }
                    Order3.split(tmp, 3, t);
                    if (numparams > 1) {
                        t = (tmp[1] - t) / (1 - t);
                        Order3.split(tmp, 9, t);
                    }
                    var index = 3;
                    if (direction === sun.awt.geom.Curve.DECREASING) {
                        index += numparams * 6;
                    }
                    while ((numparams >= 0)) {
                        Order3.addInstance(curves, tmp[index + 0], tmp[index + 1], tmp[index + 2], tmp[index + 3], tmp[index + 4], tmp[index + 5], tmp[index + 6], tmp[index + 7], direction);
                        numparams--;
                        if (direction === sun.awt.geom.Curve.INCREASING) {
                            index += 6;
                        }
                        else {
                            index -= 6;
                        }
                    }
                    ;
                };
                Order3.addInstance = function (curves, x0, y0, cx0, cy0, cx1, cy1, x1, y1, direction) {
                    if (y0 > y1) {
                        curves.add(new Order3(x1, y1, cx1, cy1, cx0, cy0, x0, y0, -direction));
                    }
                    else if (y1 > y0) {
                        curves.add(new Order3(x0, y0, cx0, cy0, cx1, cy1, x1, y1, direction));
                    }
                };
                Order3.getHorizontalParams = function (c0, cp0, cp1, c1, ret) {
                    if (c0 <= cp0 && cp0 <= cp1 && cp1 <= c1) {
                        return 0;
                    }
                    c1 -= cp1;
                    cp1 -= cp0;
                    cp0 -= c0;
                    ret[0] = cp0;
                    ret[1] = (cp1 - cp0) * 2;
                    ret[2] = (c1 - cp1 - cp1 + cp0);
                    var numroots = java.awt.geom.QuadCurve2D.solveQuadratic(ret, ret);
                    var j = 0;
                    for (var i = 0; i < numroots; i++) {
                        var t = ret[i];
                        if (t > 0 && t < 1) {
                            if (j < i) {
                                ret[j] = t;
                            }
                            j++;
                        }
                    }
                    return j;
                };
                Order3.split = function (coords, pos, t) {
                    var x0;
                    var y0;
                    var cx0;
                    var cy0;
                    var cx1;
                    var cy1;
                    var x1;
                    var y1;
                    coords[pos + 12] = x1 = coords[pos + 6];
                    coords[pos + 13] = y1 = coords[pos + 7];
                    cx1 = coords[pos + 4];
                    cy1 = coords[pos + 5];
                    x1 = cx1 + (x1 - cx1) * t;
                    y1 = cy1 + (y1 - cy1) * t;
                    x0 = coords[pos + 0];
                    y0 = coords[pos + 1];
                    cx0 = coords[pos + 2];
                    cy0 = coords[pos + 3];
                    x0 = x0 + (cx0 - x0) * t;
                    y0 = y0 + (cy0 - y0) * t;
                    cx0 = cx0 + (cx1 - cx0) * t;
                    cy0 = cy0 + (cy1 - cy0) * t;
                    cx1 = cx0 + (x1 - cx0) * t;
                    cy1 = cy0 + (y1 - cy0) * t;
                    cx0 = x0 + (cx0 - x0) * t;
                    cy0 = y0 + (cy0 - y0) * t;
                    coords[pos + 2] = x0;
                    coords[pos + 3] = y0;
                    coords[pos + 4] = cx0;
                    coords[pos + 5] = cy0;
                    coords[pos + 6] = cx0 + (cx1 - cx0) * t;
                    coords[pos + 7] = cy0 + (cy1 - cy0) * t;
                    coords[pos + 8] = cx1;
                    coords[pos + 9] = cy1;
                    coords[pos + 10] = x1;
                    coords[pos + 11] = y1;
                };
                Order3.prototype.getOrder = function () {
                    return 3;
                };
                Order3.prototype.getXTop = function () {
                    return this.x0;
                };
                Order3.prototype.getYTop = function () {
                    return this.y0;
                };
                Order3.prototype.getXBot = function () {
                    return this.x1;
                };
                Order3.prototype.getYBot = function () {
                    return this.y1;
                };
                Order3.prototype.getXMin = function () {
                    return this.xmin;
                };
                Order3.prototype.getXMax = function () {
                    return this.xmax;
                };
                Order3.prototype.getX0 = function () {
                    return (this.direction === sun.awt.geom.Curve.INCREASING) ? this.x0 : this.x1;
                };
                Order3.prototype.getY0 = function () {
                    return (this.direction === sun.awt.geom.Curve.INCREASING) ? this.y0 : this.y1;
                };
                Order3.prototype.getCX0 = function () {
                    return (this.direction === sun.awt.geom.Curve.INCREASING) ? this.cx0 : this.cx1;
                };
                Order3.prototype.getCY0 = function () {
                    return (this.direction === sun.awt.geom.Curve.INCREASING) ? this.cy0 : this.cy1;
                };
                Order3.prototype.getCX1 = function () {
                    return (this.direction === sun.awt.geom.Curve.DECREASING) ? this.cx0 : this.cx1;
                };
                Order3.prototype.getCY1 = function () {
                    return (this.direction === sun.awt.geom.Curve.DECREASING) ? this.cy0 : this.cy1;
                };
                Order3.prototype.getX1 = function () {
                    return (this.direction === sun.awt.geom.Curve.DECREASING) ? this.x0 : this.x1;
                };
                Order3.prototype.getY1 = function () {
                    return (this.direction === sun.awt.geom.Curve.DECREASING) ? this.y0 : this.y1;
                };
                Order3.prototype.TforY = function (y) {
                    if (y <= this.y0)
                        return 0;
                    if (y >= this.y1)
                        return 1;
                    if (y === this.YforT1)
                        return this.TforY1;
                    if (y === this.YforT2)
                        return this.TforY2;
                    if (y === this.YforT3)
                        return this.TforY3;
                    if (this.ycoeff3 === 0.0) {
                        return sun.awt.geom.Order2.TforY(y, this.ycoeff0, this.ycoeff1, this.ycoeff2);
                    }
                    var a = this.ycoeff2 / this.ycoeff3;
                    var b = this.ycoeff1 / this.ycoeff3;
                    var c = (this.ycoeff0 - y) / this.ycoeff3;
                    var roots = 0;
                    var Q = (a * a - 3.0 * b) / 9.0;
                    var R = (2.0 * a * a * a - 9.0 * a * b + 27.0 * c) / 54.0;
                    var R2 = R * R;
                    var Q3 = Q * Q * Q;
                    var a_3 = a / 3.0;
                    var t;
                    if (R2 < Q3) {
                        var theta = Math.acos(R / Math.sqrt(Q3));
                        Q = -2.0 * Math.sqrt(Q);
                        t = this.refine(a, b, c, y, Q * Math.cos(theta / 3.0) - a_3);
                        if (t < 0) {
                            t = this.refine(a, b, c, y, Q * Math.cos((theta + Math.PI * 2.0) / 3.0) - a_3);
                        }
                        if (t < 0) {
                            t = this.refine(a, b, c, y, Q * Math.cos((theta - Math.PI * 2.0) / 3.0) - a_3);
                        }
                    }
                    else {
                        var neg = (R < 0.0);
                        var S = Math.sqrt(R2 - Q3);
                        if (neg) {
                            R = -R;
                        }
                        var A = Math.pow(R + S, 1.0 / 3.0);
                        if (!neg) {
                            A = -A;
                        }
                        var B = (A === 0.0) ? 0.0 : (Q / A);
                        t = this.refine(a, b, c, y, (A + B) - a_3);
                    }
                    if (t < 0) {
                        var t0 = 0;
                        var t1 = 1;
                        while ((true)) {
                            t = (t0 + t1) / 2;
                            if (t === t0 || t === t1) {
                                break;
                            }
                            var yt = this.YforT(t);
                            if (yt < y) {
                                t0 = t;
                            }
                            else if (yt > y) {
                                t1 = t;
                            }
                            else {
                                break;
                            }
                        }
                        ;
                    }
                    if (t >= 0) {
                        this.TforY3 = this.TforY2;
                        this.YforT3 = this.YforT2;
                        this.TforY2 = this.TforY1;
                        this.YforT2 = this.YforT1;
                        this.TforY1 = t;
                        this.YforT1 = y;
                    }
                    return t;
                };
                Order3.prototype.refine = function (a, b, c, target, t) {
                    if (t < -0.1 || t > 1.1) {
                        return -1;
                    }
                    var y = this.YforT(t);
                    var t0;
                    var t1;
                    if (y < target) {
                        t0 = t;
                        t1 = 1;
                    }
                    else {
                        t0 = 0;
                        t1 = t;
                    }
                    var origt = t;
                    var origy = y;
                    var useslope = true;
                    while ((y !== target)) {
                        if (!useslope) {
                            var t2 = (t0 + t1) / 2;
                            if (t2 === t0 || t2 === t1) {
                                break;
                            }
                            t = t2;
                        }
                        else {
                            var slope = this.dYforT(t, 1);
                            if (slope === 0) {
                                useslope = false;
                                continue;
                            }
                            var t2 = t + ((target - y) / slope);
                            if (t2 === t || t2 <= t0 || t2 >= t1) {
                                useslope = false;
                                continue;
                            }
                            t = t2;
                        }
                        y = this.YforT(t);
                        if (y < target) {
                            t0 = t;
                        }
                        else if (y > target) {
                            t1 = t;
                        }
                        else {
                            break;
                        }
                    }
                    ;
                    var verbose = false;
                    if (false && t >= 0 && t <= 1) {
                        y = this.YforT(t);
                        var tdiff = geom.Curve.diffbits(t, origt);
                        var ydiff = geom.Curve.diffbits(y, origy);
                        var yerr = geom.Curve.diffbits(y, target);
                        if (yerr > 0 || (verbose && tdiff > 0)) {
                            console.info("target was y = " + target);
                            console.info("original was y = " + origy + ", t = " + origt);
                            console.info("final was y = " + y + ", t = " + t);
                            console.info("t diff is " + tdiff);
                            console.info("y diff is " + ydiff);
                            console.info("y error is " + yerr);
                            var tlow = geom.Curve.prev(t);
                            var ylow = this.YforT(tlow);
                            var thi = geom.Curve.next(t);
                            var yhi = this.YforT(thi);
                            if (Math.abs(target - ylow) < Math.abs(target - y) || Math.abs(target - yhi) < Math.abs(target - y)) {
                                console.info("adjacent y\'s = [" + ylow + ", " + yhi + "]");
                            }
                        }
                    }
                    return (t > 1) ? -1 : t;
                };
                Order3.prototype.XforY = function (y) {
                    if (y <= this.y0) {
                        return this.x0;
                    }
                    if (y >= this.y1) {
                        return this.x1;
                    }
                    return this.XforT(this.TforY(y));
                };
                Order3.prototype.XforT = function (t) {
                    return (((this.xcoeff3 * t) + this.xcoeff2) * t + this.xcoeff1) * t + this.xcoeff0;
                };
                Order3.prototype.YforT = function (t) {
                    return (((this.ycoeff3 * t) + this.ycoeff2) * t + this.ycoeff1) * t + this.ycoeff0;
                };
                Order3.prototype.dXforT = function (t, deriv) {
                    switch ((deriv)) {
                        case 0:
                            return (((this.xcoeff3 * t) + this.xcoeff2) * t + this.xcoeff1) * t + this.xcoeff0;
                        case 1:
                            return ((3 * this.xcoeff3 * t) + 2 * this.xcoeff2) * t + this.xcoeff1;
                        case 2:
                            return (6 * this.xcoeff3 * t) + 2 * this.xcoeff2;
                        case 3:
                            return 6 * this.xcoeff3;
                        default:
                            return 0;
                    }
                };
                Order3.prototype.dYforT = function (t, deriv) {
                    switch ((deriv)) {
                        case 0:
                            return (((this.ycoeff3 * t) + this.ycoeff2) * t + this.ycoeff1) * t + this.ycoeff0;
                        case 1:
                            return ((3 * this.ycoeff3 * t) + 2 * this.ycoeff2) * t + this.ycoeff1;
                        case 2:
                            return (6 * this.ycoeff3 * t) + 2 * this.ycoeff2;
                        case 3:
                            return 6 * this.ycoeff3;
                        default:
                            return 0;
                    }
                };
                Order3.prototype.nextVertical = function (t0, t1) {
                    var eqn = [this.xcoeff1, 2 * this.xcoeff2, 3 * this.xcoeff3];
                    var numroots = java.awt.geom.QuadCurve2D.solveQuadratic(eqn, eqn);
                    for (var i = 0; i < numroots; i++) {
                        if (eqn[i] > t0 && eqn[i] < t1) {
                            t1 = eqn[i];
                        }
                    }
                    return t1;
                };
                Order3.prototype.enlarge = function (r) {
                    r.add(this.x0, this.y0);
                    var eqn = [this.xcoeff1, 2 * this.xcoeff2, 3 * this.xcoeff3];
                    var numroots = java.awt.geom.QuadCurve2D.solveQuadratic(eqn, eqn);
                    for (var i = 0; i < numroots; i++) {
                        var t = eqn[i];
                        if (t > 0 && t < 1) {
                            r.add(this.XforT(t), this.YforT(t));
                        }
                    }
                    r.add(this.x1, this.y1);
                };
                Order3.prototype.getSubCurve = function (ystart, yend, dir) {
                    var _this = this;
                    if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && ((typeof dir === 'number') || dir === null)) {
                        return (function () {
                            if (ystart <= _this.y0 && yend >= _this.y1) {
                                return _this.getWithDirection(dir);
                            }
                            var eqn = new Array(14);
                            var t0;
                            var t1;
                            t0 = _this.TforY(ystart);
                            t1 = _this.TforY(yend);
                            eqn[0] = _this.x0;
                            eqn[1] = _this.y0;
                            eqn[2] = _this.cx0;
                            eqn[3] = _this.cy0;
                            eqn[4] = _this.cx1;
                            eqn[5] = _this.cy1;
                            eqn[6] = _this.x1;
                            eqn[7] = _this.y1;
                            if (t0 > t1) {
                                var t = t0;
                                t0 = t1;
                                t1 = t;
                            }
                            if (t1 < 1) {
                                Order3.split(eqn, 0, t1);
                            }
                            var i;
                            if (t0 <= 0) {
                                i = 0;
                            }
                            else {
                                Order3.split(eqn, 0, t0 / t1);
                                i = 6;
                            }
                            return new Order3(eqn[i + 0], ystart, eqn[i + 2], eqn[i + 3], eqn[i + 4], eqn[i + 5], eqn[i + 6], yend, dir);
                        })();
                    }
                    else if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && dir === undefined) {
                        return this.getSubCurve$double$double(ystart, yend);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Order3.prototype.getReversedCurve = function () {
                    return new Order3(this.x0, this.y0, this.cx0, this.cy0, this.cx1, this.cy1, this.x1, this.y1, -this.direction);
                };
                Order3.prototype.getSegment = function (coords) {
                    if (this.direction === sun.awt.geom.Curve.INCREASING) {
                        coords[0] = this.cx0;
                        coords[1] = this.cy0;
                        coords[2] = this.cx1;
                        coords[3] = this.cy1;
                        coords[4] = this.x1;
                        coords[5] = this.y1;
                    }
                    else {
                        coords[0] = this.cx1;
                        coords[1] = this.cy1;
                        coords[2] = this.cx0;
                        coords[3] = this.cy0;
                        coords[4] = this.x0;
                        coords[5] = this.y0;
                    }
                    return java.awt.geom.PathIterator.SEG_CUBICTO;
                };
                Order3.prototype.controlPointString = function () {
                    return (("(" + geom.Curve.round(this.getCX0()) + ", " + geom.Curve.round(this.getCY0()) + "), ") + ("(" + geom.Curve.round(this.getCX1()) + ", " + geom.Curve.round(this.getCY1()) + "), "));
                };
                return Order3;
            }(sun.awt.geom.Curve));
            geom.Order3 = Order3;
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var sun;
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var AreaOp = (function () {
                function AreaOp() {
                    this.verbose = false;
                }
                AreaOp.prototype.calculate = function (left, right) {
                    var edges = new java.util.Vector();
                    AreaOp.addEdges(edges, left, AreaOp.CTAG_LEFT);
                    AreaOp.addEdges(edges, right, AreaOp.CTAG_RIGHT);
                    edges = this.pruneEdges(edges);
                    if (this.verbose) {
                        console.info("result: ");
                        var numcurves = edges.size();
                        var curvelist = edges.toArray(new Array(numcurves));
                        for (var i = 0; i < numcurves; i++) {
                            console.info("curvelist[" + i + "] = " + curvelist[i]);
                        }
                    }
                    return edges;
                };
                AreaOp.addEdges = function (edges, curves, curvetag) {
                    var enum_ = curves.elements();
                    while ((enum_.hasMoreElements())) {
                        var c = enum_.nextElement();
                        if (c.getOrder() > 0) {
                            edges.add(new sun.awt.geom.Edge(c, curvetag));
                        }
                    }
                    ;
                };
                AreaOp.YXTopComparator_$LI$ = function () { if (AreaOp.YXTopComparator == null)
                    AreaOp.YXTopComparator = new AreaOp.AreaOp$0(); return AreaOp.YXTopComparator; };
                ;
                AreaOp.prototype.pruneEdges = function (edges) {
                    var numedges = edges.size();
                    if (numedges < 2) {
                        return edges;
                    }
                    var edgelist = edges.toArray(new Array(numedges));
                    java.util.Arrays.sort(edgelist, AreaOp.YXTopComparator_$LI$());
                    if (this.verbose) {
                        console.info("pruning: ");
                        for (var i = 0; i < numedges; i++) {
                            console.info("edgelist[" + i + "] = " + edgelist[i]);
                        }
                    }
                    var e;
                    var left = 0;
                    var right = 0;
                    var cur = 0;
                    var next = 0;
                    var yrange = new Array(2);
                    var subcurves = new java.util.Vector();
                    var chains = new java.util.Vector();
                    var links = new java.util.Vector();
                    while ((left < numedges)) {
                        var y = yrange[0];
                        for (cur = next = right - 1; cur >= left; cur--) {
                            e = edgelist[cur];
                            if (e.getCurve().getYBot() > y) {
                                if (next > cur) {
                                    edgelist[next] = e;
                                }
                                next--;
                            }
                        }
                        left = next + 1;
                        if (left >= right) {
                            if (right >= numedges) {
                                break;
                            }
                            y = edgelist[right].getCurve().getYTop();
                            if (y > yrange[0]) {
                                AreaOp.finalizeSubCurves(subcurves, chains);
                            }
                            yrange[0] = y;
                        }
                        while ((right < numedges)) {
                            e = edgelist[right];
                            if (e.getCurve().getYTop() > y) {
                                break;
                            }
                            right++;
                        }
                        ;
                        yrange[1] = edgelist[left].getCurve().getYBot();
                        if (right < numedges) {
                            y = edgelist[right].getCurve().getYTop();
                            if (yrange[1] > y) {
                                yrange[1] = y;
                            }
                        }
                        if (this.verbose) {
                            console.info("current line: y = [" + yrange[0] + ", " + yrange[1] + "]");
                            for (cur = left; cur < right; cur++) {
                                console.info("  " + edgelist[cur]);
                            }
                        }
                        var nexteq = 1;
                        for (cur = left; cur < right; cur++) {
                            e = edgelist[cur];
                            e.setEquivalence(0);
                            for (next = cur; next > left; next--) {
                                var prevedge = edgelist[next - 1];
                                var ordering = e.compareTo(prevedge, yrange);
                                if (yrange[1] <= yrange[0]) {
                                    throw new java.lang.InternalError("backstepping to " + yrange[1] + " from " + yrange[0]);
                                }
                                if (ordering >= 0) {
                                    if (ordering === 0) {
                                        var eq = prevedge.getEquivalence();
                                        if (eq === 0) {
                                            eq = nexteq++;
                                            prevedge.setEquivalence(eq);
                                        }
                                        e.setEquivalence(eq);
                                    }
                                    break;
                                }
                                edgelist[next] = prevedge;
                            }
                            edgelist[next] = e;
                        }
                        if (this.verbose) {
                            console.info("current sorted line: y = [" + yrange[0] + ", " + yrange[1] + "]");
                            for (cur = left; cur < right; cur++) {
                                console.info("  " + edgelist[cur]);
                            }
                        }
                        this.newRow();
                        var ystart = yrange[0];
                        var yend = yrange[1];
                        for (cur = left; cur < right; cur++) {
                            e = edgelist[cur];
                            var etag;
                            var eq = e.getEquivalence();
                            if (eq !== 0) {
                                var origstate = this.getState();
                                etag = (origstate === AreaOp.RSTAG_INSIDE ? AreaOp.ETAG_EXIT : AreaOp.ETAG_ENTER);
                                var activematch = null;
                                var longestmatch = e;
                                var furthesty = yend;
                                do {
                                    this.classify(e);
                                    if (activematch == null && e.isActiveFor(ystart, etag)) {
                                        activematch = e;
                                    }
                                    y = e.getCurve().getYBot();
                                    if (y > furthesty) {
                                        longestmatch = e;
                                        furthesty = y;
                                    }
                                } while ((++cur < right && (e = edgelist[cur]).getEquivalence() === eq));
                                --cur;
                                if (this.getState() === origstate) {
                                    etag = AreaOp.ETAG_IGNORE;
                                }
                                else {
                                    e = (activematch != null ? activematch : longestmatch);
                                }
                            }
                            else {
                                etag = this.classify(e);
                            }
                            if (etag !== AreaOp.ETAG_IGNORE) {
                                e.record(yend, etag);
                                links.add(new sun.awt.geom.CurveLink(e.getCurve(), ystart, yend, etag));
                            }
                        }
                        if (this.getState() !== AreaOp.RSTAG_OUTSIDE) {
                            console.info("Still inside at end of active edge list!");
                            console.info("num curves = " + (right - left));
                            console.info("num links = " + links.size());
                            console.info("y top = " + yrange[0]);
                            if (right < numedges) {
                                console.info("y top of next curve = " + edgelist[right].getCurve().getYTop());
                            }
                            else {
                                console.info("no more curves");
                            }
                            for (cur = left; cur < right; cur++) {
                                e = edgelist[cur];
                                console.info(e);
                                var eq = e.getEquivalence();
                                if (eq !== 0) {
                                    console.info("  was equal to " + eq + "...");
                                }
                            }
                        }
                        if (this.verbose) {
                            console.info("new links:");
                            for (var i = 0; i < links.size(); i++) {
                                var link = links.elementAt(i);
                                console.info("  " + link.getSubCurve());
                            }
                        }
                        AreaOp.resolveLinks(subcurves, chains, links);
                        links.clear();
                        yrange[0] = yend;
                    }
                    ;
                    AreaOp.finalizeSubCurves(subcurves, chains);
                    var ret = new java.util.Vector();
                    var enum_ = subcurves.elements();
                    while ((enum_.hasMoreElements())) {
                        var link = enum_.nextElement();
                        ret.add(link.getMoveto());
                        var nextlink = link;
                        while (((nextlink = nextlink.getNext()) != null)) {
                            if (!link.absorb(nextlink)) {
                                ret.add(link.getSubCurve());
                                link = nextlink;
                            }
                        }
                        ;
                        ret.add(link.getSubCurve());
                    }
                    ;
                    return ret;
                };
                AreaOp.finalizeSubCurves = function (subcurves, chains) {
                    var numchains = chains.size();
                    if (numchains === 0) {
                        return;
                    }
                    if ((numchains & 1) !== 0) {
                        throw new java.lang.InternalError("Odd number of chains!");
                    }
                    var endlist = new Array(numchains);
                    chains.toArray(endlist);
                    for (var i = 1; i < numchains; i += 2) {
                        var open = endlist[i - 1];
                        var close = endlist[i];
                        var subcurve = open.linkTo(close);
                        if (subcurve != null) {
                            subcurves.add(subcurve);
                        }
                    }
                    chains.clear();
                };
                AreaOp.EmptyLinkList_$LI$ = function () { if (AreaOp.EmptyLinkList == null)
                    AreaOp.EmptyLinkList = new Array(2); return AreaOp.EmptyLinkList; };
                ;
                AreaOp.EmptyChainList_$LI$ = function () { if (AreaOp.EmptyChainList == null)
                    AreaOp.EmptyChainList = new Array(2); return AreaOp.EmptyChainList; };
                ;
                AreaOp.resolveLinks = function (subcurves, chains, links) {
                    var numlinks = links.size();
                    var linklist;
                    if (numlinks === 0) {
                        linklist = AreaOp.EmptyLinkList_$LI$();
                    }
                    else {
                        if ((numlinks & 1) !== 0) {
                            throw new java.lang.InternalError("Odd number of new curves!");
                        }
                        linklist = new Array(numlinks + 2);
                        links.toArray(linklist);
                    }
                    var numchains = chains.size();
                    var endlist;
                    if (numchains === 0) {
                        endlist = AreaOp.EmptyChainList_$LI$();
                    }
                    else {
                        if ((numchains & 1) !== 0) {
                            throw new java.lang.InternalError("Odd number of chains!");
                        }
                        endlist = new Array(numchains + 2);
                        chains.toArray(endlist);
                    }
                    var curchain = 0;
                    var curlink = 0;
                    chains.clear();
                    var chain = endlist[0];
                    var nextchain = endlist[1];
                    var link = linklist[0];
                    var nextlink = linklist[1];
                    while ((chain != null || link != null)) {
                        var connectchains = (link == null);
                        var connectlinks = (chain == null);
                        if (!connectchains && !connectlinks) {
                            connectchains = ((curchain & 1) === 0 && chain.getX() === nextchain.getX());
                            connectlinks = ((curlink & 1) === 0 && link.getX() === nextlink.getX());
                            if (!connectchains && !connectlinks) {
                                var cx = chain.getX();
                                var lx = link.getX();
                                connectchains = (nextchain != null && cx < lx && AreaOp.obstructs(nextchain.getX(), lx, curchain));
                                connectlinks = (nextlink != null && lx < cx && AreaOp.obstructs(nextlink.getX(), cx, curlink));
                            }
                        }
                        if (connectchains) {
                            var subcurve = chain.linkTo(nextchain);
                            if (subcurve != null) {
                                subcurves.add(subcurve);
                            }
                            curchain += 2;
                            chain = endlist[curchain];
                            nextchain = endlist[curchain + 1];
                        }
                        if (connectlinks) {
                            var openend = new sun.awt.geom.ChainEnd(link, null);
                            var closeend = new sun.awt.geom.ChainEnd(nextlink, openend);
                            openend.setOtherEnd(closeend);
                            chains.add(openend);
                            chains.add(closeend);
                            curlink += 2;
                            link = linklist[curlink];
                            nextlink = linklist[curlink + 1];
                        }
                        if (!connectchains && !connectlinks) {
                            chain.addLink(link);
                            chains.add(chain);
                            curchain++;
                            chain = nextchain;
                            nextchain = endlist[curchain + 1];
                            curlink++;
                            link = nextlink;
                            nextlink = linklist[curlink + 1];
                        }
                    }
                    ;
                    if ((chains.size() & 1) !== 0) {
                        console.info("Odd number of chains!");
                    }
                };
                AreaOp.obstructs = function (v1, v2, phase) {
                    return (((phase & 1) === 0) ? (v1 <= v2) : (v1 < v2));
                };
                AreaOp.CTAG_LEFT = 0;
                AreaOp.CTAG_RIGHT = 1;
                AreaOp.ETAG_IGNORE = 0;
                AreaOp.ETAG_ENTER = 1;
                AreaOp.ETAG_EXIT = -1;
                AreaOp.RSTAG_INSIDE = 1;
                AreaOp.RSTAG_OUTSIDE = -1;
                return AreaOp;
            }());
            geom.AreaOp = AreaOp;
            var AreaOp;
            (function (AreaOp) {
                var CAGOp = (function (_super) {
                    __extends(CAGOp, _super);
                    function CAGOp() {
                        _super.call(this);
                        this.inLeft = false;
                        this.inRight = false;
                        this.inResult = false;
                    }
                    CAGOp.prototype.newRow = function () {
                        this.inLeft = false;
                        this.inRight = false;
                        this.inResult = false;
                    };
                    CAGOp.prototype.classify = function (e) {
                        if (e.getCurveTag() === sun.awt.geom.AreaOp.CTAG_LEFT) {
                            this.inLeft = !this.inLeft;
                        }
                        else {
                            this.inRight = !this.inRight;
                        }
                        var newClass = this.newClassification(this.inLeft, this.inRight);
                        if (this.inResult === newClass) {
                            return sun.awt.geom.AreaOp.ETAG_IGNORE;
                        }
                        this.inResult = newClass;
                        return (newClass ? sun.awt.geom.AreaOp.ETAG_ENTER : sun.awt.geom.AreaOp.ETAG_EXIT);
                    };
                    CAGOp.prototype.getState = function () {
                        return (this.inResult ? sun.awt.geom.AreaOp.RSTAG_INSIDE : sun.awt.geom.AreaOp.RSTAG_OUTSIDE);
                    };
                    return CAGOp;
                }(sun.awt.geom.AreaOp));
                AreaOp.CAGOp = CAGOp;
                var AddOp = (function (_super) {
                    __extends(AddOp, _super);
                    function AddOp() {
                        _super.apply(this, arguments);
                    }
                    AddOp.prototype.newClassification = function (inLeft, inRight) {
                        return (inLeft || inRight);
                    };
                    return AddOp;
                }(AreaOp.CAGOp));
                AreaOp.AddOp = AddOp;
                var SubOp = (function (_super) {
                    __extends(SubOp, _super);
                    function SubOp() {
                        _super.apply(this, arguments);
                    }
                    SubOp.prototype.newClassification = function (inLeft, inRight) {
                        return (inLeft && !inRight);
                    };
                    return SubOp;
                }(AreaOp.CAGOp));
                AreaOp.SubOp = SubOp;
                var IntOp = (function (_super) {
                    __extends(IntOp, _super);
                    function IntOp() {
                        _super.apply(this, arguments);
                    }
                    IntOp.prototype.newClassification = function (inLeft, inRight) {
                        return (inLeft && inRight);
                    };
                    return IntOp;
                }(AreaOp.CAGOp));
                AreaOp.IntOp = IntOp;
                var XorOp = (function (_super) {
                    __extends(XorOp, _super);
                    function XorOp() {
                        _super.apply(this, arguments);
                    }
                    XorOp.prototype.newClassification = function (inLeft, inRight) {
                        return (inLeft !== inRight);
                    };
                    return XorOp;
                }(AreaOp.CAGOp));
                AreaOp.XorOp = XorOp;
                var NZWindOp = (function (_super) {
                    __extends(NZWindOp, _super);
                    function NZWindOp() {
                        _super.call(this);
                        this.count = 0;
                    }
                    NZWindOp.prototype.newRow = function () {
                        this.count = 0;
                    };
                    NZWindOp.prototype.classify = function (e) {
                        var newCount = this.count;
                        var type = (newCount === 0 ? sun.awt.geom.AreaOp.ETAG_ENTER : sun.awt.geom.AreaOp.ETAG_IGNORE);
                        newCount += e.getCurve().getDirection();
                        this.count = newCount;
                        return (newCount === 0 ? sun.awt.geom.AreaOp.ETAG_EXIT : type);
                    };
                    NZWindOp.prototype.getState = function () {
                        return ((this.count === 0) ? sun.awt.geom.AreaOp.RSTAG_OUTSIDE : sun.awt.geom.AreaOp.RSTAG_INSIDE);
                    };
                    return NZWindOp;
                }(sun.awt.geom.AreaOp));
                AreaOp.NZWindOp = NZWindOp;
                var EOWindOp = (function (_super) {
                    __extends(EOWindOp, _super);
                    function EOWindOp() {
                        _super.call(this);
                        this.inside = false;
                    }
                    EOWindOp.prototype.newRow = function () {
                        this.inside = false;
                    };
                    EOWindOp.prototype.classify = function (e) {
                        var newInside = !this.inside;
                        this.inside = newInside;
                        return (newInside ? sun.awt.geom.AreaOp.ETAG_ENTER : sun.awt.geom.AreaOp.ETAG_EXIT);
                    };
                    EOWindOp.prototype.getState = function () {
                        return (this.inside ? sun.awt.geom.AreaOp.RSTAG_INSIDE : sun.awt.geom.AreaOp.RSTAG_OUTSIDE);
                    };
                    return EOWindOp;
                }(sun.awt.geom.AreaOp));
                AreaOp.EOWindOp = EOWindOp;
                var AreaOp$0 = (function () {
                    function AreaOp$0() {
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Comparator"] });
                    }
                    AreaOp$0.prototype.compare = function (o1, o2) {
                        var c1 = o1.getCurve();
                        var c2 = o2.getCurve();
                        var v1;
                        var v2;
                        if ((v1 = c1.getYTop()) === (v2 = c2.getYTop())) {
                            if ((v1 = c1.getXTop()) === (v2 = c2.getXTop())) {
                                return 0;
                            }
                        }
                        if (v1 < v2) {
                            return -1;
                        }
                        return 1;
                    };
                    return AreaOp$0;
                }());
                AreaOp.AreaOp$0 = AreaOp$0;
            })(AreaOp = geom.AreaOp || (geom.AreaOp = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The {@code GeneralPath} class represents a geometric path constructed from
             * straight lines, and quadratic and cubic (B&eacute;zier) curves. It can
             * contain multiple subpaths.
             * <p>
             * {@code GeneralPath} is a legacy final class which exactly implements the
             * behavior of its superclass {@link Path2D.Float}. Together with
             * {@link Path2D.Double}, the {@link Path2D} classes provide full
             * implementations of a general geometric path that support all of the
             * functionality of the {@link Shape} and {@link PathIterator} interfaces with
             * the ability to explicitly select different levels of internal coordinate
             * precision.
             * <p>
             * Use {@code Path2D.Float} (or this legacy {@code GeneralPath} subclass) when
             * dealing with data that can be represented and used with floating point
             * precision. Use {@code Path2D.Double} for data that requires the accuracy or
             * range of double precision.
             *
             * @author Jim Graham
             * @since 1.2
             */
            var GeneralPath = (function (_super) {
                __extends(GeneralPath, _super);
                function GeneralPath(windingRule, pointTypes, numTypes, pointCoords, numCoords) {
                    var _this = this;
                    if (((typeof windingRule === 'number') || windingRule === null) && ((pointTypes != null && pointTypes instanceof Array) || pointTypes === null) && ((typeof numTypes === 'number') || numTypes === null) && ((pointCoords != null && pointCoords instanceof Array) || pointCoords === null) && ((typeof numCoords === 'number') || numCoords === null)) {
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                        (function () {
                            _this.windingRule = windingRule;
                            _this.pointTypes = pointTypes;
                            _this.numTypes = numTypes;
                            _this.floatCoords = pointCoords;
                            _this.numCoords = numCoords;
                        })();
                    }
                    else if (((typeof windingRule === 'number') || windingRule === null) && ((typeof pointTypes === 'number') || pointTypes === null) && numTypes === undefined && pointCoords === undefined && numCoords === undefined) {
                        var rule = windingRule;
                        var initialCapacity = pointTypes;
                        _super.call(this, rule, initialCapacity);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                        (function () {
                        })();
                    }
                    else if (((windingRule != null && windingRule["__interfaces"] != null && windingRule["__interfaces"].indexOf("java.awt.Shape") >= 0) || windingRule === null) && pointTypes === undefined && numTypes === undefined && pointCoords === undefined && numCoords === undefined) {
                        var s = windingRule;
                        _super.call(this, s, null);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                        (function () {
                        })();
                    }
                    else if (((typeof windingRule === 'number') || windingRule === null) && pointTypes === undefined && numTypes === undefined && pointCoords === undefined && numCoords === undefined) {
                        var rule = windingRule;
                        _super.call(this, rule, java.awt.geom.Path2D.INIT_SIZE);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                        (function () {
                        })();
                    }
                    else if (windingRule === undefined && pointTypes === undefined && numTypes === undefined && pointCoords === undefined && numCoords === undefined) {
                        _super.call(this, java.awt.geom.Path2D.WIND_NON_ZERO_$LI$(), java.awt.geom.Path2D.INIT_SIZE);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                        (function () {
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                }
                GeneralPath.serialVersionUID = -8327096662768731142;
                return GeneralPath;
            }(java.awt.geom.Path2D.Float));
            geom.GeneralPath = GeneralPath;
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        /**
         * A <code>Rectangle</code> specifies an area in a coordinate space that is
         * enclosed by the <code>Rectangle</code> object's upper-left point
         * {@code (x,y)}
         * in the coordinate space, its width, and its height.
         * <p>
         * A <code>Rectangle</code> object's <code>width</code> and
         * <code>height</code> are <code>public</code> fields. The constructors
         * that create a <code>Rectangle</code>, and the methods that can modify
         * one, do not prevent setting a negative value for width or height.
         * <p>
         * <a name="Empty">
         * A {@code Rectangle} whose width or height is exactly zero has location
         * along those axes with zero dimension, but is otherwise considered empty.
         * The {@link #isEmpty} method will return true for such a {@code Rectangle}.
         * Methods which test if an empty {@code Rectangle} contains or intersects
         * a point or rectangle will always return false if either dimension is zero.
         * Methods which combine such a {@code Rectangle} with a point or rectangle
         * will include the location of the {@code Rectangle} on that axis in the
         * result as if the {@link #add(Point)} method were being called.
         * </a>
         * <p>
         * <a name="NonExistant">
         * A {@code Rectangle} whose width or height is negative has neither
         * location nor dimension along those axes with negative dimensions.
         * Such a {@code Rectangle} is treated as non-existant along those axes.
         * Such a {@code Rectangle} is also empty with respect to containment
         * calculations and methods which test if it contains or intersects a
         * point or rectangle will always return false.
         * Methods which combine such a {@code Rectangle} with a point or rectangle
         * will ignore the {@code Rectangle} entirely in generating the result.
         * If two {@code Rectangle} objects are combined and each has a negative
         * dimension, the result will have at least one negative dimension.
         * </a>
         * <p>
         * Methods which affect only the location of a {@code Rectangle} will
         * operate on its location regardless of whether or not it has a negative
         * or zero dimension along either axis.
         * <p>
         * Note that a {@code Rectangle} constructed with the default no-argument
         * constructor will have dimensions of {@code 0x0} and therefore be empty.
         * That {@code Rectangle} will still have a location of {@code (0,0)} and
         * will contribute that location to the union and add operations.
         * Code attempting to accumulate the bounds of a set of points should
         * therefore initially construct the {@code Rectangle} with a specifically
         * negative width and height or it should use the first point in the set
         * to construct the {@code Rectangle}.
         * For example:
         * <pre>{@code
         * Rectangle bounds = new Rectangle(0, 0, -1, -1);
         * for (int i = 0; i < points.length; i++) {
         * bounds.add(points[i]);
         * }
         * }</pre>
         * or if we know that the points array contains at least one point:
         * <pre>{@code
         * Rectangle bounds = new Rectangle(points[0]);
         * for (int i = 1; i < points.length; i++) {
         * bounds.add(points[i]);
         * }
         * }</pre>
         * <p>
         * This class uses 32-bit integers to store its location and dimensions.
         * Frequently operations may produce a result that exceeds the range of
         * a 32-bit integer.
         * The methods will calculate their results in a way that avoids any
         * 32-bit overflow for intermediate results and then choose the best
         * representation to store the final results back into the 32-bit fields
         * which hold the location and dimensions.
         * The location of the result will be stored into the {@link #x} and
         * {@link #y} fields by clipping the true result to the nearest 32-bit value.
         * The values stored into the {@link #width} and {@link #height} dimension
         * fields will be chosen as the 32-bit values that encompass the largest
         * part of the true result as possible.
         * Generally this means that the dimension will be clipped independently
         * to the range of 32-bit integers except that if the location had to be
         * moved to store it into its pair of 32-bit fields then the dimensions
         * will be adjusted relative to the "best representation" of the location.
         * If the true result had a negative dimension and was therefore
         * non-existant along one or both axes, the stored dimensions will be
         * negative numbers in those axes.
         * If the true result had a location that could be represented within
         * the range of 32-bit integers, but zero dimension along one or both
         * axes, then the stored dimensions will be zero in those axes.
         *
         * @author      Sami Shaio
         * @since 1.0
         */
        var Rectangle = (function (_super) {
            __extends(Rectangle, _super);
            /**
             * Constructs a new <code>Rectangle</code> whose upper-left corner is
             * specified as
             * {@code (x,y)} and whose width and height
             * are specified by the arguments of the same name.
             * @param     x the specified X coordinate
             * @param     y the specified Y coordinate
             * @param     width    the width of the <code>Rectangle</code>
             * @param     height   the height of the <code>Rectangle</code>
             * @since 1.0
             */
            function Rectangle(x, y, width, height) {
                var _this = this;
                if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof width === 'number') || width === null) && ((typeof height === 'number') || height === null)) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                    this.x = 0;
                    this.y = 0;
                    this.width = 0;
                    this.height = 0;
                    (function () {
                        _this.x = x;
                        _this.y = y;
                        _this.width = width;
                        _this.height = height;
                    })();
                }
                else if (((x != null && x instanceof java.awt.Point) || x === null) && ((y != null && y instanceof java.awt.Dimension) || y === null) && width === undefined && height === undefined) {
                    var p = x;
                    var d = y;
                    {
                        var x = p.x;
                        var y = p.y;
                        var width = d.width;
                        var height = d.height;
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                        this.x = 0;
                        this.y = 0;
                        this.width = 0;
                        this.height = 0;
                        (function () {
                            _this.x = x;
                            _this.y = y;
                            _this.width = width;
                            _this.height = height;
                        })();
                    }
                    (function () {
                    })();
                }
                else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && width === undefined && height === undefined) {
                    var width = x;
                    var height = y;
                    {
                        var x = 0;
                        var y = 0;
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                        this.x = 0;
                        this.y = 0;
                        this.width = 0;
                        this.height = 0;
                        (function () {
                            _this.x = x;
                            _this.y = y;
                            _this.width = width;
                            _this.height = height;
                        })();
                    }
                    (function () {
                    })();
                }
                else if (((x != null && x instanceof java.awt.Rectangle) || x === null) && y === undefined && width === undefined && height === undefined) {
                    var r = x;
                    {
                        var x = r.x;
                        var y = r.y;
                        var width = r.width;
                        var height = r.height;
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                        this.x = 0;
                        this.y = 0;
                        this.width = 0;
                        this.height = 0;
                        (function () {
                            _this.x = x;
                            _this.y = y;
                            _this.width = width;
                            _this.height = height;
                        })();
                    }
                    (function () {
                    })();
                }
                else if (((x != null && x instanceof java.awt.Point) || x === null) && y === undefined && width === undefined && height === undefined) {
                    var p = x;
                    {
                        var x = p.x;
                        var y = p.y;
                        var width = 0;
                        var height = 0;
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                        this.x = 0;
                        this.y = 0;
                        this.width = 0;
                        this.height = 0;
                        (function () {
                            _this.x = x;
                            _this.y = y;
                            _this.width = width;
                            _this.height = height;
                        })();
                    }
                    (function () {
                    })();
                }
                else if (((x != null && x instanceof java.awt.Dimension) || x === null) && y === undefined && width === undefined && height === undefined) {
                    var d = x;
                    {
                        var x = 0;
                        var y = 0;
                        var width = d.width;
                        var height = d.height;
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                        this.x = 0;
                        this.y = 0;
                        this.width = 0;
                        this.height = 0;
                        (function () {
                            _this.x = x;
                            _this.y = y;
                            _this.width = width;
                            _this.height = height;
                        })();
                    }
                    (function () {
                    })();
                }
                else if (x === undefined && y === undefined && width === undefined && height === undefined) {
                    {
                        var x = 0;
                        var y = 0;
                        var width = 0;
                        var height = 0;
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"] });
                        this.x = 0;
                        this.y = 0;
                        this.width = 0;
                        this.height = 0;
                        (function () {
                            _this.x = x;
                            _this.y = y;
                            _this.width = width;
                            _this.height = height;
                        })();
                    }
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * Returns the X coordinate of the bounding <code>Rectangle</code> in
             * <code>double</code> precision.
             * @return the X coordinate of the bounding <code>Rectangle</code>.
             */
            Rectangle.prototype.getX = function () {
                return this.x;
            };
            /**
             * Returns the Y coordinate of the bounding <code>Rectangle</code> in
             * <code>double</code> precision.
             * @return the Y coordinate of the bounding <code>Rectangle</code>.
             */
            Rectangle.prototype.getY = function () {
                return this.y;
            };
            /**
             * Returns the width of the bounding <code>Rectangle</code> in
             * <code>double</code> precision.
             * @return the width of the bounding <code>Rectangle</code>.
             */
            Rectangle.prototype.getWidth = function () {
                return this.width;
            };
            /**
             * Returns the height of the bounding <code>Rectangle</code> in
             * <code>double</code> precision.
             * @return the height of the bounding <code>Rectangle</code>.
             */
            Rectangle.prototype.getHeight = function () {
                return this.height;
            };
            /**
             * Gets the bounding <code>Rectangle</code> of this <code>Rectangle</code>.
             * <p>
             * This method is included for completeness, to parallel the
             * <code>getBounds</code> method of
             * {@link Component}.
             * @return    a new <code>Rectangle</code>, equal to the
             * bounding <code>Rectangle</code> for this <code>Rectangle</code>.
             * @see       java.awt.Component#getBounds
             * @see       #setBounds(Rectangle)
             * @see       #setBounds(int, int, int, int)
             * @since     1.1
             */
            Rectangle.prototype.getBounds = function () {
                return new Rectangle(this.x, this.y, this.width, this.height);
            };
            /**
             * {@inheritDoc}
             * @since 1.2
             */
            Rectangle.prototype.getBounds2D = function () {
                return new Rectangle(this.x, this.y, this.width, this.height);
            };
            /**
             * Sets the bounding <code>Rectangle</code> of this <code>Rectangle</code>
             * to match the specified <code>Rectangle</code>.
             * <p>
             * This method is included for completeness, to parallel the
             * <code>setBounds</code> method of <code>Component</code>.
             * @param r the specified <code>Rectangle</code>
             * @see       #getBounds
             * @see       java.awt.Component#setBounds(java.awt.Rectangle)
             * @since     1.1
             */
            Rectangle.prototype.setBounds$java_awt_Rectangle = function (r) {
                this.setBounds(r.x, r.y, r.width, r.height);
            };
            /**
             * Sets the bounding <code>Rectangle</code> of this
             * <code>Rectangle</code> to the specified
             * <code>x</code>, <code>y</code>, <code>width</code>,
             * and <code>height</code>.
             * <p>
             * This method is included for completeness, to parallel the
             * <code>setBounds</code> method of <code>Component</code>.
             * @param x the new X coordinate for the upper-left
             * corner of this <code>Rectangle</code>
             * @param y the new Y coordinate for the upper-left
             * corner of this <code>Rectangle</code>
             * @param width the new width for this <code>Rectangle</code>
             * @param height the new height for this <code>Rectangle</code>
             * @see       #getBounds
             * @see       java.awt.Component#setBounds(int, int, int, int)
             * @since     1.1
             */
            Rectangle.prototype.setBounds = function (x, y, width, height) {
                var _this = this;
                if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof width === 'number') || width === null) && ((typeof height === 'number') || height === null)) {
                    return (function () {
                        _this.reshape(x, y, width, height);
                    })();
                }
                else if (((x != null && x instanceof java.awt.Rectangle) || x === null) && y === undefined && width === undefined && height === undefined) {
                    return this.setBounds$java_awt_Rectangle(x);
                }
                else
                    throw new Error('invalid overload');
            };
            Rectangle.prototype.setRect = function (x, y, w, h) {
                if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                    return this.setRect$double$double$double$double(x, y, w, h);
                }
                else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                    return this.setRect$java_awt_geom_Rectangle2D(x);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Sets the bounds of this {@code Rectangle} to the integer bounds
             * which encompass the specified {@code x}, {@code y}, {@code width},
             * and {@code height}.
             * If the parameters specify a {@code Rectangle} that exceeds the
             * maximum range of integers, the result will be the best
             * representation of the specified {@code Rectangle} intersected
             * with the maximum integer bounds.
             * @param x the X coordinate of the upper-left corner of
             * the specified rectangle
             * @param y the Y coordinate of the upper-left corner of
             * the specified rectangle
             * @param width the width of the specified rectangle
             * @param height the new height of the specified rectangle
             */
            Rectangle.prototype.setRect$double$double$double$double = function (x, y, width, height) {
                var newx;
                var newy;
                var neww;
                var newh;
                if (x > 2.0 * javaemul.internal.IntegerHelper.MAX_VALUE) {
                    newx = javaemul.internal.IntegerHelper.MAX_VALUE;
                    neww = -1;
                }
                else {
                    newx = Rectangle.clip(x, false);
                    if (width >= 0)
                        width += x - newx;
                    neww = Rectangle.clip(width, width >= 0);
                }
                if (y > 2.0 * javaemul.internal.IntegerHelper.MAX_VALUE) {
                    newy = javaemul.internal.IntegerHelper.MAX_VALUE;
                    newh = -1;
                }
                else {
                    newy = Rectangle.clip(y, false);
                    if (height >= 0)
                        height += y - newy;
                    newh = Rectangle.clip(height, height >= 0);
                }
                this.reshape(newx, newy, neww, newh);
            };
            Rectangle.clip = function (v, doceil) {
                if (v <= javaemul.internal.IntegerHelper.MIN_VALUE) {
                    return javaemul.internal.IntegerHelper.MIN_VALUE;
                }
                if (v >= javaemul.internal.IntegerHelper.MAX_VALUE) {
                    return javaemul.internal.IntegerHelper.MAX_VALUE;
                }
                return ((doceil ? Math.ceil(v) : Math.floor(v)) | 0);
            };
            /**
             * Sets the bounding <code>Rectangle</code> of this
             * <code>Rectangle</code> to the specified
             * <code>x</code>, <code>y</code>, <code>width</code>,
             * and <code>height</code>.
             * <p>
             * @param x the new X coordinate for the upper-left
             * corner of this <code>Rectangle</code>
             * @param y the new Y coordinate for the upper-left
             * corner of this <code>Rectangle</code>
             * @param width the new width for this <code>Rectangle</code>
             * @param height the new height for this <code>Rectangle</code>
             * @deprecated As of JDK version 1.1,
             * replaced by <code>setBounds(int, int, int, int)</code>.
             */
            Rectangle.prototype.reshape = function (x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            };
            /**
             * Returns the location of this <code>Rectangle</code>.
             * <p>
             * This method is included for completeness, to parallel the
             * <code>getLocation</code> method of <code>Component</code>.
             * @return the <code>Point</code> that is the upper-left corner of
             * this <code>Rectangle</code>.
             * @see       java.awt.Component#getLocation
             * @see       #setLocation(Point)
             * @see       #setLocation(int, int)
             * @since     1.1
             */
            Rectangle.prototype.getLocation = function () {
                return new java.awt.Point(this.x, this.y);
            };
            /**
             * Moves this <code>Rectangle</code> to the specified location.
             * <p>
             * This method is included for completeness, to parallel the
             * <code>setLocation</code> method of <code>Component</code>.
             * @param p the <code>Point</code> specifying the new location
             * for this <code>Rectangle</code>
             * @see       java.awt.Component#setLocation(java.awt.Point)
             * @see       #getLocation
             * @since     1.1
             */
            Rectangle.prototype.setLocation$java_awt_Point = function (p) {
                this.setLocation(p.x, p.y);
            };
            /**
             * Moves this <code>Rectangle</code> to the specified location.
             * <p>
             * This method is included for completeness, to parallel the
             * <code>setLocation</code> method of <code>Component</code>.
             * @param x the X coordinate of the new location
             * @param y the Y coordinate of the new location
             * @see       #getLocation
             * @see       java.awt.Component#setLocation(int, int)
             * @since     1.1
             */
            Rectangle.prototype.setLocation = function (x, y) {
                var _this = this;
                if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return (function () {
                        _this.move(x, y);
                    })();
                }
                else if (((x != null && x instanceof java.awt.Point) || x === null) && y === undefined) {
                    return this.setLocation$java_awt_Point(x);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Moves this <code>Rectangle</code> to the specified location.
             * <p>
             * @param x the X coordinate of the new location
             * @param y the Y coordinate of the new location
             * @deprecated As of JDK version 1.1,
             * replaced by <code>setLocation(int, int)</code>.
             */
            Rectangle.prototype.move = function (x, y) {
                this.x = x;
                this.y = y;
            };
            /**
             * Translates this <code>Rectangle</code> the indicated distance,
             * to the right along the X coordinate axis, and
             * downward along the Y coordinate axis.
             * @param dx the distance to move this <code>Rectangle</code>
             * along the X axis
             * @param dy the distance to move this <code>Rectangle</code>
             * along the Y axis
             * @see       java.awt.Rectangle#setLocation(int, int)
             * @see       java.awt.Rectangle#setLocation(java.awt.Point)
             */
            Rectangle.prototype.translate = function (dx, dy) {
                var oldv = this.x;
                var newv = oldv + dx;
                if (dx < 0) {
                    if (newv > oldv) {
                        if (this.width >= 0) {
                            this.width += newv - javaemul.internal.IntegerHelper.MIN_VALUE;
                        }
                        newv = javaemul.internal.IntegerHelper.MIN_VALUE;
                    }
                }
                else {
                    if (newv < oldv) {
                        if (this.width >= 0) {
                            this.width += newv - javaemul.internal.IntegerHelper.MAX_VALUE;
                            if (this.width < 0)
                                this.width = javaemul.internal.IntegerHelper.MAX_VALUE;
                        }
                        newv = javaemul.internal.IntegerHelper.MAX_VALUE;
                    }
                }
                this.x = newv;
                oldv = this.y;
                newv = oldv + dy;
                if (dy < 0) {
                    if (newv > oldv) {
                        if (this.height >= 0) {
                            this.height += newv - javaemul.internal.IntegerHelper.MIN_VALUE;
                        }
                        newv = javaemul.internal.IntegerHelper.MIN_VALUE;
                    }
                }
                else {
                    if (newv < oldv) {
                        if (this.height >= 0) {
                            this.height += newv - javaemul.internal.IntegerHelper.MAX_VALUE;
                            if (this.height < 0)
                                this.height = javaemul.internal.IntegerHelper.MAX_VALUE;
                        }
                        newv = javaemul.internal.IntegerHelper.MAX_VALUE;
                    }
                }
                this.y = newv;
            };
            /**
             * Gets the size of this <code>Rectangle</code>, represented by
             * the returned <code>Dimension</code>.
             * <p>
             * This method is included for completeness, to parallel the
             * <code>getSize</code> method of <code>Component</code>.
             * @return a <code>Dimension</code>, representing the size of
             * this <code>Rectangle</code>.
             * @see       java.awt.Component#getSize
             * @see       #setSize(Dimension)
             * @see       #setSize(int, int)
             * @since     1.1
             */
            Rectangle.prototype.getSize = function () {
                return new java.awt.Dimension(this.width, this.height);
            };
            /**
             * Sets the size of this <code>Rectangle</code> to match the
             * specified <code>Dimension</code>.
             * <p>
             * This method is included for completeness, to parallel the
             * <code>setSize</code> method of <code>Component</code>.
             * @param d the new size for the <code>Dimension</code> object
             * @see       java.awt.Component#setSize(java.awt.Dimension)
             * @see       #getSize
             * @since     1.1
             */
            Rectangle.prototype.setSize$java_awt_Dimension = function (d) {
                this.setSize(d.width, d.height);
            };
            /**
             * Sets the size of this <code>Rectangle</code> to the specified
             * width and height.
             * <p>
             * This method is included for completeness, to parallel the
             * <code>setSize</code> method of <code>Component</code>.
             * @param width the new width for this <code>Rectangle</code>
             * @param height the new height for this <code>Rectangle</code>
             * @see       java.awt.Component#setSize(int, int)
             * @see       #getSize
             * @since     1.1
             */
            Rectangle.prototype.setSize = function (width, height) {
                var _this = this;
                if (((typeof width === 'number') || width === null) && ((typeof height === 'number') || height === null)) {
                    return (function () {
                        _this.resize(width, height);
                    })();
                }
                else if (((width != null && width instanceof java.awt.Dimension) || width === null) && height === undefined) {
                    return this.setSize$java_awt_Dimension(width);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Sets the size of this <code>Rectangle</code> to the specified
             * width and height.
             * <p>
             * @param width the new width for this <code>Rectangle</code>
             * @param height the new height for this <code>Rectangle</code>
             * @deprecated As of JDK version 1.1,
             * replaced by <code>setSize(int, int)</code>.
             */
            Rectangle.prototype.resize = function (width, height) {
                this.width = width;
                this.height = height;
            };
            Rectangle.prototype.contains = function (x, y, w, h, origrect) {
                if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && origrect === undefined) {
                    return this.contains$int$int$int$int(x, y, w, h);
                }
                else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && origrect === undefined) {
                    return this.contains$double$double$double$double(x, y, w, h);
                }
                else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined && origrect === undefined) {
                    return this.contains$int$int(x, y);
                }
                else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined && origrect === undefined) {
                    return this.contains$double$double(x, y);
                }
                else if (((x != null && x instanceof java.awt.Point) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
                    return this.contains$java_awt_Point(x);
                }
                else if (((x != null && x instanceof java.awt.Rectangle) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
                    return this.contains$java_awt_Rectangle(x);
                }
                else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
                    return this.contains$java_awt_geom_Point2D(x);
                }
                else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
                    return this.contains$java_awt_geom_Rectangle2D(x);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Checks whether or not this <code>Rectangle</code> contains the
             * specified <code>Point</code>.
             * @param p the <code>Point</code> to test
             * @return    <code>true</code> if the specified <code>Point</code>
             * is inside this <code>Rectangle</code>;
             * <code>false</code> otherwise.
             * @since     1.1
             */
            Rectangle.prototype.contains$java_awt_Point = function (p) {
                return this.contains(p.x, p.y);
            };
            /**
             * Checks whether or not this <code>Rectangle</code> contains the
             * point at the specified location {@code (x,y)}.
             *
             * @param  x the specified X coordinate
             * @param  y the specified Y coordinate
             * @return    <code>true</code> if the point
             * {@code (x,y)} is inside this
             * <code>Rectangle</code>;
             * <code>false</code> otherwise.
             * @since     1.1
             */
            Rectangle.prototype.contains$int$int = function (x, y) {
                return this.inside(x, y);
            };
            /**
             * Checks whether or not this <code>Rectangle</code> entirely contains
             * the specified <code>Rectangle</code>.
             *
             * @param     r   the specified <code>Rectangle</code>
             * @return    <code>true</code> if the <code>Rectangle</code>
             * is contained entirely inside this <code>Rectangle</code>;
             * <code>false</code> otherwise
             * @since     1.2
             */
            Rectangle.prototype.contains$java_awt_Rectangle = function (r) {
                return this.contains(r.x, r.y, r.width, r.height);
            };
            /**
             * Checks whether this <code>Rectangle</code> entirely contains
             * the <code>Rectangle</code>
             * at the specified location {@code (X,Y)} with the
             * specified dimensions {@code (W,H)}.
             * @param     X the specified X coordinate
             * @param     Y the specified Y coordinate
             * @param     W   the width of the <code>Rectangle</code>
             * @param     H   the height of the <code>Rectangle</code>
             * @return    <code>true</code> if the <code>Rectangle</code> specified by
             * {@code (X, Y, W, H)}
             * is entirely enclosed inside this <code>Rectangle</code>;
             * <code>false</code> otherwise.
             * @since     1.1
             */
            Rectangle.prototype.contains$int$int$int$int = function (X, Y, W, H) {
                var w = this.width;
                var h = this.height;
                if ((w | h | W | H) < 0) {
                    return false;
                }
                var x = this.x;
                var y = this.y;
                if (X < x || Y < y) {
                    return false;
                }
                w += x;
                W += X;
                if (W <= X) {
                    if (w >= x || W > w)
                        return false;
                }
                else {
                    if (w >= x && W > w)
                        return false;
                }
                h += y;
                H += Y;
                if (H <= Y) {
                    if (h >= y || H > h)
                        return false;
                }
                else {
                    if (h >= y && H > h)
                        return false;
                }
                return true;
            };
            /**
             * Checks whether or not this <code>Rectangle</code> contains the
             * point at the specified location {@code (X,Y)}.
             *
             * @param  X the specified X coordinate
             * @param  Y the specified Y coordinate
             * @return    <code>true</code> if the point
             * {@code (X,Y)} is inside this
             * <code>Rectangle</code>;
             * <code>false</code> otherwise.
             * @deprecated As of JDK version 1.1,
             * replaced by <code>contains(int, int)</code>.
             */
            Rectangle.prototype.inside = function (X, Y) {
                var w = this.width;
                var h = this.height;
                if ((w | h) < 0) {
                    return false;
                }
                var x = this.x;
                var y = this.y;
                if (X < x || Y < y) {
                    return false;
                }
                w += x;
                h += y;
                return ((w < x || w > X) && (h < y || h > Y));
            };
            /**
             * Determines whether or not this <code>Rectangle</code> and the specified
             * <code>Rectangle</code> intersect. Two rectangles intersect if
             * their intersection is nonempty.
             *
             * @param r the specified <code>Rectangle</code>
             * @return    <code>true</code> if the specified <code>Rectangle</code>
             * and this <code>Rectangle</code> intersect;
             * <code>false</code> otherwise.
             */
            Rectangle.prototype.intersects$java_awt_Rectangle = function (r) {
                var tw = this.width;
                var th = this.height;
                var rw = r.width;
                var rh = r.height;
                if (rw <= 0 || rh <= 0 || tw <= 0 || th <= 0) {
                    return false;
                }
                var tx = this.x;
                var ty = this.y;
                var rx = r.x;
                var ry = r.y;
                rw += rx;
                rh += ry;
                tw += tx;
                th += ty;
                return ((rw < rx || rw > tx) && (rh < ry || rh > ty) && (tw < tx || tw > rx) && (th < ty || th > ry));
            };
            /**
             * Computes the intersection of this <code>Rectangle</code> with the
             * specified <code>Rectangle</code>. Returns a new <code>Rectangle</code>
             * that represents the intersection of the two rectangles.
             * If the two rectangles do not intersect, the result will be
             * an empty rectangle.
             *
             * @param     r   the specified <code>Rectangle</code>
             * @return    the largest <code>Rectangle</code> contained in both the
             * specified <code>Rectangle</code> and in
             * this <code>Rectangle</code>; or if the rectangles
             * do not intersect, an empty rectangle.
             */
            Rectangle.prototype.intersection = function (r) {
                var tx1 = this.x;
                var ty1 = this.y;
                var rx1 = r.x;
                var ry1 = r.y;
                var tx2 = tx1;
                tx2 += this.width;
                var ty2 = ty1;
                ty2 += this.height;
                var rx2 = rx1;
                rx2 += r.width;
                var ry2 = ry1;
                ry2 += r.height;
                if (tx1 < rx1)
                    tx1 = rx1;
                if (ty1 < ry1)
                    ty1 = ry1;
                if (tx2 > rx2)
                    tx2 = rx2;
                if (ty2 > ry2)
                    ty2 = ry2;
                tx2 -= tx1;
                ty2 -= ty1;
                if (tx2 < javaemul.internal.IntegerHelper.MIN_VALUE)
                    tx2 = javaemul.internal.IntegerHelper.MIN_VALUE;
                if (ty2 < javaemul.internal.IntegerHelper.MIN_VALUE)
                    ty2 = javaemul.internal.IntegerHelper.MIN_VALUE;
                return new Rectangle(tx1, ty1, (tx2 | 0), (ty2 | 0));
            };
            /**
             * Computes the union of this <code>Rectangle</code> with the
             * specified <code>Rectangle</code>. Returns a new
             * <code>Rectangle</code> that
             * represents the union of the two rectangles.
             * <p>
             * If either {@code Rectangle} has any dimension less than zero
             * the rules for <a href=#NonExistant>non-existant</a> rectangles
             * apply.
             * If only one has a dimension less than zero, then the result
             * will be a copy of the other {@code Rectangle}.
             * If both have dimension less than zero, then the result will
             * have at least one dimension less than zero.
             * <p>
             * If the resulting {@code Rectangle} would have a dimension
             * too large to be expressed as an {@code int}, the result
             * will have a dimension of {@code Integer.MAX_VALUE} along
             * that dimension.
             * @param r the specified <code>Rectangle</code>
             * @return    the smallest <code>Rectangle</code> containing both
             * the specified <code>Rectangle</code> and this
             * <code>Rectangle</code>.
             */
            Rectangle.prototype.union = function (r) {
                var tx2 = this.width;
                var ty2 = this.height;
                if ((tx2 | ty2) < 0) {
                    return new Rectangle(r);
                }
                var rx2 = r.width;
                var ry2 = r.height;
                if ((rx2 | ry2) < 0) {
                    return new Rectangle(this);
                }
                var tx1 = this.x;
                var ty1 = this.y;
                tx2 += tx1;
                ty2 += ty1;
                var rx1 = r.x;
                var ry1 = r.y;
                rx2 += rx1;
                ry2 += ry1;
                if (tx1 > rx1)
                    tx1 = rx1;
                if (ty1 > ry1)
                    ty1 = ry1;
                if (tx2 < rx2)
                    tx2 = rx2;
                if (ty2 < ry2)
                    ty2 = ry2;
                tx2 -= tx1;
                ty2 -= ty1;
                if (tx2 > javaemul.internal.IntegerHelper.MAX_VALUE)
                    tx2 = javaemul.internal.IntegerHelper.MAX_VALUE;
                if (ty2 > javaemul.internal.IntegerHelper.MAX_VALUE)
                    ty2 = javaemul.internal.IntegerHelper.MAX_VALUE;
                return new Rectangle(tx1, ty1, (tx2 | 0), (ty2 | 0));
            };
            /**
             * Adds a point, specified by the integer arguments {@code newx,newy}
             * to the bounds of this {@code Rectangle}.
             * <p>
             * If this {@code Rectangle} has any dimension less than zero,
             * the rules for <a href=#NonExistant>non-existant</a>
             * rectangles apply.
             * In that case, the new bounds of this {@code Rectangle} will
             * have a location equal to the specified coordinates and
             * width and height equal to zero.
             * <p>
             * After adding a point, a call to <code>contains</code> with the
             * added point as an argument does not necessarily return
             * <code>true</code>. The <code>contains</code> method does not
             * return <code>true</code> for points on the right or bottom
             * edges of a <code>Rectangle</code>. Therefore, if the added point
             * falls on the right or bottom edge of the enlarged
             * <code>Rectangle</code>, <code>contains</code> returns
             * <code>false</code> for that point.
             * If the specified point must be contained within the new
             * {@code Rectangle}, a 1x1 rectangle should be added instead:
             * <pre>
             * r.add(newx, newy, 1, 1);
             * </pre>
             * @param newx the X coordinate of the new point
             * @param newy the Y coordinate of the new point
             */
            Rectangle.prototype.add = function (newx, newy) {
                var _this = this;
                if (((typeof newx === 'number') || newx === null) && ((typeof newy === 'number') || newy === null)) {
                    return (function () {
                        if ((_this.width | _this.height) < 0) {
                            _this.x = newx;
                            _this.y = newy;
                            _this.width = _this.height = 0;
                            return;
                        }
                        var x1 = _this.x;
                        var y1 = _this.y;
                        var x2 = _this.width;
                        var y2 = _this.height;
                        x2 += x1;
                        y2 += y1;
                        if (x1 > newx)
                            x1 = newx;
                        if (y1 > newy)
                            y1 = newy;
                        if (x2 < newx)
                            x2 = newx;
                        if (y2 < newy)
                            y2 = newy;
                        x2 -= x1;
                        y2 -= y1;
                        if (x2 > javaemul.internal.IntegerHelper.MAX_VALUE)
                            x2 = javaemul.internal.IntegerHelper.MAX_VALUE;
                        if (y2 > javaemul.internal.IntegerHelper.MAX_VALUE)
                            y2 = javaemul.internal.IntegerHelper.MAX_VALUE;
                        _this.reshape(x1, y1, (x2 | 0), (y2 | 0));
                    })();
                }
                else if (((typeof newx === 'number') || newx === null) && ((typeof newy === 'number') || newy === null)) {
                    return this.add$double$double(newx, newy);
                }
                else if (((newx != null && newx instanceof java.awt.Point) || newx === null) && newy === undefined) {
                    return this.add$java_awt_Point(newx);
                }
                else if (((newx != null && newx instanceof java.awt.Rectangle) || newx === null) && newy === undefined) {
                    return this.add$java_awt_Rectangle(newx);
                }
                else if (((newx != null && newx instanceof java.awt.geom.Point2D) || newx === null) && newy === undefined) {
                    return this.add$java_awt_geom_Point2D(newx);
                }
                else if (((newx != null && newx instanceof java.awt.geom.Rectangle2D) || newx === null) && newy === undefined) {
                    return this.add$java_awt_geom_Rectangle2D(newx);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Adds the specified {@code Point} to the bounds of this
             * {@code Rectangle}.
             * <p>
             * If this {@code Rectangle} has any dimension less than zero,
             * the rules for <a href=#NonExistant>non-existant</a>
             * rectangles apply.
             * In that case, the new bounds of this {@code Rectangle} will
             * have a location equal to the coordinates of the specified
             * {@code Point} and width and height equal to zero.
             * <p>
             * After adding a <code>Point</code>, a call to <code>contains</code>
             * with the added <code>Point</code> as an argument does not
             * necessarily return <code>true</code>. The <code>contains</code>
             * method does not return <code>true</code> for points on the right
             * or bottom edges of a <code>Rectangle</code>. Therefore if the added
             * <code>Point</code> falls on the right or bottom edge of the
             * enlarged <code>Rectangle</code>, <code>contains</code> returns
             * <code>false</code> for that <code>Point</code>.
             * If the specified point must be contained within the new
             * {@code Rectangle}, a 1x1 rectangle should be added instead:
             * <pre>
             * r.add(pt.x, pt.y, 1, 1);
             * </pre>
             * @param pt the new <code>Point</code> to add to this
             * <code>Rectangle</code>
             */
            Rectangle.prototype.add$java_awt_Point = function (pt) {
                this.add(pt.x, pt.y);
            };
            /**
             * Adds a <code>Rectangle</code> to this <code>Rectangle</code>.
             * The resulting <code>Rectangle</code> is the union of the two
             * rectangles.
             * <p>
             * If either {@code Rectangle} has any dimension less than 0, the
             * result will have the dimensions of the other {@code Rectangle}.
             * If both {@code Rectangle}s have at least one dimension less
             * than 0, the result will have at least one dimension less than 0.
             * <p>
             * If either {@code Rectangle} has one or both dimensions equal
             * to 0, the result along those axes with 0 dimensions will be
             * equivalent to the results obtained by adding the corresponding
             * origin coordinate to the result rectangle along that axis,
             * similar to the operation of the {@link #add(Point)} method,
             * but contribute no further dimension beyond that.
             * <p>
             * If the resulting {@code Rectangle} would have a dimension
             * too large to be expressed as an {@code int}, the result
             * will have a dimension of {@code Integer.MAX_VALUE} along
             * that dimension.
             * @param  r the specified <code>Rectangle</code>
             */
            Rectangle.prototype.add$java_awt_Rectangle = function (r) {
                var tx2 = this.width;
                var ty2 = this.height;
                if ((tx2 | ty2) < 0) {
                    this.reshape(r.x, r.y, r.width, r.height);
                }
                var rx2 = r.width;
                var ry2 = r.height;
                if ((rx2 | ry2) < 0) {
                    return;
                }
                var tx1 = this.x;
                var ty1 = this.y;
                tx2 += tx1;
                ty2 += ty1;
                var rx1 = r.x;
                var ry1 = r.y;
                rx2 += rx1;
                ry2 += ry1;
                if (tx1 > rx1)
                    tx1 = rx1;
                if (ty1 > ry1)
                    ty1 = ry1;
                if (tx2 < rx2)
                    tx2 = rx2;
                if (ty2 < ry2)
                    ty2 = ry2;
                tx2 -= tx1;
                ty2 -= ty1;
                if (tx2 > javaemul.internal.IntegerHelper.MAX_VALUE)
                    tx2 = javaemul.internal.IntegerHelper.MAX_VALUE;
                if (ty2 > javaemul.internal.IntegerHelper.MAX_VALUE)
                    ty2 = javaemul.internal.IntegerHelper.MAX_VALUE;
                this.reshape(tx1, ty1, (tx2 | 0), (ty2 | 0));
            };
            /**
             * Resizes the <code>Rectangle</code> both horizontally and vertically.
             * <p>
             * This method modifies the <code>Rectangle</code> so that it is
             * <code>h</code> units larger on both the left and right side,
             * and <code>v</code> units larger at both the top and bottom.
             * <p>
             * The new <code>Rectangle</code> has {@code (x - h, y - v)}
             * as its upper-left corner,
             * width of {@code (width + 2h)},
             * and a height of {@code (height + 2v)}.
             * <p>
             * If negative values are supplied for <code>h</code> and
             * <code>v</code>, the size of the <code>Rectangle</code>
             * decreases accordingly.
             * The {@code grow} method will check for integer overflow
             * and underflow, but does not check whether the resulting
             * values of {@code width} and {@code height} grow
             * from negative to non-negative or shrink from non-negative
             * to negative.
             * @param h the horizontal expansion
             * @param v the vertical expansion
             */
            Rectangle.prototype.grow = function (h, v) {
                var x0 = this.x;
                var y0 = this.y;
                var x1 = this.width;
                var y1 = this.height;
                x1 += x0;
                y1 += y0;
                x0 -= h;
                y0 -= v;
                x1 += h;
                y1 += v;
                if (x1 < x0) {
                    x1 -= x0;
                    if (x1 < javaemul.internal.IntegerHelper.MIN_VALUE)
                        x1 = javaemul.internal.IntegerHelper.MIN_VALUE;
                    if (x0 < javaemul.internal.IntegerHelper.MIN_VALUE)
                        x0 = javaemul.internal.IntegerHelper.MIN_VALUE;
                    else if (x0 > javaemul.internal.IntegerHelper.MAX_VALUE)
                        x0 = javaemul.internal.IntegerHelper.MAX_VALUE;
                }
                else {
                    if (x0 < javaemul.internal.IntegerHelper.MIN_VALUE)
                        x0 = javaemul.internal.IntegerHelper.MIN_VALUE;
                    else if (x0 > javaemul.internal.IntegerHelper.MAX_VALUE)
                        x0 = javaemul.internal.IntegerHelper.MAX_VALUE;
                    x1 -= x0;
                    if (x1 < javaemul.internal.IntegerHelper.MIN_VALUE)
                        x1 = javaemul.internal.IntegerHelper.MIN_VALUE;
                    else if (x1 > javaemul.internal.IntegerHelper.MAX_VALUE)
                        x1 = javaemul.internal.IntegerHelper.MAX_VALUE;
                }
                if (y1 < y0) {
                    y1 -= y0;
                    if (y1 < javaemul.internal.IntegerHelper.MIN_VALUE)
                        y1 = javaemul.internal.IntegerHelper.MIN_VALUE;
                    if (y0 < javaemul.internal.IntegerHelper.MIN_VALUE)
                        y0 = javaemul.internal.IntegerHelper.MIN_VALUE;
                    else if (y0 > javaemul.internal.IntegerHelper.MAX_VALUE)
                        y0 = javaemul.internal.IntegerHelper.MAX_VALUE;
                }
                else {
                    if (y0 < javaemul.internal.IntegerHelper.MIN_VALUE)
                        y0 = javaemul.internal.IntegerHelper.MIN_VALUE;
                    else if (y0 > javaemul.internal.IntegerHelper.MAX_VALUE)
                        y0 = javaemul.internal.IntegerHelper.MAX_VALUE;
                    y1 -= y0;
                    if (y1 < javaemul.internal.IntegerHelper.MIN_VALUE)
                        y1 = javaemul.internal.IntegerHelper.MIN_VALUE;
                    else if (y1 > javaemul.internal.IntegerHelper.MAX_VALUE)
                        y1 = javaemul.internal.IntegerHelper.MAX_VALUE;
                }
                this.reshape((x0 | 0), (y0 | 0), (x1 | 0), (y1 | 0));
            };
            /**
             * {@inheritDoc}
             * @since 1.2
             */
            Rectangle.prototype.isEmpty = function () {
                return (this.width <= 0) || (this.height <= 0);
            };
            /**
             * {@inheritDoc}
             * @since 1.2
             */
            Rectangle.prototype.outcode = function (x, y) {
                var _this = this;
                if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return (function () {
                        var out = 0;
                        if (_this.width <= 0) {
                            out |= java.awt.geom.Rectangle2D.OUT_LEFT | java.awt.geom.Rectangle2D.OUT_RIGHT;
                        }
                        else if (x < _this.x) {
                            out |= java.awt.geom.Rectangle2D.OUT_LEFT;
                        }
                        else if (x > _this.x + _this.width) {
                            out |= java.awt.geom.Rectangle2D.OUT_RIGHT;
                        }
                        if (_this.height <= 0) {
                            out |= java.awt.geom.Rectangle2D.OUT_TOP | java.awt.geom.Rectangle2D.OUT_BOTTOM;
                        }
                        else if (y < _this.y) {
                            out |= java.awt.geom.Rectangle2D.OUT_TOP;
                        }
                        else if (y > _this.y + _this.height) {
                            out |= java.awt.geom.Rectangle2D.OUT_BOTTOM;
                        }
                        return out;
                    })();
                }
                else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined) {
                    return this.outcode$java_awt_geom_Point2D(x);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * {@inheritDoc}
             * @since 1.2
             */
            Rectangle.prototype.createIntersection = function (r) {
                if (r != null && r instanceof java.awt.Rectangle) {
                    return this.intersection(r);
                }
                var dest = new java.awt.geom.Rectangle2D.Double();
                java.awt.geom.Rectangle2D.intersect(this, r, dest);
                return dest;
            };
            /**
             * {@inheritDoc}
             * @since 1.2
             */
            Rectangle.prototype.createUnion = function (r) {
                if (r != null && r instanceof java.awt.Rectangle) {
                    return r;
                }
                var dest = new java.awt.geom.Rectangle2D.Double();
                java.awt.geom.Rectangle2D.union(this, r, dest);
                return dest;
            };
            /**
             * Checks whether two rectangles are equal.
             * <p>
             * The result is <code>true</code> if and only if the argument is not
             * <code>null</code> and is a <code>Rectangle</code> object that has the
             * same upper-left corner, width, and height as
             * this <code>Rectangle</code>.
             * @param obj the <code>Object</code> to compare with
             * this <code>Rectangle</code>
             * @return    <code>true</code> if the objects are equal;
             * <code>false</code> otherwise.
             */
            Rectangle.prototype.equals = function (obj) {
                if (obj != null && obj instanceof java.awt.Rectangle) {
                    var r = obj;
                    return ((this.x === r.x) && (this.y === r.y) && (this.width === r.width) && (this.height === r.height));
                }
                return _super.prototype.equals.call(this, obj);
            };
            /**
             * Returns a <code>String</code> representing this
             * <code>Rectangle</code> and its values.
             * @return a <code>String</code> representing this
             * <code>Rectangle</code> object's coordinate and size values.
             */
            Rectangle.prototype.toString = function () {
                return "java.awt.Rectangle" + "[x=" + this.x + ",y=" + this.y + ",width=" + this.width + ",height=" + this.height + "]";
            };
            Rectangle.serialVersionUID = -4345857070255674764;
            return Rectangle;
        }(java.awt.geom.Rectangle2D));
        awt.Rectangle = Rectangle;
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var applet;
    (function (applet_1) {
        var Applet = (function () {
            function Applet() {
            }
            Applet.__static_initialize = function () { if (!Applet.__static_initialized) {
                Applet.__static_initialized = true;
                Applet.__static_initializer_0();
            } };
            Applet.__static_initializer_0 = function () {
                console.info("installing applet onload hook");
                window.onload = function (e) {
                    console.info("applet onload hook");
                    var divList = document.getElementsByClassName("applet");
                    if (divList.length === 0) {
                        return null;
                    }
                    var div = divList[0];
                    if (div.getAttribute("data-applet") != null) {
                        console.info("installing applet: " + div.getAttribute("data-applet"));
                        div.style.position = "relative";
                        var canvas = document.createElement("canvas");
                        canvas.setAttribute("width", div.getAttribute("data-width"));
                        canvas.setAttribute("height", div.getAttribute("data-height"));
                        div.style.width = div.getAttribute("data-width");
                        div.style.height = div.getAttribute("data-height");
                        if (div.firstChild != null) {
                            div.insertBefore(canvas, div.firstChild);
                        }
                        else {
                            div.appendChild(canvas);
                        }
                        canvas.style.position = "absolute";
                        canvas.style.left = "0px";
                        canvas.style.right = "0px";
                        canvas.style.width = div.style.width;
                        canvas.style.height = div.style.height;
                        canvas.style.zIndex = "-1";
                        var names = div.getAttribute("data-applet").split(".");
                        var constructor = window;
                        for (var index138 = 0; index138 < names.length; index138++) {
                            var name = names[index138];
                            {
                                constructor = constructor[name];
                                console.info("name: " + name + " -> " + constructor);
                            }
                        }
                        var applet = new constructor();
                        applet.container = div;
                        var g = new java.awt.WebGraphics2D(canvas);
                        applet.init();
                        applet.paint(g);
                    }
                    return null;
                };
            };
            Applet.prototype.init = function () {
            };
            Applet.prototype.paint = function (g) {
                var wg = g;
                if (this.backgroundColor != null) {
                    wg.getContext().fillStyle = this.backgroundColor.toHTML();
                    console.log("painting background: " + this.backgroundColor.toHTML());
                    wg.getContext().fillRect(0, 0, wg.getContext().canvas.width, wg.getContext().canvas.height);
                }
            };
            Applet.prototype.setBackground = function (c) {
                this.backgroundColor = c;
            };
            Applet.prototype.setLayout = function (layout) {
                this.layout = layout;
                if (this.container.firstChild != null) {
                    this.container.insertBefore(layout.getHTMLElement(), this.container.firstChild);
                }
                else {
                    this.container.appendChild(layout.getHTMLElement());
                }
            };
            Applet.prototype.add = function (component) {
                this.layout.add(component);
            };
            Applet.__static_initialized = false;
            Applet.CURRENT_ID = 0;
            return Applet;
        }());
        applet_1.Applet = Applet;
    })(applet = java.applet || (java.applet = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var io;
    (function (io) {
        /**
         * @skip
         */
        var PrintStream = (function (_super) {
            __extends(PrintStream, _super);
            function PrintStream(out) {
                _super.call(this, out);
                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Closeable", "java.lang.AutoCloseable", "java.io.Flushable"] });
            }
            PrintStream.prototype.print$boolean = function (x) {
            };
            PrintStream.prototype.print$char = function (x) {
            };
            PrintStream.prototype.print = function (x) {
                if (((x != null && x instanceof Array) || x === null)) {
                    return (function () {
                    })();
                }
                else if (((typeof x === 'string') || x === null)) {
                    return this.print$java_lang_String(x);
                }
                else if (((typeof x === 'boolean') || x === null)) {
                    return this.print$boolean(x);
                }
                else if (((typeof x === 'string') || x === null)) {
                    return this.print$char(x);
                }
                else if (((typeof x === 'number') || x === null)) {
                    return this.print$int(x);
                }
                else if (((typeof x === 'number') || x === null)) {
                    return this.print$long(x);
                }
                else if (((typeof x === 'number') || x === null)) {
                    return this.print$float(x);
                }
                else if (((typeof x === 'number') || x === null)) {
                    return this.print$double(x);
                }
                else if (((x != null) || x === null)) {
                    return this.print$java_lang_Object(x);
                }
                else
                    throw new Error('invalid overload');
            };
            PrintStream.prototype.print$double = function (x) {
            };
            PrintStream.prototype.print$float = function (x) {
            };
            PrintStream.prototype.print$int = function (x) {
            };
            PrintStream.prototype.print$long = function (x) {
            };
            PrintStream.prototype.print$java_lang_Object = function (x) {
            };
            PrintStream.prototype.print$java_lang_String = function (s) {
            };
            PrintStream.prototype.println$ = function () {
            };
            PrintStream.prototype.println$boolean = function (x) {
            };
            PrintStream.prototype.println$char = function (x) {
            };
            PrintStream.prototype.println = function (x) {
                if (((x != null && x instanceof Array) || x === null)) {
                    return (function () {
                    })();
                }
                else if (((typeof x === 'string') || x === null)) {
                    return this.println$java_lang_String(x);
                }
                else if (((typeof x === 'boolean') || x === null)) {
                    return this.println$boolean(x);
                }
                else if (((typeof x === 'string') || x === null)) {
                    return this.println$char(x);
                }
                else if (((typeof x === 'number') || x === null)) {
                    return this.println$int(x);
                }
                else if (((typeof x === 'number') || x === null)) {
                    return this.println$long(x);
                }
                else if (((typeof x === 'number') || x === null)) {
                    return this.println$float(x);
                }
                else if (((typeof x === 'number') || x === null)) {
                    return this.println$double(x);
                }
                else if (((x != null) || x === null)) {
                    return this.println$java_lang_Object(x);
                }
                else if (x === undefined) {
                    return this.println$();
                }
                else
                    throw new Error('invalid overload');
            };
            PrintStream.prototype.println$double = function (x) {
            };
            PrintStream.prototype.println$float = function (x) {
            };
            PrintStream.prototype.println$int = function (x) {
            };
            PrintStream.prototype.println$long = function (x) {
            };
            PrintStream.prototype.println$java_lang_Object = function (x) {
            };
            PrintStream.prototype.println$java_lang_String = function (s) {
            };
            return PrintStream;
        }(java.io.FilterOutputStream));
        io.PrintStream = PrintStream;
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var io;
    (function (io) {
        /**
         * JSweet implementation.
         */
        var FileReader = (function (_super) {
            __extends(FileReader, _super);
            function FileReader(fileName) {
                if (((typeof fileName === 'string') || fileName === null)) {
                    _super.call(this, new java.io.FileInputStream(fileName));
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Closeable", "java.lang.AutoCloseable"] });
                    (function () {
                    })();
                }
                else if (((fileName != null && fileName instanceof java.io.File) || fileName === null)) {
                    var file = fileName;
                    _super.call(this, new java.io.FileInputStream(file));
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Closeable", "java.lang.AutoCloseable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            return FileReader;
        }(java.io.InputStreamReader));
        io.FileReader = FileReader;
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var io;
    (function (io) {
        /**
         * JSweet implementation.
         */
        var FileWriter = (function (_super) {
            __extends(FileWriter, _super);
            function FileWriter(fileName, append) {
                if (((typeof fileName === 'string') || fileName === null) && ((typeof append === 'boolean') || append === null)) {
                    _super.call(this, new java.io.FileOutputStream(fileName, append));
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Appendable", "java.io.Closeable", "java.lang.AutoCloseable", "java.io.Flushable"] });
                    (function () {
                    })();
                }
                else if (((fileName != null && fileName instanceof java.io.File) || fileName === null) && ((typeof append === 'boolean') || append === null)) {
                    var file = fileName;
                    _super.call(this, new java.io.FileOutputStream(file, append));
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Appendable", "java.io.Closeable", "java.lang.AutoCloseable", "java.io.Flushable"] });
                    (function () {
                    })();
                }
                else if (((typeof fileName === 'string') || fileName === null) && append === undefined) {
                    _super.call(this, new java.io.FileOutputStream(fileName));
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Appendable", "java.io.Closeable", "java.lang.AutoCloseable", "java.io.Flushable"] });
                    (function () {
                    })();
                }
                else if (((fileName != null && fileName instanceof java.io.File) || fileName === null) && append === undefined) {
                    var file = fileName;
                    _super.call(this, new java.io.FileOutputStream(file));
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Appendable", "java.io.Closeable", "java.lang.AutoCloseable", "java.io.Flushable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            return FileWriter;
        }(java.io.OutputStreamWriter));
        io.FileWriter = FileWriter;
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var io;
    (function (io) {
        /**
         * JSweet implementation.
         */
        var FileNotFoundException = (function (_super) {
            __extends(FileNotFoundException, _super);
            function FileNotFoundException(s) {
                if (((typeof s === 'string') || s === null)) {
                    _super.call(this, s);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (s === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            FileNotFoundException.serialVersionUID = -897856973823710492;
            return FileNotFoundException;
        }(java.io.IOException));
        io.FileNotFoundException = FileNotFoundException;
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var io;
    (function (io) {
        /**
         * A character encoding is not supported - <a
         * href="http://java.sun.com/javase/6/docs/api/java/io/UnsupportedEncodingException.html">[Sun's
         * docs]</a>.
         */
        var UnsupportedEncodingException = (function (_super) {
            __extends(UnsupportedEncodingException, _super);
            function UnsupportedEncodingException(msg) {
                if (((typeof msg === 'string') || msg === null)) {
                    _super.call(this, msg);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (msg === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            return UnsupportedEncodingException;
        }(java.io.IOException));
        io.UnsupportedEncodingException = UnsupportedEncodingException;
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The <code>IllegalPathStateException</code> represents an
             * exception that is thrown if an operation is performed on a path
             * that is in an illegal state with respect to the particular
             * operation being performed, such as appending a path segment
             * to a {@link GeneralPath} without an initial moveto.
             */
            var IllegalPathStateException = (function (_super) {
                __extends(IllegalPathStateException, _super);
                /**
                 * Constructs an <code>IllegalPathStateException</code> with the
                 * specified detail message.
                 * @param   s   the detail message
                 * @since   1.2
                 */
                function IllegalPathStateException(s) {
                    if (((typeof s === 'string') || s === null)) {
                        _super.call(this, s);
                        this.message = s;
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                        (function () {
                        })();
                    }
                    else if (s === undefined) {
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                        (function () {
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                }
                return IllegalPathStateException;
            }(Error));
            geom.IllegalPathStateException = IllegalPathStateException;
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var io;
    (function (io) {
        /**
         * See <a
         * href="https://docs.oracle.com/javase/8/docs/api/java/io/UncheckedIOException.html">the
         * official Java API doc</a> for details.
         */
        var UncheckedIOException = (function (_super) {
            __extends(UncheckedIOException, _super);
            function UncheckedIOException(message, cause) {
                if (((typeof message === 'string') || message === null) && ((cause != null && cause instanceof java.io.IOException) || cause === null)) {
                    _super.call(this, message);
                    this.message = message;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (((message != null && message instanceof java.io.IOException) || message === null) && cause === undefined) {
                    var cause = message;
                    _super.call(this, javaemul.internal.InternalPreconditions.checkNotNull(cause));
                    this.message = javaemul.internal.InternalPreconditions.checkNotNull(cause);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            UncheckedIOException.prototype.getCause = function () {
                return null;
            };
            return UncheckedIOException;
        }(Error));
        io.UncheckedIOException = UncheckedIOException;
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var lang;
    (function (lang) {
        var annotation;
        (function (annotation) {
            /**
             * Indicates an attempt to access an element of an annotation that has changed
             * since it was compiled or serialized <a
             * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/annotation/AnnotationTypeMismatchException.html">[Sun
             * docs]</a>.
             */
            var AnnotationTypeMismatchException = (function (_super) {
                __extends(AnnotationTypeMismatchException, _super);
                function AnnotationTypeMismatchException() {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                }
                return AnnotationTypeMismatchException;
            }(Error));
            annotation.AnnotationTypeMismatchException = AnnotationTypeMismatchException;
        })(annotation = lang.annotation || (lang.annotation = {}));
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var lang;
    (function (lang) {
        var annotation;
        (function (annotation) {
            /**
             * Indicates an attempt to access an element of an annotation that was added
             * since it was compiled or serialized <a
             * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/annotation/IncompleteAnnotationException.html">[Sun
             * docs]</a>.
             */
            var IncompleteAnnotationException = (function (_super) {
                __extends(IncompleteAnnotationException, _super);
                function IncompleteAnnotationException(annotationType, elementName) {
                    _super.call(this, "Incomplete annotation: trying to access " + elementName + " on " + annotationType);
                    this.message = "Incomplete annotation: trying to access " + elementName + " on " + annotationType;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    this.__annotationType = annotationType;
                    this.__elementName = elementName;
                }
                IncompleteAnnotationException.prototype.annotationType = function () {
                    return this.__annotationType;
                };
                IncompleteAnnotationException.prototype.elementName = function () {
                    return this.__elementName;
                };
                return IncompleteAnnotationException;
            }(Error));
            annotation.IncompleteAnnotationException = IncompleteAnnotationException;
        })(annotation = lang.annotation || (lang.annotation = {}));
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var lang;
    (function (lang) {
        /**
         * NOTE: in GWT this is only thrown for division by zero on longs and
         * BigInteger/BigDecimal.
         * <p>
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/ArithmeticException.html">the
         * official Java API doc</a> for details.
         */
        var ArithmeticException = (function (_super) {
            __extends(ArithmeticException, _super);
            function ArithmeticException(explanation) {
                if (((typeof explanation === 'string') || explanation === null)) {
                    _super.call(this, explanation);
                    this.message = explanation;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (explanation === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            return ArithmeticException;
        }(Error));
        lang.ArithmeticException = ArithmeticException;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var lang;
    (function (lang) {
        /**
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/ArrayStoreException.html">the
         * official Java API doc</a> for details.
         */
        var ArrayStoreException = (function (_super) {
            __extends(ArrayStoreException, _super);
            function ArrayStoreException(message) {
                if (((typeof message === 'string') || message === null)) {
                    _super.call(this, message);
                    this.message = message;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (message === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            return ArrayStoreException;
        }(Error));
        lang.ArrayStoreException = ArrayStoreException;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var lang;
    (function (lang) {
        /**
         * Indicates failure to cast one type into another.
         */
        var ClassCastException = (function (_super) {
            __extends(ClassCastException, _super);
            function ClassCastException(message) {
                if (((typeof message === 'string') || message === null)) {
                    _super.call(this, message);
                    this.message = message;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (message === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            return ClassCastException;
        }(Error));
        lang.ClassCastException = ClassCastException;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var lang;
    (function (lang) {
        /**
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/IllegalArgumentException.html">the
         * official Java API doc</a> for details.
         */
        var IllegalArgumentException = (function (_super) {
            __extends(IllegalArgumentException, _super);
            function IllegalArgumentException(message, cause) {
                if (((typeof message === 'string') || message === null) && ((cause != null && cause instanceof Error) || cause === null)) {
                    _super.call(this, message);
                    this.message = message;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (((typeof message === 'string') || message === null) && cause === undefined) {
                    _super.call(this, message);
                    this.message = message;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (((message != null && message instanceof Error) || message === null) && cause === undefined) {
                    var cause = message;
                    _super.call(this, cause);
                    this.message = cause;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (message === undefined && cause === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            return IllegalArgumentException;
        }(Error));
        lang.IllegalArgumentException = IllegalArgumentException;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var lang;
    (function (lang) {
        /**
         * Indicates that an objet was in an invalid state during an attempted
         * operation.
         */
        var IllegalStateException = (function (_super) {
            __extends(IllegalStateException, _super);
            function IllegalStateException(message, cause) {
                if (((typeof message === 'string') || message === null) && ((cause != null && cause instanceof Error) || cause === null)) {
                    _super.call(this, message);
                    this.message = message;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (((typeof message === 'string') || message === null) && cause === undefined) {
                    var s = message;
                    _super.call(this, s);
                    this.message = s;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (((message != null && message instanceof Error) || message === null) && cause === undefined) {
                    var cause = message;
                    _super.call(this, cause);
                    this.message = cause;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (message === undefined && cause === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            return IllegalStateException;
        }(Error));
        lang.IllegalStateException = IllegalStateException;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var lang;
    (function (lang) {
        /**
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/IndexOutOfBoundsException.html">the
         * official Java API doc</a> for details.
         */
        var IndexOutOfBoundsException = (function (_super) {
            __extends(IndexOutOfBoundsException, _super);
            function IndexOutOfBoundsException(message) {
                if (((typeof message === 'string') || message === null)) {
                    _super.call(this, message);
                    this.message = message;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (message === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            return IndexOutOfBoundsException;
        }(Error));
        lang.IndexOutOfBoundsException = IndexOutOfBoundsException;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var lang;
    (function (lang) {
        /**
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/NegativeArraySizeException.html">the
         * official Java API doc</a> for details.
         */
        var NegativeArraySizeException = (function (_super) {
            __extends(NegativeArraySizeException, _super);
            function NegativeArraySizeException(message) {
                if (((typeof message === 'string') || message === null)) {
                    _super.call(this, message);
                    this.message = message;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (message === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            return NegativeArraySizeException;
        }(Error));
        lang.NegativeArraySizeException = NegativeArraySizeException;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var lang;
    (function (lang) {
        /**
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/NullPointerException.html">the
         * official Java API doc</a> for details.
         */
        var NullPointerException = (function (_super) {
            __extends(NullPointerException, _super);
            function NullPointerException(message) {
                if (((typeof message === 'string') || message === null)) {
                    _super.call(this, message);
                    this.message = message;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (message === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            NullPointerException.prototype.createError = function (msg) {
                return new TypeError(msg);
            };
            return NullPointerException;
        }(Error));
        lang.NullPointerException = NullPointerException;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var lang;
    (function (lang) {
        /**
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/UnsupportedOperationException.html">the
         * official Java API doc</a> for details.
         */
        var UnsupportedOperationException = (function (_super) {
            __extends(UnsupportedOperationException, _super);
            function UnsupportedOperationException(message, cause) {
                if (((typeof message === 'string') || message === null) && ((cause != null && cause instanceof Error) || cause === null)) {
                    _super.call(this, message);
                    this.message = message;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (((typeof message === 'string') || message === null) && cause === undefined) {
                    _super.call(this, message);
                    this.message = message;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (((message != null && message instanceof Error) || message === null) && cause === undefined) {
                    var cause = message;
                    _super.call(this, cause);
                    this.message = cause;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (message === undefined && cause === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            return UnsupportedOperationException;
        }(Error));
        lang.UnsupportedOperationException = UnsupportedOperationException;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/ConcurrentModificationException.html">the
         * official Java API doc</a> for details.
         */
        var ConcurrentModificationException = (function (_super) {
            __extends(ConcurrentModificationException, _super);
            function ConcurrentModificationException(message) {
                if (((typeof message === 'string') || message === null)) {
                    _super.call(this, message);
                    this.message = message;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (message === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            return ConcurrentModificationException;
        }(Error));
        util.ConcurrentModificationException = ConcurrentModificationException;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/EmptyStackException.html">the
         * official Java API doc</a> for details.
         */
        var EmptyStackException = (function (_super) {
            __extends(EmptyStackException, _super);
            function EmptyStackException() {
                _super.call(this);
                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
            }
            return EmptyStackException;
        }(Error));
        util.EmptyStackException = EmptyStackException;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/MissingResourceException.html">the
         * official Java API doc</a> for details.
         */
        var MissingResourceException = (function (_super) {
            __extends(MissingResourceException, _super);
            function MissingResourceException(s, className, key) {
                _super.call(this, s);
                this.message = s;
                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                this.key = key;
                this.className = className;
            }
            MissingResourceException.prototype.getClassName = function () {
                return this.className;
            };
            MissingResourceException.prototype.getKey = function () {
                return this.key;
            };
            return MissingResourceException;
        }(Error));
        util.MissingResourceException = MissingResourceException;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/NoSuchElementException.html">the
         * official Java API doc</a> for details.
         */
        var NoSuchElementException = (function (_super) {
            __extends(NoSuchElementException, _super);
            function NoSuchElementException(s) {
                if (((typeof s === 'string') || s === null)) {
                    _super.call(this, s);
                    this.message = s;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (s === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            return NoSuchElementException;
        }(Error));
        util.NoSuchElementException = NoSuchElementException;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var security;
    (function (security) {
        /**
         * A generic security exception type - <a
         * href="http://java.sun.com/j2se/1.4.2/docs/api/java/security/DigestException.html">[Sun's
         * docs]</a>.
         */
        var DigestException = (function (_super) {
            __extends(DigestException, _super);
            function DigestException(msg) {
                if (((typeof msg === 'string') || msg === null)) {
                    _super.call(this, msg);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (msg === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            return DigestException;
        }(java.security.GeneralSecurityException));
        security.DigestException = DigestException;
    })(security = java.security || (java.security = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var security;
    (function (security) {
        /**
         * A generic security exception type - <a
         * href="http://java.sun.com/j2se/1.4.2/docs/api/java/security/NoSuchAlgorithmException.html">[Sun's
         * docs]</a>.
         */
        var NoSuchAlgorithmException = (function (_super) {
            __extends(NoSuchAlgorithmException, _super);
            function NoSuchAlgorithmException(msg) {
                if (((typeof msg === 'string') || msg === null)) {
                    _super.call(this, msg);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (msg === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            return NoSuchAlgorithmException;
        }(java.security.GeneralSecurityException));
        security.NoSuchAlgorithmException = NoSuchAlgorithmException;
    })(security = java.security || (java.security = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var nio;
    (function (nio) {
        var charset;
        (function (charset) {
            /**
             * Constant definitions for the standard Charsets.
             */
            var StandardCharsets = (function () {
                function StandardCharsets() {
                }
                StandardCharsets.ISO_8859_1_$LI$ = function () { if (StandardCharsets.ISO_8859_1 == null)
                    StandardCharsets.ISO_8859_1 = javaemul.internal.EmulatedCharset.ISO_8859_1_$LI$(); return StandardCharsets.ISO_8859_1; };
                ;
                StandardCharsets.UTF_8_$LI$ = function () { if (StandardCharsets.UTF_8 == null)
                    StandardCharsets.UTF_8 = javaemul.internal.EmulatedCharset.UTF_8_$LI$(); return StandardCharsets.UTF_8; };
                ;
                return StandardCharsets;
            }());
            charset.StandardCharsets = StandardCharsets;
        })(charset = nio.charset || (nio.charset = {}));
    })(nio = java.nio || (java.nio = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * Skeletal implementation of the List interface. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractSequentialList.html">[Sun
         * docs]</a>
         *
         * @param <E> element type.
         */
        var AbstractSequentialList = (function (_super) {
            __extends(AbstractSequentialList, _super);
            function AbstractSequentialList() {
                _super.call(this);
                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.List", "java.util.Collection", "java.lang.Iterable"] });
            }
            AbstractSequentialList.prototype.add = function (index, element) {
                var _this = this;
                if (((typeof index === 'number') || index === null) && ((element != null) || element === null)) {
                    return (function () {
                        var iter = _this.listIterator(index);
                        iter.add(element);
                    })();
                }
                else if (((index != null) || index === null) && element === undefined) {
                    return this.add$java_lang_Object(index);
                }
                else
                    throw new Error('invalid overload');
            };
            AbstractSequentialList.prototype.addAll = function (index, c) {
                var _this = this;
                if (((typeof index === 'number') || index === null) && ((c != null && c["__interfaces"] != null && c["__interfaces"].indexOf("java.util.Collection") >= 0) || c === null)) {
                    return (function () {
                        javaemul.internal.InternalPreconditions.checkNotNull(c);
                        var modified = false;
                        var iter = _this.listIterator(index);
                        for (var index139 = c.iterator(); index139.hasNext();) {
                            var e = index139.next();
                            {
                                iter.add(e);
                                modified = true;
                            }
                        }
                        return modified;
                    })();
                }
                else if (((index != null && index["__interfaces"] != null && index["__interfaces"].indexOf("java.util.Collection") >= 0) || index === null) && c === undefined) {
                    return this.addAll$java_util_Collection(index);
                }
                else
                    throw new Error('invalid overload');
            };
            AbstractSequentialList.prototype.get = function (index) {
                var iter = this.listIterator(index);
                try {
                    return iter.next();
                }
                catch (e) {
                    throw new java.lang.IndexOutOfBoundsException("Can\'t get element " + index);
                }
                ;
            };
            AbstractSequentialList.prototype.iterator = function () {
                return this.listIterator();
            };
            AbstractSequentialList.prototype.listIterator = function (index) {
                if (((typeof index === 'number') || index === null)) {
                    return null;
                }
                else if (index === undefined) {
                    return this.listIterator$();
                }
                else
                    throw new Error('invalid overload');
            };
            AbstractSequentialList.prototype.remove = function (index) {
                var _this = this;
                if (((typeof index === 'number') || index === null)) {
                    return (function () {
                        var iter = _this.listIterator(index);
                        try {
                            var old = iter.next();
                            iter.remove();
                            return old;
                        }
                        catch (e) {
                            throw new java.lang.IndexOutOfBoundsException("Can\'t remove element " + index);
                        }
                        ;
                    })();
                }
                else if (((index != null) || index === null)) {
                    return this.remove$java_lang_Object(index);
                }
                else
                    throw new Error('invalid overload');
            };
            AbstractSequentialList.prototype.set = function (index, element) {
                var iter = this.listIterator(index);
                try {
                    var old = iter.next();
                    iter.set(element);
                    return old;
                }
                catch (e) {
                    throw new java.lang.IndexOutOfBoundsException("Can\'t set element " + index);
                }
                ;
            };
            return AbstractSequentialList;
        }(java.util.AbstractList));
        util.AbstractSequentialList = AbstractSequentialList;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * Resizeable array implementation of the List interface. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/ArrayList.html">[Sun
         * docs]</a>
         *
         * <p>
         * This implementation differs from JDK 1.5 <code>ArrayList</code> in terms of
         * capacity management. There is no speed advantage to pre-allocating array
         * sizes in JavaScript, so this implementation does not include any of the
         * capacity and "growth increment" concepts in the standard ArrayList class.
         * Although <code>ArrayList(int)</code> accepts a value for the initial
         * capacity of the array, this constructor simply delegates to
         * <code>ArrayList()</code>. It is only present for compatibility with JDK
         * 1.5's API.
         * </p>
         *
         * @param <E> the element type.
         */
        var ArrayList = (function (_super) {
            __extends(ArrayList, _super);
            function ArrayList(c) {
                var _this = this;
                if (((c != null && c["__interfaces"] != null && c["__interfaces"].indexOf("java.util.Collection") >= 0) || c === null)) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.RandomAccess", "java.util.List", "java.lang.Cloneable", "java.util.Collection", "java.lang.Iterable", "java.io.Serializable"] });
                    (function () {
                        _this.array = new Array(0);
                        javaemul.internal.ArrayHelper.insertTo(_this.array, 0, c.toArray());
                    })();
                }
                else if (((typeof c === 'number') || c === null)) {
                    var initialCapacity = c;
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.RandomAccess", "java.util.List", "java.lang.Cloneable", "java.util.Collection", "java.lang.Iterable", "java.io.Serializable"] });
                    (function () {
                        javaemul.internal.InternalPreconditions.checkArgument(initialCapacity >= 0, "Initial capacity must not be negative");
                        _this.array = new Array(0);
                    })();
                }
                else if (c === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.RandomAccess", "java.util.List", "java.lang.Cloneable", "java.util.Collection", "java.lang.Iterable", "java.io.Serializable"] });
                    (function () {
                        _this.array = new Array(0);
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            ArrayList.prototype.forEach = function (action) {
                javaemul.internal.InternalPreconditions.checkNotNull(action);
                for (var index140 = this.iterator(); index140.hasNext();) {
                    var t = index140.next();
                    {
                        action(t);
                    }
                }
            };
            ArrayList.prototype.add$java_lang_Object = function (o) {
                this.array[this.array.length] = o;
                return true;
            };
            ArrayList.prototype.add = function (index, o) {
                var _this = this;
                if (((typeof index === 'number') || index === null) && ((o != null) || o === null)) {
                    return (function () {
                        javaemul.internal.InternalPreconditions.checkPositionIndex(index, _this.array.length);
                        javaemul.internal.ArrayHelper.insertTo(_this.array, index, o);
                    })();
                }
                else if (((index != null) || index === null) && o === undefined) {
                    return this.add$java_lang_Object(index);
                }
                else
                    throw new Error('invalid overload');
            };
            ArrayList.prototype.addAll$java_util_Collection = function (c) {
                var cArray = c.toArray();
                var len = cArray.length;
                if (len === 0) {
                    return false;
                }
                javaemul.internal.ArrayHelper.insertTo(this.array, this.array.length, cArray);
                return true;
            };
            ArrayList.prototype.addAll = function (index, c) {
                var _this = this;
                if (((typeof index === 'number') || index === null) && ((c != null && c["__interfaces"] != null && c["__interfaces"].indexOf("java.util.Collection") >= 0) || c === null)) {
                    return (function () {
                        javaemul.internal.InternalPreconditions.checkPositionIndex(index, _this.array.length);
                        var cArray = c.toArray();
                        var len = cArray.length;
                        if (len === 0) {
                            return false;
                        }
                        javaemul.internal.ArrayHelper.insertTo(_this.array, index, cArray);
                        return true;
                    })();
                }
                else if (((index != null && index["__interfaces"] != null && index["__interfaces"].indexOf("java.util.Collection") >= 0) || index === null) && c === undefined) {
                    return this.addAll$java_util_Collection(index);
                }
                else
                    throw new Error('invalid overload');
            };
            ArrayList.prototype.clear = function () {
                this.array = new Array(0);
            };
            ArrayList.prototype.clone = function () {
                return new ArrayList(this);
            };
            ArrayList.prototype.contains = function (o) {
                return (this.indexOf(o) !== -1);
            };
            ArrayList.prototype.ensureCapacity = function (ignored) {
            };
            ArrayList.prototype.get = function (index) {
                javaemul.internal.InternalPreconditions.checkElementIndex(index, this.array.length);
                return this.array[index];
            };
            ArrayList.prototype.indexOf$java_lang_Object = function (o) {
                return this.indexOf(o, 0);
            };
            ArrayList.prototype.iterator = function () {
                return new ArrayList.ArrayList$0(this);
            };
            ArrayList.prototype.isEmpty = function () {
                return this.array.length === 0;
            };
            ArrayList.prototype.lastIndexOf$java_lang_Object = function (o) {
                return this.lastIndexOf(o, this.size() - 1);
            };
            ArrayList.prototype.remove = function (index) {
                var _this = this;
                if (((typeof index === 'number') || index === null)) {
                    return (function () {
                        var previous = _this.get(index);
                        javaemul.internal.ArrayHelper.removeFrom(_this.array, index, 1);
                        return previous;
                    })();
                }
                else if (((index != null) || index === null)) {
                    return this.remove$java_lang_Object(index);
                }
                else
                    throw new Error('invalid overload');
            };
            ArrayList.prototype.remove$java_lang_Object = function (o) {
                var i = this.indexOf(o);
                if (i === -1) {
                    return false;
                }
                this.remove(i);
                return true;
            };
            ArrayList.prototype.set = function (index, o) {
                var previous = this.get(index);
                this.array[index] = o;
                return previous;
            };
            ArrayList.prototype.size = function () {
                return this.array.length;
            };
            ArrayList.prototype.toArray$ = function () {
                return javaemul.internal.ArrayHelper.clone(this.array, 0, this.array.length);
            };
            ArrayList.prototype.toArray = function (out) {
                var _this = this;
                if (((out != null && out instanceof Array) || out === null)) {
                    return (function () {
                        var size = _this.array.length;
                        if (out.length < size) {
                            out = javaemul.internal.ArrayHelper.createFrom(out, size);
                        }
                        for (var i = 0; i < size; ++i) {
                            out[i] = _this.array[i];
                        }
                        if (out.length > size) {
                            out[size] = null;
                        }
                        return out;
                    })();
                }
                else if (out === undefined) {
                    return this.toArray$();
                }
                else
                    throw new Error('invalid overload');
            };
            ArrayList.prototype.trimToSize = function () {
            };
            ArrayList.prototype.removeRange = function (fromIndex, endIndex) {
                javaemul.internal.InternalPreconditions.checkPositionIndexes(fromIndex, endIndex, this.array.length);
                var count = endIndex - fromIndex;
                javaemul.internal.ArrayHelper.removeFrom(this.array, fromIndex, count);
            };
            /**
             * Used by Vector.
             */
            ArrayList.prototype.indexOf = function (o, index) {
                var _this = this;
                if (((o != null) || o === null) && ((typeof index === 'number') || index === null)) {
                    return (function () {
                        for (; index < _this.array.length; ++index) {
                            if (java.util.Objects.equals(o, _this.array[index])) {
                                return index;
                            }
                        }
                        return -1;
                    })();
                }
                else if (((o != null) || o === null) && index === undefined) {
                    return this.indexOf$java_lang_Object(o);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Used by Vector.
             */
            ArrayList.prototype.lastIndexOf = function (o, index) {
                var _this = this;
                if (((o != null) || o === null) && ((typeof index === 'number') || index === null)) {
                    return (function () {
                        for (; index >= 0; --index) {
                            if (java.util.Objects.equals(o, _this.array[index])) {
                                return index;
                            }
                        }
                        return -1;
                    })();
                }
                else if (((o != null) || o === null) && index === undefined) {
                    return this.lastIndexOf$java_lang_Object(o);
                }
                else
                    throw new Error('invalid overload');
            };
            ArrayList.prototype.setSize = function (newSize) {
                javaemul.internal.ArrayHelper.setLength(this.array, newSize);
            };
            return ArrayList;
        }(java.util.AbstractList));
        util.ArrayList = ArrayList;
        var ArrayList;
        (function (ArrayList) {
            var ArrayList$0 = (function () {
                function ArrayList$0(__parent) {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Iterator"] });
                    this.__parent = __parent;
                    this.i = 0;
                    this.last = -1;
                }
                ArrayList$0.prototype.forEachRemaining = function (consumer) {
                    javaemul.internal.InternalPreconditions.checkNotNull(consumer);
                    while ((this.hasNext())) {
                        consumer(this.next());
                    }
                    ;
                };
                ArrayList$0.prototype.hasNext = function () {
                    return this.i < this.__parent.array.length;
                };
                ArrayList$0.prototype.next = function () {
                    javaemul.internal.InternalPreconditions.checkElement(this.hasNext());
                    this.last = this.i++;
                    return this.__parent.array[this.last];
                };
                ArrayList$0.prototype.remove = function () {
                    javaemul.internal.InternalPreconditions.checkState(this.last !== -1);
                    this.__parent.remove(this.i = this.last);
                    this.last = -1;
                };
                return ArrayList$0;
            }());
            ArrayList.ArrayList$0 = ArrayList$0;
        })(ArrayList = util.ArrayList || (util.ArrayList = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * Utility methods related to native arrays. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Arrays.html">[Sun
         * docs]</a>
         */
        var Arrays = (function () {
            function Arrays() {
            }
            Arrays.asList = function () {
                var array = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    array[_i - 0] = arguments[_i];
                }
                return new Arrays.ArrayList(array);
            };
            /**
             * Perform a binary search on a sorted byte array.
             *
             * @param sortedArray byte array to search
             * @param key value to search for
             * @return the index of an element with a matching value, or a negative number
             * which is the index of the next larger value (or just past the end
             * of the array if the searched value is larger than all elements in
             * the array) minus 1 (to ensure error returns are negative)
             */
            Arrays.binarySearch$byte_A$byte = function (sortedArray, key) {
                var low = 0;
                var high = sortedArray.length - 1;
                while ((low <= high)) {
                    var mid = low + ((high - low) >> 1);
                    var midVal = sortedArray[mid];
                    if (midVal < key) {
                        low = mid + 1;
                    }
                    else if (midVal > key) {
                        high = mid - 1;
                    }
                    else {
                        return mid;
                    }
                }
                ;
                return -low - 1;
            };
            /**
             * Perform a binary search on a sorted char array.
             *
             * @param a char array to search
             * @param key value to search for
             * @return the index of an element with a matching value, or a negative number
             * which is the index of the next larger value (or just past the end
             * of the array if the searched value is larger than all elements in
             * the array) minus 1 (to ensure error returns are negative)
             */
            Arrays.binarySearch$char_A$char = function (a, key) {
                var low = 0;
                var high = a.length - 1;
                while ((low <= high)) {
                    var mid = low + ((high - low) >> 1);
                    var midVal = a[mid];
                    if ((midVal).charCodeAt(0) < (key).charCodeAt(0)) {
                        low = mid + 1;
                    }
                    else if ((midVal).charCodeAt(0) > (key).charCodeAt(0)) {
                        high = mid - 1;
                    }
                    else {
                        return mid;
                    }
                }
                ;
                return -low - 1;
            };
            /**
             * Perform a binary search on a sorted double array.
             *
             * @param sortedArray double array to search
             * @param key value to search for
             * @return the index of an element with a matching value, or a negative number
             * which is the index of the next larger value (or just past the end
             * of the array if the searched value is larger than all elements in
             * the array) minus 1 (to ensure error returns are negative)
             */
            Arrays.binarySearch$double_A$double = function (sortedArray, key) {
                var low = 0;
                var high = sortedArray.length - 1;
                while ((low <= high)) {
                    var mid = low + ((high - low) >> 1);
                    var midVal = sortedArray[mid];
                    if (midVal < key) {
                        low = mid + 1;
                    }
                    else if (midVal > key) {
                        high = mid - 1;
                    }
                    else {
                        return mid;
                    }
                }
                ;
                return -low - 1;
            };
            /**
             * Perform a binary search on a sorted float array.
             *
             * Note that some underlying JavaScript interpreters do not actually implement
             * floats (using double instead), so you may get slightly different behavior
             * regarding values that are very close (or equal) since conversion errors
             * to/from double may change the values slightly.
             *
             * @param sortedArray float array to search
             * @param key value to search for
             * @return the index of an element with a matching value, or a negative number
             * which is the index of the next larger value (or just past the end
             * of the array if the searched value is larger than all elements in
             * the array) minus 1 (to ensure error returns are negative)
             */
            Arrays.binarySearch$float_A$float = function (sortedArray, key) {
                var low = 0;
                var high = sortedArray.length - 1;
                while ((low <= high)) {
                    var mid = low + ((high - low) >> 1);
                    var midVal = sortedArray[mid];
                    if (midVal < key) {
                        low = mid + 1;
                    }
                    else if (midVal > key) {
                        high = mid - 1;
                    }
                    else {
                        return mid;
                    }
                }
                ;
                return -low - 1;
            };
            /**
             * Perform a binary search on a sorted int array.
             *
             * @param sortedArray int array to search
             * @param key value to search for
             * @return the index of an element with a matching value, or a negative number
             * which is the index of the next larger value (or just past the end
             * of the array if the searched value is larger than all elements in
             * the array) minus 1 (to ensure error returns are negative)
             */
            Arrays.binarySearch$int_A$int = function (sortedArray, key) {
                var low = 0;
                var high = sortedArray.length - 1;
                while ((low <= high)) {
                    var mid = low + ((high - low) >> 1);
                    var midVal = sortedArray[mid];
                    if (midVal < key) {
                        low = mid + 1;
                    }
                    else if (midVal > key) {
                        high = mid - 1;
                    }
                    else {
                        return mid;
                    }
                }
                ;
                return -low - 1;
            };
            /**
             * Perform a binary search on a sorted long array.
             *
             * Note that most underlying JavaScript interpreters do not actually implement
             * longs, so the values must be stored in doubles instead. This means that
             * certain legal values cannot be represented, and comparison of two unequal
             * long values may result in unexpected results if they are not also
             * representable as doubles.
             *
             * @param sortedArray long array to search
             * @param key value to search for
             * @return the index of an element with a matching value, or a negative number
             * which is the index of the next larger value (or just past the end
             * of the array if the searched value is larger than all elements in
             * the array) minus 1 (to ensure error returns are negative)
             */
            Arrays.binarySearch$long_A$long = function (sortedArray, key) {
                var low = 0;
                var high = sortedArray.length - 1;
                while ((low <= high)) {
                    var mid = low + ((high - low) >> 1);
                    var midVal = sortedArray[mid];
                    if (midVal < key) {
                        low = mid + 1;
                    }
                    else if (midVal > key) {
                        high = mid - 1;
                    }
                    else {
                        return mid;
                    }
                }
                ;
                return -low - 1;
            };
            /**
             * Perform a binary search on a sorted object array, using natural ordering.
             *
             * @param sortedArray object array to search
             * @param key value to search for
             * @return the index of an element with a matching value, or a negative number
             * which is the index of the next larger value (or just past the end
             * of the array if the searched value is larger than all elements in
             * the array) minus 1 (to ensure error returns are negative)
             * @throws ClassCastException if <code>key</code> is not comparable to
             * <code>sortedArray</code>'s elements.
             */
            Arrays.binarySearch$java_lang_Object_A$java_lang_Object = function (sortedArray, key) {
                return Arrays.binarySearch(sortedArray, key, java.util.Comparators.natural());
            };
            /**
             * Perform a binary search on a sorted short array.
             *
             * @param sortedArray short array to search
             * @param key value to search for
             * @return the index of an element with a matching value, or a negative number
             * which is the index of the next larger value (or just past the end
             * of the array if the searched value is larger than all elements in
             * the array) minus 1 (to ensure error returns are negative)
             */
            Arrays.binarySearch$short_A$short = function (sortedArray, key) {
                var low = 0;
                var high = sortedArray.length - 1;
                while ((low <= high)) {
                    var mid = low + ((high - low) >> 1);
                    var midVal = sortedArray[mid];
                    if (midVal < key) {
                        low = mid + 1;
                    }
                    else if (midVal > key) {
                        high = mid - 1;
                    }
                    else {
                        return mid;
                    }
                }
                ;
                return -low - 1;
            };
            /**
             * Perform a binary search on a sorted object array, using a user-specified
             * comparison function.
             *
             * @param sortedArray object array to search
             * @param key value to search for
             * @param comparator comparision function, <code>null</code> indicates
             * <i>natural ordering</i> should be used.
             * @return the index of an element with a matching value, or a negative number
             * which is the index of the next larger value (or just past the end
             * of the array if the searched value is larger than all elements in
             * the array) minus 1 (to ensure error returns are negative)
             * @throws ClassCastException if <code>key</code> and
             * <code>sortedArray</code>'s elements cannot be compared by
             * <code>comparator</code>.
             */
            Arrays.binarySearch = function (sortedArray, key, comparator) {
                if (((sortedArray != null && sortedArray instanceof Array) || sortedArray === null) && ((key != null) || key === null) && ((comparator != null && comparator["__interfaces"] != null && comparator["__interfaces"].indexOf("java.util.Comparator") >= 0) || comparator === null)) {
                    return (function () {
                        if (comparator == null) {
                            comparator = java.util.Comparators.natural();
                        }
                        var low = 0;
                        var high = sortedArray.length - 1;
                        while ((low <= high)) {
                            var mid = low + ((high - low) >> 1);
                            var midVal = sortedArray[mid];
                            var compareResult = comparator.compare(midVal, key);
                            if (compareResult < 0) {
                                low = mid + 1;
                            }
                            else if (compareResult > 0) {
                                high = mid - 1;
                            }
                            else {
                                return mid;
                            }
                        }
                        ;
                        return -low - 1;
                    })();
                }
                else if (((sortedArray != null && sortedArray instanceof Array) || sortedArray === null) && ((typeof key === 'number') || key === null) && comparator === undefined) {
                    return java.util.Arrays.binarySearch$byte_A$byte(sortedArray, key);
                }
                else if (((sortedArray != null && sortedArray instanceof Array) || sortedArray === null) && ((typeof key === 'string') || key === null) && comparator === undefined) {
                    return java.util.Arrays.binarySearch$char_A$char(sortedArray, key);
                }
                else if (((sortedArray != null && sortedArray instanceof Array) || sortedArray === null) && ((typeof key === 'number') || key === null) && comparator === undefined) {
                    return java.util.Arrays.binarySearch$short_A$short(sortedArray, key);
                }
                else if (((sortedArray != null && sortedArray instanceof Array) || sortedArray === null) && ((typeof key === 'number') || key === null) && comparator === undefined) {
                    return java.util.Arrays.binarySearch$int_A$int(sortedArray, key);
                }
                else if (((sortedArray != null && sortedArray instanceof Array) || sortedArray === null) && ((typeof key === 'number') || key === null) && comparator === undefined) {
                    return java.util.Arrays.binarySearch$long_A$long(sortedArray, key);
                }
                else if (((sortedArray != null && sortedArray instanceof Array) || sortedArray === null) && ((typeof key === 'number') || key === null) && comparator === undefined) {
                    return java.util.Arrays.binarySearch$float_A$float(sortedArray, key);
                }
                else if (((sortedArray != null && sortedArray instanceof Array) || sortedArray === null) && ((typeof key === 'number') || key === null) && comparator === undefined) {
                    return java.util.Arrays.binarySearch$double_A$double(sortedArray, key);
                }
                else if (((sortedArray != null && sortedArray instanceof Array) || sortedArray === null) && ((key != null) || key === null) && comparator === undefined) {
                    return java.util.Arrays.binarySearch$java_lang_Object_A$java_lang_Object(sortedArray, key);
                }
                else
                    throw new Error('invalid overload');
            };
            Arrays.copyOf = function (original, newLength) {
                if (((original != null && original instanceof Array) || original === null) && ((typeof newLength === 'number') || newLength === null)) {
                    return (function () {
                        javaemul.internal.InternalPreconditions.checkArraySize(newLength);
                        return Arrays.copyOfRange(original, 0, newLength);
                    })();
                }
                else if (((original != null && original instanceof Array) || original === null) && ((typeof newLength === 'number') || newLength === null)) {
                    return java.util.Arrays.copyOf$byte_A$int(original, newLength);
                }
                else if (((original != null && original instanceof Array) || original === null) && ((typeof newLength === 'number') || newLength === null)) {
                    return java.util.Arrays.copyOf$char_A$int(original, newLength);
                }
                else if (((original != null && original instanceof Array) || original === null) && ((typeof newLength === 'number') || newLength === null)) {
                    return java.util.Arrays.copyOf$double_A$int(original, newLength);
                }
                else if (((original != null && original instanceof Array) || original === null) && ((typeof newLength === 'number') || newLength === null)) {
                    return java.util.Arrays.copyOf$float_A$int(original, newLength);
                }
                else if (((original != null && original instanceof Array) || original === null) && ((typeof newLength === 'number') || newLength === null)) {
                    return java.util.Arrays.copyOf$int_A$int(original, newLength);
                }
                else if (((original != null && original instanceof Array) || original === null) && ((typeof newLength === 'number') || newLength === null)) {
                    return java.util.Arrays.copyOf$long_A$int(original, newLength);
                }
                else if (((original != null && original instanceof Array) || original === null) && ((typeof newLength === 'number') || newLength === null)) {
                    return java.util.Arrays.copyOf$short_A$int(original, newLength);
                }
                else if (((original != null && original instanceof Array) || original === null) && ((typeof newLength === 'number') || newLength === null)) {
                    return java.util.Arrays.copyOf$java_lang_Object_A$int(original, newLength);
                }
                else
                    throw new Error('invalid overload');
            };
            Arrays.copyOf$byte_A$int = function (original, newLength) {
                javaemul.internal.InternalPreconditions.checkArraySize(newLength);
                return Arrays.copyOfRange(original, 0, newLength);
            };
            Arrays.copyOf$char_A$int = function (original, newLength) {
                javaemul.internal.InternalPreconditions.checkArraySize(newLength);
                return Arrays.copyOfRange(original, 0, newLength);
            };
            Arrays.copyOf$double_A$int = function (original, newLength) {
                javaemul.internal.InternalPreconditions.checkArraySize(newLength);
                return Arrays.copyOfRange(original, 0, newLength);
            };
            Arrays.copyOf$float_A$int = function (original, newLength) {
                javaemul.internal.InternalPreconditions.checkArraySize(newLength);
                return Arrays.copyOfRange(original, 0, newLength);
            };
            Arrays.copyOf$int_A$int = function (original, newLength) {
                javaemul.internal.InternalPreconditions.checkArraySize(newLength);
                return Arrays.copyOfRange(original, 0, newLength);
            };
            Arrays.copyOf$long_A$int = function (original, newLength) {
                javaemul.internal.InternalPreconditions.checkArraySize(newLength);
                return Arrays.copyOfRange(original, 0, newLength);
            };
            Arrays.copyOf$short_A$int = function (original, newLength) {
                javaemul.internal.InternalPreconditions.checkArraySize(newLength);
                return Arrays.copyOfRange(original, 0, newLength);
            };
            Arrays.copyOf$java_lang_Object_A$int = function (original, newLength) {
                javaemul.internal.InternalPreconditions.checkArraySize(newLength);
                javaemul.internal.InternalPreconditions.checkNotNull(original, "original");
                var clone = javaemul.internal.ArrayHelper.clone(original, 0, newLength);
                javaemul.internal.ArrayHelper.setLength(clone, newLength);
                return clone;
            };
            Arrays.copyOfRange = function (original, from, to) {
                if (((original != null && original instanceof Array) || original === null) && ((typeof from === 'number') || from === null) && ((typeof to === 'number') || to === null)) {
                    return (function () {
                        var len = Arrays.getCopyLength(original, from, to);
                        var copy = new Array(to - from);
                        javaemul.internal.ArrayHelper.copy(original, from, copy, 0, len);
                        return copy;
                    })();
                }
                else if (((original != null && original instanceof Array) || original === null) && ((typeof from === 'number') || from === null) && ((typeof to === 'number') || to === null)) {
                    return java.util.Arrays.copyOfRange$byte_A$int$int(original, from, to);
                }
                else if (((original != null && original instanceof Array) || original === null) && ((typeof from === 'number') || from === null) && ((typeof to === 'number') || to === null)) {
                    return java.util.Arrays.copyOfRange$char_A$int$int(original, from, to);
                }
                else if (((original != null && original instanceof Array) || original === null) && ((typeof from === 'number') || from === null) && ((typeof to === 'number') || to === null)) {
                    return java.util.Arrays.copyOfRange$double_A$int$int(original, from, to);
                }
                else if (((original != null && original instanceof Array) || original === null) && ((typeof from === 'number') || from === null) && ((typeof to === 'number') || to === null)) {
                    return java.util.Arrays.copyOfRange$float_A$int$int(original, from, to);
                }
                else if (((original != null && original instanceof Array) || original === null) && ((typeof from === 'number') || from === null) && ((typeof to === 'number') || to === null)) {
                    return java.util.Arrays.copyOfRange$int_A$int$int(original, from, to);
                }
                else if (((original != null && original instanceof Array) || original === null) && ((typeof from === 'number') || from === null) && ((typeof to === 'number') || to === null)) {
                    return java.util.Arrays.copyOfRange$long_A$int$int(original, from, to);
                }
                else if (((original != null && original instanceof Array) || original === null) && ((typeof from === 'number') || from === null) && ((typeof to === 'number') || to === null)) {
                    return java.util.Arrays.copyOfRange$short_A$int$int(original, from, to);
                }
                else if (((original != null && original instanceof Array) || original === null) && ((typeof from === 'number') || from === null) && ((typeof to === 'number') || to === null)) {
                    return java.util.Arrays.copyOfRange$java_lang_Object_A$int$int(original, from, to);
                }
                else
                    throw new Error('invalid overload');
            };
            Arrays.copyOfRange$byte_A$int$int = function (original, from, to) {
                var len = Arrays.getCopyLength(original, from, to);
                var copy = new Array(to - from);
                javaemul.internal.ArrayHelper.copy(original, from, copy, 0, len);
                return copy;
            };
            Arrays.copyOfRange$char_A$int$int = function (original, from, to) {
                var len = Arrays.getCopyLength(original, from, to);
                var copy = new Array(to - from);
                javaemul.internal.ArrayHelper.copy(original, from, copy, 0, len);
                return copy;
            };
            Arrays.copyOfRange$double_A$int$int = function (original, from, to) {
                var len = Arrays.getCopyLength(original, from, to);
                var copy = new Array(to - from);
                javaemul.internal.ArrayHelper.copy(original, from, copy, 0, len);
                return copy;
            };
            Arrays.copyOfRange$float_A$int$int = function (original, from, to) {
                var len = Arrays.getCopyLength(original, from, to);
                var copy = new Array(to - from);
                javaemul.internal.ArrayHelper.copy(original, from, copy, 0, len);
                return copy;
            };
            Arrays.copyOfRange$int_A$int$int = function (original, from, to) {
                var len = Arrays.getCopyLength(original, from, to);
                var copy = new Array(to - from);
                javaemul.internal.ArrayHelper.copy(original, from, copy, 0, len);
                return copy;
            };
            Arrays.copyOfRange$long_A$int$int = function (original, from, to) {
                var len = Arrays.getCopyLength(original, from, to);
                var copy = new Array(to - from);
                javaemul.internal.ArrayHelper.copy(original, from, copy, 0, len);
                return copy;
            };
            Arrays.copyOfRange$short_A$int$int = function (original, from, to) {
                var len = Arrays.getCopyLength(original, from, to);
                var copy = new Array(to - from);
                javaemul.internal.ArrayHelper.copy(original, from, copy, 0, len);
                return copy;
            };
            Arrays.copyOfRange$java_lang_Object_A$int$int = function (original, from, to) {
                var len = Arrays.getCopyLength(original, from, to);
                var copy = javaemul.internal.ArrayHelper.createFrom(original, to - from);
                javaemul.internal.ArrayHelper.copy(original, from, copy, 0, len);
                return copy;
            };
            Arrays.deepEquals = function (a1, a2) {
                if (a1 === a2) {
                    return true;
                }
                if (a1 == null || a2 == null) {
                    return false;
                }
                if (a1.length !== a2.length) {
                    return false;
                }
                for (var i = 0, n = a1.length; i < n; ++i) {
                    if (!java.util.Objects.deepEquals(a1[i], a2[i])) {
                        return false;
                    }
                }
                return true;
            };
            Arrays.deepHashCode = function (a) {
                if (a == null) {
                    return 0;
                }
                var hashCode = 1;
                for (var index141 = 0; index141 < a.length; index141++) {
                    var obj = a[index141];
                    {
                        var hash;
                        if (obj != null && obj instanceof Array) {
                            hash = Arrays.deepHashCode(obj);
                        }
                        else if (obj != null && obj instanceof Array) {
                            hash = Arrays.hashCode(obj);
                        }
                        else if (obj != null && obj instanceof Array) {
                            hash = Arrays.hashCode(obj);
                        }
                        else if (obj != null && obj instanceof Array) {
                            hash = Arrays.hashCode(obj);
                        }
                        else if (obj != null && obj instanceof Array) {
                            hash = Arrays.hashCode(obj);
                        }
                        else if (obj != null && obj instanceof Array) {
                            hash = Arrays.hashCode(obj);
                        }
                        else if (obj != null && obj instanceof Array) {
                            hash = Arrays.hashCode(obj);
                        }
                        else if (obj != null && obj instanceof Array) {
                            hash = Arrays.hashCode(obj);
                        }
                        else if (obj != null && obj instanceof Array) {
                            hash = Arrays.hashCode(obj);
                        }
                        else {
                            hash = java.util.Objects.hashCode(obj);
                        }
                        hashCode = 31 * hashCode + hash;
                        hashCode = javaemul.internal.Coercions.ensureInt(hashCode);
                    }
                }
                return hashCode;
            };
            Arrays.deepToString$java_lang_Object_A = function (a) {
                return Arrays.deepToString(a, new java.util.HashSet());
            };
            Arrays.equals = function (array1, array2) {
                if (((array1 != null && array1 instanceof Array) || array1 === null) && ((array2 != null && array2 instanceof Array) || array2 === null)) {
                    return (function () {
                        if (array1 === array2) {
                            return true;
                        }
                        if (array1 == null || array2 == null) {
                            return false;
                        }
                        if (array1.length !== array2.length) {
                            return false;
                        }
                        for (var i = 0; i < array1.length; ++i) {
                            if (array1[i] !== array2[i]) {
                                return false;
                            }
                        }
                        return true;
                    })();
                }
                else if (((array1 != null && array1 instanceof Array) || array1 === null) && ((array2 != null && array2 instanceof Array) || array2 === null)) {
                    return java.util.Arrays.equals$byte_A$byte_A(array1, array2);
                }
                else if (((array1 != null && array1 instanceof Array) || array1 === null) && ((array2 != null && array2 instanceof Array) || array2 === null)) {
                    return java.util.Arrays.equals$char_A$char_A(array1, array2);
                }
                else if (((array1 != null && array1 instanceof Array) || array1 === null) && ((array2 != null && array2 instanceof Array) || array2 === null)) {
                    return java.util.Arrays.equals$double_A$double_A(array1, array2);
                }
                else if (((array1 != null && array1 instanceof Array) || array1 === null) && ((array2 != null && array2 instanceof Array) || array2 === null)) {
                    return java.util.Arrays.equals$float_A$float_A(array1, array2);
                }
                else if (((array1 != null && array1 instanceof Array) || array1 === null) && ((array2 != null && array2 instanceof Array) || array2 === null)) {
                    return java.util.Arrays.equals$int_A$int_A(array1, array2);
                }
                else if (((array1 != null && array1 instanceof Array) || array1 === null) && ((array2 != null && array2 instanceof Array) || array2 === null)) {
                    return java.util.Arrays.equals$long_A$long_A(array1, array2);
                }
                else if (((array1 != null && array1 instanceof Array) || array1 === null) && ((array2 != null && array2 instanceof Array) || array2 === null)) {
                    return java.util.Arrays.equals$java_lang_Object_A$java_lang_Object_A(array1, array2);
                }
                else if (((array1 != null && array1 instanceof Array) || array1 === null) && ((array2 != null && array2 instanceof Array) || array2 === null)) {
                    return java.util.Arrays.equals$short_A$short_A(array1, array2);
                }
                else
                    throw new Error('invalid overload');
            };
            Arrays.equals$byte_A$byte_A = function (array1, array2) {
                if (array1 === array2) {
                    return true;
                }
                if (array1 == null || array2 == null) {
                    return false;
                }
                if (array1.length !== array2.length) {
                    return false;
                }
                for (var i = 0; i < array1.length; ++i) {
                    if (array1[i] !== array2[i]) {
                        return false;
                    }
                }
                return true;
            };
            Arrays.equals$char_A$char_A = function (array1, array2) {
                if (array1 === array2) {
                    return true;
                }
                if (array1 == null || array2 == null) {
                    return false;
                }
                if (array1.length !== array2.length) {
                    return false;
                }
                for (var i = 0; i < array1.length; ++i) {
                    if (array1[i] !== array2[i]) {
                        return false;
                    }
                }
                return true;
            };
            Arrays.equals$double_A$double_A = function (array1, array2) {
                if (array1 === array2) {
                    return true;
                }
                if (array1 == null || array2 == null) {
                    return false;
                }
                if (array1.length !== array2.length) {
                    return false;
                }
                for (var i = 0; i < array1.length; ++i) {
                    if (array1[i] !== array2[i]) {
                        return false;
                    }
                }
                return true;
            };
            Arrays.equals$float_A$float_A = function (array1, array2) {
                if (array1 === array2) {
                    return true;
                }
                if (array1 == null || array2 == null) {
                    return false;
                }
                if (array1.length !== array2.length) {
                    return false;
                }
                for (var i = 0; i < array1.length; ++i) {
                    if (array1[i] !== array2[i]) {
                        return false;
                    }
                }
                return true;
            };
            Arrays.equals$int_A$int_A = function (array1, array2) {
                if (array1 === array2) {
                    return true;
                }
                if (array1 == null || array2 == null) {
                    return false;
                }
                if (array1.length !== array2.length) {
                    return false;
                }
                for (var i = 0; i < array1.length; ++i) {
                    if (array1[i] !== array2[i]) {
                        return false;
                    }
                }
                return true;
            };
            Arrays.equals$long_A$long_A = function (array1, array2) {
                if (array1 === array2) {
                    return true;
                }
                if (array1 == null || array2 == null) {
                    return false;
                }
                if (array1.length !== array2.length) {
                    return false;
                }
                for (var i = 0; i < array1.length; ++i) {
                    if (array1[i] !== array2[i]) {
                        return false;
                    }
                }
                return true;
            };
            Arrays.equals$java_lang_Object_A$java_lang_Object_A = function (array1, array2) {
                if (array1 === array2) {
                    return true;
                }
                if (array1 == null || array2 == null) {
                    return false;
                }
                if (array1.length !== array2.length) {
                    return false;
                }
                for (var i = 0; i < array1.length; ++i) {
                    var val1 = array1[i];
                    var val2 = array2[i];
                    if (!java.util.Objects.equals(val1, val2)) {
                        return false;
                    }
                }
                return true;
            };
            Arrays.equals$short_A$short_A = function (array1, array2) {
                if (array1 === array2) {
                    return true;
                }
                if (array1 == null || array2 == null) {
                    return false;
                }
                if (array1.length !== array2.length) {
                    return false;
                }
                for (var i = 0; i < array1.length; ++i) {
                    if (array1[i] !== array2[i]) {
                        return false;
                    }
                }
                return true;
            };
            Arrays.fill$boolean_A$boolean = function (a, val) {
                Arrays.fill(a, 0, a.length, val);
            };
            Arrays.fill = function (a, fromIndex, toIndex, val) {
                if (((a != null && a instanceof Array) || a === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && ((typeof val === 'boolean') || val === null)) {
                    return (function () {
                        for (var i = fromIndex; i < toIndex; ++i) {
                            a[i] = val;
                        }
                    })();
                }
                else if (((a != null && a instanceof Array) || a === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && ((typeof val === 'number') || val === null)) {
                    return java.util.Arrays.fill$byte_A$int$int$byte(a, fromIndex, toIndex, val);
                }
                else if (((a != null && a instanceof Array) || a === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && ((typeof val === 'string') || val === null)) {
                    return java.util.Arrays.fill$char_A$int$int$char(a, fromIndex, toIndex, val);
                }
                else if (((a != null && a instanceof Array) || a === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && ((typeof val === 'number') || val === null)) {
                    return java.util.Arrays.fill$short_A$int$int$short(a, fromIndex, toIndex, val);
                }
                else if (((a != null && a instanceof Array) || a === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && ((typeof val === 'number') || val === null)) {
                    return java.util.Arrays.fill$int_A$int$int$int(a, fromIndex, toIndex, val);
                }
                else if (((a != null && a instanceof Array) || a === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && ((typeof val === 'number') || val === null)) {
                    return java.util.Arrays.fill$long_A$int$int$long(a, fromIndex, toIndex, val);
                }
                else if (((a != null && a instanceof Array) || a === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && ((typeof val === 'number') || val === null)) {
                    return java.util.Arrays.fill$float_A$int$int$float(a, fromIndex, toIndex, val);
                }
                else if (((a != null && a instanceof Array) || a === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && ((typeof val === 'number') || val === null)) {
                    return java.util.Arrays.fill$double_A$int$int$double(a, fromIndex, toIndex, val);
                }
                else if (((a != null && a instanceof Array) || a === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && ((val != null) || val === null)) {
                    return java.util.Arrays.fill$java_lang_Object_A$int$int$java_lang_Object(a, fromIndex, toIndex, val);
                }
                else if (((a != null && a instanceof Array) || a === null) && ((typeof fromIndex === 'boolean') || fromIndex === null) && toIndex === undefined && val === undefined) {
                    return java.util.Arrays.fill$boolean_A$boolean(a, fromIndex);
                }
                else if (((a != null && a instanceof Array) || a === null) && ((typeof fromIndex === 'number') || fromIndex === null) && toIndex === undefined && val === undefined) {
                    return java.util.Arrays.fill$byte_A$byte(a, fromIndex);
                }
                else if (((a != null && a instanceof Array) || a === null) && ((typeof fromIndex === 'string') || fromIndex === null) && toIndex === undefined && val === undefined) {
                    return java.util.Arrays.fill$char_A$char(a, fromIndex);
                }
                else if (((a != null && a instanceof Array) || a === null) && ((typeof fromIndex === 'number') || fromIndex === null) && toIndex === undefined && val === undefined) {
                    return java.util.Arrays.fill$short_A$short(a, fromIndex);
                }
                else if (((a != null && a instanceof Array) || a === null) && ((typeof fromIndex === 'number') || fromIndex === null) && toIndex === undefined && val === undefined) {
                    return java.util.Arrays.fill$int_A$int(a, fromIndex);
                }
                else if (((a != null && a instanceof Array) || a === null) && ((typeof fromIndex === 'number') || fromIndex === null) && toIndex === undefined && val === undefined) {
                    return java.util.Arrays.fill$long_A$long(a, fromIndex);
                }
                else if (((a != null && a instanceof Array) || a === null) && ((typeof fromIndex === 'number') || fromIndex === null) && toIndex === undefined && val === undefined) {
                    return java.util.Arrays.fill$float_A$float(a, fromIndex);
                }
                else if (((a != null && a instanceof Array) || a === null) && ((typeof fromIndex === 'number') || fromIndex === null) && toIndex === undefined && val === undefined) {
                    return java.util.Arrays.fill$double_A$double(a, fromIndex);
                }
                else if (((a != null && a instanceof Array) || a === null) && ((fromIndex != null) || fromIndex === null) && toIndex === undefined && val === undefined) {
                    return java.util.Arrays.fill$java_lang_Object_A$java_lang_Object(a, fromIndex);
                }
                else
                    throw new Error('invalid overload');
            };
            Arrays.fill$byte_A$byte = function (a, val) {
                Arrays.fill(a, 0, a.length, val);
            };
            Arrays.fill$byte_A$int$int$byte = function (a, fromIndex, toIndex, val) {
                for (var i = fromIndex; i < toIndex; ++i) {
                    a[i] = val;
                }
            };
            Arrays.fill$char_A$char = function (a, val) {
                Arrays.fill(a, 0, a.length, val);
            };
            Arrays.fill$char_A$int$int$char = function (a, fromIndex, toIndex, val) {
                for (var i = fromIndex; i < toIndex; ++i) {
                    a[i] = val;
                }
            };
            Arrays.fill$double_A$double = function (a, val) {
                Arrays.fill(a, 0, a.length, val);
            };
            Arrays.fill$double_A$int$int$double = function (a, fromIndex, toIndex, val) {
                for (var i = fromIndex; i < toIndex; ++i) {
                    a[i] = val;
                }
            };
            Arrays.fill$float_A$float = function (a, val) {
                Arrays.fill(a, 0, a.length, val);
            };
            Arrays.fill$float_A$int$int$float = function (a, fromIndex, toIndex, val) {
                for (var i = fromIndex; i < toIndex; ++i) {
                    a[i] = val;
                }
            };
            Arrays.fill$int_A$int = function (a, val) {
                Arrays.fill(a, 0, a.length, val);
            };
            Arrays.fill$int_A$int$int$int = function (a, fromIndex, toIndex, val) {
                for (var i = fromIndex; i < toIndex; ++i) {
                    a[i] = val;
                }
            };
            Arrays.fill$long_A$int$int$long = function (a, fromIndex, toIndex, val) {
                for (var i = fromIndex; i < toIndex; ++i) {
                    a[i] = val;
                }
            };
            Arrays.fill$long_A$long = function (a, val) {
                Arrays.fill(a, 0, a.length, val);
            };
            Arrays.fill$java_lang_Object_A$int$int$java_lang_Object = function (a, fromIndex, toIndex, val) {
                for (var i = fromIndex; i < toIndex; ++i) {
                    a[i] = val;
                }
            };
            Arrays.fill$java_lang_Object_A$java_lang_Object = function (a, val) {
                Arrays.fill(a, 0, a.length, val);
            };
            Arrays.fill$short_A$int$int$short = function (a, fromIndex, toIndex, val) {
                for (var i = fromIndex; i < toIndex; ++i) {
                    a[i] = val;
                }
            };
            Arrays.fill$short_A$short = function (a, val) {
                Arrays.fill(a, 0, a.length, val);
            };
            Arrays.hashCode = function (a) {
                if (((a != null && a instanceof Array) || a === null)) {
                    return (function () {
                        if (a == null) {
                            return 0;
                        }
                        var hashCode = 1;
                        for (var index142 = 0; index142 < a.length; index142++) {
                            var e = a[index142];
                            {
                                hashCode = 31 * hashCode + javaemul.internal.BooleanHelper.hashCode(e);
                                hashCode = javaemul.internal.Coercions.ensureInt(hashCode);
                            }
                        }
                        return hashCode;
                    })();
                }
                else if (((a != null && a instanceof Array) || a === null)) {
                    return java.util.Arrays.hashCode$byte_A(a);
                }
                else if (((a != null && a instanceof Array) || a === null)) {
                    return java.util.Arrays.hashCode$char_A(a);
                }
                else if (((a != null && a instanceof Array) || a === null)) {
                    return java.util.Arrays.hashCode$double_A(a);
                }
                else if (((a != null && a instanceof Array) || a === null)) {
                    return java.util.Arrays.hashCode$float_A(a);
                }
                else if (((a != null && a instanceof Array) || a === null)) {
                    return java.util.Arrays.hashCode$int_A(a);
                }
                else if (((a != null && a instanceof Array) || a === null)) {
                    return java.util.Arrays.hashCode$long_A(a);
                }
                else if (((a != null && a instanceof Array) || a === null)) {
                    return java.util.Arrays.hashCode$java_lang_Object_A(a);
                }
                else if (((a != null && a instanceof Array) || a === null)) {
                    return java.util.Arrays.hashCode$short_A(a);
                }
                else
                    throw new Error('invalid overload');
            };
            Arrays.hashCode$byte_A = function (a) {
                if (a == null) {
                    return 0;
                }
                var hashCode = 1;
                for (var index143 = 0; index143 < a.length; index143++) {
                    var e = a[index143];
                    {
                        hashCode = 31 * hashCode + javaemul.internal.ByteHelper.hashCode(e);
                        hashCode = javaemul.internal.Coercions.ensureInt(hashCode);
                    }
                }
                return hashCode;
            };
            Arrays.hashCode$char_A = function (a) {
                if (a == null) {
                    return 0;
                }
                var hashCode = 1;
                for (var index144 = 0; index144 < a.length; index144++) {
                    var e = a[index144];
                    {
                        hashCode = 31 * hashCode + javaemul.internal.CharacterHelper.hashCode(e);
                        hashCode = javaemul.internal.Coercions.ensureInt(hashCode);
                    }
                }
                return hashCode;
            };
            Arrays.hashCode$double_A = function (a) {
                if (a == null) {
                    return 0;
                }
                var hashCode = 1;
                for (var index145 = 0; index145 < a.length; index145++) {
                    var e = a[index145];
                    {
                        hashCode = 31 * hashCode + javaemul.internal.DoubleHelper.hashCode(e);
                        hashCode = javaemul.internal.Coercions.ensureInt(hashCode);
                    }
                }
                return hashCode;
            };
            Arrays.hashCode$float_A = function (a) {
                if (a == null) {
                    return 0;
                }
                var hashCode = 1;
                for (var index146 = 0; index146 < a.length; index146++) {
                    var e = a[index146];
                    {
                        hashCode = 31 * hashCode + javaemul.internal.FloatHelper.hashCode(e);
                        hashCode = javaemul.internal.Coercions.ensureInt(hashCode);
                    }
                }
                return hashCode;
            };
            Arrays.hashCode$int_A = function (a) {
                if (a == null) {
                    return 0;
                }
                var hashCode = 1;
                for (var index147 = 0; index147 < a.length; index147++) {
                    var e = a[index147];
                    {
                        hashCode = 31 * hashCode + javaemul.internal.IntegerHelper.hashCode(e);
                        hashCode = javaemul.internal.Coercions.ensureInt(hashCode);
                    }
                }
                return hashCode;
            };
            Arrays.hashCode$long_A = function (a) {
                if (a == null) {
                    return 0;
                }
                var hashCode = 1;
                for (var index148 = 0; index148 < a.length; index148++) {
                    var e = a[index148];
                    {
                        hashCode = 31 * hashCode + javaemul.internal.LongHelper.hashCode(e);
                        hashCode = javaemul.internal.Coercions.ensureInt(hashCode);
                    }
                }
                return hashCode;
            };
            Arrays.hashCode$java_lang_Object_A = function (a) {
                if (a == null) {
                    return 0;
                }
                var hashCode = 1;
                for (var index149 = 0; index149 < a.length; index149++) {
                    var e = a[index149];
                    {
                        hashCode = 31 * hashCode + java.util.Objects.hashCode(e);
                        hashCode = javaemul.internal.Coercions.ensureInt(hashCode);
                    }
                }
                return hashCode;
            };
            Arrays.hashCode$short_A = function (a) {
                if (a == null) {
                    return 0;
                }
                var hashCode = 1;
                for (var index150 = 0; index150 < a.length; index150++) {
                    var e = a[index150];
                    {
                        hashCode = 31 * hashCode + javaemul.internal.ShortHelper.hashCode(e);
                        hashCode = javaemul.internal.Coercions.ensureInt(hashCode);
                    }
                }
                return hashCode;
            };
            Arrays.sort$byte_A = function (array) {
                Arrays.nativeNumberSort(array);
            };
            Arrays.sort$byte_A$int$int = function (array, fromIndex, toIndex) {
                javaemul.internal.InternalPreconditions.checkPositionIndexes(fromIndex, toIndex, array.length);
                Arrays.nativeNumberSort(array, fromIndex, toIndex);
            };
            Arrays.sort$char_A = function (array) {
                Arrays.nativeNumberSort(array);
            };
            Arrays.sort$char_A$int$int = function (array, fromIndex, toIndex) {
                javaemul.internal.InternalPreconditions.checkPositionIndexes(fromIndex, toIndex, array.length);
                Arrays.nativeNumberSort(array, fromIndex, toIndex);
            };
            Arrays.sort$double_A = function (array) {
                Arrays.nativeNumberSort(array);
            };
            Arrays.sort$double_A$int$int = function (array, fromIndex, toIndex) {
                javaemul.internal.InternalPreconditions.checkPositionIndexes(fromIndex, toIndex, array.length);
                Arrays.nativeNumberSort(array, fromIndex, toIndex);
            };
            Arrays.sort$float_A = function (array) {
                Arrays.nativeNumberSort(array);
            };
            Arrays.sort$float_A$int$int = function (array, fromIndex, toIndex) {
                javaemul.internal.InternalPreconditions.checkPositionIndexes(fromIndex, toIndex, array.length);
                Arrays.nativeNumberSort(array, fromIndex, toIndex);
            };
            Arrays.sort$int_A = function (array) {
                Arrays.nativeNumberSort(array);
            };
            Arrays.sort$int_A$int$int = function (array, fromIndex, toIndex) {
                javaemul.internal.InternalPreconditions.checkPositionIndexes(fromIndex, toIndex, array.length);
                Arrays.nativeNumberSort(array, fromIndex, toIndex);
            };
            Arrays.sort$long_A = function (array) {
                Arrays.nativeLongSort(array, javaemul.internal.LongCompareHolder.getLongComparator());
            };
            Arrays.sort$long_A$int$int = function (array, fromIndex, toIndex) {
                javaemul.internal.InternalPreconditions.checkPositionIndexes(fromIndex, toIndex, array.length);
                Arrays.nativeLongSort(array, fromIndex, toIndex);
            };
            Arrays.sort$java_lang_Object_A = function (array) {
                Arrays.mergeSort(array, 0, array.length, java.util.Comparators.natural());
            };
            Arrays.sort$java_lang_Object_A$int$int = function (x, fromIndex, toIndex) {
                Arrays.mergeSort(x, fromIndex, toIndex, java.util.Comparators.natural());
            };
            Arrays.sort$short_A = function (array) {
                Arrays.nativeNumberSort(array);
            };
            Arrays.sort$short_A$int$int = function (array, fromIndex, toIndex) {
                javaemul.internal.InternalPreconditions.checkPositionIndexes(fromIndex, toIndex, array.length);
                Arrays.nativeNumberSort(array, fromIndex, toIndex);
            };
            Arrays.sort$java_lang_Object_A$java_util_Comparator = function (x, c) {
                Arrays.mergeSort(x, 0, x.length, c);
            };
            Arrays.sort = function (x, fromIndex, toIndex, c) {
                if (((x != null && x instanceof Array) || x === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && ((c != null && c["__interfaces"] != null && c["__interfaces"].indexOf("java.util.Comparator") >= 0) || c === null)) {
                    return (function () {
                        javaemul.internal.InternalPreconditions.checkPositionIndexes(fromIndex, toIndex, x.length);
                        Arrays.mergeSort(x, fromIndex, toIndex, c);
                    })();
                }
                else if (((x != null && x instanceof Array) || x === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && c === undefined) {
                    return java.util.Arrays.sort$byte_A$int$int(x, fromIndex, toIndex);
                }
                else if (((x != null && x instanceof Array) || x === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && c === undefined) {
                    return java.util.Arrays.sort$char_A$int$int(x, fromIndex, toIndex);
                }
                else if (((x != null && x instanceof Array) || x === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && c === undefined) {
                    return java.util.Arrays.sort$double_A$int$int(x, fromIndex, toIndex);
                }
                else if (((x != null && x instanceof Array) || x === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && c === undefined) {
                    return java.util.Arrays.sort$float_A$int$int(x, fromIndex, toIndex);
                }
                else if (((x != null && x instanceof Array) || x === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && c === undefined) {
                    return java.util.Arrays.sort$int_A$int$int(x, fromIndex, toIndex);
                }
                else if (((x != null && x instanceof Array) || x === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && c === undefined) {
                    return java.util.Arrays.sort$long_A$int$int(x, fromIndex, toIndex);
                }
                else if (((x != null && x instanceof Array) || x === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && c === undefined) {
                    return java.util.Arrays.sort$java_lang_Object_A$int$int(x, fromIndex, toIndex);
                }
                else if (((x != null && x instanceof Array) || x === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && c === undefined) {
                    return java.util.Arrays.sort$short_A$int$int(x, fromIndex, toIndex);
                }
                else if (((x != null && x instanceof Array) || x === null) && ((fromIndex != null && fromIndex["__interfaces"] != null && fromIndex["__interfaces"].indexOf("java.util.Comparator") >= 0) || fromIndex === null) && toIndex === undefined && c === undefined) {
                    return java.util.Arrays.sort$java_lang_Object_A$java_util_Comparator(x, fromIndex);
                }
                else if (((x != null && x instanceof Array) || x === null) && fromIndex === undefined && toIndex === undefined && c === undefined) {
                    return java.util.Arrays.sort$byte_A(x);
                }
                else if (((x != null && x instanceof Array) || x === null) && fromIndex === undefined && toIndex === undefined && c === undefined) {
                    return java.util.Arrays.sort$char_A(x);
                }
                else if (((x != null && x instanceof Array) || x === null) && fromIndex === undefined && toIndex === undefined && c === undefined) {
                    return java.util.Arrays.sort$double_A(x);
                }
                else if (((x != null && x instanceof Array) || x === null) && fromIndex === undefined && toIndex === undefined && c === undefined) {
                    return java.util.Arrays.sort$float_A(x);
                }
                else if (((x != null && x instanceof Array) || x === null) && fromIndex === undefined && toIndex === undefined && c === undefined) {
                    return java.util.Arrays.sort$int_A(x);
                }
                else if (((x != null && x instanceof Array) || x === null) && fromIndex === undefined && toIndex === undefined && c === undefined) {
                    return java.util.Arrays.sort$long_A(x);
                }
                else if (((x != null && x instanceof Array) || x === null) && fromIndex === undefined && toIndex === undefined && c === undefined) {
                    return java.util.Arrays.sort$java_lang_Object_A(x);
                }
                else if (((x != null && x instanceof Array) || x === null) && fromIndex === undefined && toIndex === undefined && c === undefined) {
                    return java.util.Arrays.sort$short_A(x);
                }
                else
                    throw new Error('invalid overload');
            };
            Arrays.toString = function (a) {
                if (((a != null && a instanceof Array) || a === null)) {
                    return (function () {
                        if (a == null) {
                            return "null";
                        }
                        var joiner = new java.util.StringJoiner(", ", "[", "]");
                        for (var index151 = 0; index151 < a.length; index151++) {
                            var element = a[index151];
                            {
                                joiner.add(/* valueOf */ new String(element).toString());
                            }
                        }
                        return joiner.toString();
                    })();
                }
                else if (((a != null && a instanceof Array) || a === null)) {
                    return java.util.Arrays.toString$byte_A(a);
                }
                else if (((a != null && a instanceof Array) || a === null)) {
                    return java.util.Arrays.toString$char_A(a);
                }
                else if (((a != null && a instanceof Array) || a === null)) {
                    return java.util.Arrays.toString$double_A(a);
                }
                else if (((a != null && a instanceof Array) || a === null)) {
                    return java.util.Arrays.toString$float_A(a);
                }
                else if (((a != null && a instanceof Array) || a === null)) {
                    return java.util.Arrays.toString$int_A(a);
                }
                else if (((a != null && a instanceof Array) || a === null)) {
                    return java.util.Arrays.toString$long_A(a);
                }
                else if (((a != null && a instanceof Array) || a === null)) {
                    return java.util.Arrays.toString$java_lang_Object_A(a);
                }
                else if (((a != null && a instanceof Array) || a === null)) {
                    return java.util.Arrays.toString$short_A(a);
                }
                else
                    throw new Error('invalid overload');
            };
            Arrays.toString$byte_A = function (a) {
                if (a == null) {
                    return "null";
                }
                var joiner = new java.util.StringJoiner(", ", "[", "]");
                for (var index152 = 0; index152 < a.length; index152++) {
                    var element = a[index152];
                    {
                        joiner.add(/* valueOf */ new String(element).toString());
                    }
                }
                return joiner.toString();
            };
            Arrays.toString$char_A = function (a) {
                if (a == null) {
                    return "null";
                }
                var joiner = new java.util.StringJoiner(", ", "[", "]");
                for (var index153 = 0; index153 < a.length; index153++) {
                    var element = a[index153];
                    {
                        joiner.add(/* valueOf */ new String(element).toString());
                    }
                }
                return joiner.toString();
            };
            Arrays.toString$double_A = function (a) {
                if (a == null) {
                    return "null";
                }
                var joiner = new java.util.StringJoiner(", ", "[", "]");
                for (var index154 = 0; index154 < a.length; index154++) {
                    var element = a[index154];
                    {
                        joiner.add(/* valueOf */ new String(element).toString());
                    }
                }
                return joiner.toString();
            };
            Arrays.toString$float_A = function (a) {
                if (a == null) {
                    return "null";
                }
                var joiner = new java.util.StringJoiner(", ", "[", "]");
                for (var index155 = 0; index155 < a.length; index155++) {
                    var element = a[index155];
                    {
                        joiner.add(/* valueOf */ new String(element).toString());
                    }
                }
                return joiner.toString();
            };
            Arrays.toString$int_A = function (a) {
                if (a == null) {
                    return "null";
                }
                var joiner = new java.util.StringJoiner(", ", "[", "]");
                for (var index156 = 0; index156 < a.length; index156++) {
                    var element = a[index156];
                    {
                        joiner.add(/* valueOf */ new String(element).toString());
                    }
                }
                return joiner.toString();
            };
            Arrays.toString$long_A = function (a) {
                if (a == null) {
                    return "null";
                }
                var joiner = new java.util.StringJoiner(", ", "[", "]");
                for (var index157 = 0; index157 < a.length; index157++) {
                    var element = a[index157];
                    {
                        joiner.add(/* valueOf */ new String(element).toString());
                    }
                }
                return joiner.toString();
            };
            Arrays.toString$java_lang_Object_A = function (x) {
                if (x == null) {
                    return "null";
                }
                return Arrays.asList.apply(null, x).toString();
            };
            Arrays.toString$short_A = function (a) {
                if (a == null) {
                    return "null";
                }
                var joiner = new java.util.StringJoiner(", ", "[", "]");
                for (var index158 = 0; index158 < a.length; index158++) {
                    var element = a[index158];
                    {
                        joiner.add(/* valueOf */ new String(element).toString());
                    }
                }
                return joiner.toString();
            };
            /**
             * Recursive helper function for {@link Arrays#deepToString(Object[])}.
             */
            Arrays.deepToString = function (a, arraysIveSeen) {
                if (((a != null && a instanceof Array) || a === null) && ((arraysIveSeen != null && arraysIveSeen["__interfaces"] != null && arraysIveSeen["__interfaces"].indexOf("java.util.Set") >= 0) || arraysIveSeen === null)) {
                    return (function () {
                        if (a == null) {
                            return "null";
                        }
                        if (!arraysIveSeen.add(a)) {
                            return "[...]";
                        }
                        var joiner = new java.util.StringJoiner(", ", "[", "]");
                        for (var index159 = 0; index159 < a.length; index159++) {
                            var obj = a[index159];
                            {
                                if (obj != null && obj.getClass().isArray()) {
                                    if (obj != null && obj instanceof Array) {
                                        if (arraysIveSeen.contains(obj)) {
                                            joiner.add("[...]");
                                        }
                                        else {
                                            var objArray = obj;
                                            var tempSet = new java.util.HashSet(arraysIveSeen);
                                            joiner.add(Arrays.deepToString(objArray, tempSet));
                                        }
                                    }
                                    else if (obj != null && obj instanceof Array) {
                                        joiner.add(Arrays.toString(obj));
                                    }
                                    else if (obj != null && obj instanceof Array) {
                                        joiner.add(Arrays.toString(obj));
                                    }
                                    else if (obj != null && obj instanceof Array) {
                                        joiner.add(Arrays.toString(obj));
                                    }
                                    else if (obj != null && obj instanceof Array) {
                                        joiner.add(Arrays.toString(obj));
                                    }
                                    else if (obj != null && obj instanceof Array) {
                                        joiner.add(Arrays.toString(obj));
                                    }
                                    else if (obj != null && obj instanceof Array) {
                                        joiner.add(Arrays.toString(obj));
                                    }
                                    else if (obj != null && obj instanceof Array) {
                                        joiner.add(Arrays.toString(obj));
                                    }
                                    else if (obj != null && obj instanceof Array) {
                                        joiner.add(Arrays.toString(obj));
                                    }
                                    else {
                                    }
                                }
                                else {
                                    joiner.add(/* valueOf */ new String(obj).toString());
                                }
                            }
                        }
                        return joiner.toString();
                    })();
                }
                else if (((a != null && a instanceof Array) || a === null) && arraysIveSeen === undefined) {
                    return java.util.Arrays.deepToString$java_lang_Object_A(a);
                }
                else
                    throw new Error('invalid overload');
            };
            Arrays.getCopyLength = function (array, from, to) {
                javaemul.internal.InternalPreconditions.checkArgument(from <= to, "%s > %s", from, to);
                var len = javaemul.internal.ArrayHelper.getLength(array);
                to = Math.min(to, len);
                javaemul.internal.InternalPreconditions.checkCriticalPositionIndexes(from, to, len);
                return to - from;
            };
            /**
             * Sort a small subsection of an array by insertion sort.
             *
             * @param array array to sort
             * @param low lower bound of range to sort
             * @param high upper bound of range to sort
             * @param comp comparator to use
             */
            Arrays.insertionSort = function (array, low, high, comp) {
                for (var i = low + 1; i < high; ++i) {
                    for (var j = i; j > low && comp.compare(array[j - 1], array[j]) > 0; --j) {
                        var t = array[j];
                        array[j] = array[j - 1];
                        array[j - 1] = t;
                    }
                }
            };
            /**
             * Merge the two sorted subarrays (srcLow,srcMid] and (srcMid,srcHigh] into
             * dest.
             *
             * @param src source array for merge
             * @param srcLow lower bound of bottom sorted half
             * @param srcMid upper bound of bottom sorted half & lower bound of top sorted
             * half
             * @param srcHigh upper bound of top sorted half
             * @param dest destination array for merge
             * @param destLow lower bound of destination
             * @param destHigh upper bound of destination
             * @param comp comparator to use
             */
            Arrays.merge = function (src, srcLow, srcMid, srcHigh, dest, destLow, destHigh, comp) {
                var topIdx = srcMid;
                while ((destLow < destHigh)) {
                    if (topIdx >= srcHigh || (srcLow < srcMid && comp.compare(src[srcLow], src[topIdx]) <= 0)) {
                        dest[destLow++] = src[srcLow++];
                    }
                    else {
                        dest[destLow++] = src[topIdx++];
                    }
                }
                ;
            };
            /**
             * Performs a merge sort on the specified portion of an object array.
             *
             * Uses O(n) temporary space to perform the merge, but is stable.
             */
            Arrays.mergeSort$java_lang_Object_A$int$int$java_util_Comparator = function (x, fromIndex, toIndex, comp) {
                if (comp == null) {
                    comp = java.util.Comparators.natural();
                }
                var temp = Arrays.copyOfRange(x, fromIndex, toIndex);
                Arrays.mergeSort(temp, x, fromIndex, toIndex, -fromIndex, comp);
            };
            /**
             * Recursive helper function for
             * {@link Arrays#mergeSort(Object[], int, int, Comparator)}.
             *
             * @param temp temporary space, as large as the range of elements being
             * sorted. On entry, temp should contain a copy of the sort range
             * from array.
             * @param array array to sort
             * @param low lower bound of range to sort
             * @param high upper bound of range to sort
             * @param ofs offset to convert an array index into a temp index
             * @param comp comparison function
             */
            Arrays.mergeSort = function (temp, array, low, high, ofs, comp) {
                if (((temp != null && temp instanceof Array) || temp === null) && ((array != null && array instanceof Array) || array === null) && ((typeof low === 'number') || low === null) && ((typeof high === 'number') || high === null) && ((typeof ofs === 'number') || ofs === null) && ((comp != null && comp["__interfaces"] != null && comp["__interfaces"].indexOf("java.util.Comparator") >= 0) || comp === null)) {
                    return (function () {
                        var length = high - low;
                        if (length < 7) {
                            Arrays.insertionSort(array, low, high, comp);
                            return;
                        }
                        var tempLow = low + ofs;
                        var tempHigh = high + ofs;
                        var tempMid = tempLow + ((tempHigh - tempLow) >> 1);
                        Arrays.mergeSort(array, temp, tempLow, tempMid, -ofs, comp);
                        Arrays.mergeSort(array, temp, tempMid, tempHigh, -ofs, comp);
                        if (comp.compare(temp[tempMid - 1], temp[tempMid]) <= 0) {
                            while ((low < high)) {
                                array[low++] = temp[tempLow++];
                            }
                            ;
                            return;
                        }
                        Arrays.merge(temp, tempLow, tempMid, tempHigh, array, low, high, comp);
                    })();
                }
                else if (((temp != null && temp instanceof Array) || temp === null) && ((typeof array === 'number') || array === null) && ((typeof low === 'number') || low === null) && ((high != null && high["__interfaces"] != null && high["__interfaces"].indexOf("java.util.Comparator") >= 0) || high === null) && ofs === undefined && comp === undefined) {
                    return java.util.Arrays.mergeSort$java_lang_Object_A$int$int$java_util_Comparator(temp, array, low, high);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Sort an entire array of number primitives.
             */
            Arrays.nativeLongSort$java_lang_Object$java_lang_Object = function (array, compareFunction) {
                array.sort(compareFunction);
            };
            /**
             * Sort a subset of an array of number primitives.
             */
            Arrays.nativeLongSort = function (array, fromIndex, toIndex) {
                if (((array != null) || array === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null)) {
                    return (function () {
                        var temp = javaemul.internal.ArrayHelper.unsafeClone(array, fromIndex, toIndex);
                        Arrays.nativeLongSort(temp, javaemul.internal.LongCompareHolder.getLongComparator());
                        javaemul.internal.ArrayHelper.copy(temp, 0, array, fromIndex, toIndex - fromIndex);
                    })();
                }
                else if (((array != null) || array === null) && ((fromIndex != null) || fromIndex === null) && toIndex === undefined) {
                    return java.util.Arrays.nativeLongSort$java_lang_Object$java_lang_Object(array, fromIndex);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Sort an entire array of number primitives.
             */
            Arrays.nativeNumberSort$java_lang_Object = function (array) {
                array.sort(function (a, b) {
                    return a - b;
                });
            };
            /**
             * Sort a subset of an array of number primitives.
             */
            Arrays.nativeNumberSort = function (array, fromIndex, toIndex) {
                if (((array != null) || array === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null)) {
                    return (function () {
                        var temp = javaemul.internal.ArrayHelper.unsafeClone(array, fromIndex, toIndex);
                        Arrays.nativeNumberSort(temp);
                        javaemul.internal.ArrayHelper.copy(temp, 0, array, fromIndex, toIndex - fromIndex);
                    })();
                }
                else if (((array != null) || array === null) && fromIndex === undefined && toIndex === undefined) {
                    return java.util.Arrays.nativeNumberSort$java_lang_Object(array);
                }
                else
                    throw new Error('invalid overload');
            };
            return Arrays;
        }());
        util.Arrays = Arrays;
        var Arrays;
        (function (Arrays) {
            var ArrayList = (function (_super) {
                __extends(ArrayList, _super);
                function ArrayList(array) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.RandomAccess", "java.util.List", "java.util.Collection", "java.lang.Iterable", "java.io.Serializable"] });
                    this.array = array;
                }
                ArrayList.prototype.contains = function (o) {
                    return (this.indexOf(o) !== -1);
                };
                ArrayList.prototype.get = function (index) {
                    javaemul.internal.InternalPreconditions.checkElementIndex(index, this.size());
                    return this.array[index];
                };
                ArrayList.prototype.set = function (index, value) {
                    var was = this.get(index);
                    this.array[index] = value;
                    return was;
                };
                ArrayList.prototype.size = function () {
                    return this.array.length;
                };
                ArrayList.prototype.toArray$ = function () {
                    return this.toArray(new Array(this.array.length));
                };
                ArrayList.prototype.toArray = function (out) {
                    var _this = this;
                    if (((out != null && out instanceof Array) || out === null)) {
                        return (function () {
                            var size = _this.size();
                            if (out.length < size) {
                                out = javaemul.internal.ArrayHelper.createFrom(out, size);
                            }
                            for (var i = 0; i < size; ++i) {
                                out[i] = _this.array[i];
                            }
                            if (out.length > size) {
                                out[size] = null;
                            }
                            return out;
                        })();
                    }
                    else if (out === undefined) {
                        return this.toArray$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                return ArrayList;
            }(java.util.AbstractList));
            Arrays.ArrayList = ArrayList;
        })(Arrays = util.Arrays || (util.Arrays = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * To keep performance characteristics in line with Java community expectations,
         * <code>Vector</code> is a wrapper around <code>ArrayList</code>. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Vector.html">[Sun
         * docs]</a>
         *
         * @param <E> element type.
         */
        var Vector = (function (_super) {
            __extends(Vector, _super);
            /**
             * Capacity increment is ignored.
             */
            function Vector(initialCapacity, ignoredCapacityIncrement) {
                var _this = this;
                if (((typeof initialCapacity === 'number') || initialCapacity === null) && ((typeof ignoredCapacityIncrement === 'number') || ignoredCapacityIncrement === null)) {
                    {
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.RandomAccess", "java.util.List", "java.lang.Cloneable", "java.util.Collection", "java.lang.Iterable", "java.io.Serializable"] });
                        (function () {
                            _this.arrayList = new java.util.ArrayList(initialCapacity);
                        })();
                    }
                    (function () {
                    })();
                }
                else if (((initialCapacity != null && initialCapacity["__interfaces"] != null && initialCapacity["__interfaces"].indexOf("java.util.Collection") >= 0) || initialCapacity === null) && ignoredCapacityIncrement === undefined) {
                    var c = initialCapacity;
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.RandomAccess", "java.util.List", "java.lang.Cloneable", "java.util.Collection", "java.lang.Iterable", "java.io.Serializable"] });
                    (function () {
                        _this.arrayList = new java.util.ArrayList();
                        _this.addAll(c);
                    })();
                }
                else if (((typeof initialCapacity === 'number') || initialCapacity === null) && ignoredCapacityIncrement === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.RandomAccess", "java.util.List", "java.lang.Cloneable", "java.util.Collection", "java.lang.Iterable", "java.io.Serializable"] });
                    (function () {
                        _this.arrayList = new java.util.ArrayList(initialCapacity);
                    })();
                }
                else if (initialCapacity === undefined && ignoredCapacityIncrement === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.RandomAccess", "java.util.List", "java.lang.Cloneable", "java.util.Collection", "java.lang.Iterable", "java.io.Serializable"] });
                    (function () {
                        _this.arrayList = new java.util.ArrayList();
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            Vector.prototype.forEach = function (action) {
                javaemul.internal.InternalPreconditions.checkNotNull(action);
                for (var index160 = this.iterator(); index160.hasNext();) {
                    var t = index160.next();
                    {
                        action(t);
                    }
                }
            };
            Vector.prototype.add$java_lang_Object = function (o) {
                return this.arrayList.add(o);
            };
            Vector.prototype.add = function (index, o) {
                var _this = this;
                if (((typeof index === 'number') || index === null) && ((o != null) || o === null)) {
                    return (function () {
                        Vector.checkArrayElementIndex(index, _this.size() + 1);
                        _this.arrayList.add(index, o);
                    })();
                }
                else if (((index != null) || index === null) && o === undefined) {
                    return this.add$java_lang_Object(index);
                }
                else
                    throw new Error('invalid overload');
            };
            Vector.prototype.addAll$java_util_Collection = function (c) {
                return this.arrayList.addAll(c);
            };
            Vector.prototype.addAll = function (index, c) {
                var _this = this;
                if (((typeof index === 'number') || index === null) && ((c != null && c["__interfaces"] != null && c["__interfaces"].indexOf("java.util.Collection") >= 0) || c === null)) {
                    return (function () {
                        return _this.arrayList.addAll(index, c);
                    })();
                }
                else if (((index != null && index["__interfaces"] != null && index["__interfaces"].indexOf("java.util.Collection") >= 0) || index === null) && c === undefined) {
                    return this.addAll$java_util_Collection(index);
                }
                else
                    throw new Error('invalid overload');
            };
            Vector.prototype.addElement = function (o) {
                this.add(o);
            };
            Vector.prototype.capacity = function () {
                return this.arrayList.size();
            };
            Vector.prototype.clear = function () {
                this.arrayList.clear();
            };
            Vector.prototype.clone = function () {
                return new Vector(this);
            };
            Vector.prototype.contains = function (elem) {
                return this.arrayList.contains(elem);
            };
            Vector.prototype.containsAll = function (c) {
                return this.arrayList.containsAll(c);
            };
            Vector.prototype.copyInto = function (objs) {
                var i = -1;
                var n = this.size();
                while ((++i < n)) {
                    objs[i] = this.get(i);
                }
                ;
            };
            Vector.prototype.elementAt = function (index) {
                return this.get(index);
            };
            Vector.prototype.elements = function () {
                return java.util.Collections.enumeration(this.arrayList);
            };
            Vector.prototype.ensureCapacity = function (capacity) {
                this.arrayList.ensureCapacity(capacity);
            };
            Vector.prototype.firstElement = function () {
                javaemul.internal.InternalPreconditions.checkElement(!this.isEmpty());
                return this.get(0);
            };
            Vector.prototype.get = function (index) {
                Vector.checkArrayElementIndex(index, this.size());
                return this.arrayList.get(index);
            };
            Vector.prototype.indexOf$java_lang_Object = function (elem) {
                return this.arrayList.indexOf(elem);
            };
            Vector.prototype.indexOf = function (elem, index) {
                var _this = this;
                if (((elem != null) || elem === null) && ((typeof index === 'number') || index === null)) {
                    return (function () {
                        Vector.checkArrayIndexOutOfBounds(index >= 0, index);
                        return _this.arrayList.indexOf(elem, index);
                    })();
                }
                else if (((elem != null) || elem === null) && index === undefined) {
                    return this.indexOf$java_lang_Object(elem);
                }
                else
                    throw new Error('invalid overload');
            };
            Vector.prototype.insertElementAt = function (o, index) {
                this.add(index, o);
            };
            Vector.prototype.isEmpty = function () {
                return (this.arrayList.size() === 0);
            };
            Vector.prototype.iterator = function () {
                return this.arrayList.iterator();
            };
            Vector.prototype.lastElement = function () {
                javaemul.internal.InternalPreconditions.checkElement(!this.isEmpty());
                return this.get(this.size() - 1);
            };
            Vector.prototype.lastIndexOf$java_lang_Object = function (o) {
                return this.arrayList.lastIndexOf(o);
            };
            Vector.prototype.lastIndexOf = function (o, index) {
                var _this = this;
                if (((o != null) || o === null) && ((typeof index === 'number') || index === null)) {
                    return (function () {
                        Vector.checkArrayIndexOutOfBounds(index < _this.size(), index);
                        return _this.arrayList.lastIndexOf(o, index);
                    })();
                }
                else if (((o != null) || o === null) && index === undefined) {
                    return this.lastIndexOf$java_lang_Object(o);
                }
                else
                    throw new Error('invalid overload');
            };
            Vector.prototype.remove = function (index) {
                var _this = this;
                if (((typeof index === 'number') || index === null)) {
                    return (function () {
                        Vector.checkArrayElementIndex(index, _this.size());
                        return _this.arrayList.remove(index);
                    })();
                }
                else if (((index != null) || index === null)) {
                    return this.remove$java_lang_Object(index);
                }
                else
                    throw new Error('invalid overload');
            };
            Vector.prototype.removeAll = function (c) {
                return this.arrayList.removeAll(c);
            };
            Vector.prototype.removeAllElements = function () {
                this.clear();
            };
            Vector.prototype.removeElement = function (o) {
                return this.remove(o);
            };
            Vector.prototype.removeElementAt = function (index) {
                this.remove(index);
            };
            Vector.prototype.set = function (index, elem) {
                Vector.checkArrayElementIndex(index, this.size());
                return this.arrayList.set(index, elem);
            };
            Vector.prototype.setElementAt = function (o, index) {
                this.set(index, o);
            };
            Vector.prototype.setSize = function (size) {
                Vector.checkArrayIndexOutOfBounds(size >= 0, size);
                this.arrayList.setSize(size);
            };
            Vector.prototype.size = function () {
                return this.arrayList.size();
            };
            Vector.prototype.subList = function (fromIndex, toIndex) {
                return this.arrayList.subList(fromIndex, toIndex);
            };
            Vector.prototype.toArray$ = function () {
                return this.arrayList.toArray();
            };
            Vector.prototype.toArray = function (a) {
                var _this = this;
                if (((a != null && a instanceof Array) || a === null)) {
                    return (function () {
                        return _this.arrayList.toArray(a);
                    })();
                }
                else if (a === undefined) {
                    return this.toArray$();
                }
                else
                    throw new Error('invalid overload');
            };
            Vector.prototype.toString = function () {
                return this.arrayList.toString();
            };
            Vector.prototype.trimToSize = function () {
                this.arrayList.trimToSize();
            };
            Vector.prototype.removeRange = function (fromIndex, endIndex) {
                this.arrayList.removeRange(fromIndex, endIndex);
            };
            Vector.checkArrayElementIndex = function (index, size) {
                if (index < 0 || index >= size) {
                    throw new java.lang.ArrayIndexOutOfBoundsException();
                }
            };
            Vector.checkArrayIndexOutOfBounds = function (expression, index) {
                if (!expression) {
                    throw new java.lang.ArrayIndexOutOfBoundsException(/* valueOf */ new String(index).toString());
                }
            };
            return Vector;
        }(java.util.AbstractList));
        util.Vector = Vector;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * An unbounded priority queue based on a priority heap. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/PriorityQueue.html">[Sun
         * docs]</a>
         *
         * @param <E> element type.
         */
        var PriorityQueue = (function (_super) {
            __extends(PriorityQueue, _super);
            function PriorityQueue(initialCapacity, cmp) {
                var _this = this;
                if (((typeof initialCapacity === 'number') || initialCapacity === null) && ((cmp != null && cmp["__interfaces"] != null && cmp["__interfaces"].indexOf("java.util.Comparator") >= 0) || cmp === null)) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Collection", "java.util.Queue", "java.lang.Iterable"] });
                    (function () {
                        _this.heap = new java.util.ArrayList(initialCapacity);
                        if (cmp == null) {
                            cmp = java.util.Comparators.natural();
                        }
                        _this.cmp = cmp;
                    })();
                }
                else if (((initialCapacity != null && initialCapacity instanceof java.util.PriorityQueue) || initialCapacity === null) && cmp === undefined) {
                    var c = initialCapacity;
                    {
                        var initialCapacity = c.size();
                        var cmp = c.comparator();
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Collection", "java.util.Queue", "java.lang.Iterable"] });
                        (function () {
                            _this.heap = new java.util.ArrayList(initialCapacity);
                            if (cmp == null) {
                                cmp = java.util.Comparators.natural();
                            }
                            _this.cmp = cmp;
                        })();
                    }
                    (function () {
                        _this.addAll(c);
                    })();
                }
                else if (((initialCapacity != null && initialCapacity["__interfaces"] != null && initialCapacity["__interfaces"].indexOf("java.util.SortedSet") >= 0) || initialCapacity === null) && cmp === undefined) {
                    var c = initialCapacity;
                    {
                        var initialCapacity = c.size();
                        var cmp = c.comparator();
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Collection", "java.util.Queue", "java.lang.Iterable"] });
                        (function () {
                            _this.heap = new java.util.ArrayList(initialCapacity);
                            if (cmp == null) {
                                cmp = java.util.Comparators.natural();
                            }
                            _this.cmp = cmp;
                        })();
                    }
                    (function () {
                        _this.addAll(c);
                    })();
                }
                else if (((initialCapacity != null && initialCapacity["__interfaces"] != null && initialCapacity["__interfaces"].indexOf("java.util.Collection") >= 0) || initialCapacity === null) && cmp === undefined) {
                    var c = initialCapacity;
                    {
                        var initialCapacity = c.size();
                        {
                            var cmp = null;
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Collection", "java.util.Queue", "java.lang.Iterable"] });
                            (function () {
                                _this.heap = new java.util.ArrayList(initialCapacity);
                                if (cmp == null) {
                                    cmp = java.util.Comparators.natural();
                                }
                                _this.cmp = cmp;
                            })();
                        }
                        (function () {
                        })();
                    }
                    (function () {
                        _this.addAll(c);
                    })();
                }
                else if (((typeof initialCapacity === 'number') || initialCapacity === null) && cmp === undefined) {
                    {
                        var cmp = null;
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Collection", "java.util.Queue", "java.lang.Iterable"] });
                        (function () {
                            _this.heap = new java.util.ArrayList(initialCapacity);
                            if (cmp == null) {
                                cmp = java.util.Comparators.natural();
                            }
                            _this.cmp = cmp;
                        })();
                    }
                    (function () {
                    })();
                }
                else if (initialCapacity === undefined && cmp === undefined) {
                    {
                        var initialCapacity = 11;
                        {
                            var cmp = null;
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Collection", "java.util.Queue", "java.lang.Iterable"] });
                            (function () {
                                _this.heap = new java.util.ArrayList(initialCapacity);
                                if (cmp == null) {
                                    cmp = java.util.Comparators.natural();
                                }
                                _this.cmp = cmp;
                            })();
                        }
                        (function () {
                        })();
                    }
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            PriorityQueue.getLeftChild = function (node) {
                return 2 * node + 1;
            };
            PriorityQueue.getParent = function (node) {
                return ((node - 1) / 2 | 0);
            };
            PriorityQueue.getRightChild = function (node) {
                return 2 * node + 2;
            };
            PriorityQueue.isLeaf = function (node, size) {
                return node * 2 + 1 >= size;
            };
            PriorityQueue.prototype.addAll = function (index, c) {
                if (((index != null && index["__interfaces"] != null && index["__interfaces"].indexOf("java.util.Collection") >= 0) || index === null) && c === undefined) {
                    return this.addAll$java_util_Collection(index);
                }
                else
                    throw new Error('invalid overload');
            };
            PriorityQueue.prototype.addAll$java_util_Collection = function (c) {
                if (this.heap.addAll(c)) {
                    this.makeHeap(0);
                    return true;
                }
                return false;
            };
            PriorityQueue.prototype.clear = function () {
                this.heap.clear();
            };
            PriorityQueue.prototype.comparator = function () {
                return this.cmp === java.util.Comparators.natural() ? null : this.cmp;
            };
            PriorityQueue.prototype.contains = function (o) {
                return this.heap.contains(o);
            };
            PriorityQueue.prototype.containsAll = function (c) {
                return this.heap.containsAll(c);
            };
            PriorityQueue.prototype.isEmpty = function () {
                return this.heap.isEmpty();
            };
            PriorityQueue.prototype.iterator = function () {
                return java.util.Collections.unmodifiableList(this.heap).iterator();
            };
            PriorityQueue.prototype.offer = function (e) {
                var node = this.heap.size();
                this.heap.add(e);
                while ((node > 0)) {
                    var childNode = node;
                    node = PriorityQueue.getParent(node);
                    if (this.cmp.compare(this.heap.get(node), e) <= 0) {
                        this.heap.set(childNode, e);
                        return true;
                    }
                    this.heap.set(childNode, this.heap.get(node));
                }
                ;
                this.heap.set(node, e);
                return true;
            };
            PriorityQueue.prototype.peek = function () {
                if (this.heap.size() === 0) {
                    return null;
                }
                return this.heap.get(0);
            };
            PriorityQueue.prototype.poll = function () {
                if (this.heap.size() === 0) {
                    return null;
                }
                var value = this.heap.get(0);
                this.removeAtIndex(0);
                return value;
            };
            PriorityQueue.prototype.remove = function (index) {
                if (((index != null) || index === null)) {
                    return this.remove$java_lang_Object(index);
                }
                else if (index === undefined) {
                    return this.remove$();
                }
                else
                    throw new Error('invalid overload');
            };
            PriorityQueue.prototype.remove$java_lang_Object = function (o) {
                var index = this.heap.indexOf(o);
                if (index < 0) {
                    return false;
                }
                this.removeAtIndex(index);
                return true;
            };
            PriorityQueue.prototype.removeAll = function (c) {
                if (this.heap.removeAll(c)) {
                    this.makeHeap(0);
                    return true;
                }
                return false;
            };
            PriorityQueue.prototype.retainAll = function (c) {
                if (this.heap.retainAll(c)) {
                    this.makeHeap(0);
                    return true;
                }
                return false;
            };
            PriorityQueue.prototype.size = function () {
                return this.heap.size();
            };
            PriorityQueue.prototype.toArray$ = function () {
                return this.heap.toArray();
            };
            PriorityQueue.prototype.toArray = function (a) {
                var _this = this;
                if (((a != null && a instanceof Array) || a === null)) {
                    return (function () {
                        return _this.heap.toArray(a);
                    })();
                }
                else if (a === undefined) {
                    return this.toArray$();
                }
                else
                    throw new Error('invalid overload');
            };
            PriorityQueue.prototype.toString = function () {
                return this.heap.toString();
            };
            /**
             * Make the subtree rooted at <code>node</code> a valid heap. O(n) time
             *
             * @param node
             */
            PriorityQueue.prototype.makeHeap = function (node) {
                if (this.isLeaf(node)) {
                    return;
                }
                this.makeHeap(PriorityQueue.getLeftChild(node));
                var rightChild = PriorityQueue.getRightChild(node);
                if (rightChild < this.heap.size()) {
                    this.makeHeap(rightChild);
                }
                this.mergeHeaps(node);
            };
            /**
             * Merge two subheaps into a single heap. O(log n) time
             *
             * PRECONDITION: both children of <code>node</code> are heaps
             *
             * @param node the parent of the two subtrees to merge
             */
            PriorityQueue.prototype.mergeHeaps = function (node) {
                var heapSize = this.heap.size();
                var value = this.heap.get(node);
                while ((!PriorityQueue.isLeaf(node, heapSize))) {
                    var smallestChild = this.getSmallestChild(node, heapSize);
                    if (this.cmp.compare(value, this.heap.get(smallestChild)) < 0) {
                        break;
                    }
                    this.heap.set(node, this.heap.get(smallestChild));
                    node = smallestChild;
                }
                ;
                this.heap.set(node, value);
            };
            PriorityQueue.prototype.getSmallestChild = function (node, heapSize) {
                var smallestChild;
                var leftChild = PriorityQueue.getLeftChild(node);
                var rightChild = leftChild + 1;
                smallestChild = leftChild;
                if ((rightChild < heapSize) && (this.cmp.compare(this.heap.get(rightChild), this.heap.get(leftChild)) < 0)) {
                    smallestChild = rightChild;
                }
                return smallestChild;
            };
            PriorityQueue.prototype.isLeaf = function (node) {
                return PriorityQueue.isLeaf(node, this.heap.size());
            };
            PriorityQueue.prototype.removeAtIndex = function (index) {
                var lastValue = this.heap.remove(this.heap.size() - 1);
                if (index < this.heap.size()) {
                    this.heap.set(index, lastValue);
                    this.mergeHeaps(index);
                }
            };
            return PriorityQueue;
        }(java.util.AbstractQueue));
        util.PriorityQueue = PriorityQueue;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * Skeletal implementation of the Map interface.
         * <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractMap.html">
         * [Sun docs]</a>
         *
         * @param <K>
         * the key type.
         * @param <V>
         * the value type.
         */
        var AbstractMap = (function () {
            function AbstractMap() {
                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Map"] });
            }
            AbstractMap.prototype.clear = function () {
                this.entrySet().clear();
            };
            AbstractMap.prototype.containsKey = function (key) {
                return this.implFindEntry(key, false) != null;
            };
            AbstractMap.prototype.containsValue = function (value) {
                for (var index161 = this.entrySet().iterator(); index161.hasNext();) {
                    var entry = index161.next();
                    {
                        var v = entry.getValue();
                        if (java.util.Objects.equals(value, v)) {
                            return true;
                        }
                    }
                }
                return false;
            };
            AbstractMap.prototype.containsEntry = function (entry) {
                var key = entry.getKey();
                var value = entry.getValue();
                var ourValue = this.get(key);
                if (!java.util.Objects.equals(value, ourValue)) {
                    return false;
                }
                if (ourValue == null && !this.containsKey(key)) {
                    return false;
                }
                return true;
            };
            AbstractMap.prototype.equals = function (obj) {
                if (obj === this) {
                    return true;
                }
                if (!(obj != null && obj["__interfaces"] != null && obj["__interfaces"].indexOf("java.util.Map") >= 0)) {
                    return false;
                }
                var otherMap = obj;
                if (this.size() !== otherMap.size()) {
                    return false;
                }
                for (var index162 = otherMap.entrySet().iterator(); index162.hasNext();) {
                    var entry = index162.next();
                    {
                        if (!this.containsEntry(entry)) {
                            return false;
                        }
                    }
                }
                return true;
            };
            AbstractMap.prototype.get = function (key) {
                return AbstractMap.getEntryValueOrNull(this.implFindEntry(key, false));
            };
            AbstractMap.prototype.hashCode = function () {
                return java.util.Collections.hashCode(this.entrySet());
            };
            AbstractMap.prototype.isEmpty = function () {
                return this.size() === 0;
            };
            AbstractMap.prototype.keySet = function () {
                return new AbstractMap.AbstractMap$0(this);
            };
            AbstractMap.prototype.put = function (key, value) {
                if (((key != null) || key === null) && ((value != null) || value === null)) {
                    return this.put$java_lang_Object$java_lang_Object(key, value);
                }
                else
                    throw new Error('invalid overload');
            };
            AbstractMap.prototype.put$java_lang_Object$java_lang_Object = function (key, value) {
                throw new java.lang.UnsupportedOperationException("Put not supported on this map");
            };
            AbstractMap.prototype.putAll = function (map) {
                javaemul.internal.InternalPreconditions.checkNotNull(map);
                for (var index163 = map.entrySet().iterator(); index163.hasNext();) {
                    var e = index163.next();
                    {
                        this.put(e.getKey(), e.getValue());
                    }
                }
            };
            AbstractMap.prototype.remove = function (key) {
                return AbstractMap.getEntryValueOrNull(this.implFindEntry(key, true));
            };
            AbstractMap.prototype.size = function () {
                return this.entrySet().size();
            };
            AbstractMap.prototype.toString$ = function () {
                var joiner = new java.util.StringJoiner(", ", "{", "}");
                for (var index164 = this.entrySet().iterator(); index164.hasNext();) {
                    var entry = index164.next();
                    {
                        joiner.add(this.toString(entry));
                    }
                }
                return joiner.toString();
            };
            AbstractMap.prototype.toString = function (entry) {
                var _this = this;
                if (((entry != null && entry["__interfaces"] != null && entry["__interfaces"].indexOf("java.util.Map.Entry") >= 0) || entry === null)) {
                    return (function () {
                        return _this.toString(entry.getKey()) + "=" + _this.toString(entry.getValue());
                    })();
                }
                else if (((entry != null) || entry === null)) {
                    return this.toString$java_lang_Object(entry);
                }
                else if (entry === undefined) {
                    return this.toString$();
                }
                else
                    throw new Error('invalid overload');
            };
            AbstractMap.prototype.toString$java_lang_Object = function (o) {
                return o === this ? "(this Map)" : new String(o).toString();
            };
            AbstractMap.prototype.values = function () {
                return new AbstractMap.AbstractMap$1(this);
            };
            AbstractMap.getEntryKeyOrNull = function (entry) {
                return entry == null ? null : entry.getKey();
            };
            AbstractMap.getEntryValueOrNull = function (entry) {
                return entry == null ? null : entry.getValue();
            };
            AbstractMap.prototype.implFindEntry = function (key, remove) {
                for (var iter = this.entrySet().iterator(); iter.hasNext();) {
                    var entry = iter.next();
                    var k = entry.getKey();
                    if (java.util.Objects.equals(key, k)) {
                        if (remove) {
                            entry = new AbstractMap.SimpleEntry(entry.getKey(), entry.getValue());
                            iter.remove();
                        }
                        return entry;
                    }
                }
                return null;
            };
            return AbstractMap;
        }());
        util.AbstractMap = AbstractMap;
        var AbstractMap;
        (function (AbstractMap) {
            /**
             * Basic {@link Map.Entry} implementation used by {@link SimpleEntry} and
             * {@link SimpleImmutableEntry}.
             */
            var AbstractEntry = (function () {
                function AbstractEntry(key, value) {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Map.Entry"] });
                    this.key = key;
                    this.value = value;
                }
                AbstractEntry.prototype.getKey = function () {
                    return this.key;
                };
                AbstractEntry.prototype.getValue = function () {
                    return this.value;
                };
                AbstractEntry.prototype.setValue = function (value) {
                    var oldValue = this.value;
                    this.value = value;
                    return oldValue;
                };
                AbstractEntry.prototype.equals = function (other) {
                    if (!(other != null && other["__interfaces"] != null && other["__interfaces"].indexOf("java.util.Map.Entry") >= 0)) {
                        return false;
                    }
                    var entry = other;
                    return java.util.Objects.equals(this.key, entry.getKey()) && java.util.Objects.equals(this.value, entry.getValue());
                };
                /**
                 * Calculate the hash code using Sun's specified algorithm.
                 */
                AbstractEntry.prototype.hashCode = function () {
                    return java.util.Objects.hashCode(this.key) ^ java.util.Objects.hashCode(this.value);
                };
                AbstractEntry.prototype.toString = function () {
                    return this.key + "=" + this.value;
                };
                return AbstractEntry;
            }());
            AbstractMap.AbstractEntry = AbstractEntry;
            /**
             * A mutable {@link Map.Entry} shared by several {@link Map}
             * implementations.
             */
            var SimpleEntry = (function (_super) {
                __extends(SimpleEntry, _super);
                function SimpleEntry(key, value) {
                    if (((key != null) || key === null) && ((value != null) || value === null)) {
                        _super.call(this, key, value);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Map.Entry"] });
                        (function () {
                        })();
                    }
                    else if (((key != null && key["__interfaces"] != null && key["__interfaces"].indexOf("java.util.Map.Entry") >= 0) || key === null) && value === undefined) {
                        var entry = key;
                        _super.call(this, entry.getKey(), entry.getValue());
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Map.Entry"] });
                        (function () {
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                }
                return SimpleEntry;
            }(AbstractMap.AbstractEntry));
            AbstractMap.SimpleEntry = SimpleEntry;
            /**
             * An immutable {@link Map.Entry} shared by several {@link Map}
             * implementations.
             */
            var SimpleImmutableEntry = (function (_super) {
                __extends(SimpleImmutableEntry, _super);
                function SimpleImmutableEntry(key, value) {
                    if (((key != null) || key === null) && ((value != null) || value === null)) {
                        _super.call(this, key, value);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Map.Entry"] });
                        (function () {
                        })();
                    }
                    else if (((key != null && key["__interfaces"] != null && key["__interfaces"].indexOf("java.util.Map.Entry") >= 0) || key === null) && value === undefined) {
                        var entry = key;
                        _super.call(this, entry.getKey(), entry.getValue());
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Map.Entry"] });
                        (function () {
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                }
                SimpleImmutableEntry.prototype.setValue = function (value) {
                    throw new java.lang.UnsupportedOperationException();
                };
                return SimpleImmutableEntry;
            }(AbstractMap.AbstractEntry));
            AbstractMap.SimpleImmutableEntry = SimpleImmutableEntry;
            var AbstractMap$0 = (function (_super) {
                __extends(AbstractMap$0, _super);
                function AbstractMap$0(__parent) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Collection", "java.util.Set", "java.lang.Iterable"] });
                    this.__parent = __parent;
                }
                AbstractMap$0.prototype.clear = function () {
                    this.__parent.clear();
                };
                AbstractMap$0.prototype.contains = function (key) {
                    return this.__parent.containsKey(key);
                };
                AbstractMap$0.prototype.iterator = function () {
                    var outerIter = this.__parent.entrySet().iterator();
                    return new AbstractMap$0.AbstractMap$0$0(this, outerIter);
                };
                AbstractMap$0.prototype.remove = function (key) {
                    if (this.__parent.containsKey(key)) {
                        this.__parent.remove(key);
                        return true;
                    }
                    return false;
                };
                AbstractMap$0.prototype.size = function () {
                    return this.__parent.size();
                };
                return AbstractMap$0;
            }(java.util.AbstractSet));
            AbstractMap.AbstractMap$0 = AbstractMap$0;
            var AbstractMap$0;
            (function (AbstractMap$0) {
                var AbstractMap$0$0 = (function () {
                    function AbstractMap$0$0(__parent, outerIter) {
                        this.outerIter = outerIter;
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Iterator"] });
                        this.__parent = __parent;
                    }
                    AbstractMap$0$0.prototype.forEachRemaining = function (consumer) {
                        javaemul.internal.InternalPreconditions.checkNotNull(consumer);
                        while ((this.hasNext())) {
                            consumer(this.next());
                        }
                        ;
                    };
                    AbstractMap$0$0.prototype.hasNext = function () {
                        return this.outerIter.hasNext();
                    };
                    AbstractMap$0$0.prototype.next = function () {
                        var entry = this.outerIter.next();
                        return entry.getKey();
                    };
                    AbstractMap$0$0.prototype.remove = function () {
                        this.outerIter.remove();
                    };
                    return AbstractMap$0$0;
                }());
                AbstractMap$0.AbstractMap$0$0 = AbstractMap$0$0;
            })(AbstractMap$0 = AbstractMap.AbstractMap$0 || (AbstractMap.AbstractMap$0 = {}));
            var AbstractMap$1 = (function (_super) {
                __extends(AbstractMap$1, _super);
                function AbstractMap$1(__parent) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Collection", "java.lang.Iterable"] });
                    this.__parent = __parent;
                }
                AbstractMap$1.prototype.clear = function () {
                    this.__parent.clear();
                };
                AbstractMap$1.prototype.contains = function (value) {
                    return this.__parent.containsValue(value);
                };
                AbstractMap$1.prototype.iterator = function () {
                    var outerIter = this.__parent.entrySet().iterator();
                    return new AbstractMap$1.AbstractMap$1$0(this, outerIter);
                };
                AbstractMap$1.prototype.size = function () {
                    return this.__parent.size();
                };
                return AbstractMap$1;
            }(java.util.AbstractCollection));
            AbstractMap.AbstractMap$1 = AbstractMap$1;
            var AbstractMap$1;
            (function (AbstractMap$1) {
                var AbstractMap$1$0 = (function () {
                    function AbstractMap$1$0(__parent, outerIter) {
                        this.outerIter = outerIter;
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Iterator"] });
                        this.__parent = __parent;
                    }
                    AbstractMap$1$0.prototype.forEachRemaining = function (consumer) {
                        javaemul.internal.InternalPreconditions.checkNotNull(consumer);
                        while ((this.hasNext())) {
                            consumer(this.next());
                        }
                        ;
                    };
                    AbstractMap$1$0.prototype.hasNext = function () {
                        return this.outerIter.hasNext();
                    };
                    AbstractMap$1$0.prototype.next = function () {
                        var entry = this.outerIter.next();
                        return entry.getValue();
                    };
                    AbstractMap$1$0.prototype.remove = function () {
                        this.outerIter.remove();
                    };
                    return AbstractMap$1$0;
                }());
                AbstractMap$1.AbstractMap$1$0 = AbstractMap$1$0;
            })(AbstractMap$1 = AbstractMap.AbstractMap$1 || (AbstractMap.AbstractMap$1 = {}));
        })(AbstractMap = util.AbstractMap || (util.AbstractMap = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * A {@link java.util.Set} of {@link Enum}s. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/EnumSet.html">[Sun
         * docs]</a>
         *
         * @param <E> enumeration type
         */
        var EnumSet = (function (_super) {
            __extends(EnumSet, _super);
            /**
             * Single implementation only.
             */
            function EnumSet() {
                _super.call(this);
                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Collection", "java.util.Set", "java.lang.Iterable"] });
            }
            EnumSet.allOf = function (elementType) {
                var all = elementType.getEnumConstants();
                var set = javaemul.internal.ArrayHelper.clone(all, 0, all.length);
                return new EnumSet.EnumSetImpl(all, set, all.length);
            };
            EnumSet.complementOf = function (other) {
                var s = other;
                var all = s.all;
                var oldSet = s.set;
                var newSet = javaemul.internal.ArrayHelper.createFrom(oldSet, oldSet.length);
                for (var i = 0, c = oldSet.length; i < c; ++i) {
                    if (oldSet[i] == null) {
                        newSet[i] = all[i];
                    }
                }
                return new EnumSet.EnumSetImpl(all, newSet, all.length - s.__size);
            };
            EnumSet.copyOf$java_util_Collection = function (c) {
                if (c != null && c instanceof java.util.EnumSet) {
                    return EnumSet.copyOf(c);
                }
                javaemul.internal.InternalPreconditions.checkArgument(!c.isEmpty(), "Collection is empty");
                var iterator = c.iterator();
                var first = iterator.next();
                var set = EnumSet.of(first);
                while ((iterator.hasNext())) {
                    var e = iterator.next();
                    set.add(e);
                }
                ;
                return set;
            };
            EnumSet.copyOf = function (s) {
                if (((s != null && s instanceof java.util.EnumSet) || s === null)) {
                    return (function () {
                        return s.clone();
                    })();
                }
                else if (((s != null && s["__interfaces"] != null && s["__interfaces"].indexOf("java.util.Collection") >= 0) || s === null)) {
                    return java.util.EnumSet.copyOf$java_util_Collection(s);
                }
                else
                    throw new Error('invalid overload');
            };
            EnumSet.noneOf = function (elementType) {
                var all = elementType.getEnumConstants();
                return new EnumSet.EnumSetImpl(all, javaemul.internal.ArrayHelper.createFrom(all, all.length), 0);
            };
            EnumSet.of$java_lang_Enum = function (first) {
                var set = EnumSet.noneOf(first.getDeclaringClass());
                set.add(first);
                return set;
            };
            EnumSet.of = function (first) {
                var rest = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    rest[_i - 1] = arguments[_i];
                }
                if (((first != null) || first === null) && ((rest != null && rest instanceof Array) || rest === null)) {
                    return (function () {
                        var set = EnumSet.of(first);
                        java.util.Collections.addAll(set, rest);
                        return set;
                    })();
                }
                else if (((first != null) || first === null) && rest === undefined) {
                    return java.util.EnumSet.of$java_lang_Enum(first);
                }
                else
                    throw new Error('invalid overload');
            };
            EnumSet.range = function (from, to) {
                javaemul.internal.InternalPreconditions.checkArgument(from.compareTo(to) <= 0, "%s > %s", from, to);
                var all = from.getDeclaringClass().getEnumConstants();
                var set = javaemul.internal.ArrayHelper.createFrom(all, all.length);
                var start = from.ordinal();
                var end = to.ordinal() + 1;
                for (var i = start; i < end; ++i) {
                    set[i] = all[i];
                }
                return new EnumSet.EnumSetImpl(all, set, end - start);
            };
            return EnumSet;
        }(java.util.AbstractSet));
        util.EnumSet = EnumSet;
        var EnumSet;
        (function (EnumSet) {
            /**
             * Implemented via sparse array since the set size is finite. Iteration takes
             * linear time with respect to the set of the enum rather than the number of
             * items in the set.
             *
             * Note: Implemented as a subclass instead of a concrete final EnumSet class.
             * This is because declaring an EnumSet.add(E) causes hosted mode to bind to
             * the tighter method rather than the bridge method; but the tighter method
             * isn't available in the real JRE.
             */
            var EnumSetImpl = (function (_super) {
                __extends(EnumSetImpl, _super);
                /**
                 * Constructs a set taking ownership of the specified set. The size must
                 * accurately reflect the number of non-null items in set.
                 */
                function EnumSetImpl(all, set, size) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Collection", "java.util.Set", "java.lang.Iterable"] });
                    this.__size = 0;
                    this.all = all;
                    this.set = set;
                    this.__size = size;
                }
                EnumSetImpl.prototype.add = function (index, element) {
                    if (((index != null) || index === null) && element === undefined) {
                        return this.add$java_lang_Enum(index);
                    }
                    else if (((index != null) || index === null) && element === undefined) {
                        return this.add$java_lang_Object(index);
                    }
                    else
                        throw new Error('invalid overload');
                };
                EnumSetImpl.prototype.add$java_lang_Enum = function (e) {
                    javaemul.internal.InternalPreconditions.checkNotNull(e);
                    var ordinal = e.ordinal();
                    if (this.set[ordinal] == null) {
                        this.set[ordinal] = e;
                        ++this.__size;
                        return true;
                    }
                    return false;
                };
                EnumSetImpl.prototype.clone = function () {
                    var clonedSet = javaemul.internal.ArrayHelper.clone(this.set, 0, this.set.length);
                    return new EnumSet.EnumSetImpl(this.all, clonedSet, this.__size);
                };
                EnumSetImpl.prototype.contains = function (o) {
                    return (o != null && o instanceof java.lang.Enum) && this.containsEnum(o);
                };
                EnumSetImpl.prototype.containsEnum = function (e) {
                    return e != null && this.set[e.ordinal()] === e;
                };
                EnumSetImpl.prototype.iterator = function () {
                    return new EnumSetImpl.IteratorImpl(this);
                };
                EnumSetImpl.prototype.remove = function (index) {
                    if (((index != null) || index === null)) {
                        return this.remove$java_lang_Object(index);
                    }
                    else
                        throw new Error('invalid overload');
                };
                EnumSetImpl.prototype.remove$java_lang_Object = function (o) {
                    return (o != null && o instanceof java.lang.Enum) && this.removeEnum(o);
                };
                EnumSetImpl.prototype.removeEnum = function (e) {
                    if (e != null && this.set[e.ordinal()] === e) {
                        this.set[e.ordinal()] = null;
                        --this.__size;
                        return true;
                    }
                    return false;
                };
                EnumSetImpl.prototype.size = function () {
                    return this.__size;
                };
                EnumSetImpl.prototype.capacity = function () {
                    return this.all.length;
                };
                return EnumSetImpl;
            }(java.util.EnumSet));
            EnumSet.EnumSetImpl = EnumSetImpl;
            var EnumSetImpl;
            (function (EnumSetImpl) {
                var IteratorImpl = (function () {
                    function IteratorImpl(__parent) {
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Iterator"] });
                        this.__parent = __parent;
                        this.i = -1;
                        this.last = -1;
                        this.findNext();
                    }
                    IteratorImpl.prototype.forEachRemaining = function (consumer) {
                        javaemul.internal.InternalPreconditions.checkNotNull(consumer);
                        while ((this.hasNext())) {
                            consumer(this.next());
                        }
                        ;
                    };
                    IteratorImpl.prototype.hasNext = function () {
                        return this.i < this.__parent.capacity();
                    };
                    IteratorImpl.prototype.next = function () {
                        javaemul.internal.InternalPreconditions.checkElement(this.hasNext());
                        this.last = this.i;
                        this.findNext();
                        return this.__parent.set[this.last];
                    };
                    IteratorImpl.prototype.remove = function () {
                        javaemul.internal.InternalPreconditions.checkState(this.last !== -1);
                        this.__parent.set[this.last] = null;
                        --this.__parent.__size;
                        this.last = -1;
                    };
                    IteratorImpl.prototype.findNext = function () {
                        ++this.i;
                        for (var c = this.__parent.capacity(); this.i < c; ++this.i) {
                            if (this.__parent.set[this.i] != null) {
                                return;
                            }
                        }
                    };
                    return IteratorImpl;
                }());
                EnumSetImpl.IteratorImpl = IteratorImpl;
            })(EnumSetImpl = EnumSet.EnumSetImpl || (EnumSet.EnumSetImpl = {}));
        })(EnumSet = util.EnumSet || (util.EnumSet = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * Implements a set in terms of a hash table. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/HashSet.html">[Sun
         * docs]</a>
         *
         * @param <E> element type.
         */
        var HashSet = (function (_super) {
            __extends(HashSet, _super);
            function HashSet(initialCapacity, loadFactor) {
                var _this = this;
                if (((typeof initialCapacity === 'number') || initialCapacity === null) && ((typeof loadFactor === 'number') || loadFactor === null)) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.util.Collection", "java.util.Set", "java.lang.Iterable", "java.io.Serializable"] });
                    (function () {
                        _this.map = new java.util.HashMap(initialCapacity, loadFactor);
                    })();
                }
                else if (((initialCapacity != null && initialCapacity["__interfaces"] != null && initialCapacity["__interfaces"].indexOf("java.util.Collection") >= 0) || initialCapacity === null) && loadFactor === undefined) {
                    var c = initialCapacity;
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.util.Collection", "java.util.Set", "java.lang.Iterable", "java.io.Serializable"] });
                    (function () {
                        _this.map = new java.util.HashMap(c.size());
                        _this.addAll(c);
                    })();
                }
                else if (((initialCapacity != null && initialCapacity instanceof java.util.HashMap) || initialCapacity === null) && loadFactor === undefined) {
                    var map = initialCapacity;
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.util.Collection", "java.util.Set", "java.lang.Iterable", "java.io.Serializable"] });
                    (function () {
                        _this.map = map;
                    })();
                }
                else if (((typeof initialCapacity === 'number') || initialCapacity === null) && loadFactor === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.util.Collection", "java.util.Set", "java.lang.Iterable", "java.io.Serializable"] });
                    (function () {
                        _this.map = new java.util.HashMap(initialCapacity);
                    })();
                }
                else if (initialCapacity === undefined && loadFactor === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.util.Collection", "java.util.Set", "java.lang.Iterable", "java.io.Serializable"] });
                    (function () {
                        _this.map = new java.util.HashMap();
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            HashSet.prototype.forEach = function (action) {
                javaemul.internal.InternalPreconditions.checkNotNull(action);
                for (var index165 = this.iterator(); index165.hasNext();) {
                    var t = index165.next();
                    {
                        action(t);
                    }
                }
            };
            HashSet.prototype.add = function (index, element) {
                if (((index != null) || index === null) && element === undefined) {
                    return this.add$java_lang_Object(index);
                }
                else
                    throw new Error('invalid overload');
            };
            HashSet.prototype.add$java_lang_Object = function (o) {
                var old = this.map.put(o, this);
                return (old == null);
            };
            HashSet.prototype.clear = function () {
                this.map.clear();
            };
            HashSet.prototype.clone = function () {
                return new HashSet(this);
            };
            HashSet.prototype.contains = function (o) {
                return this.map.containsKey(o);
            };
            HashSet.prototype.isEmpty = function () {
                return this.map.isEmpty();
            };
            HashSet.prototype.iterator = function () {
                return this.map.keySet().iterator();
            };
            HashSet.prototype.remove = function (index) {
                if (((index != null) || index === null)) {
                    return this.remove$java_lang_Object(index);
                }
                else
                    throw new Error('invalid overload');
            };
            HashSet.prototype.remove$java_lang_Object = function (o) {
                return (this.map.remove(o) != null);
            };
            HashSet.prototype.size = function () {
                return this.map.size();
            };
            HashSet.prototype.toString = function () {
                return this.map.keySet().toString();
            };
            return HashSet;
        }(java.util.AbstractSet));
        util.HashSet = HashSet;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * Implements a set using a TreeMap. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/TreeSet.html">[Sun
         * docs]</a>
         *
         * @param <E> element type.
         */
        var TreeSet = (function (_super) {
            __extends(TreeSet, _super);
            function TreeSet(c) {
                var _this = this;
                if (((c != null && c["__interfaces"] != null && c["__interfaces"].indexOf("java.util.Collection") >= 0) || c === null)) {
                    {
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.SortedSet", "java.util.Collection", "java.util.Set", "java.util.NavigableSet", "java.lang.Iterable", "java.io.Serializable"] });
                        (function () {
                            _this.map = new java.util.TreeMap();
                        })();
                    }
                    (function () {
                        _this.addAll(c);
                    })();
                }
                else if (((c != null && c["__interfaces"] != null && c["__interfaces"].indexOf("java.util.Comparator") >= 0) || c === null)) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.SortedSet", "java.util.Collection", "java.util.Set", "java.util.NavigableSet", "java.lang.Iterable", "java.io.Serializable"] });
                    (function () {
                        _this.map = new java.util.TreeMap(c);
                    })();
                }
                else if (((c != null && c["__interfaces"] != null && c["__interfaces"].indexOf("java.util.SortedSet") >= 0) || c === null)) {
                    var s = c;
                    {
                        var c = javaemul.internal.InternalPreconditions.checkNotNull(s).comparator();
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.SortedSet", "java.util.Collection", "java.util.Set", "java.util.NavigableSet", "java.lang.Iterable", "java.io.Serializable"] });
                        (function () {
                            _this.map = new java.util.TreeMap(c);
                        })();
                    }
                    (function () {
                        _this.addAll(s);
                    })();
                }
                else if (((c != null && c["__interfaces"] != null && c["__interfaces"].indexOf("java.util.NavigableMap") >= 0) || c === null)) {
                    var map = c;
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.SortedSet", "java.util.Collection", "java.util.Set", "java.util.NavigableSet", "java.lang.Iterable", "java.io.Serializable"] });
                    (function () {
                        _this.map = map;
                    })();
                }
                else if (c === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.SortedSet", "java.util.Collection", "java.util.Set", "java.util.NavigableSet", "java.lang.Iterable", "java.io.Serializable"] });
                    (function () {
                        _this.map = new java.util.TreeMap();
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            TreeSet.prototype.forEach = function (action) {
                javaemul.internal.InternalPreconditions.checkNotNull(action);
                for (var index166 = this.iterator(); index166.hasNext();) {
                    var t = index166.next();
                    {
                        action(t);
                    }
                }
            };
            TreeSet.prototype.add = function (index, element) {
                if (((index != null) || index === null) && element === undefined) {
                    return this.add$java_lang_Object(index);
                }
                else
                    throw new Error('invalid overload');
            };
            TreeSet.prototype.add$java_lang_Object = function (o) {
                return this.map.put(o, javaemul.internal.BooleanHelper.FALSE) == null;
            };
            TreeSet.prototype.ceiling = function (e) {
                return this.map.ceilingKey(e);
            };
            TreeSet.prototype.clear = function () {
                this.map.clear();
            };
            TreeSet.prototype.comparator = function () {
                return this.map.comparator();
            };
            TreeSet.prototype.contains = function (o) {
                return this.map.containsKey(o);
            };
            TreeSet.prototype.descendingIterator = function () {
                return this.descendingSet().iterator();
            };
            TreeSet.prototype.descendingSet = function () {
                return new TreeSet(this.map.descendingMap());
            };
            TreeSet.prototype.first = function () {
                return this.map.firstKey();
            };
            TreeSet.prototype.floor = function (e) {
                return this.map.floorKey(e);
            };
            TreeSet.prototype.headSet$java_lang_Object = function (toElement) {
                return this.headSet(toElement, false);
            };
            TreeSet.prototype.headSet = function (toElement, inclusive) {
                var _this = this;
                if (((toElement != null) || toElement === null) && ((typeof inclusive === 'boolean') || inclusive === null)) {
                    return (function () {
                        return new TreeSet(_this.map.headMap(toElement, inclusive));
                    })();
                }
                else if (((toElement != null) || toElement === null) && inclusive === undefined) {
                    return this.headSet$java_lang_Object(toElement);
                }
                else
                    throw new Error('invalid overload');
            };
            TreeSet.prototype.higher = function (e) {
                return this.map.higherKey(e);
            };
            TreeSet.prototype.iterator = function () {
                return this.map.keySet().iterator();
            };
            TreeSet.prototype.last = function () {
                return this.map.lastKey();
            };
            TreeSet.prototype.lower = function (e) {
                return this.map.lowerKey(e);
            };
            TreeSet.prototype.pollFirst = function () {
                return java.util.AbstractMap.getEntryKeyOrNull(this.map.pollFirstEntry());
            };
            TreeSet.prototype.pollLast = function () {
                return java.util.AbstractMap.getEntryKeyOrNull(this.map.pollLastEntry());
            };
            TreeSet.prototype.remove = function (index) {
                if (((index != null) || index === null)) {
                    return this.remove$java_lang_Object(index);
                }
                else
                    throw new Error('invalid overload');
            };
            TreeSet.prototype.remove$java_lang_Object = function (o) {
                return this.map.remove(o) != null;
            };
            TreeSet.prototype.size = function () {
                return this.map.size();
            };
            TreeSet.prototype.subSet = function (fromElement, fromInclusive, toElement, toInclusive) {
                var _this = this;
                if (((fromElement != null) || fromElement === null) && ((typeof fromInclusive === 'boolean') || fromInclusive === null) && ((toElement != null) || toElement === null) && ((typeof toInclusive === 'boolean') || toInclusive === null)) {
                    return (function () {
                        return new TreeSet(_this.map.subMap(fromElement, fromInclusive, toElement, toInclusive));
                    })();
                }
                else if (((fromElement != null) || fromElement === null) && ((fromInclusive != null) || fromInclusive === null) && toElement === undefined && toInclusive === undefined) {
                    return this.subSet$java_lang_Object$java_lang_Object(fromElement, fromInclusive);
                }
                else
                    throw new Error('invalid overload');
            };
            TreeSet.prototype.subSet$java_lang_Object$java_lang_Object = function (fromElement, toElement) {
                return this.subSet(fromElement, true, toElement, false);
            };
            TreeSet.prototype.tailSet$java_lang_Object = function (fromElement) {
                return this.tailSet(fromElement, true);
            };
            TreeSet.prototype.tailSet = function (fromElement, inclusive) {
                var _this = this;
                if (((fromElement != null) || fromElement === null) && ((typeof inclusive === 'boolean') || inclusive === null)) {
                    return (function () {
                        return new TreeSet(_this.map.tailMap(fromElement, inclusive));
                    })();
                }
                else if (((fromElement != null) || fromElement === null) && inclusive === undefined) {
                    return this.tailSet$java_lang_Object(fromElement);
                }
                else
                    throw new Error('invalid overload');
            };
            return TreeSet;
        }(java.util.AbstractSet));
        util.TreeSet = TreeSet;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var lang;
    (function (lang) {
        /**
         * General-purpose low-level utility methods. GWT only supports a limited subset
         * of these methods due to browser limitations. Only the documented methods are
         * available.
         */
        var System = (function () {
            function System() {
            }
            System.err_$LI$ = function () { if (System.err == null)
                System.err = new java.io.PrintStream(null); return System.err; };
            ;
            System.out_$LI$ = function () { if (System.out == null)
                System.out = new java.io.PrintStream(null); return System.out; };
            ;
            System.arraycopy = function (src, srcOfs, dest, destOfs, len) {
                javaemul.internal.InternalPreconditions.checkNotNull(src, "src");
                javaemul.internal.InternalPreconditions.checkNotNull(dest, "dest");
                var srcType = src.getClass();
                var destType = dest.getClass();
                javaemul.internal.InternalPreconditions.checkArrayType(srcType.isArray(), "srcType is not an array");
                javaemul.internal.InternalPreconditions.checkArrayType(destType.isArray(), "destType is not an array");
                var srcComp = srcType.getComponentType();
                var destComp = destType.getComponentType();
                javaemul.internal.InternalPreconditions.checkArrayType(System.arrayTypeMatch(srcComp, destComp), "Array types don\'t match");
                var srclen = javaemul.internal.ArrayHelper.getLength(src);
                var destlen = javaemul.internal.ArrayHelper.getLength(dest);
                if (srcOfs < 0 || destOfs < 0 || len < 0 || srcOfs + len > srclen || destOfs + len > destlen) {
                    throw new java.lang.IndexOutOfBoundsException();
                }
                if ((!srcComp.isPrimitive() || srcComp.isArray()) && !srcType.equals(destType)) {
                    var srcArray = src;
                    var destArray = dest;
                    if (src === dest && srcOfs < destOfs) {
                        srcOfs += len;
                        for (var destEnd = destOfs + len; destEnd-- > destOfs;) {
                            destArray[destEnd] = srcArray[--srcOfs];
                        }
                    }
                    else {
                        for (var destEnd = destOfs + len; destOfs < destEnd;) {
                            destArray[destOfs++] = srcArray[srcOfs++];
                        }
                    }
                }
                else if (len > 0) {
                    javaemul.internal.ArrayHelper.copy(src, srcOfs, dest, destOfs, len);
                }
            };
            System.currentTimeMillis = function () {
                return Math.round(javaemul.internal.DateUtil.now());
            };
            /**
             * Has no effect; just here for source compatibility.
             *
             * @skip
             */
            System.gc = function () {
            };
            /**
             * The compiler replaces getProperty by the actual value of the property.
             */
            System.getProperty$java_lang_String = function (key) {
                switch ((key)) {
                    case "user.dir":
                        return "";
                    case "user.home":
                        return "";
                    case "user.name":
                        return "jsweet";
                    case "file.separator":
                        return "/";
                    case "java.home":
                        return null;
                    case "java.vendor":
                        return "JSweet";
                    case "java.vendor.url":
                        return "http://www.jsweet.org";
                    case "java.version":
                        return "jsweet";
                    case "os.arch":
                        return "generic";
                    case "os.name":
                        return "generic";
                    case "os.version":
                        return "unknown";
                    case "java.io.tmpdir":
                        return "";
                    default:
                        return null;
                }
            };
            /**
             * The compiler replaces getProperty by the actual value of the property.
             */
            System.getProperty = function (key, def) {
                if (((typeof key === 'string') || key === null) && ((typeof def === 'string') || def === null)) {
                    return (function () {
                        var prop = System.getProperty(key);
                        return prop == null ? def : prop;
                    })();
                }
                else if (((typeof key === 'string') || key === null) && def === undefined) {
                    return java.lang.System.getProperty$java_lang_String(key);
                }
                else
                    throw new Error('invalid overload');
            };
            System.identityHashCode = function (o) {
                return javaemul.internal.HashCodes.getIdentityHashCode(o);
            };
            System.setErr = function (err) {
                java.lang.System.err = err;
            };
            System.setOut = function (out) {
                java.lang.System.out = out;
            };
            System.arrayTypeMatch = function (srcComp, destComp) {
                if (srcComp.isPrimitive()) {
                    return srcComp.equals(destComp);
                }
                else {
                    return !destComp.isPrimitive();
                }
            };
            return System;
        }());
        lang.System = System;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var lang;
    (function (lang) {
        /**
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/NumberFormatException.html">the
         * official Java API doc</a> for details.
         */
        var NumberFormatException = (function (_super) {
            __extends(NumberFormatException, _super);
            function NumberFormatException(message) {
                if (((typeof message === 'string') || message === null)) {
                    _super.call(this, message);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (message === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            NumberFormatException.forInputString = function (s) {
                return new java.lang.NumberFormatException("For input string: \"" + s + "\"");
            };
            NumberFormatException.forNullInputString = function () {
                return new java.lang.NumberFormatException("null");
            };
            NumberFormatException.forRadix = function (radix) {
                return new java.lang.NumberFormatException("radix " + radix + " out of range");
            };
            return NumberFormatException;
        }(java.lang.IllegalArgumentException));
        lang.NumberFormatException = NumberFormatException;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var nio;
    (function (nio) {
        var charset;
        (function (charset) {
            /**
             * GWT emulation of {@link IllegalCharsetNameException}.
             */
            var IllegalCharsetNameException = (function (_super) {
                __extends(IllegalCharsetNameException, _super);
                function IllegalCharsetNameException(charsetName) {
                    _super.call(this, /* valueOf */ new String(charsetName).toString());
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    this.charsetName = charsetName;
                }
                IllegalCharsetNameException.prototype.getCharsetName = function () {
                    return this.charsetName;
                };
                return IllegalCharsetNameException;
            }(java.lang.IllegalArgumentException));
            charset.IllegalCharsetNameException = IllegalCharsetNameException;
        })(charset = nio.charset || (nio.charset = {}));
    })(nio = java.nio || (java.nio = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var nio;
    (function (nio) {
        var charset;
        (function (charset) {
            /**
             * GWT emulation of {@link UnsupportedCharsetException}.
             */
            var UnsupportedCharsetException = (function (_super) {
                __extends(UnsupportedCharsetException, _super);
                function UnsupportedCharsetException(charsetName) {
                    _super.call(this, /* valueOf */ new String(charsetName).toString());
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    this.charsetName = charsetName;
                }
                UnsupportedCharsetException.prototype.getCharsetName = function () {
                    return this.charsetName;
                };
                return UnsupportedCharsetException;
            }(java.lang.IllegalArgumentException));
            charset.UnsupportedCharsetException = UnsupportedCharsetException;
        })(charset = nio.charset || (nio.charset = {}));
    })(nio = java.nio || (java.nio = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var lang;
    (function (lang) {
        /**
         * NOTE: in GWT this will never be thrown for normal array accesses, only for
         * explicit throws.
         *
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/ArrayIndexOutOfBoundsException.html">the
         * official Java API doc</a> for details.
         */
        var ArrayIndexOutOfBoundsException = (function (_super) {
            __extends(ArrayIndexOutOfBoundsException, _super);
            function ArrayIndexOutOfBoundsException(msg) {
                if (((typeof msg === 'string') || msg === null)) {
                    _super.call(this, msg);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (((typeof msg === 'number') || msg === null)) {
                    var index = msg;
                    _super.call(this, "Array index " + index + " out of range");
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (msg === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            return ArrayIndexOutOfBoundsException;
        }(java.lang.IndexOutOfBoundsException));
        lang.ArrayIndexOutOfBoundsException = ArrayIndexOutOfBoundsException;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var lang;
    (function (lang) {
        /**
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/StringIndexOfBoundsException.html">the
         * official Java API doc</a> for details.
         */
        var StringIndexOutOfBoundsException = (function (_super) {
            __extends(StringIndexOutOfBoundsException, _super);
            function StringIndexOutOfBoundsException(message) {
                if (((typeof message === 'string') || message === null)) {
                    _super.call(this, message);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (((typeof message === 'number') || message === null)) {
                    var index = message;
                    _super.call(this, "String index out of range: " + index);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (message === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            return StringIndexOutOfBoundsException;
        }(java.lang.IndexOutOfBoundsException));
        lang.StringIndexOutOfBoundsException = StringIndexOutOfBoundsException;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * Linked list implementation.
         * <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/LinkedList.html">
         * [Sun docs]</a>
         *
         * @param <E>
         * element type.
         */
        var LinkedList = (function (_super) {
            __extends(LinkedList, _super);
            function LinkedList(c) {
                var _this = this;
                if (((c != null && c["__interfaces"] != null && c["__interfaces"].indexOf("java.util.Collection") >= 0) || c === null)) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.util.List", "java.util.Collection", "java.util.Queue", "java.util.Deque", "java.lang.Iterable", "java.io.Serializable"] });
                    this.__size = 0;
                    (function () {
                        _this.header = new LinkedList.Node();
                        _this.tail = new LinkedList.Node();
                        _this.reset();
                        _this.addAll(c);
                    })();
                }
                else if (c === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.util.List", "java.util.Collection", "java.util.Queue", "java.util.Deque", "java.lang.Iterable", "java.io.Serializable"] });
                    this.__size = 0;
                    (function () {
                        _this.header = new LinkedList.Node();
                        _this.tail = new LinkedList.Node();
                        _this.reset();
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            LinkedList.prototype.forEach = function (action) {
                javaemul.internal.InternalPreconditions.checkNotNull(action);
                for (var index167 = this.iterator(); index167.hasNext();) {
                    var t = index167.next();
                    {
                        action(t);
                    }
                }
            };
            LinkedList.prototype.add$java_lang_Object = function (o) {
                this.addLast(o);
                return true;
            };
            LinkedList.prototype.addFirst = function (o) {
                this.addNode(o, this.header, this.header.next);
            };
            LinkedList.prototype.addLast = function (o) {
                this.addNode(o, this.tail.prev, this.tail);
            };
            LinkedList.prototype.clear = function () {
                this.reset();
            };
            LinkedList.prototype.reset = function () {
                this.header.next = this.tail;
                this.tail.prev = this.header;
                this.header.prev = this.tail.next = null;
                this.__size = 0;
            };
            LinkedList.prototype.clone = function () {
                return new LinkedList(this);
            };
            LinkedList.prototype.descendingIterator = function () {
                return new LinkedList.DescendingIteratorImpl(this);
            };
            LinkedList.prototype.element = function () {
                return this.getFirst();
            };
            LinkedList.prototype.getFirst = function () {
                javaemul.internal.InternalPreconditions.checkElement(this.__size !== 0);
                return this.header.next.value;
            };
            LinkedList.prototype.getLast = function () {
                javaemul.internal.InternalPreconditions.checkElement(this.__size !== 0);
                return this.tail.prev.value;
            };
            LinkedList.prototype.listIterator = function (index) {
                var _this = this;
                if (((typeof index === 'number') || index === null)) {
                    return (function () {
                        javaemul.internal.InternalPreconditions.checkPositionIndex(index, _this.__size);
                        var node;
                        if (index >= _this.__size >> 1) {
                            node = _this.tail;
                            for (var i = _this.__size; i > index; --i) {
                                node = node.prev;
                            }
                        }
                        else {
                            node = _this.header.next;
                            for (var i = 0; i < index; ++i) {
                                node = node.next;
                            }
                        }
                        return new LinkedList.ListIteratorImpl2(_this, index, node);
                    })();
                }
                else if (index === undefined) {
                    return this.listIterator$();
                }
                else
                    throw new Error('invalid overload');
            };
            LinkedList.prototype.offer = function (o) {
                return this.offerLast(o);
            };
            LinkedList.prototype.offerFirst = function (e) {
                this.addFirst(e);
                return true;
            };
            LinkedList.prototype.offerLast = function (e) {
                this.addLast(e);
                return true;
            };
            LinkedList.prototype.peek = function () {
                return this.peekFirst();
            };
            LinkedList.prototype.peekFirst = function () {
                return this.__size === 0 ? null : this.getFirst();
            };
            LinkedList.prototype.peekLast = function () {
                return this.__size === 0 ? null : this.getLast();
            };
            LinkedList.prototype.poll = function () {
                return this.pollFirst();
            };
            LinkedList.prototype.pollFirst = function () {
                return this.__size === 0 ? null : this.removeFirst();
            };
            LinkedList.prototype.pollLast = function () {
                return this.__size === 0 ? null : this.removeLast();
            };
            LinkedList.prototype.pop = function () {
                return this.removeFirst();
            };
            LinkedList.prototype.push = function (e) {
                this.addFirst(e);
            };
            LinkedList.prototype.remove$ = function () {
                return this.removeFirst();
            };
            LinkedList.prototype.removeFirst = function () {
                javaemul.internal.InternalPreconditions.checkElement(this.__size !== 0);
                return this.removeNode(this.header.next);
            };
            LinkedList.prototype.removeFirstOccurrence = function (o) {
                return this.remove(o);
            };
            LinkedList.prototype.removeLast = function () {
                javaemul.internal.InternalPreconditions.checkElement(this.__size !== 0);
                return this.removeNode(this.tail.prev);
            };
            LinkedList.prototype.removeLastOccurrence = function (o) {
                for (var e = this.tail.prev; e !== this.header; e = e.prev) {
                    if (java.util.Objects.equals(e.value, o)) {
                        this.removeNode(e);
                        return true;
                    }
                }
                return false;
            };
            LinkedList.prototype.size = function () {
                return this.__size;
            };
            LinkedList.prototype.addNode = function (o, prev, next) {
                var node = new LinkedList.Node();
                node.value = o;
                node.prev = prev;
                node.next = next;
                next.prev = prev.next = node;
                ++this.__size;
            };
            LinkedList.prototype.removeNode = function (node) {
                var oldValue = node.value;
                node.next.prev = node.prev;
                node.prev.next = node.next;
                node.next = node.prev = null;
                node.value = null;
                --this.__size;
                return oldValue;
            };
            return LinkedList;
        }(java.util.AbstractSequentialList));
        util.LinkedList = LinkedList;
        var LinkedList;
        (function (LinkedList) {
            var DescendingIteratorImpl = (function () {
                function DescendingIteratorImpl(__parent) {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Iterator"] });
                    this.__parent = __parent;
                    this.itr = new LinkedList.ListIteratorImpl2(this.__parent, this.__parent.__size, this.__parent.tail);
                }
                DescendingIteratorImpl.prototype.forEachRemaining = function (consumer) {
                    javaemul.internal.InternalPreconditions.checkNotNull(consumer);
                    while ((this.hasNext())) {
                        consumer(this.next());
                    }
                    ;
                };
                DescendingIteratorImpl.prototype.hasNext = function () {
                    return this.itr.hasPrevious();
                };
                DescendingIteratorImpl.prototype.next = function () {
                    return this.itr.previous();
                };
                DescendingIteratorImpl.prototype.remove = function () {
                    this.itr.remove();
                };
                return DescendingIteratorImpl;
            }());
            LinkedList.DescendingIteratorImpl = DescendingIteratorImpl;
            /**
             * Implementation of ListIterator for linked lists.
             */
            var ListIteratorImpl2 = (function () {
                /**
                 * @param index
                 * from the beginning of the list (0 = first node)
                 * @param startNode
                 * the initial current node
                 */
                function ListIteratorImpl2(__parent, index, startNode) {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Iterator", "java.util.ListIterator"] });
                    this.__parent = __parent;
                    this.currentIndex = 0;
                    this.lastNode = null;
                    this.currentNode = startNode;
                    this.currentIndex = index;
                }
                ListIteratorImpl2.prototype.forEachRemaining = function (consumer) {
                    javaemul.internal.InternalPreconditions.checkNotNull(consumer);
                    while ((this.hasNext())) {
                        consumer(this.next());
                    }
                    ;
                };
                ListIteratorImpl2.prototype.add = function (o) {
                    this.__parent.addNode(o, this.currentNode.prev, this.currentNode);
                    ++this.currentIndex;
                    this.lastNode = null;
                };
                ListIteratorImpl2.prototype.hasNext = function () {
                    return this.currentNode !== this.__parent.tail;
                };
                ListIteratorImpl2.prototype.hasPrevious = function () {
                    return this.currentNode.prev !== this.__parent.header;
                };
                ListIteratorImpl2.prototype.next = function () {
                    javaemul.internal.InternalPreconditions.checkElement(this.hasNext());
                    this.lastNode = this.currentNode;
                    this.currentNode = this.currentNode.next;
                    ++this.currentIndex;
                    return this.lastNode.value;
                };
                ListIteratorImpl2.prototype.nextIndex = function () {
                    return this.currentIndex;
                };
                ListIteratorImpl2.prototype.previous = function () {
                    javaemul.internal.InternalPreconditions.checkElement(this.hasPrevious());
                    this.lastNode = this.currentNode = this.currentNode.prev;
                    --this.currentIndex;
                    return this.lastNode.value;
                };
                ListIteratorImpl2.prototype.previousIndex = function () {
                    return this.currentIndex - 1;
                };
                ListIteratorImpl2.prototype.remove = function () {
                    javaemul.internal.InternalPreconditions.checkState(this.lastNode != null);
                    var nextNode = this.lastNode.next;
                    this.__parent.removeNode(this.lastNode);
                    if (this.currentNode === this.lastNode) {
                        this.currentNode = nextNode;
                    }
                    else {
                        --this.currentIndex;
                    }
                    this.lastNode = null;
                };
                ListIteratorImpl2.prototype.set = function (o) {
                    javaemul.internal.InternalPreconditions.checkState(this.lastNode != null);
                    this.lastNode.value = o;
                };
                return ListIteratorImpl2;
            }());
            LinkedList.ListIteratorImpl2 = ListIteratorImpl2;
            /**
             * Internal class representing a doubly-linked list node.
             *
             * @param <E>
             * element type
             */
            var Node = (function () {
                function Node() {
                }
                return Node;
            }());
            LinkedList.Node = Node;
        })(LinkedList = util.LinkedList || (util.LinkedList = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * An <code>Area</code> object stores and manipulates a resolution-independent
             * description of an enclosed area of 2-dimensional space. <code>Area</code>
             * objects can be transformed and can perform various Constructive Area Geometry
             * (CAG) operations when combined with other <code>Area</code> objects. The CAG
             * operations include area {@link #add addition}, {@link #subtract subtraction},
             * {@link #intersect intersection}, and {@link #exclusiveOr exclusive or}. See
             * the linked method documentation for examples of the various operations.
             * <p>
             * The <code>Area</code> class implements the <code>Shape</code> interface and
             * provides full support for all of its hit-testing and path iteration
             * facilities, but an <code>Area</code> is more specific than a generalized path
             * in a number of ways:
             * <ul>
             * <li>Only closed paths and sub-paths are stored. <code>Area</code> objects
             * constructed from unclosed paths are implicitly closed during construction as
             * if those paths had been filled by the <code>Graphics2D.fill</code> method.
             * <li>The interiors of the individual stored sub-paths are all non-empty and
             * non-overlapping. Paths are decomposed during construction into separate
             * component non-overlapping parts, empty pieces of the path are discarded, and
             * then these non-empty and non-overlapping properties are maintained through
             * all subsequent CAG operations. Outlines of different component sub-paths may
             * touch each other, as long as they do not cross so that their enclosed areas
             * overlap.
             * <li>The geometry of the path describing the outline of the <code>Area</code>
             * resembles the path from which it was constructed only in that it describes
             * the same enclosed 2-dimensional area, but may use entirely different types
             * and ordering of the path segments to do so.
             * </ul>
             * Interesting issues which are not always obvious when using the
             * <code>Area</code> include:
             * <ul>
             * <li>Creating an <code>Area</code> from an unclosed (open) <code>Shape</code>
             * results in a closed outline in the <code>Area</code> object.
             * <li>Creating an <code>Area</code> from a <code>Shape</code> which encloses no
             * area (even when "closed") produces an empty <code>Area</code>. A common
             * example of this issue is that producing an <code>Area</code> from a line will
             * be empty since the line encloses no area. An empty <code>Area</code> will
             * iterate no geometry in its <code>PathIterator</code> objects.
             * <li>A self-intersecting <code>Shape</code> may be split into two (or more)
             * sub-paths each enclosing one of the non-intersecting portions of the original
             * path.
             * <li>An <code>Area</code> may take more path segments to describe the same
             * geometry even when the original outline is simple and obvious. The analysis
             * that the <code>Area</code> class must perform on the path may not reflect the
             * same concepts of "simple and obvious" as a human being perceives.
             * </ul>
             *
             * @since 1.2
             */
            var Area = (function () {
                /**
                 * The <code>Area</code> class creates an area geometry from the specified
                 * {@link Shape} object. The geometry is explicitly closed, if the
                 * <code>Shape</code> is not already closed. The fill rule (even-odd or
                 * winding) specified by the geometry of the <code>Shape</code> is used to
                 * determine the resulting enclosed area.
                 *
                 * @param s
                 * the <code>Shape</code> from which the area is constructed
                 * @throws NullPointerException
                 * if <code>s</code> is null
                 * @since 1.2
                 */
                function Area(s) {
                    var _this = this;
                    if (((s != null && s["__interfaces"] != null && s["__interfaces"].indexOf("java.awt.Shape") >= 0) || s === null)) {
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable"] });
                        (function () {
                            if (s != null && s instanceof java.awt.geom.Area) {
                                _this.curves = s.curves;
                            }
                            else {
                                _this.curves = Area.pathToCurves(s.getPathIterator(null));
                            }
                        })();
                    }
                    else if (s === undefined) {
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.Shape", "java.lang.Cloneable"] });
                        (function () {
                            _this.curves = Area.EmptyCurves_$LI$();
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                }
                Area.EmptyCurves_$LI$ = function () { if (Area.EmptyCurves == null)
                    Area.EmptyCurves = new java.util.Vector(); return Area.EmptyCurves; };
                ;
                Area.pathToCurves = function (pi) {
                    var curves = new java.util.Vector();
                    var windingRule = pi.getWindingRule();
                    var coords = new Array(23);
                    var movx = 0;
                    var movy = 0;
                    var curx = 0;
                    var cury = 0;
                    var newx;
                    var newy;
                    while ((!pi.isDone())) {
                        switch ((pi.currentSegment(coords))) {
                            case java.awt.geom.PathIterator.SEG_MOVETO:
                                sun.awt.geom.Curve.insertLine(curves, curx, cury, movx, movy);
                                curx = movx = coords[0];
                                cury = movy = coords[1];
                                sun.awt.geom.Curve.insertMove(curves, movx, movy);
                                break;
                            case java.awt.geom.PathIterator.SEG_LINETO:
                                newx = coords[0];
                                newy = coords[1];
                                sun.awt.geom.Curve.insertLine(curves, curx, cury, newx, newy);
                                curx = newx;
                                cury = newy;
                                break;
                            case java.awt.geom.PathIterator.SEG_QUADTO:
                                newx = coords[2];
                                newy = coords[3];
                                sun.awt.geom.Curve.insertQuad(curves, curx, cury, coords);
                                curx = newx;
                                cury = newy;
                                break;
                            case java.awt.geom.PathIterator.SEG_CUBICTO:
                                newx = coords[4];
                                newy = coords[5];
                                sun.awt.geom.Curve.insertCubic(curves, curx, cury, coords);
                                curx = newx;
                                cury = newy;
                                break;
                            case java.awt.geom.PathIterator.SEG_CLOSE:
                                sun.awt.geom.Curve.insertLine(curves, curx, cury, movx, movy);
                                curx = movx;
                                cury = movy;
                                break;
                        }
                        pi.next();
                    }
                    ;
                    sun.awt.geom.Curve.insertLine(curves, curx, cury, movx, movy);
                    var operator;
                    if (windingRule === java.awt.geom.PathIterator.WIND_EVEN_ODD) {
                        operator = new sun.awt.geom.AreaOp.EOWindOp();
                    }
                    else {
                        operator = new sun.awt.geom.AreaOp.NZWindOp();
                    }
                    return operator.calculate(curves, Area.EmptyCurves_$LI$());
                };
                /**
                 * Adds the shape of the specified <code>Area</code> to the shape of this
                 * <code>Area</code>. The resulting shape of this <code>Area</code> will
                 * include the union of both shapes, or all areas that were contained in
                 * either this or the specified <code>Area</code>.
                 *
                 * <pre>
                 * // Example:
                 * Area a1 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 0,8]);
                 * Area a2 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 8,8]);
                 * a1.add(a2);
                 *
                 * a1(before)     +         a2         =     a1(after)
                 *
                 * ################     ################     ################
                 * ##############         ##############     ################
                 * ############             ############     ################
                 * ##########                 ##########     ################
                 * ########                     ########     ################
                 * ######                         ######     ######    ######
                 * ####                             ####     ####        ####
                 * ##                                 ##     ##            ##
                 * </pre>
                 *
                 * @param rhs
                 * the <code>Area</code> to be added to the current shape
                 * @throws NullPointerException
                 * if <code>rhs</code> is null
                 * @since 1.2
                 */
                Area.prototype.add = function (rhs) {
                    this.curves = new sun.awt.geom.AreaOp.AddOp().calculate(this.curves, rhs.curves);
                    this.invalidateBounds();
                };
                /**
                 * Subtracts the shape of the specified <code>Area</code> from the shape of
                 * this <code>Area</code>. The resulting shape of this <code>Area</code>
                 * will include areas that were contained only in this <code>Area</code> and
                 * not in the specified <code>Area</code>.
                 *
                 * <pre>
                 * // Example:
                 * Area a1 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 0,8]);
                 * Area a2 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 8,8]);
                 * a1.subtract(a2);
                 *
                 * a1(before)     -         a2         =     a1(after)
                 *
                 * ################     ################
                 * ##############         ##############     ##
                 * ############             ############     ####
                 * ##########                 ##########     ######
                 * ########                     ########     ########
                 * ######                         ######     ######
                 * ####                             ####     ####
                 * ##                                 ##     ##
                 * </pre>
                 *
                 * @param rhs
                 * the <code>Area</code> to be subtracted from the current shape
                 * @throws NullPointerException
                 * if <code>rhs</code> is null
                 * @since 1.2
                 */
                Area.prototype.subtract = function (rhs) {
                    this.curves = new sun.awt.geom.AreaOp.SubOp().calculate(this.curves, rhs.curves);
                    this.invalidateBounds();
                };
                /**
                 * Sets the shape of this <code>Area</code> to the intersection of its
                 * current shape and the shape of the specified <code>Area</code>. The
                 * resulting shape of this <code>Area</code> will include only areas that
                 * were contained in both this <code>Area</code> and also in the specified
                 * <code>Area</code>.
                 *
                 * <pre>
                 * // Example:
                 * Area a1 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 0,8]);
                 * Area a2 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 8,8]);
                 * a1.intersect(a2);
                 *
                 * a1(before)   intersect     a2         =     a1(after)
                 *
                 * ################     ################     ################
                 * ##############         ##############       ############
                 * ############             ############         ########
                 * ##########                 ##########           ####
                 * ########                     ########
                 * ######                         ######
                 * ####                             ####
                 * ##                                 ##
                 * </pre>
                 *
                 * @param rhs
                 * the <code>Area</code> to be intersected with this
                 * <code>Area</code>
                 * @throws NullPointerException
                 * if <code>rhs</code> is null
                 * @since 1.2
                 */
                Area.prototype.intersect = function (rhs) {
                    this.curves = new sun.awt.geom.AreaOp.IntOp().calculate(this.curves, rhs.curves);
                    this.invalidateBounds();
                };
                /**
                 * Sets the shape of this <code>Area</code> to be the combined area of its
                 * current shape and the shape of the specified <code>Area</code>, minus
                 * their intersection. The resulting shape of this <code>Area</code> will
                 * include only areas that were contained in either this <code>Area</code>
                 * or in the specified <code>Area</code>, but not in both.
                 *
                 * <pre>
                 * // Example:
                 * Area a1 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 0,8]);
                 * Area a2 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 8,8]);
                 * a1.exclusiveOr(a2);
                 *
                 * a1(before)    xor        a2         =     a1(after)
                 *
                 * ################     ################
                 * ##############         ##############     ##            ##
                 * ############             ############     ####        ####
                 * ##########                 ##########     ######    ######
                 * ########                     ########     ################
                 * ######                         ######     ######    ######
                 * ####                             ####     ####        ####
                 * ##                                 ##     ##            ##
                 * </pre>
                 *
                 * @param rhs
                 * the <code>Area</code> to be exclusive ORed with this
                 * <code>Area</code>.
                 * @throws NullPointerException
                 * if <code>rhs</code> is null
                 * @since 1.2
                 */
                Area.prototype.exclusiveOr = function (rhs) {
                    this.curves = new sun.awt.geom.AreaOp.XorOp().calculate(this.curves, rhs.curves);
                    this.invalidateBounds();
                };
                /**
                 * Removes all of the geometry from this <code>Area</code> and restores it
                 * to an empty area.
                 *
                 * @since 1.2
                 */
                Area.prototype.reset = function () {
                    this.curves = new java.util.Vector();
                    this.invalidateBounds();
                };
                /**
                 * Tests whether this <code>Area</code> object encloses any area.
                 *
                 * @return <code>true</code> if this <code>Area</code> object represents an
                 * empty area; <code>false</code> otherwise.
                 * @since 1.2
                 */
                Area.prototype.isEmpty = function () {
                    return (this.curves.size() === 0);
                };
                /**
                 * Tests whether this <code>Area</code> consists entirely of straight edged
                 * polygonal geometry.
                 *
                 * @return <code>true</code> if the geometry of this <code>Area</code>
                 * consists entirely of line segments; <code>false</code> otherwise.
                 * @since 1.2
                 */
                Area.prototype.isPolygonal = function () {
                    var enum_ = this.curves.elements();
                    while ((enum_.hasMoreElements())) {
                        if (enum_.nextElement().getOrder() > 1) {
                            return false;
                        }
                    }
                    ;
                    return true;
                };
                /**
                 * Tests whether this <code>Area</code> is rectangular in shape.
                 *
                 * @return <code>true</code> if the geometry of this <code>Area</code> is
                 * rectangular in shape; <code>false</code> otherwise.
                 * @since 1.2
                 */
                Area.prototype.isRectangular = function () {
                    var size = this.curves.size();
                    if (size === 0) {
                        return true;
                    }
                    if (size > 3) {
                        return false;
                    }
                    var c1 = this.curves.get(1);
                    var c2 = this.curves.get(2);
                    if (c1.getOrder() !== 1 || c2.getOrder() !== 1) {
                        return false;
                    }
                    if (c1.getXTop() !== c1.getXBot() || c2.getXTop() !== c2.getXBot()) {
                        return false;
                    }
                    if (c1.getYTop() !== c2.getYTop() || c1.getYBot() !== c2.getYBot()) {
                        return false;
                    }
                    return true;
                };
                /**
                 * Tests whether this <code>Area</code> is comprised of a single closed
                 * subpath. This method returns <code>true</code> if the path contains 0 or
                 * 1 subpaths, or <code>false</code> if the path contains more than 1
                 * subpath. The subpaths are counted by the number of
                 * {@link PathIterator#SEG_MOVETO SEG_MOVETO} segments that appear in the
                 * path.
                 *
                 * @return <code>true</code> if the <code>Area</code> is comprised of a
                 * single basic geometry; <code>false</code> otherwise.
                 * @since 1.2
                 */
                Area.prototype.isSingular = function () {
                    if (this.curves.size() < 3) {
                        return true;
                    }
                    var enum_ = this.curves.elements();
                    enum_.nextElement();
                    while ((enum_.hasMoreElements())) {
                        if (enum_.nextElement().getOrder() === 0) {
                            return false;
                        }
                    }
                    ;
                    return true;
                };
                Area.prototype.invalidateBounds = function () {
                    this.cachedBounds = null;
                };
                Area.prototype.getCachedBounds = function () {
                    if (this.cachedBounds != null) {
                        return this.cachedBounds;
                    }
                    var r = new java.awt.geom.Rectangle2D.Double();
                    if (this.curves.size() > 0) {
                        var c = this.curves.get(0);
                        r.setRect(c.getX0(), c.getY0(), 0, 0);
                        for (var i = 1; i < this.curves.size(); i++) {
                            this.curves.get(i).enlarge(r);
                        }
                    }
                    return (this.cachedBounds = r);
                };
                /**
                 * Returns a high precision bounding {@link Rectangle2D} that completely
                 * encloses this <code>Area</code>.
                 * <p>
                 * The Area class will attempt to return the tightest bounding box possible
                 * for the Shape. The bounding box will not be padded to include the control
                 * points of curves in the outline of the Shape, but should tightly fit the
                 * actual geometry of the outline itself.
                 *
                 * @return the bounding <code>Rectangle2D</code> for the <code>Area</code>.
                 * @since 1.2
                 */
                Area.prototype.getBounds2D = function () {
                    return this.getCachedBounds().getBounds2D();
                };
                /**
                 * Returns a bounding {@link Rectangle} that completely encloses this
                 * <code>Area</code>.
                 * <p>
                 * The Area class will attempt to return the tightest bounding box possible
                 * for the Shape. The bounding box will not be padded to include the control
                 * points of curves in the outline of the Shape, but should tightly fit the
                 * actual geometry of the outline itself. Since the returned object
                 * represents the bounding box with integers, the bounding box can only be
                 * as tight as the nearest integer coordinates that encompass the geometry
                 * of the Shape.
                 *
                 * @return the bounding <code>Rectangle</code> for the <code>Area</code>.
                 * @since 1.2
                 */
                Area.prototype.getBounds = function () {
                    return this.getCachedBounds().getBounds();
                };
                /**
                 * Returns an exact copy of this <code>Area</code> object.
                 *
                 * @return Created clone object
                 * @since 1.2
                 */
                Area.prototype.clone = function () {
                    return new Area(this);
                };
                /**
                 * Tests whether the geometries of the two <code>Area</code> objects are
                 * equal. This method will return false if the argument is null.
                 *
                 * @param other
                 * the <code>Area</code> to be compared to this <code>Area</code>
                 * @return <code>true</code> if the two geometries are equal;
                 * <code>false</code> otherwise.
                 * @since 1.2
                 */
                Area.prototype.equals = function (other) {
                    if (other === this) {
                        return true;
                    }
                    if (other == null) {
                        return false;
                    }
                    var c = new sun.awt.geom.AreaOp.XorOp().calculate(this.curves, other.curves);
                    return c.isEmpty();
                };
                /**
                 * Transforms the geometry of this <code>Area</code> using the specified
                 * {@link AffineTransform}. The geometry is transformed in place, which
                 * permanently changes the enclosed area defined by this object.
                 *
                 * @param t
                 * the transformation used to transform the area
                 * @throws NullPointerException
                 * if <code>t</code> is null
                 * @since 1.2
                 */
                Area.prototype.transform = function (t) {
                    if (t == null) {
                        throw new java.lang.NullPointerException("transform must not be null");
                    }
                    this.curves = Area.pathToCurves(this.getPathIterator(t));
                    this.invalidateBounds();
                };
                /**
                 * Creates a new <code>Area</code> object that contains the same geometry as
                 * this <code>Area</code> transformed by the specified
                 * <code>AffineTransform</code>. This <code>Area</code> object is unchanged.
                 *
                 * @param t
                 * the specified <code>AffineTransform</code> used to transform
                 * the new <code>Area</code>
                 * @throws NullPointerException
                 * if <code>t</code> is null
                 * @return a new <code>Area</code> object representing the transformed
                 * geometry.
                 * @since 1.2
                 */
                Area.prototype.createTransformedArea = function (t) {
                    var a = new Area(this);
                    a.transform(t);
                    return a;
                };
                Area.prototype.contains = function (x, y, w, h, origrect) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && origrect === undefined) {
                        return this.contains$double$double$double$double(x, y, w, h);
                    }
                    else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$double$double(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$java_awt_geom_Point2D(x);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                Area.prototype.contains$double$double = function (x, y) {
                    if (!this.getCachedBounds().contains(x, y)) {
                        return false;
                    }
                    var enum_ = this.curves.elements();
                    var crossings = 0;
                    while ((enum_.hasMoreElements())) {
                        var c = enum_.nextElement();
                        crossings += c.crossingsFor(x, y);
                    }
                    ;
                    return ((crossings & 1) === 1);
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                Area.prototype.contains$java_awt_geom_Point2D = function (p) {
                    return this.contains(p.getX(), p.getY());
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                Area.prototype.contains$double$double$double$double = function (x, y, w, h) {
                    if (w < 0 || h < 0) {
                        return false;
                    }
                    if (!this.getCachedBounds().contains(x, y, w, h)) {
                        return false;
                    }
                    var c = sun.awt.geom.Crossings.findCrossings(this.curves, x, y, x + w, y + h);
                    return (c != null && c.covers(y, y + h));
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                Area.prototype.contains$java_awt_geom_Rectangle2D = function (r) {
                    return this.contains(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                Area.prototype.intersects = function (x, y, w, h) {
                    var _this = this;
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return (function () {
                            if (w < 0 || h < 0) {
                                return false;
                            }
                            if (!_this.getCachedBounds().intersects(x, y, w, h)) {
                                return false;
                            }
                            var c = sun.awt.geom.Crossings.findCrossings(_this.curves, x, y, x + w, y + h);
                            return (c == null || !c.isEmpty());
                        })();
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.intersects$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                Area.prototype.intersects$java_awt_geom_Rectangle2D = function (r) {
                    return this.intersects(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                /**
                 * Creates a {@link PathIterator} for the outline of this <code>Area</code>
                 * object. This <code>Area</code> object is unchanged.
                 *
                 * @param at
                 * an optional <code>AffineTransform</code> to be applied to the
                 * coordinates as they are returned in the iteration, or
                 * <code>null</code> if untransformed coordinates are desired
                 * @return the <code>PathIterator</code> object that returns the geometry of
                 * the outline of this <code>Area</code>, one segment at a time.
                 * @since 1.2
                 */
                Area.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
                    return new java.awt.geom.AreaIterator(this.curves, at);
                };
                /**
                 * Creates a <code>PathIterator</code> for the flattened outline of this
                 * <code>Area</code> object. Only uncurved path segments represented by the
                 * SEG_MOVETO, SEG_LINETO, and SEG_CLOSE point types are returned by the
                 * iterator. This <code>Area</code> object is unchanged.
                 *
                 * @param at
                 * an optional <code>AffineTransform</code> to be applied to the
                 * coordinates as they are returned in the iteration, or
                 * <code>null</code> if untransformed coordinates are desired
                 * @param flatness
                 * the maximum amount that the control points for a given curve
                 * can vary from colinear before a subdivided curve is replaced
                 * by a straight line connecting the end points
                 * @return the <code>PathIterator</code> object that returns the geometry of
                 * the outline of this <code>Area</code>, one segment at a time.
                 * @since 1.2
                 */
                Area.prototype.getPathIterator = function (at, flatness) {
                    var _this = this;
                    if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
                        return (function () {
                            return new java.awt.geom.FlatteningPathIterator(_this.getPathIterator(at), flatness);
                        })();
                    }
                    else if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && flatness === undefined) {
                        return this.getPathIterator$java_awt_geom_AffineTransform(at);
                    }
                    else
                        throw new Error('invalid overload');
                };
                return Area;
            }());
            geom.Area = Area;
            var AreaIterator = (function () {
                function AreaIterator(curves, at) {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.awt.geom.PathIterator"] });
                    this.index = 0;
                    this.curves = curves;
                    this.transform = at;
                    if (curves.size() >= 1) {
                        this.thiscurve = curves.get(0);
                    }
                }
                AreaIterator.prototype.getWindingRule = function () {
                    return java.awt.geom.PathIterator.WIND_NON_ZERO;
                };
                AreaIterator.prototype.isDone = function () {
                    return (this.prevcurve == null && this.thiscurve == null);
                };
                AreaIterator.prototype.next = function (doNext) {
                    if (doNext === undefined) {
                        return this.next$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                AreaIterator.prototype.next$ = function () {
                    if (this.prevcurve != null) {
                        this.prevcurve = null;
                    }
                    else {
                        this.prevcurve = this.thiscurve;
                        this.index++;
                        if (this.index < this.curves.size()) {
                            this.thiscurve = this.curves.get(this.index);
                            if (this.thiscurve.getOrder() !== 0 && this.prevcurve.getX1() === this.thiscurve.getX0() && this.prevcurve.getY1() === this.thiscurve.getY0()) {
                                this.prevcurve = null;
                            }
                        }
                        else {
                            this.thiscurve = null;
                        }
                    }
                };
                AreaIterator.prototype.currentSegment = function (coords) {
                    var _this = this;
                    if (((coords != null && coords instanceof Array) || coords === null)) {
                        return (function () {
                            var dcoords = new Array(6);
                            var segtype = _this.currentSegment(dcoords);
                            var numpoints = (segtype === java.awt.geom.PathIterator.SEG_CLOSE ? 0 : (segtype === java.awt.geom.PathIterator.SEG_QUADTO ? 2 : (segtype === java.awt.geom.PathIterator.SEG_CUBICTO ? 3 : 1)));
                            for (var i = 0; i < numpoints * 2; i++) {
                                coords[i] = dcoords[i];
                            }
                            return segtype;
                        })();
                    }
                    else if (((coords != null && coords instanceof Array) || coords === null)) {
                        return this.currentSegment$double_A(coords);
                    }
                    else
                        throw new Error('invalid overload');
                };
                AreaIterator.prototype.currentSegment$double_A = function (coords) {
                    var segtype;
                    var numpoints;
                    if (this.prevcurve != null) {
                        if (this.thiscurve == null || this.thiscurve.getOrder() === 0) {
                            return java.awt.geom.PathIterator.SEG_CLOSE;
                        }
                        coords[0] = this.thiscurve.getX0();
                        coords[1] = this.thiscurve.getY0();
                        segtype = java.awt.geom.PathIterator.SEG_LINETO;
                        numpoints = 1;
                    }
                    else if (this.thiscurve == null) {
                        throw new java.util.NoSuchElementException("area iterator out of bounds");
                    }
                    else {
                        segtype = this.thiscurve.getSegment(coords);
                        numpoints = this.thiscurve.getOrder();
                        if (numpoints === 0) {
                            numpoints = 1;
                        }
                    }
                    if (this.transform != null) {
                        this.transform.transform(coords, 0, coords, 0, numpoints);
                    }
                    return segtype;
                };
                return AreaIterator;
            }());
            geom.AreaIterator = AreaIterator;
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * Maintains a last-in, first-out collection of objects. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Stack.html">[Sun
         * docs]</a>
         *
         * @param <E> element type.
         */
        var Stack = (function (_super) {
            __extends(Stack, _super);
            function Stack() {
                _super.call(this);
                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.RandomAccess", "java.util.List", "java.lang.Cloneable", "java.util.Collection", "java.lang.Iterable", "java.io.Serializable"] });
            }
            Stack.prototype.clone = function () {
                var s = new Stack();
                s.addAll(this);
                return s;
            };
            Stack.prototype.empty = function () {
                return this.isEmpty();
            };
            Stack.prototype.peek = function () {
                var sz = this.size();
                if (sz > 0) {
                    return this.get(sz - 1);
                }
                else {
                    throw new java.util.EmptyStackException();
                }
            };
            Stack.prototype.pop = function () {
                var sz = this.size();
                if (sz > 0) {
                    return this.remove(sz - 1);
                }
                else {
                    throw new java.util.EmptyStackException();
                }
            };
            Stack.prototype.push = function (o) {
                this.add(o);
                return o;
            };
            Stack.prototype.search = function (o) {
                var pos = this.lastIndexOf(o);
                if (pos >= 0) {
                    return this.size() - pos;
                }
                return -1;
            };
            return Stack;
        }(java.util.Vector));
        util.Stack = Stack;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * Implementation of Map interface based on a hash table. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/HashMap.html">[Sun
         * docs]</a>
         *
         * @param <K> key type
         * @param <V> value type
         */
        var AbstractHashMap = (function (_super) {
            __extends(AbstractHashMap, _super);
            function AbstractHashMap(ignored, alsoIgnored) {
                var _this = this;
                if (((typeof ignored === 'number') || ignored === null) && ((typeof alsoIgnored === 'number') || alsoIgnored === null)) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Map"] });
                    (function () {
                        javaemul.internal.InternalPreconditions.checkArgument(ignored >= 0, "Negative initial capacity");
                        javaemul.internal.InternalPreconditions.checkArgument(alsoIgnored >= 0, "Non-positive load factor");
                        _this.reset();
                    })();
                }
                else if (((ignored != null && ignored["__interfaces"] != null && ignored["__interfaces"].indexOf("java.util.Map") >= 0) || ignored === null) && alsoIgnored === undefined) {
                    var toBeCopied = ignored;
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Map"] });
                    (function () {
                        _this.reset();
                        _this.putAll(toBeCopied);
                    })();
                }
                else if (((typeof ignored === 'number') || ignored === null) && alsoIgnored === undefined) {
                    {
                        var alsoIgnored = 0;
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Map"] });
                        (function () {
                            javaemul.internal.InternalPreconditions.checkArgument(ignored >= 0, "Negative initial capacity");
                            javaemul.internal.InternalPreconditions.checkArgument(alsoIgnored >= 0, "Non-positive load factor");
                            _this.reset();
                        })();
                    }
                    (function () {
                    })();
                }
                else if (ignored === undefined && alsoIgnored === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Map"] });
                    (function () {
                        _this.reset();
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            AbstractHashMap.prototype.clear = function () {
                this.reset();
            };
            AbstractHashMap.prototype.reset = function () {
                this.hashCodeMap = new java.util.InternalHashCodeMap(this);
                this.stringMap = new java.util.InternalStringMap(this);
                java.util.ConcurrentModificationDetector.structureChanged(this);
            };
            AbstractHashMap.prototype.containsKey = function (key) {
                return (typeof key === 'string') ? this.hasStringValue(javaemul.internal.JsUtils.unsafeCastToString(key)) : this.hasHashValue(key);
            };
            AbstractHashMap.prototype.containsValue = function (value) {
                return this._containsValue(value, this.stringMap) || this._containsValue(value, this.hashCodeMap);
            };
            AbstractHashMap.prototype._containsValue = function (value, entries) {
                for (var index168 = entries.iterator(); index168.hasNext();) {
                    var entry = index168.next();
                    {
                        if (this._equals(value, entry.getValue())) {
                            return true;
                        }
                    }
                }
                return false;
            };
            AbstractHashMap.prototype.entrySet = function () {
                return new AbstractHashMap.EntrySet(this);
            };
            AbstractHashMap.prototype.get = function (key) {
                return (typeof key === 'string') ? this.getStringValue(javaemul.internal.JsUtils.unsafeCastToString(key)) : this.getHashValue(key);
            };
            AbstractHashMap.prototype.put = function (key, value) {
                return (typeof key === 'string') ? this.putStringValue(javaemul.internal.JsUtils.unsafeCastToString(key), value) : this.putHashValue(key, value);
            };
            AbstractHashMap.prototype.remove = function (key) {
                return (typeof key === 'string') ? this.removeStringValue(javaemul.internal.JsUtils.unsafeCastToString(key)) : this.removeHashValue(key);
            };
            AbstractHashMap.prototype.size = function () {
                return this.hashCodeMap.size() + this.stringMap.getSize();
            };
            /**
             * Returns the Map.Entry whose key is Object equal to <code>key</code>,
             * provided that <code>key</code>'s hash code is <code>hashCode</code>;
             * or <code>null</code> if no such Map.Entry exists at the specified
             * hashCode.
             */
            AbstractHashMap.prototype.getHashValue = function (key) {
                return util.AbstractMap.getEntryValueOrNull(this.hashCodeMap.getEntry(key));
            };
            /**
             * Returns the value for the given key in the stringMap. Returns
             * <code>null</code> if the specified key does not exist.
             */
            AbstractHashMap.prototype.getStringValue = function (key) {
                return key == null ? this.getHashValue(null) : this.stringMap.get(key);
            };
            /**
             * Returns true if the a key exists in the hashCodeMap that is Object equal to
             * <code>key</code>, provided that <code>key</code>'s hash code is
             * <code>hashCode</code>.
             */
            AbstractHashMap.prototype.hasHashValue = function (key) {
                return this.hashCodeMap.getEntry(key) != null;
            };
            /**
             * Returns true if the given key exists in the stringMap.
             */
            AbstractHashMap.prototype.hasStringValue = function (key) {
                return key == null ? this.hasHashValue(null) : this.stringMap.contains(key);
            };
            /**
             * Sets the specified key to the specified value in the hashCodeMap. Returns
             * the value previously at that key. Returns <code>null</code> if the
             * specified key did not exist.
             */
            AbstractHashMap.prototype.putHashValue = function (key, value) {
                return this.hashCodeMap.put(key, value);
            };
            /**
             * Sets the specified key to the specified value in the stringMap. Returns the
             * value previously at that key. Returns <code>null</code> if the specified
             * key did not exist.
             */
            AbstractHashMap.prototype.putStringValue = function (key, value) {
                return key == null ? this.putHashValue(null, value) : this.stringMap.put(key, value);
            };
            /**
             * Removes the pair whose key is Object equal to <code>key</code> from
             * <code>hashCodeMap</code>, provided that <code>key</code>'s hash code
             * is <code>hashCode</code>. Returns the value that was associated with the
             * removed key, or null if no such key existed.
             */
            AbstractHashMap.prototype.removeHashValue = function (key) {
                return this.hashCodeMap.remove(key);
            };
            /**
             * Removes the specified key from the stringMap and returns the value that was
             * previously there. Returns <code>null</code> if the specified key does not
             * exist.
             */
            AbstractHashMap.prototype.removeStringValue = function (key) {
                return key == null ? this.removeHashValue(null) : this.stringMap.remove(key);
            };
            return AbstractHashMap;
        }(java.util.AbstractMap));
        util.AbstractHashMap = AbstractHashMap;
        var AbstractHashMap;
        (function (AbstractHashMap) {
            var EntrySet = (function (_super) {
                __extends(EntrySet, _super);
                function EntrySet(__parent) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Collection", "java.util.Set", "java.lang.Iterable"] });
                    this.__parent = __parent;
                }
                EntrySet.prototype.clear = function () {
                    this.__parent.clear();
                };
                EntrySet.prototype.contains = function (o) {
                    if (o != null && o["__interfaces"] != null && o["__interfaces"].indexOf("java.util.Map.Entry") >= 0) {
                        return this.__parent.containsEntry(o);
                    }
                    return false;
                };
                EntrySet.prototype.iterator = function () {
                    return new AbstractHashMap.EntrySetIterator(this.__parent);
                };
                EntrySet.prototype.remove = function (index) {
                    if (((index != null) || index === null)) {
                        return this.remove$java_lang_Object(index);
                    }
                    else
                        throw new Error('invalid overload');
                };
                EntrySet.prototype.remove$java_lang_Object = function (entry) {
                    if (this.contains(entry)) {
                        var key = entry.getKey();
                        this.__parent.remove(key);
                        return true;
                    }
                    return false;
                };
                EntrySet.prototype.size = function () {
                    return this.__parent.size();
                };
                return EntrySet;
            }(java.util.AbstractSet));
            AbstractHashMap.EntrySet = EntrySet;
            /**
             * Iterator for <code>EntrySet</code>.
             */
            var EntrySetIterator = (function () {
                function EntrySetIterator(__parent) {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Iterator"] });
                    this.__parent = __parent;
                    this.__hasNext = false;
                    this.stringMapEntries = this.__parent.stringMap.iterator();
                    this.current = this.stringMapEntries;
                    this.__hasNext = this.computeHasNext();
                    java.util.ConcurrentModificationDetector.recordLastKnownStructure(this.__parent, this);
                }
                EntrySetIterator.prototype.forEachRemaining = function (consumer) {
                    javaemul.internal.InternalPreconditions.checkNotNull(consumer);
                    while ((this.hasNext())) {
                        consumer(this.next());
                    }
                    ;
                };
                EntrySetIterator.prototype.hasNext = function () {
                    return this.__hasNext;
                };
                EntrySetIterator.prototype.computeHasNext = function () {
                    if (this.current.hasNext()) {
                        return true;
                    }
                    if (this.current !== this.stringMapEntries) {
                        return false;
                    }
                    this.current = this.__parent.hashCodeMap.iterator();
                    return this.current.hasNext();
                };
                EntrySetIterator.prototype.next = function () {
                    java.util.ConcurrentModificationDetector.checkStructuralChange(this.__parent, this);
                    javaemul.internal.InternalPreconditions.checkElement(this.hasNext());
                    this.last = this.current;
                    var rv = this.current.next();
                    this.__hasNext = this.computeHasNext();
                    return rv;
                };
                EntrySetIterator.prototype.remove = function () {
                    javaemul.internal.InternalPreconditions.checkState(this.last != null);
                    java.util.ConcurrentModificationDetector.checkStructuralChange(this.__parent, this);
                    this.last.remove();
                    this.last = null;
                    this.__hasNext = this.computeHasNext();
                    java.util.ConcurrentModificationDetector.recordLastKnownStructure(this.__parent, this);
                };
                return EntrySetIterator;
            }());
            AbstractHashMap.EntrySetIterator = EntrySetIterator;
        })(AbstractHashMap = util.AbstractHashMap || (util.AbstractHashMap = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * Skeletal implementation of a NavigableMap.
         */
        var AbstractNavigableMap = (function (_super) {
            __extends(AbstractNavigableMap, _super);
            function AbstractNavigableMap() {
                _super.call(this);
                Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Map", "java.util.NavigableMap", "java.util.SortedMap"] });
            }
            AbstractNavigableMap.copyOf = function (entry) {
                return entry == null ? null : new util.AbstractMap.SimpleImmutableEntry(entry);
            };
            AbstractNavigableMap.getKeyOrNSE = function (entry) {
                if (entry == null) {
                    throw new java.util.NoSuchElementException();
                }
                return entry.getKey();
            };
            AbstractNavigableMap.prototype.ceilingEntry = function (key) {
                return AbstractNavigableMap.copyOf(this.getCeilingEntry(key));
            };
            AbstractNavigableMap.prototype.ceilingKey = function (key) {
                return util.AbstractMap.getEntryKeyOrNull(this.getCeilingEntry(key));
            };
            AbstractNavigableMap.prototype.containsKey = function (k) {
                var key = k;
                return this.getEntry(key) != null;
            };
            AbstractNavigableMap.prototype.descendingKeySet = function () {
                return this.descendingMap().navigableKeySet();
            };
            AbstractNavigableMap.prototype.descendingMap = function () {
                return new AbstractNavigableMap.DescendingMap(this);
            };
            AbstractNavigableMap.prototype.entrySet = function () {
                return new AbstractNavigableMap.EntrySet(this);
            };
            AbstractNavigableMap.prototype.firstEntry = function () {
                return AbstractNavigableMap.copyOf(this.getFirstEntry());
            };
            AbstractNavigableMap.prototype.firstKey = function () {
                return AbstractNavigableMap.getKeyOrNSE(this.getFirstEntry());
            };
            AbstractNavigableMap.prototype.floorEntry = function (key) {
                return AbstractNavigableMap.copyOf(this.getFloorEntry(key));
            };
            AbstractNavigableMap.prototype.floorKey = function (key) {
                return util.AbstractMap.getEntryKeyOrNull(this.getFloorEntry(key));
            };
            AbstractNavigableMap.prototype.get = function (k) {
                var key = k;
                return util.AbstractMap.getEntryValueOrNull(this.getEntry(key));
            };
            AbstractNavigableMap.prototype.headMap = function (toKey, inclusive) {
                if (((toKey != null) || toKey === null) && inclusive === undefined) {
                    return this.headMap$java_lang_Object(toKey);
                }
                else
                    throw new Error('invalid overload');
            };
            AbstractNavigableMap.prototype.headMap$java_lang_Object = function (toKey) {
                return this.headMap(toKey, false);
            };
            AbstractNavigableMap.prototype.higherEntry = function (key) {
                return AbstractNavigableMap.copyOf(this.getHigherEntry(key));
            };
            AbstractNavigableMap.prototype.higherKey = function (key) {
                return util.AbstractMap.getEntryKeyOrNull(this.getHigherEntry(key));
            };
            AbstractNavigableMap.prototype.keySet = function () {
                return this.navigableKeySet();
            };
            AbstractNavigableMap.prototype.lastEntry = function () {
                return AbstractNavigableMap.copyOf(this.getLastEntry());
            };
            AbstractNavigableMap.prototype.lastKey = function () {
                return AbstractNavigableMap.getKeyOrNSE(this.getLastEntry());
            };
            AbstractNavigableMap.prototype.lowerEntry = function (key) {
                return AbstractNavigableMap.copyOf(this.getLowerEntry(key));
            };
            AbstractNavigableMap.prototype.lowerKey = function (key) {
                return util.AbstractMap.getEntryKeyOrNull(this.getLowerEntry(key));
            };
            AbstractNavigableMap.prototype.navigableKeySet = function () {
                return new AbstractNavigableMap.NavigableKeySet(this);
            };
            AbstractNavigableMap.prototype.pollFirstEntry = function () {
                return this.pollEntry(this.getFirstEntry());
            };
            AbstractNavigableMap.prototype.pollLastEntry = function () {
                return this.pollEntry(this.getLastEntry());
            };
            AbstractNavigableMap.prototype.subMap = function (fromKey, fromInclusive, toKey, toInclusive) {
                if (((fromKey != null) || fromKey === null) && ((fromInclusive != null) || fromInclusive === null) && toKey === undefined && toInclusive === undefined) {
                    return this.subMap$java_lang_Object$java_lang_Object(fromKey, fromInclusive);
                }
                else
                    throw new Error('invalid overload');
            };
            AbstractNavigableMap.prototype.subMap$java_lang_Object$java_lang_Object = function (fromKey, toKey) {
                return this.subMap(fromKey, true, toKey, false);
            };
            AbstractNavigableMap.prototype.tailMap = function (fromKey, inclusive) {
                if (((fromKey != null) || fromKey === null) && inclusive === undefined) {
                    return this.tailMap$java_lang_Object(fromKey);
                }
                else
                    throw new Error('invalid overload');
            };
            AbstractNavigableMap.prototype.tailMap$java_lang_Object = function (fromKey) {
                return this.tailMap(fromKey, true);
            };
            AbstractNavigableMap.prototype.containsEntry = function (entry) {
                var key = entry.getKey();
                var lookupEntry = this.getEntry(key);
                return lookupEntry != null && java.util.Objects.equals(lookupEntry.getValue(), entry.getValue());
            };
            AbstractNavigableMap.prototype.pollEntry = function (entry) {
                if (entry != null) {
                    this.removeEntry(entry);
                }
                return AbstractNavigableMap.copyOf(entry);
            };
            return AbstractNavigableMap;
        }(java.util.AbstractMap));
        util.AbstractNavigableMap = AbstractNavigableMap;
        var AbstractNavigableMap;
        (function (AbstractNavigableMap) {
            var DescendingMap = (function (_super) {
                __extends(DescendingMap, _super);
                function DescendingMap(__parent) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Map", "java.util.NavigableMap", "java.util.SortedMap"] });
                    this.__parent = __parent;
                }
                DescendingMap.prototype.clear = function () {
                    this.ascendingMap().clear();
                };
                DescendingMap.prototype.comparator = function () {
                    return java.util.Collections.reverseOrder(this.ascendingMap().comparator());
                };
                DescendingMap.prototype.descendingMap = function () {
                    return this.ascendingMap();
                };
                DescendingMap.prototype.headMap = function (toKey, inclusive) {
                    var _this = this;
                    if (((toKey != null) || toKey === null) && ((typeof inclusive === 'boolean') || inclusive === null)) {
                        return (function () {
                            return _this.ascendingMap().tailMap(toKey, inclusive).descendingMap();
                        })();
                    }
                    else if (((toKey != null) || toKey === null) && inclusive === undefined) {
                        return this.headMap$java_lang_Object(toKey);
                    }
                    else
                        throw new Error('invalid overload');
                };
                DescendingMap.prototype.put = function (key, value) {
                    return this.ascendingMap().put(key, value);
                };
                DescendingMap.prototype.remove = function (key) {
                    return this.ascendingMap().remove(key);
                };
                DescendingMap.prototype.size = function () {
                    return this.ascendingMap().size();
                };
                DescendingMap.prototype.subMap = function (fromKey, fromInclusive, toKey, toInclusive) {
                    var _this = this;
                    if (((fromKey != null) || fromKey === null) && ((typeof fromInclusive === 'boolean') || fromInclusive === null) && ((toKey != null) || toKey === null) && ((typeof toInclusive === 'boolean') || toInclusive === null)) {
                        return (function () {
                            return _this.ascendingMap().subMap(toKey, toInclusive, fromKey, fromInclusive).descendingMap();
                        })();
                    }
                    else if (((fromKey != null) || fromKey === null) && ((fromInclusive != null) || fromInclusive === null) && toKey === undefined && toInclusive === undefined) {
                        return this.subMap$java_lang_Object$java_lang_Object(fromKey, fromInclusive);
                    }
                    else
                        throw new Error('invalid overload');
                };
                DescendingMap.prototype.tailMap = function (fromKey, inclusive) {
                    var _this = this;
                    if (((fromKey != null) || fromKey === null) && ((typeof inclusive === 'boolean') || inclusive === null)) {
                        return (function () {
                            return _this.ascendingMap().headMap(fromKey, inclusive).descendingMap();
                        })();
                    }
                    else if (((fromKey != null) || fromKey === null) && inclusive === undefined) {
                        return this.tailMap$java_lang_Object(fromKey);
                    }
                    else
                        throw new Error('invalid overload');
                };
                DescendingMap.prototype.ascendingMap = function () {
                    return this.__parent;
                };
                DescendingMap.prototype.descendingEntryIterator = function () {
                    return this.ascendingMap().entryIterator();
                };
                DescendingMap.prototype.entryIterator = function () {
                    return this.ascendingMap().descendingEntryIterator();
                };
                DescendingMap.prototype.getEntry = function (key) {
                    return this.ascendingMap().getEntry(key);
                };
                DescendingMap.prototype.getFirstEntry = function () {
                    return this.ascendingMap().getLastEntry();
                };
                DescendingMap.prototype.getLastEntry = function () {
                    return this.ascendingMap().getFirstEntry();
                };
                DescendingMap.prototype.getCeilingEntry = function (key) {
                    return this.ascendingMap().getFloorEntry(key);
                };
                DescendingMap.prototype.getFloorEntry = function (key) {
                    return this.ascendingMap().getCeilingEntry(key);
                };
                DescendingMap.prototype.getHigherEntry = function (key) {
                    return this.ascendingMap().getLowerEntry(key);
                };
                DescendingMap.prototype.getLowerEntry = function (key) {
                    return this.ascendingMap().getHigherEntry(key);
                };
                DescendingMap.prototype.removeEntry = function (entry) {
                    return this.ascendingMap().removeEntry(entry);
                };
                return DescendingMap;
            }(java.util.AbstractNavigableMap));
            AbstractNavigableMap.DescendingMap = DescendingMap;
            var EntrySet = (function (_super) {
                __extends(EntrySet, _super);
                function EntrySet(__parent) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Collection", "java.util.Set", "java.lang.Iterable"] });
                    this.__parent = __parent;
                }
                EntrySet.prototype.contains = function (o) {
                    return (o != null && o["__interfaces"] != null && o["__interfaces"].indexOf("java.util.Map.Entry") >= 0) && this.__parent.containsEntry(o);
                };
                EntrySet.prototype.iterator = function () {
                    return this.__parent.entryIterator();
                };
                EntrySet.prototype.remove = function (index) {
                    if (((index != null) || index === null)) {
                        return this.remove$java_lang_Object(index);
                    }
                    else
                        throw new Error('invalid overload');
                };
                EntrySet.prototype.remove$java_lang_Object = function (o) {
                    if (o != null && o["__interfaces"] != null && o["__interfaces"].indexOf("java.util.Map.Entry") >= 0) {
                        var entry = o;
                        return this.__parent.removeEntry(entry);
                    }
                    return false;
                };
                EntrySet.prototype.size = function () {
                    return this.__parent.size();
                };
                return EntrySet;
            }(java.util.AbstractSet));
            AbstractNavigableMap.EntrySet = EntrySet;
            var NavigableKeySet = (function (_super) {
                __extends(NavigableKeySet, _super);
                function NavigableKeySet(map) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.SortedSet", "java.util.Collection", "java.util.Set", "java.util.NavigableSet", "java.lang.Iterable"] });
                    this.map = map;
                }
                NavigableKeySet.prototype.forEach = function (action) {
                    javaemul.internal.InternalPreconditions.checkNotNull(action);
                    for (var index169 = this.iterator(); index169.hasNext();) {
                        var t = index169.next();
                        {
                            action(t);
                        }
                    }
                };
                NavigableKeySet.prototype.ceiling = function (k) {
                    return this.map.ceilingKey(k);
                };
                NavigableKeySet.prototype.clear = function () {
                    this.map.clear();
                };
                NavigableKeySet.prototype.comparator = function () {
                    return this.map.comparator();
                };
                NavigableKeySet.prototype.contains = function (o) {
                    return this.map.containsKey(o);
                };
                NavigableKeySet.prototype.descendingIterator = function () {
                    return this.descendingSet().iterator();
                };
                NavigableKeySet.prototype.descendingSet = function () {
                    return this.map.descendingMap().navigableKeySet();
                };
                NavigableKeySet.prototype.first = function () {
                    return this.map.firstKey();
                };
                NavigableKeySet.prototype.floor = function (k) {
                    return this.map.floorKey(k);
                };
                NavigableKeySet.prototype.headSet$java_lang_Object = function (toElement) {
                    return this.headSet(toElement, false);
                };
                NavigableKeySet.prototype.headSet = function (toElement, inclusive) {
                    var _this = this;
                    if (((toElement != null) || toElement === null) && ((typeof inclusive === 'boolean') || inclusive === null)) {
                        return (function () {
                            return _this.map.headMap(toElement, inclusive).navigableKeySet();
                        })();
                    }
                    else if (((toElement != null) || toElement === null) && inclusive === undefined) {
                        return this.headSet$java_lang_Object(toElement);
                    }
                    else
                        throw new Error('invalid overload');
                };
                NavigableKeySet.prototype.higher = function (k) {
                    return this.map.higherKey(k);
                };
                NavigableKeySet.prototype.iterator = function () {
                    var entryIterator = this.map.entrySet().iterator();
                    return new NavigableKeySet.NavigableKeySet$0(this, entryIterator);
                };
                NavigableKeySet.prototype.last = function () {
                    return this.map.lastKey();
                };
                NavigableKeySet.prototype.lower = function (k) {
                    return this.map.lowerKey(k);
                };
                NavigableKeySet.prototype.pollFirst = function () {
                    return util.AbstractMap.getEntryKeyOrNull(this.map.pollFirstEntry());
                };
                NavigableKeySet.prototype.pollLast = function () {
                    return util.AbstractMap.getEntryKeyOrNull(this.map.pollLastEntry());
                };
                NavigableKeySet.prototype.remove = function (index) {
                    if (((index != null) || index === null)) {
                        return this.remove$java_lang_Object(index);
                    }
                    else
                        throw new Error('invalid overload');
                };
                NavigableKeySet.prototype.remove$java_lang_Object = function (o) {
                    if (this.map.containsKey(o)) {
                        this.map.remove(o);
                        return true;
                    }
                    return false;
                };
                NavigableKeySet.prototype.size = function () {
                    return this.map.size();
                };
                NavigableKeySet.prototype.subSet = function (fromElement, fromInclusive, toElement, toInclusive) {
                    var _this = this;
                    if (((fromElement != null) || fromElement === null) && ((typeof fromInclusive === 'boolean') || fromInclusive === null) && ((toElement != null) || toElement === null) && ((typeof toInclusive === 'boolean') || toInclusive === null)) {
                        return (function () {
                            return _this.map.subMap(fromElement, fromInclusive, toElement, toInclusive).navigableKeySet();
                        })();
                    }
                    else if (((fromElement != null) || fromElement === null) && ((fromInclusive != null) || fromInclusive === null) && toElement === undefined && toInclusive === undefined) {
                        return this.subSet$java_lang_Object$java_lang_Object(fromElement, fromInclusive);
                    }
                    else
                        throw new Error('invalid overload');
                };
                NavigableKeySet.prototype.subSet$java_lang_Object$java_lang_Object = function (fromElement, toElement) {
                    return this.subSet(fromElement, true, toElement, false);
                };
                NavigableKeySet.prototype.tailSet$java_lang_Object = function (fromElement) {
                    return this.tailSet(fromElement, true);
                };
                NavigableKeySet.prototype.tailSet = function (fromElement, inclusive) {
                    var _this = this;
                    if (((fromElement != null) || fromElement === null) && ((typeof inclusive === 'boolean') || inclusive === null)) {
                        return (function () {
                            return _this.map.tailMap(fromElement, inclusive).navigableKeySet();
                        })();
                    }
                    else if (((fromElement != null) || fromElement === null) && inclusive === undefined) {
                        return this.tailSet$java_lang_Object(fromElement);
                    }
                    else
                        throw new Error('invalid overload');
                };
                return NavigableKeySet;
            }(java.util.AbstractSet));
            AbstractNavigableMap.NavigableKeySet = NavigableKeySet;
            var NavigableKeySet;
            (function (NavigableKeySet) {
                var NavigableKeySet$0 = (function () {
                    function NavigableKeySet$0(__parent, entryIterator) {
                        this.entryIterator = entryIterator;
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Iterator"] });
                        this.__parent = __parent;
                    }
                    NavigableKeySet$0.prototype.forEachRemaining = function (consumer) {
                        javaemul.internal.InternalPreconditions.checkNotNull(consumer);
                        while ((this.hasNext())) {
                            consumer(this.next());
                        }
                        ;
                    };
                    NavigableKeySet$0.prototype.hasNext = function () {
                        return this.entryIterator.hasNext();
                    };
                    NavigableKeySet$0.prototype.next = function () {
                        var entry = this.entryIterator.next();
                        return entry.getKey();
                    };
                    NavigableKeySet$0.prototype.remove = function () {
                        this.entryIterator.remove();
                    };
                    return NavigableKeySet$0;
                }());
                NavigableKeySet.NavigableKeySet$0 = NavigableKeySet$0;
            })(NavigableKeySet = AbstractNavigableMap.NavigableKeySet || (AbstractNavigableMap.NavigableKeySet = {}));
        })(AbstractNavigableMap = util.AbstractNavigableMap || (util.AbstractNavigableMap = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * Utility methods that operate on collections. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Collections.html">[Sun
         * docs]</a>
         */
        var Collections = (function () {
            function Collections() {
            }
            Collections.EMPTY_LIST_$LI$ = function () { if (Collections.EMPTY_LIST == null)
                Collections.EMPTY_LIST = new Collections.EmptyList(); return Collections.EMPTY_LIST; };
            ;
            Collections.EMPTY_MAP_$LI$ = function () { if (Collections.EMPTY_MAP == null)
                Collections.EMPTY_MAP = new Collections.EmptyMap(); return Collections.EMPTY_MAP; };
            ;
            Collections.EMPTY_SET_$LI$ = function () { if (Collections.EMPTY_SET == null)
                Collections.EMPTY_SET = new Collections.EmptySet(); return Collections.EMPTY_SET; };
            ;
            Collections.addAll = function (c) {
                var a = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    a[_i - 1] = arguments[_i];
                }
                var result = false;
                for (var index170 = 0; index170 < a.length; index170++) {
                    var e = a[index170];
                    {
                        result = result || c.add(e);
                    }
                }
                return result;
            };
            Collections.asLifoQueue = function (deque) {
                return new Collections.LifoQueue(deque);
            };
            /**
             * Perform a binary search on a sorted List, using a user-specified comparison
             * function.
             *
             * <p>
             * Note: The GWT implementation differs from the JDK implementation in that it
             * does not do an iterator-based binary search for Lists that do not implement
             * RandomAccess.
             * </p>
             *
             * @param sortedList List to search
             * @param key value to search for
             * @param comparator comparision function, <code>null</code> indicates
             * <i>natural ordering</i> should be used.
             * @return the index of an element with a matching value, or a negative number
             * which is the index of the next larger value (or just past the end
             * of the array if the searched value is larger than all elements in
             * the array) minus 1 (to ensure error returns are negative)
             * @throws ClassCastException if <code>key</code> and
             * <code>sortedList</code>'s elements cannot be compared by
             * <code>comparator</code>.
             */
            Collections.binarySearch = function (sortedList, key, comparator) {
                if (comparator === void 0) { comparator = null; }
                if (comparator == null) {
                    comparator = java.util.Comparators.natural();
                }
                var low = 0;
                var high = sortedList.size() - 1;
                while ((low <= high)) {
                    var mid = low + ((high - low) >> 1);
                    var midVal = sortedList.get(mid);
                    var compareResult = comparator.compare(midVal, key);
                    if (compareResult < 0) {
                        low = mid + 1;
                    }
                    else if (compareResult > 0) {
                        high = mid - 1;
                    }
                    else {
                        return mid;
                    }
                }
                ;
                return -low - 1;
            };
            Collections.copy = function (dest, src) {
                if (src.size() > dest.size()) {
                    throw new java.lang.IndexOutOfBoundsException("src does not fit in dest");
                }
                var destIt = dest.listIterator();
                for (var index171 = src.iterator(); index171.hasNext();) {
                    var e = index171.next();
                    {
                        destIt.next();
                        destIt.set(e);
                    }
                }
            };
            Collections.disjoint = function (c1, c2) {
                var iterating = c1;
                var testing = c2;
                if ((c1 != null && c1["__interfaces"] != null && c1["__interfaces"].indexOf("java.util.Set") >= 0) && !(c2 != null && c2["__interfaces"] != null && c2["__interfaces"].indexOf("java.util.Set") >= 0)) {
                    iterating = c2;
                    testing = c1;
                }
                for (var index172 = iterating.iterator(); index172.hasNext();) {
                    var o = index172.next();
                    {
                        if (testing.contains(o)) {
                            return false;
                        }
                    }
                }
                return true;
            };
            Collections.emptyIterator = function () {
                return Collections.EmptyListIterator.INSTANCE_$LI$();
            };
            Collections.emptyList = function () {
                return Collections.EMPTY_LIST_$LI$();
            };
            Collections.emptyListIterator = function () {
                return Collections.EmptyListIterator.INSTANCE_$LI$();
            };
            Collections.emptyMap = function () {
                return Collections.EMPTY_MAP_$LI$();
            };
            Collections.emptySet = function () {
                return Collections.EMPTY_SET_$LI$();
            };
            Collections.enumeration = function (c) {
                var it = c.iterator();
                return new Collections.Collections$0(it);
            };
            Collections.fill = function (list, obj) {
                for (var it = list.listIterator(); it.hasNext();) {
                    it.next();
                    it.set(obj);
                }
            };
            Collections.frequency = function (c, o) {
                var count = 0;
                for (var index173 = c.iterator(); index173.hasNext();) {
                    var e = index173.next();
                    {
                        if (java.util.Objects.equals(o, e)) {
                            ++count;
                        }
                    }
                }
                return count;
            };
            Collections.list = function (e) {
                var arrayList = new java.util.ArrayList();
                while ((e.hasMoreElements())) {
                    arrayList.add(e.nextElement());
                }
                ;
                return arrayList;
            };
            Collections.max = function (coll, comp) {
                if (comp === void 0) { comp = null; }
                if (comp == null) {
                    comp = java.util.Comparators.natural();
                }
                var it = coll.iterator();
                var max = it.next();
                while ((it.hasNext())) {
                    var t = it.next();
                    if (comp.compare(t, max) > 0) {
                        max = t;
                    }
                }
                ;
                return max;
            };
            Collections.min = function (coll, comp) {
                if (comp === void 0) { comp = null; }
                return Collections.max(coll, Collections.reverseOrder(comp));
            };
            Collections.newSetFromMap = function (map) {
                javaemul.internal.InternalPreconditions.checkArgument(map.isEmpty(), "map is not empty");
                return new Collections.SetFromMap(map);
            };
            Collections.nCopies = function (n, o) {
                var list = new java.util.ArrayList();
                for (var i = 0; i < n; ++i) {
                    list.add(o);
                }
                return Collections.unmodifiableList(list);
            };
            Collections.replaceAll = function (list, oldVal, newVal) {
                var modified = false;
                for (var it = list.listIterator(); it.hasNext();) {
                    var t = it.next();
                    if (java.util.Objects.equals(t, oldVal)) {
                        it.set(newVal);
                        modified = true;
                    }
                }
                return modified;
            };
            Collections.reverse = function (l) {
                if (l != null && l["__interfaces"] != null && l["__interfaces"].indexOf("java.util.RandomAccess") >= 0) {
                    for (var iFront = 0, iBack = l.size() - 1; iFront < iBack; ++iFront, --iBack) {
                        Collections.swap(l, iFront, iBack);
                    }
                }
                else {
                    var head = l.listIterator();
                    var tail = l.listIterator(l.size());
                    while ((head.nextIndex() < tail.previousIndex())) {
                        var headElem = head.next();
                        var tailElem = tail.previous();
                        head.set(tailElem);
                        tail.set(headElem);
                    }
                    ;
                }
            };
            Collections.reverseOrder$ = function () {
                return Collections.ReverseComparator.INSTANCE_$LI$();
            };
            Collections.reverseOrder = function (cmp) {
                if (((cmp != null && cmp["__interfaces"] != null && cmp["__interfaces"].indexOf("java.util.Comparator") >= 0) || cmp === null)) {
                    return (function () {
                        if (cmp == null) {
                            return Collections.reverseOrder();
                        }
                        return new Collections.Collections$1(cmp);
                    })();
                }
                else if (cmp === undefined) {
                    return java.util.Collections.reverseOrder$();
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Rotates the elements in {@code list} by the distance {@code dist}
             * <p>
             * e.g. for a given list with elements [1, 2, 3, 4, 5, 6, 7, 8, 9, 0], calling rotate(list, 3) or
             * rotate(list, -7) would modify the list to look like this: [8, 9, 0, 1, 2, 3, 4, 5, 6, 7]
             *
             * @param lst the list whose elements are to be rotated.
             * @param dist is the distance the list is rotated. This can be any valid integer. Negative values
             * rotate the list backwards.
             */
            Collections.rotate = function (lst, dist) {
                javaemul.internal.InternalPreconditions.checkNotNull(lst);
                var size = lst.size();
                if (size === 0) {
                    return;
                }
                var normdist = dist % size;
                if (normdist === 0) {
                    return;
                }
                if (normdist < 0) {
                    normdist += size;
                }
                if (lst != null && lst["__interfaces"] != null && lst["__interfaces"].indexOf("java.util.RandomAccess") >= 0) {
                    var list = lst;
                    var temp = list.get(0);
                    var index = 0;
                    var beginIndex = 0;
                    for (var i = 0; i < size; i++) {
                        index = (index + normdist) % size;
                        temp = list.set(index, temp);
                        if (index === beginIndex) {
                            index = ++beginIndex;
                            temp = list.get(beginIndex);
                        }
                    }
                }
                else {
                    var divideIndex = size - normdist;
                    var sublist1 = lst.subList(0, divideIndex);
                    var sublist2 = lst.subList(divideIndex, size);
                    Collections.reverse(sublist1);
                    Collections.reverse(sublist2);
                    Collections.reverse(lst);
                }
            };
            Collections.shuffle = function (list, rnd) {
                if (rnd === void 0) { rnd = Collections.RandomHolder.rnd_$LI$(); }
                if (list != null && list["__interfaces"] != null && list["__interfaces"].indexOf("java.util.RandomAccess") >= 0) {
                    for (var i = list.size() - 1; i >= 1; i--) {
                        Collections.swapImpl(list, i, rnd.nextInt(i + 1));
                    }
                }
                else {
                    var arr = list.toArray();
                    for (var i = arr.length - 1; i >= 1; i--) {
                        Collections.swapImpl(arr, i, rnd.nextInt(i + 1));
                    }
                    var it = list.listIterator();
                    for (var index174 = 0; index174 < arr.length; index174++) {
                        var e = arr[index174];
                        {
                            it.next();
                            it.set(e);
                        }
                    }
                }
            };
            Collections.singleton = function (o) {
                var set = new java.util.HashSet(1);
                set.add(o);
                return Collections.unmodifiableSet(set);
            };
            Collections.singletonList = function (o) {
                return new Collections.SingletonList(o);
            };
            Collections.singletonMap = function (key, value) {
                var map = new java.util.HashMap(1);
                map.put(key, value);
                return Collections.unmodifiableMap(map);
            };
            Collections.sort = function (target, c) {
                if (c === void 0) { c = null; }
                var x = target.toArray();
                java.util.Arrays.sort(x, c);
                Collections.replaceContents(target, x);
            };
            Collections.swap = function (list, i, j) {
                Collections.swapImpl(list, i, j);
            };
            Collections.unmodifiableCollection = function (coll) {
                return new Collections.UnmodifiableCollection(coll);
            };
            Collections.unmodifiableList = function (list) {
                return (list != null && list["__interfaces"] != null && list["__interfaces"].indexOf("java.util.RandomAccess") >= 0) ? new Collections.UnmodifiableRandomAccessList(list) : new Collections.UnmodifiableList(list);
            };
            Collections.unmodifiableMap = function (map) {
                return new Collections.UnmodifiableMap(map);
            };
            Collections.unmodifiableSet = function (set) {
                return new Collections.UnmodifiableSet(set);
            };
            Collections.unmodifiableSortedMap = function (map) {
                return new Collections.UnmodifiableSortedMap(map);
            };
            Collections.unmodifiableSortedSet = function (set) {
                return new Collections.UnmodifiableSortedSet(set);
            };
            /**
             * Computes hash code without preserving elements order (e.g. HashSet).
             */
            Collections.hashCode$java_lang_Iterable = function (collection) {
                var hashCode = 0;
                for (var index175 = collection.iterator(); index175.hasNext();) {
                    var e = index175.next();
                    {
                        hashCode = hashCode + java.util.Objects.hashCode(e);
                        hashCode = javaemul.internal.Coercions.ensureInt(hashCode);
                    }
                }
                return hashCode;
            };
            /**
             * Computes hash code preserving collection order (e.g. ArrayList).
             */
            Collections.hashCode = function (list) {
                if (((list != null && list["__interfaces"] != null && list["__interfaces"].indexOf("java.util.List") >= 0) || list === null)) {
                    return (function () {
                        var hashCode = 1;
                        for (var index176 = list.iterator(); index176.hasNext();) {
                            var e = index176.next();
                            {
                                hashCode = 31 * hashCode + java.util.Objects.hashCode(e);
                                hashCode = javaemul.internal.Coercions.ensureInt(hashCode);
                            }
                        }
                        return hashCode;
                    })();
                }
                else if (((list != null && list["__interfaces"] != null && list["__interfaces"].indexOf("java.lang.Iterable") >= 0) || list === null)) {
                    return java.util.Collections.hashCode$java_lang_Iterable(list);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Replace contents of a list from an array.
             *
             * @param <T> element type
             * @param target list to replace contents from an array
             * @param x an Object array which can contain only T instances
             */
            Collections.replaceContents = function (target, x) {
                var size = target.size();
                for (var i = 0; i < size; i++) {
                    target.set(i, x[i]);
                }
            };
            Collections.swapImpl = function (list, i, j) {
                if (((list != null && list["__interfaces"] != null && list["__interfaces"].indexOf("java.util.List") >= 0) || list === null) && ((typeof i === 'number') || i === null) && ((typeof j === 'number') || j === null)) {
                    return (function () {
                        var t = list.get(i);
                        list.set(i, list.get(j));
                        list.set(j, t);
                    })();
                }
                else if (((list != null && list instanceof Array) || list === null) && ((typeof i === 'number') || i === null) && ((typeof j === 'number') || j === null)) {
                    return java.util.Collections.swapImpl$java_lang_Object_A$int$int(list, i, j);
                }
                else
                    throw new Error('invalid overload');
            };
            Collections.swapImpl$java_lang_Object_A$int$int = function (a, i, j) {
                var obj = a[i];
                a[i] = a[j];
                a[j] = obj;
            };
            return Collections;
        }());
        util.Collections = Collections;
        var Collections;
        (function (Collections) {
            var LifoQueue = (function (_super) {
                __extends(LifoQueue, _super);
                function LifoQueue(deque) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Collection", "java.util.Queue", "java.lang.Iterable", "java.io.Serializable"] });
                    this.deque = deque;
                }
                LifoQueue.prototype.iterator = function () {
                    return this.deque.iterator();
                };
                LifoQueue.prototype.offer = function (e) {
                    return this.deque.offerFirst(e);
                };
                LifoQueue.prototype.peek = function () {
                    return this.deque.peekFirst();
                };
                LifoQueue.prototype.poll = function () {
                    return this.deque.pollFirst();
                };
                LifoQueue.prototype.size = function () {
                    return this.deque.size();
                };
                return LifoQueue;
            }(java.util.AbstractQueue));
            Collections.LifoQueue = LifoQueue;
            var EmptyList = (function (_super) {
                __extends(EmptyList, _super);
                function EmptyList() {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.RandomAccess", "java.util.List", "java.util.Collection", "java.lang.Iterable", "java.io.Serializable"] });
                }
                EmptyList.prototype.contains = function (object) {
                    return false;
                };
                EmptyList.prototype.get = function (location) {
                    javaemul.internal.InternalPreconditions.checkElementIndex(location, 0);
                    return null;
                };
                EmptyList.prototype.iterator = function () {
                    return Collections.emptyIterator();
                };
                EmptyList.prototype.listIterator$ = function () {
                    return Collections.emptyListIterator();
                };
                EmptyList.prototype.size = function () {
                    return 0;
                };
                return EmptyList;
            }(java.util.AbstractList));
            Collections.EmptyList = EmptyList;
            var EmptyListIterator = (function () {
                function EmptyListIterator() {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Iterator", "java.util.ListIterator"] });
                }
                EmptyListIterator.prototype.forEachRemaining = function (consumer) {
                    javaemul.internal.InternalPreconditions.checkNotNull(consumer);
                    while ((this.hasNext())) {
                        consumer(this.next());
                    }
                    ;
                };
                EmptyListIterator.INSTANCE_$LI$ = function () { if (EmptyListIterator.INSTANCE == null)
                    EmptyListIterator.INSTANCE = new Collections.EmptyListIterator(); return EmptyListIterator.INSTANCE; };
                ;
                EmptyListIterator.prototype.add = function (o) {
                    throw new java.lang.UnsupportedOperationException();
                };
                EmptyListIterator.prototype.hasNext = function () {
                    return false;
                };
                EmptyListIterator.prototype.hasPrevious = function () {
                    return false;
                };
                EmptyListIterator.prototype.next = function () {
                    throw new java.util.NoSuchElementException();
                };
                EmptyListIterator.prototype.nextIndex = function () {
                    return 0;
                };
                EmptyListIterator.prototype.previous = function () {
                    throw new java.util.NoSuchElementException();
                };
                EmptyListIterator.prototype.previousIndex = function () {
                    return -1;
                };
                EmptyListIterator.prototype.remove = function () {
                    throw new java.lang.IllegalStateException();
                };
                EmptyListIterator.prototype.set = function (o) {
                    throw new java.lang.IllegalStateException();
                };
                return EmptyListIterator;
            }());
            Collections.EmptyListIterator = EmptyListIterator;
            var EmptySet = (function (_super) {
                __extends(EmptySet, _super);
                function EmptySet() {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Collection", "java.util.Set", "java.lang.Iterable", "java.io.Serializable"] });
                }
                EmptySet.prototype.contains = function (object) {
                    return false;
                };
                EmptySet.prototype.iterator = function () {
                    return Collections.emptyIterator();
                };
                EmptySet.prototype.size = function () {
                    return 0;
                };
                return EmptySet;
            }(java.util.AbstractSet));
            Collections.EmptySet = EmptySet;
            var EmptyMap = (function (_super) {
                __extends(EmptyMap, _super);
                function EmptyMap() {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Map", "java.io.Serializable"] });
                }
                EmptyMap.prototype.containsKey = function (key) {
                    return false;
                };
                EmptyMap.prototype.containsValue = function (value) {
                    return false;
                };
                EmptyMap.prototype.entrySet = function () {
                    return java.util.Collections.EMPTY_SET_$LI$();
                };
                EmptyMap.prototype.get = function (key) {
                    return null;
                };
                EmptyMap.prototype.keySet = function () {
                    return java.util.Collections.EMPTY_SET_$LI$();
                };
                EmptyMap.prototype.size = function () {
                    return 0;
                };
                EmptyMap.prototype.values = function () {
                    return java.util.Collections.EMPTY_LIST_$LI$();
                };
                return EmptyMap;
            }(java.util.AbstractMap));
            Collections.EmptyMap = EmptyMap;
            var ReverseComparator = (function () {
                function ReverseComparator() {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Comparator"] });
                }
                ReverseComparator.INSTANCE_$LI$ = function () { if (ReverseComparator.INSTANCE == null)
                    ReverseComparator.INSTANCE = new Collections.ReverseComparator(); return ReverseComparator.INSTANCE; };
                ;
                ReverseComparator.prototype.compare = function (o1, o2) {
                    if (((o1 != null && o1["__interfaces"] != null && o1["__interfaces"].indexOf("java.lang.Comparable") >= 0) || o1 === null) && ((o2 != null && o2["__interfaces"] != null && o2["__interfaces"].indexOf("java.lang.Comparable") >= 0) || o2 === null)) {
                        return (function () {
                            return o2.compareTo(o1);
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                };
                return ReverseComparator;
            }());
            Collections.ReverseComparator = ReverseComparator;
            var SetFromMap = (function (_super) {
                __extends(SetFromMap, _super);
                function SetFromMap(map) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Collection", "java.util.Set", "java.lang.Iterable", "java.io.Serializable"] });
                    this.backingMap = map;
                }
                SetFromMap.prototype.add = function (index, element) {
                    if (((index != null) || index === null) && element === undefined) {
                        return this.add$java_lang_Object(index);
                    }
                    else
                        throw new Error('invalid overload');
                };
                SetFromMap.prototype.add$java_lang_Object = function (e) {
                    return this.backingMap.put(e, javaemul.internal.BooleanHelper.TRUE) == null;
                };
                SetFromMap.prototype.clear = function () {
                    this.backingMap.clear();
                };
                SetFromMap.prototype.contains = function (o) {
                    return this.backingMap.containsKey(o);
                };
                SetFromMap.prototype.equals = function (o) {
                    return o === this || this.keySet().equals(o);
                };
                SetFromMap.prototype.hashCode = function () {
                    return this.keySet().hashCode();
                };
                SetFromMap.prototype.iterator = function () {
                    return this.keySet().iterator();
                };
                SetFromMap.prototype.remove = function (index) {
                    if (((index != null) || index === null)) {
                        return this.remove$java_lang_Object(index);
                    }
                    else
                        throw new Error('invalid overload');
                };
                SetFromMap.prototype.remove$java_lang_Object = function (o) {
                    return this.backingMap.remove(o) != null;
                };
                SetFromMap.prototype.size = function () {
                    return this.keySet().size();
                };
                SetFromMap.prototype.toString = function () {
                    return this.keySet().toString();
                };
                /**
                 * Lazy initialize keySet to avoid NPE after deserialization.
                 */
                SetFromMap.prototype.keySet = function () {
                    if (this.__keySet == null) {
                        this.__keySet = this.backingMap.keySet();
                    }
                    return this.__keySet;
                };
                return SetFromMap;
            }(java.util.AbstractSet));
            Collections.SetFromMap = SetFromMap;
            var SingletonList = (function (_super) {
                __extends(SingletonList, _super);
                function SingletonList(element) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.List", "java.util.Collection", "java.lang.Iterable", "java.io.Serializable"] });
                    this.element = element;
                }
                SingletonList.prototype.contains = function (item) {
                    return java.util.Objects.equals(this.element, item);
                };
                SingletonList.prototype.get = function (index) {
                    javaemul.internal.InternalPreconditions.checkElementIndex(index, 1);
                    return this.element;
                };
                SingletonList.prototype.size = function () {
                    return 1;
                };
                return SingletonList;
            }(java.util.AbstractList));
            Collections.SingletonList = SingletonList;
            var UnmodifiableCollection = (function () {
                function UnmodifiableCollection(coll) {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Collection", "java.lang.Iterable"] });
                    this.coll = coll;
                }
                UnmodifiableCollection.prototype.forEach = function (action) {
                    javaemul.internal.InternalPreconditions.checkNotNull(action);
                    for (var index177 = this.iterator(); index177.hasNext();) {
                        var t = index177.next();
                        {
                            action(t);
                        }
                    }
                };
                UnmodifiableCollection.prototype.add = function (index, element) {
                    if (((index != null) || index === null) && element === undefined) {
                        return this.add$java_lang_Object(index);
                    }
                    else
                        throw new Error('invalid overload');
                };
                UnmodifiableCollection.prototype.add$java_lang_Object = function (o) {
                    throw new java.lang.UnsupportedOperationException();
                };
                UnmodifiableCollection.prototype.addAll = function (index, c) {
                    if (((index != null && index["__interfaces"] != null && index["__interfaces"].indexOf("java.util.Collection") >= 0) || index === null) && c === undefined) {
                        return this.addAll$java_util_Collection(index);
                    }
                    else
                        throw new Error('invalid overload');
                };
                UnmodifiableCollection.prototype.addAll$java_util_Collection = function (c) {
                    throw new java.lang.UnsupportedOperationException();
                };
                UnmodifiableCollection.prototype.clear = function () {
                    throw new java.lang.UnsupportedOperationException();
                };
                UnmodifiableCollection.prototype.contains = function (o) {
                    return this.coll.contains(o);
                };
                UnmodifiableCollection.prototype.containsAll = function (c) {
                    return this.coll.containsAll(c);
                };
                UnmodifiableCollection.prototype.isEmpty = function () {
                    return this.coll.isEmpty();
                };
                UnmodifiableCollection.prototype.iterator = function () {
                    return new Collections.UnmodifiableCollectionIterator(this.coll.iterator());
                };
                UnmodifiableCollection.prototype.remove = function (index) {
                    if (((index != null) || index === null)) {
                        return this.remove$java_lang_Object(index);
                    }
                    else
                        throw new Error('invalid overload');
                };
                UnmodifiableCollection.prototype.remove$java_lang_Object = function (o) {
                    throw new java.lang.UnsupportedOperationException();
                };
                UnmodifiableCollection.prototype.removeAll = function (c) {
                    throw new java.lang.UnsupportedOperationException();
                };
                UnmodifiableCollection.prototype.retainAll = function (c) {
                    throw new java.lang.UnsupportedOperationException();
                };
                UnmodifiableCollection.prototype.size = function () {
                    return this.coll.size();
                };
                UnmodifiableCollection.prototype.toArray$ = function () {
                    return this.coll.toArray();
                };
                UnmodifiableCollection.prototype.toArray = function (a) {
                    var _this = this;
                    if (((a != null && a instanceof Array) || a === null)) {
                        return (function () {
                            return _this.coll.toArray(a);
                        })();
                    }
                    else if (a === undefined) {
                        return this.toArray$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                UnmodifiableCollection.prototype.toString = function () {
                    return this.coll.toString();
                };
                return UnmodifiableCollection;
            }());
            Collections.UnmodifiableCollection = UnmodifiableCollection;
            var UnmodifiableList = (function (_super) {
                __extends(UnmodifiableList, _super);
                function UnmodifiableList(list) {
                    _super.call(this, list);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.List", "java.util.Collection", "java.lang.Iterable"] });
                    this.list = list;
                }
                UnmodifiableList.prototype.forEach = function (action) {
                    javaemul.internal.InternalPreconditions.checkNotNull(action);
                    for (var index178 = this.iterator(); index178.hasNext();) {
                        var t = index178.next();
                        {
                            action(t);
                        }
                    }
                };
                UnmodifiableList.prototype.add = function (index, element) {
                    if (((typeof index === 'number') || index === null) && ((element != null) || element === null)) {
                        return (function () {
                            throw new java.lang.UnsupportedOperationException();
                        })();
                    }
                    else if (((index != null) || index === null) && element === undefined) {
                        return this.add$java_lang_Object(index);
                    }
                    else
                        throw new Error('invalid overload');
                };
                UnmodifiableList.prototype.addAll = function (index, c) {
                    if (((typeof index === 'number') || index === null) && ((c != null && c["__interfaces"] != null && c["__interfaces"].indexOf("java.util.Collection") >= 0) || c === null)) {
                        return (function () {
                            throw new java.lang.UnsupportedOperationException();
                        })();
                    }
                    else if (((index != null && index["__interfaces"] != null && index["__interfaces"].indexOf("java.util.Collection") >= 0) || index === null) && c === undefined) {
                        return this.addAll$java_util_Collection(index);
                    }
                    else
                        throw new Error('invalid overload');
                };
                UnmodifiableList.prototype.equals = function (o) {
                    return this.list.equals(o);
                };
                UnmodifiableList.prototype.get = function (index) {
                    return this.list.get(index);
                };
                UnmodifiableList.prototype.hashCode = function () {
                    return this.list.hashCode();
                };
                UnmodifiableList.prototype.indexOf = function (o, index) {
                    if (((o != null) || o === null) && index === undefined) {
                        return this.indexOf$java_lang_Object(o);
                    }
                    else
                        throw new Error('invalid overload');
                };
                UnmodifiableList.prototype.indexOf$java_lang_Object = function (o) {
                    return this.list.indexOf(o);
                };
                UnmodifiableList.prototype.isEmpty = function () {
                    return this.list.isEmpty();
                };
                UnmodifiableList.prototype.lastIndexOf = function (o, index) {
                    if (((o != null) || o === null) && index === undefined) {
                        return this.lastIndexOf$java_lang_Object(o);
                    }
                    else
                        throw new Error('invalid overload');
                };
                UnmodifiableList.prototype.lastIndexOf$java_lang_Object = function (o) {
                    return this.list.lastIndexOf(o);
                };
                UnmodifiableList.prototype.listIterator$ = function () {
                    return this.listIterator(0);
                };
                UnmodifiableList.prototype.listIterator = function (from) {
                    var _this = this;
                    if (((typeof from === 'number') || from === null)) {
                        return (function () {
                            return new Collections.UnmodifiableListIterator(_this.list.listIterator(from));
                        })();
                    }
                    else if (from === undefined) {
                        return this.listIterator$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                UnmodifiableList.prototype.remove = function (index) {
                    if (((typeof index === 'number') || index === null)) {
                        return (function () {
                            throw new java.lang.UnsupportedOperationException();
                        })();
                    }
                    else if (((index != null) || index === null)) {
                        return this.remove$java_lang_Object(index);
                    }
                    else
                        throw new Error('invalid overload');
                };
                UnmodifiableList.prototype.set = function (index, element) {
                    throw new java.lang.UnsupportedOperationException();
                };
                UnmodifiableList.prototype.subList = function (fromIndex, toIndex) {
                    return new Collections.UnmodifiableList(this.list.subList(fromIndex, toIndex));
                };
                return UnmodifiableList;
            }(Collections.UnmodifiableCollection));
            Collections.UnmodifiableList = UnmodifiableList;
            var UnmodifiableRandomAccessList = (function (_super) {
                __extends(UnmodifiableRandomAccessList, _super);
                function UnmodifiableRandomAccessList(list) {
                    _super.call(this, list);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.RandomAccess", "java.util.List", "java.util.Collection", "java.lang.Iterable"] });
                }
                return UnmodifiableRandomAccessList;
            }(Collections.UnmodifiableList));
            Collections.UnmodifiableRandomAccessList = UnmodifiableRandomAccessList;
            var UnmodifiableSet = (function (_super) {
                __extends(UnmodifiableSet, _super);
                function UnmodifiableSet(set) {
                    _super.call(this, set);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Collection", "java.util.Set", "java.lang.Iterable"] });
                }
                UnmodifiableSet.prototype.forEach = function (action) {
                    javaemul.internal.InternalPreconditions.checkNotNull(action);
                    for (var index179 = this.iterator(); index179.hasNext();) {
                        var t = index179.next();
                        {
                            action(t);
                        }
                    }
                };
                UnmodifiableSet.prototype.equals = function (o) {
                    return this.coll.equals(o);
                };
                UnmodifiableSet.prototype.hashCode = function () {
                    return this.coll.hashCode();
                };
                return UnmodifiableSet;
            }(Collections.UnmodifiableCollection));
            Collections.UnmodifiableSet = UnmodifiableSet;
            var UnmodifiableMap = (function () {
                function UnmodifiableMap(map) {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Map"] });
                    this.map = map;
                }
                UnmodifiableMap.prototype.clear = function () {
                    throw new java.lang.UnsupportedOperationException();
                };
                UnmodifiableMap.prototype.containsKey = function (key) {
                    return this.map.containsKey(key);
                };
                UnmodifiableMap.prototype.containsValue = function (val) {
                    return this.map.containsValue(val);
                };
                UnmodifiableMap.prototype.entrySet = function () {
                    if (this.__entrySet == null) {
                        this.__entrySet = new UnmodifiableMap.UnmodifiableEntrySet(this.map.entrySet());
                    }
                    return this.__entrySet;
                };
                UnmodifiableMap.prototype.equals = function (o) {
                    return this.map.equals(o);
                };
                UnmodifiableMap.prototype.get = function (key) {
                    return this.map.get(key);
                };
                UnmodifiableMap.prototype.hashCode = function () {
                    return this.map.hashCode();
                };
                UnmodifiableMap.prototype.isEmpty = function () {
                    return this.map.isEmpty();
                };
                UnmodifiableMap.prototype.keySet = function () {
                    if (this.__keySet == null) {
                        this.__keySet = new Collections.UnmodifiableSet(this.map.keySet());
                    }
                    return this.__keySet;
                };
                UnmodifiableMap.prototype.put = function (key, value) {
                    throw new java.lang.UnsupportedOperationException();
                };
                UnmodifiableMap.prototype.putAll = function (t) {
                    throw new java.lang.UnsupportedOperationException();
                };
                UnmodifiableMap.prototype.remove = function (key) {
                    throw new java.lang.UnsupportedOperationException();
                };
                UnmodifiableMap.prototype.size = function () {
                    return this.map.size();
                };
                UnmodifiableMap.prototype.toString = function () {
                    return this.map.toString();
                };
                UnmodifiableMap.prototype.values = function () {
                    if (this.__values == null) {
                        this.__values = new Collections.UnmodifiableCollection(this.map.values());
                    }
                    return this.__values;
                };
                return UnmodifiableMap;
            }());
            Collections.UnmodifiableMap = UnmodifiableMap;
            var UnmodifiableMap;
            (function (UnmodifiableMap) {
                var UnmodifiableEntrySet = (function (_super) {
                    __extends(UnmodifiableEntrySet, _super);
                    function UnmodifiableEntrySet(s) {
                        _super.call(this, s);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Collection", "java.util.Set", "java.lang.Iterable"] });
                    }
                    UnmodifiableEntrySet.prototype.contains = function (o) {
                        return this.coll.contains(o);
                    };
                    UnmodifiableEntrySet.prototype.containsAll = function (o) {
                        return this.coll.containsAll(o);
                    };
                    UnmodifiableEntrySet.prototype.iterator = function () {
                        var it = this.coll.iterator();
                        return new UnmodifiableEntrySet.UnmodifiableEntrySet$0(this, it);
                    };
                    UnmodifiableEntrySet.prototype.toArray$ = function () {
                        var array = _super.prototype.toArray.call(this);
                        this.wrap(array, array.length);
                        return array;
                    };
                    UnmodifiableEntrySet.prototype.toArray = function (a) {
                        var _this = this;
                        if (((a != null && a instanceof Array) || a === null)) {
                            return (function () {
                                var result = _super.prototype.toArray.call(_this, a);
                                _this.wrap(result, _this.coll.size());
                                return result;
                            })();
                        }
                        else if (a === undefined) {
                            return this.toArray$();
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * Wrap an array of Map.Entries as UnmodifiableEntries.
                     *
                     * @param array array to wrap
                     * @param size number of entries to wrap
                     */
                    UnmodifiableEntrySet.prototype.wrap = function (array, size) {
                        for (var i = 0; i < size; ++i) {
                            array[i] = new UnmodifiableEntrySet.UnmodifiableEntry(array[i]);
                        }
                    };
                    return UnmodifiableEntrySet;
                }(Collections.UnmodifiableSet));
                UnmodifiableMap.UnmodifiableEntrySet = UnmodifiableEntrySet;
                var UnmodifiableEntrySet;
                (function (UnmodifiableEntrySet) {
                    var UnmodifiableEntry = (function () {
                        function UnmodifiableEntry(entry) {
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Map.Entry"] });
                            this.entry = entry;
                        }
                        UnmodifiableEntry.prototype.equals = function (o) {
                            return this.entry.equals(o);
                        };
                        UnmodifiableEntry.prototype.getKey = function () {
                            return this.entry.getKey();
                        };
                        UnmodifiableEntry.prototype.getValue = function () {
                            return this.entry.getValue();
                        };
                        UnmodifiableEntry.prototype.hashCode = function () {
                            return this.entry.hashCode();
                        };
                        UnmodifiableEntry.prototype.setValue = function (value) {
                            throw new java.lang.UnsupportedOperationException();
                        };
                        UnmodifiableEntry.prototype.toString = function () {
                            return this.entry.toString();
                        };
                        return UnmodifiableEntry;
                    }());
                    UnmodifiableEntrySet.UnmodifiableEntry = UnmodifiableEntry;
                    var UnmodifiableEntrySet$0 = (function () {
                        function UnmodifiableEntrySet$0(__parent, it) {
                            this.it = it;
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Iterator"] });
                            this.__parent = __parent;
                        }
                        UnmodifiableEntrySet$0.prototype.forEachRemaining = function (consumer) {
                            javaemul.internal.InternalPreconditions.checkNotNull(consumer);
                            while ((this.hasNext())) {
                                consumer(this.next());
                            }
                            ;
                        };
                        UnmodifiableEntrySet$0.prototype.hasNext = function () {
                            return this.it.hasNext();
                        };
                        UnmodifiableEntrySet$0.prototype.next = function () {
                            return new UnmodifiableEntrySet.UnmodifiableEntry(this.it.next());
                        };
                        UnmodifiableEntrySet$0.prototype.remove = function () {
                            throw new java.lang.UnsupportedOperationException();
                        };
                        return UnmodifiableEntrySet$0;
                    }());
                    UnmodifiableEntrySet.UnmodifiableEntrySet$0 = UnmodifiableEntrySet$0;
                })(UnmodifiableEntrySet = UnmodifiableMap.UnmodifiableEntrySet || (UnmodifiableMap.UnmodifiableEntrySet = {}));
            })(UnmodifiableMap = Collections.UnmodifiableMap || (Collections.UnmodifiableMap = {}));
            var UnmodifiableSortedMap = (function (_super) {
                __extends(UnmodifiableSortedMap, _super);
                function UnmodifiableSortedMap(sortedMap) {
                    _super.call(this, sortedMap);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Map", "java.util.SortedMap"] });
                    this.sortedMap = sortedMap;
                }
                UnmodifiableSortedMap.prototype.comparator = function () {
                    return this.sortedMap.comparator();
                };
                UnmodifiableSortedMap.prototype.equals = function (o) {
                    return this.sortedMap.equals(o);
                };
                UnmodifiableSortedMap.prototype.firstKey = function () {
                    return this.sortedMap.firstKey();
                };
                UnmodifiableSortedMap.prototype.hashCode = function () {
                    return this.sortedMap.hashCode();
                };
                UnmodifiableSortedMap.prototype.headMap = function (toKey, inclusive) {
                    if (((toKey != null) || toKey === null) && inclusive === undefined) {
                        return this.headMap$java_lang_Object(toKey);
                    }
                    else
                        throw new Error('invalid overload');
                };
                UnmodifiableSortedMap.prototype.headMap$java_lang_Object = function (toKey) {
                    return new Collections.UnmodifiableSortedMap(this.sortedMap.headMap(toKey));
                };
                UnmodifiableSortedMap.prototype.lastKey = function () {
                    return this.sortedMap.lastKey();
                };
                UnmodifiableSortedMap.prototype.subMap = function (fromKey, fromInclusive, toKey, toInclusive) {
                    if (((fromKey != null) || fromKey === null) && ((fromInclusive != null) || fromInclusive === null) && toKey === undefined && toInclusive === undefined) {
                        return this.subMap$java_lang_Object$java_lang_Object(fromKey, fromInclusive);
                    }
                    else
                        throw new Error('invalid overload');
                };
                UnmodifiableSortedMap.prototype.subMap$java_lang_Object$java_lang_Object = function (fromKey, toKey) {
                    return new Collections.UnmodifiableSortedMap(this.sortedMap.subMap(fromKey, toKey));
                };
                UnmodifiableSortedMap.prototype.tailMap = function (fromKey, inclusive) {
                    if (((fromKey != null) || fromKey === null) && inclusive === undefined) {
                        return this.tailMap$java_lang_Object(fromKey);
                    }
                    else
                        throw new Error('invalid overload');
                };
                UnmodifiableSortedMap.prototype.tailMap$java_lang_Object = function (fromKey) {
                    return new Collections.UnmodifiableSortedMap(this.sortedMap.tailMap(fromKey));
                };
                return UnmodifiableSortedMap;
            }(Collections.UnmodifiableMap));
            Collections.UnmodifiableSortedMap = UnmodifiableSortedMap;
            var UnmodifiableSortedSet = (function (_super) {
                __extends(UnmodifiableSortedSet, _super);
                function UnmodifiableSortedSet(sortedSet) {
                    _super.call(this, sortedSet);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.SortedSet", "java.util.Collection", "java.util.Set", "java.lang.Iterable"] });
                    this.sortedSet = sortedSet;
                }
                UnmodifiableSortedSet.prototype.forEach = function (action) {
                    javaemul.internal.InternalPreconditions.checkNotNull(action);
                    for (var index180 = this.iterator(); index180.hasNext();) {
                        var t = index180.next();
                        {
                            action(t);
                        }
                    }
                };
                UnmodifiableSortedSet.prototype.comparator = function () {
                    return this.sortedSet.comparator();
                };
                UnmodifiableSortedSet.prototype.equals = function (o) {
                    return this.sortedSet.equals(o);
                };
                UnmodifiableSortedSet.prototype.first = function () {
                    return this.sortedSet.first();
                };
                UnmodifiableSortedSet.prototype.hashCode = function () {
                    return this.sortedSet.hashCode();
                };
                UnmodifiableSortedSet.prototype.headSet = function (toElement, inclusive) {
                    if (((toElement != null) || toElement === null) && inclusive === undefined) {
                        return this.headSet$java_lang_Object(toElement);
                    }
                    else
                        throw new Error('invalid overload');
                };
                UnmodifiableSortedSet.prototype.headSet$java_lang_Object = function (toElement) {
                    return new Collections.UnmodifiableSortedSet(this.sortedSet.headSet(toElement));
                };
                UnmodifiableSortedSet.prototype.last = function () {
                    return this.sortedSet.last();
                };
                UnmodifiableSortedSet.prototype.subSet = function (fromElement, fromInclusive, toElement, toInclusive) {
                    if (((fromElement != null) || fromElement === null) && ((fromInclusive != null) || fromInclusive === null) && toElement === undefined && toInclusive === undefined) {
                        return this.subSet$java_lang_Object$java_lang_Object(fromElement, fromInclusive);
                    }
                    else
                        throw new Error('invalid overload');
                };
                UnmodifiableSortedSet.prototype.subSet$java_lang_Object$java_lang_Object = function (fromElement, toElement) {
                    return new Collections.UnmodifiableSortedSet(this.sortedSet.subSet(fromElement, toElement));
                };
                UnmodifiableSortedSet.prototype.tailSet = function (fromElement, inclusive) {
                    if (((fromElement != null) || fromElement === null) && inclusive === undefined) {
                        return this.tailSet$java_lang_Object(fromElement);
                    }
                    else
                        throw new Error('invalid overload');
                };
                UnmodifiableSortedSet.prototype.tailSet$java_lang_Object = function (fromElement) {
                    return new Collections.UnmodifiableSortedSet(this.sortedSet.tailSet(fromElement));
                };
                return UnmodifiableSortedSet;
            }(Collections.UnmodifiableSet));
            Collections.UnmodifiableSortedSet = UnmodifiableSortedSet;
            var UnmodifiableCollectionIterator = (function () {
                function UnmodifiableCollectionIterator(it) {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Iterator"] });
                    this.it = it;
                }
                UnmodifiableCollectionIterator.prototype.forEachRemaining = function (consumer) {
                    javaemul.internal.InternalPreconditions.checkNotNull(consumer);
                    while ((this.hasNext())) {
                        consumer(this.next());
                    }
                    ;
                };
                UnmodifiableCollectionIterator.prototype.hasNext = function () {
                    return this.it.hasNext();
                };
                UnmodifiableCollectionIterator.prototype.next = function () {
                    return this.it.next();
                };
                UnmodifiableCollectionIterator.prototype.remove = function () {
                    throw new java.lang.UnsupportedOperationException();
                };
                return UnmodifiableCollectionIterator;
            }());
            Collections.UnmodifiableCollectionIterator = UnmodifiableCollectionIterator;
            var UnmodifiableListIterator = (function (_super) {
                __extends(UnmodifiableListIterator, _super);
                function UnmodifiableListIterator(lit) {
                    _super.call(this, lit);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Iterator", "java.util.ListIterator"] });
                    this.lit = lit;
                }
                UnmodifiableListIterator.prototype.forEachRemaining = function (consumer) {
                    javaemul.internal.InternalPreconditions.checkNotNull(consumer);
                    while ((this.hasNext())) {
                        consumer(this.next());
                    }
                    ;
                };
                UnmodifiableListIterator.prototype.add = function (o) {
                    throw new java.lang.UnsupportedOperationException();
                };
                UnmodifiableListIterator.prototype.hasPrevious = function () {
                    return this.lit.hasPrevious();
                };
                UnmodifiableListIterator.prototype.nextIndex = function () {
                    return this.lit.nextIndex();
                };
                UnmodifiableListIterator.prototype.previous = function () {
                    return this.lit.previous();
                };
                UnmodifiableListIterator.prototype.previousIndex = function () {
                    return this.lit.previousIndex();
                };
                UnmodifiableListIterator.prototype.set = function (o) {
                    throw new java.lang.UnsupportedOperationException();
                };
                return UnmodifiableListIterator;
            }(Collections.UnmodifiableCollectionIterator));
            Collections.UnmodifiableListIterator = UnmodifiableListIterator;
            var RandomHolder = (function () {
                function RandomHolder() {
                }
                RandomHolder.rnd_$LI$ = function () { if (RandomHolder.rnd == null)
                    RandomHolder.rnd = new java.util.Random(); return RandomHolder.rnd; };
                ;
                return RandomHolder;
            }());
            Collections.RandomHolder = RandomHolder;
            var Collections$0 = (function () {
                function Collections$0(it) {
                    this.it = it;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Enumeration"] });
                }
                Collections$0.prototype.hasMoreElements = function () {
                    return this.it.hasNext();
                };
                Collections$0.prototype.nextElement = function () {
                    return this.it.next();
                };
                return Collections$0;
            }());
            Collections.Collections$0 = Collections$0;
            var Collections$1 = (function () {
                function Collections$1(cmp) {
                    this.cmp = cmp;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Comparator"] });
                }
                Collections$1.prototype.compare = function (t1, t2) {
                    return this.cmp.compare(t2, t1);
                };
                return Collections$1;
            }());
            Collections.Collections$1 = Collections$1;
        })(Collections = util.Collections || (util.Collections = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * A {@link java.util.Map} of {@link Enum}s. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/EnumMap.html">[Sun
         * docs]</a>
         *
         * @param <K> key type
         * @param <V> value type
         */
        var EnumMap = (function (_super) {
            __extends(EnumMap, _super);
            function EnumMap(type) {
                var _this = this;
                if (((type != null && type instanceof java.lang.Class) || type === null)) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Map"] });
                    (function () {
                        _this.init(type);
                    })();
                }
                else if (((type != null && type instanceof java.util.EnumMap) || type === null)) {
                    var m = type;
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Map"] });
                    (function () {
                        _this.init(m);
                    })();
                }
                else if (((type != null && type["__interfaces"] != null && type["__interfaces"].indexOf("java.util.Map") >= 0) || type === null)) {
                    var m = type;
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Map"] });
                    (function () {
                        if (m != null && m instanceof java.util.EnumMap) {
                            _this.init(m);
                        }
                        else {
                            javaemul.internal.InternalPreconditions.checkArgument(!m.isEmpty(), "Specified map is empty");
                            _this.init(m.keySet().iterator().next().getDeclaringClass());
                            _this.putAll(m);
                        }
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            EnumMap.prototype.clear = function () {
                this.__keySet.clear();
                this.__values = new Array(this.__values.length);
            };
            EnumMap.prototype.clone = function () {
                return new EnumMap(this);
            };
            EnumMap.prototype.containsKey = function (key) {
                return this.__keySet.contains(key);
            };
            EnumMap.prototype.containsValue = function (value) {
                for (var index181 = this.__keySet.iterator(); index181.hasNext();) {
                    var key = index181.next();
                    {
                        if (java.util.Objects.equals(value, this.__values[key.ordinal()])) {
                            return true;
                        }
                    }
                }
                return false;
            };
            EnumMap.prototype.entrySet = function () {
                return new EnumMap.EntrySet(this);
            };
            EnumMap.prototype.get = function (k) {
                return this.__keySet.contains(k) ? this.__values[this.asOrdinal(k)] : null;
            };
            EnumMap.prototype.put = function (key, value) {
                var _this = this;
                if (((key != null) || key === null) && ((value != null) || value === null)) {
                    return (function () {
                        _this.__keySet.add(key);
                        return _this.set(key.ordinal(), value);
                    })();
                }
                else if (((key != null) || key === null) && ((value != null) || value === null)) {
                    return this.put$java_lang_Object$java_lang_Object(key, value);
                }
                else
                    throw new Error('invalid overload');
            };
            EnumMap.prototype.remove = function (key) {
                return this.__keySet.remove(key) ? this.set(this.asOrdinal(key), null) : null;
            };
            EnumMap.prototype.size = function () {
                return this.__keySet.size();
            };
            /**
             * Returns <code>key</code> as <code>K</code>. Only runtime checks that
             * key is an Enum, not that it's the particular Enum K. Should only be called
             * when you are sure <code>key</code> is of type <code>K</code>.
             */
            EnumMap.prototype.asKey = function (key) {
                return key;
            };
            EnumMap.prototype.asOrdinal = function (key) {
                return this.asKey(key).ordinal();
            };
            EnumMap.prototype.init = function (type) {
                var _this = this;
                if (((type != null && type instanceof java.lang.Class) || type === null)) {
                    return (function () {
                        _this.__keySet = java.util.EnumSet.noneOf(type);
                        _this.__values = new Array(_this.__keySet.capacity());
                    })();
                }
                else if (((type != null && type instanceof java.util.EnumMap) || type === null)) {
                    return this.init$java_util_EnumMap(type);
                }
                else
                    throw new Error('invalid overload');
            };
            EnumMap.prototype.init$java_util_EnumMap = function (m) {
                this.__keySet = m.__keySet.clone();
                this.__values = javaemul.internal.ArrayHelper.clone(m.__values, 0, m.__values.length);
            };
            EnumMap.prototype.set = function (ordinal, value) {
                var was = this.__values[ordinal];
                this.__values[ordinal] = value;
                return was;
            };
            return EnumMap;
        }(java.util.AbstractMap));
        util.EnumMap = EnumMap;
        var EnumMap;
        (function (EnumMap) {
            var EntrySet = (function (_super) {
                __extends(EntrySet, _super);
                function EntrySet(__parent) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Collection", "java.util.Set", "java.lang.Iterable"] });
                    this.__parent = __parent;
                }
                EntrySet.prototype.clear = function () {
                    this.__parent.clear();
                };
                EntrySet.prototype.contains = function (o) {
                    if (o != null && o["__interfaces"] != null && o["__interfaces"].indexOf("java.util.Map.Entry") >= 0) {
                        return this.__parent.containsEntry(o);
                    }
                    return false;
                };
                EntrySet.prototype.iterator = function () {
                    return new EnumMap.EntrySetIterator(this.__parent);
                };
                EntrySet.prototype.remove = function (index) {
                    if (((index != null) || index === null)) {
                        return this.remove$java_lang_Object(index);
                    }
                    else
                        throw new Error('invalid overload');
                };
                EntrySet.prototype.remove$java_lang_Object = function (entry) {
                    if (this.contains(entry)) {
                        var key = entry.getKey();
                        this.__parent.remove(key);
                        return true;
                    }
                    return false;
                };
                EntrySet.prototype.size = function () {
                    return this.__parent.size();
                };
                return EntrySet;
            }(java.util.AbstractSet));
            EnumMap.EntrySet = EntrySet;
            var EntrySetIterator = (function () {
                function EntrySetIterator(__parent) {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Iterator"] });
                    this.__parent = __parent;
                    this.it = this.__parent.__keySet.iterator();
                }
                EntrySetIterator.prototype.forEachRemaining = function (consumer) {
                    javaemul.internal.InternalPreconditions.checkNotNull(consumer);
                    while ((this.hasNext())) {
                        consumer(this.next());
                    }
                    ;
                };
                EntrySetIterator.prototype.hasNext = function () {
                    return this.it.hasNext();
                };
                EntrySetIterator.prototype.next = function () {
                    this.key = this.it.next();
                    return new EnumMap.MapEntry(this.__parent, this.key);
                };
                EntrySetIterator.prototype.remove = function () {
                    javaemul.internal.InternalPreconditions.checkState(this.key != null);
                    this.__parent.remove(this.key);
                    this.key = null;
                };
                return EntrySetIterator;
            }());
            EnumMap.EntrySetIterator = EntrySetIterator;
            var MapEntry = (function (_super) {
                __extends(MapEntry, _super);
                function MapEntry(__parent, key) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Map.Entry"] });
                    this.__parent = __parent;
                    this.key = key;
                }
                MapEntry.prototype.getKey = function () {
                    return this.key;
                };
                MapEntry.prototype.getValue = function () {
                    return this.__parent.__values[this.key.ordinal()];
                };
                MapEntry.prototype.setValue = function (value) {
                    return this.__parent.set(this.key.ordinal(), value);
                };
                return MapEntry;
            }(java.util.AbstractMapEntry));
            EnumMap.MapEntry = MapEntry;
        })(EnumMap = util.EnumMap || (util.EnumMap = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * Hash table and linked-list implementation of the Set interface with
         * predictable iteration order. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/LinkedHashSet.html">[Sun
         * docs]</a>
         *
         * @param <E> element type.
         */
        var LinkedHashSet = (function (_super) {
            __extends(LinkedHashSet, _super);
            function LinkedHashSet(ignored, alsoIgnored) {
                var _this = this;
                if (((typeof ignored === 'number') || ignored === null) && ((typeof alsoIgnored === 'number') || alsoIgnored === null)) {
                    _super.call(this, new java.util.LinkedHashMap(ignored, alsoIgnored));
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.util.Collection", "java.util.Set", "java.lang.Iterable", "java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (((ignored != null && ignored["__interfaces"] != null && ignored["__interfaces"].indexOf("java.util.Collection") >= 0) || ignored === null) && alsoIgnored === undefined) {
                    var c = ignored;
                    _super.call(this, new java.util.LinkedHashMap());
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.util.Collection", "java.util.Set", "java.lang.Iterable", "java.io.Serializable"] });
                    (function () {
                        _this.addAll(c);
                    })();
                }
                else if (((typeof ignored === 'number') || ignored === null) && alsoIgnored === undefined) {
                    _super.call(this, new java.util.LinkedHashMap(ignored));
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.util.Collection", "java.util.Set", "java.lang.Iterable", "java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (ignored === undefined && alsoIgnored === undefined) {
                    _super.call(this, new java.util.LinkedHashMap());
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.util.Collection", "java.util.Set", "java.lang.Iterable", "java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            LinkedHashSet.prototype.forEach = function (action) {
                javaemul.internal.InternalPreconditions.checkNotNull(action);
                for (var index182 = this.iterator(); index182.hasNext();) {
                    var t = index182.next();
                    {
                        action(t);
                    }
                }
            };
            LinkedHashSet.prototype.clone = function () {
                return new LinkedHashSet(this);
            };
            return LinkedHashSet;
        }(java.util.HashSet));
        util.LinkedHashSet = LinkedHashSet;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var io;
    (function (io) {
        /**
         * JSweet implementation for file.
         */
        var File = (function () {
            function File(parent, child, direct) {
                var _this = this;
                this.status = null;
                if (((parent != null && parent instanceof java.io.File) || parent === null) && ((typeof child === 'string') || child === null) && ((typeof direct === 'boolean') || direct === null)) {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Comparable", "java.io.Serializable"] });
                    this.prefixLength = 0;
                    (function () {
                        _this.path = File.fs_$LI$().resolve(parent.path, child);
                        _this.prefixLength = parent.prefixLength;
                    })();
                }
                else if (((typeof parent === 'string') || parent === null) && ((typeof child === 'string') || child === null) && direct === undefined) {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Comparable", "java.io.Serializable"] });
                    this.prefixLength = 0;
                    (function () {
                        if (child == null) {
                            throw new java.lang.NullPointerException();
                        }
                        if (parent != null) {
                            if ((parent === "")) {
                                _this.path = File.fs_$LI$().resolve(File.fs_$LI$().getDefaultParent(), File.fs_$LI$().normalize(child));
                            }
                            else {
                                _this.path = File.fs_$LI$().resolve(File.fs_$LI$().normalize(parent), File.fs_$LI$().normalize(child));
                            }
                        }
                        else {
                            _this.path = File.fs_$LI$().normalize(child);
                        }
                        _this.prefixLength = File.fs_$LI$().prefixLength(_this.path);
                    })();
                }
                else if (((parent != null && parent instanceof java.io.File) || parent === null) && ((typeof child === 'string') || child === null) && direct === undefined) {
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Comparable", "java.io.Serializable"] });
                    this.prefixLength = 0;
                    (function () {
                        if (child == null) {
                            throw new java.lang.NullPointerException();
                        }
                        if (parent != null) {
                            if ((parent.path === "")) {
                                _this.path = File.fs_$LI$().resolve(File.fs_$LI$().getDefaultParent(), File.fs_$LI$().normalize(child));
                            }
                            else {
                                _this.path = File.fs_$LI$().resolve(parent.path, File.fs_$LI$().normalize(child));
                            }
                        }
                        else {
                            _this.path = File.fs_$LI$().normalize(child);
                        }
                        _this.prefixLength = File.fs_$LI$().prefixLength(_this.path);
                    })();
                }
                else if (((typeof parent === 'string') || parent === null) && ((typeof child === 'number') || child === null) && direct === undefined) {
                    var pathname = parent;
                    var prefixLength = child;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Comparable", "java.io.Serializable"] });
                    this.prefixLength = 0;
                    (function () {
                        _this.path = pathname;
                        _this.prefixLength = prefixLength;
                    })();
                }
                else if (((typeof parent === 'string') || parent === null) && child === undefined && direct === undefined) {
                    var pathname = parent;
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Comparable", "java.io.Serializable"] });
                    this.prefixLength = 0;
                    (function () {
                        if (pathname == null) {
                            throw new java.lang.NullPointerException();
                        }
                        _this.path = File.fs_$LI$().normalize(pathname);
                        _this.prefixLength = File.fs_$LI$().prefixLength(_this.path);
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            File.fs_$LI$ = function () { if (File.fs == null)
                File.fs = new java.io.LocalStorageFileSystem(); return File.fs; };
            ;
            File.prototype.isInvalid = function () {
                if (this.status == null) {
                    this.status = (this.path.indexOf('\u0000') < 0) ? File.PathStatus.CHECKED : File.PathStatus.INVALID;
                }
                return this.status === File.PathStatus.INVALID;
            };
            File.prototype.getPrefixLength = function () {
                return this.prefixLength;
            };
            File.separatorChar_$LI$ = function () { if (File.separatorChar == null)
                File.separatorChar = File.fs_$LI$().getSeparator(); return File.separatorChar; };
            ;
            File.separator_$LI$ = function () { if (File.separator == null)
                File.separator = "" + File.separatorChar_$LI$(); return File.separator; };
            ;
            File.pathSeparatorChar_$LI$ = function () { if (File.pathSeparatorChar == null)
                File.pathSeparatorChar = File.fs_$LI$().getPathSeparator(); return File.pathSeparatorChar; };
            ;
            File.pathSeparator_$LI$ = function () { if (File.pathSeparator == null)
                File.pathSeparator = "" + File.pathSeparatorChar_$LI$(); return File.pathSeparator; };
            ;
            File.prototype.getName = function () {
                var index = this.path.lastIndexOf(File.separatorChar_$LI$());
                if (index < this.prefixLength)
                    return this.path.substring(this.prefixLength);
                return this.path.substring(index + 1);
            };
            File.prototype.getParent = function () {
                var index = this.path.lastIndexOf(File.separatorChar_$LI$());
                if (index < this.prefixLength) {
                    if ((this.prefixLength > 0) && (this.path.length > this.prefixLength))
                        return this.path.substring(0, this.prefixLength);
                    return null;
                }
                return this.path.substring(0, index);
            };
            File.prototype.getParentFile = function () {
                var p = this.getParent();
                if (p == null)
                    return null;
                return new File(p, this.prefixLength);
            };
            File.prototype.getPath = function () {
                return this.path;
            };
            File.prototype.isAbsolute = function () {
                return File.fs_$LI$().isAbsolute(this);
            };
            File.prototype.getAbsolutePath = function () {
                return File.fs_$LI$().resolve(this);
            };
            File.prototype.getAbsoluteFile = function () {
                var absPath = this.getAbsolutePath();
                return new File(absPath, File.fs_$LI$().prefixLength(absPath));
            };
            File.prototype.getCanonicalPath = function () {
                if (this.isInvalid()) {
                    throw new java.io.IOException("Invalid file path");
                }
                return File.fs_$LI$().canonicalize(File.fs_$LI$().resolve(this));
            };
            File.prototype.getCanonicalFile = function () {
                var canonPath = this.getCanonicalPath();
                return new File(canonPath, File.fs_$LI$().prefixLength(canonPath));
            };
            File.slashify = function (path, isDirectory) {
                var p = path;
                if (File.separatorChar_$LI$() !== '/')
                    p = p.split(File.separatorChar_$LI$()).join('/');
                if (!(function (str, searchString, position) {
                    if (position === void 0) { position = 0; }
                    return str.substr(position, searchString.length) === searchString;
                })(p, "/"))
                    p = "/" + p;
                if (!(function (str, searchString) { var pos = str.length - searchString.length; var lastIndex = str.indexOf(searchString, pos); return lastIndex !== -1 && lastIndex === pos; })(p, "/") && isDirectory)
                    p = p + "/";
                return p;
            };
            File.prototype.canRead = function () {
                if (this.isInvalid()) {
                    return false;
                }
                return File.fs_$LI$().checkAccess(this, java.io.FileSystem.ACCESS_READ);
            };
            File.prototype.canWrite = function () {
                if (this.isInvalid()) {
                    return false;
                }
                return File.fs_$LI$().checkAccess(this, java.io.FileSystem.ACCESS_WRITE);
            };
            File.prototype.exists = function () {
                if (this.isInvalid()) {
                    return false;
                }
                return ((File.fs_$LI$().getBooleanAttributes(this) & java.io.FileSystem.BA_EXISTS) !== 0);
            };
            File.prototype.isDirectory = function () {
                if (this.isInvalid()) {
                    return false;
                }
                return ((File.fs_$LI$().getBooleanAttributes(this) & java.io.FileSystem.BA_DIRECTORY) !== 0);
            };
            File.prototype.isFile = function () {
                if (this.isInvalid()) {
                    return false;
                }
                return ((File.fs_$LI$().getBooleanAttributes(this) & java.io.FileSystem.BA_REGULAR) !== 0);
            };
            File.prototype.isHidden = function () {
                if (this.isInvalid()) {
                    return false;
                }
                return ((File.fs_$LI$().getBooleanAttributes(this) & java.io.FileSystem.BA_HIDDEN) !== 0);
            };
            File.prototype.lastModified = function () {
                if (this.isInvalid()) {
                    return 0;
                }
                return File.fs_$LI$().getLastModifiedTime(this);
            };
            File.prototype.length = function () {
                if (this.isInvalid()) {
                    return 0;
                }
                return File.fs_$LI$().getLength(this);
            };
            File.prototype.createNewFile = function () {
                if (this.isInvalid()) {
                    throw new java.io.IOException("Invalid file path");
                }
                return File.fs_$LI$().createFileExclusively(this.path);
            };
            File.prototype.delete = function () {
                if (this.isInvalid()) {
                    return false;
                }
                return File.fs_$LI$().delete(this);
            };
            File.prototype.list$ = function () {
                if (this.isInvalid()) {
                    return null;
                }
                return File.fs_$LI$().list(this);
            };
            File.prototype.list = function (filter) {
                var _this = this;
                if (((typeof filter === 'function' && filter.length == 2) || filter === null)) {
                    return (function () {
                        var names = _this.list();
                        if ((names == null) || (filter == null)) {
                            return names;
                        }
                        var v = new java.util.ArrayList();
                        for (var i = 0; i < names.length; i++) {
                            if (filter(_this, names[i])) {
                                v.add(names[i]);
                            }
                        }
                        return v.toArray(new Array(v.size()));
                    })();
                }
                else if (filter === undefined) {
                    return this.list$();
                }
                else
                    throw new Error('invalid overload');
            };
            File.prototype.listFiles$ = function () {
                var ss = this.list();
                if (ss == null)
                    return null;
                var n = ss.length;
                var fs = new Array(n);
                for (var i = 0; i < n; i++) {
                    fs[i] = new File(this, ss[i], true);
                }
                return fs;
            };
            File.prototype.listFiles = function (filter) {
                var _this = this;
                if (((typeof filter === 'function' && filter.length == 2) || filter === null)) {
                    return (function () {
                        var ss = _this.list();
                        if (ss == null)
                            return null;
                        var files = new java.util.ArrayList();
                        for (var index183 = 0; index183 < ss.length; index183++) {
                            var s = ss[index183];
                            if ((filter == null) || filter(_this, s))
                                files.add(new File(_this, s, true));
                        }
                        return files.toArray(new Array(files.size()));
                    })();
                }
                else if (((typeof filter === 'function' && filter.length == 1) || filter === null)) {
                    return this.listFiles$java_io_FileFilter(filter);
                }
                else if (filter === undefined) {
                    return this.listFiles$();
                }
                else
                    throw new Error('invalid overload');
            };
            File.prototype.listFiles$java_io_FileFilter = function (filter) {
                var ss = this.list();
                if (ss == null)
                    return null;
                var files = new java.util.ArrayList();
                for (var index184 = 0; index184 < ss.length; index184++) {
                    var s = ss[index184];
                    {
                        var f = new File(this, s, true);
                        if ((filter == null) || filter(f))
                            files.add(f);
                    }
                }
                return files.toArray(new Array(files.size()));
            };
            File.prototype.mkdir = function () {
                if (this.isInvalid()) {
                    return false;
                }
                return File.fs_$LI$().createDirectory(this);
            };
            File.prototype.mkdirs = function () {
                if (this.exists()) {
                    return false;
                }
                if (this.mkdir()) {
                    return true;
                }
                var canonFile = null;
                try {
                    canonFile = this.getCanonicalFile();
                }
                catch (e) {
                    return false;
                }
                ;
                var parent = canonFile.getParentFile();
                return (parent != null && (parent.mkdirs() || parent.exists()) && canonFile.mkdir());
            };
            File.prototype.renameTo = function (dest) {
                if (dest == null) {
                    throw new java.lang.NullPointerException();
                }
                if (this.isInvalid() || dest.isInvalid()) {
                    return false;
                }
                return File.fs_$LI$().rename(this, dest);
            };
            File.prototype.setLastModified = function (time) {
                if (time < 0)
                    throw new java.lang.IllegalArgumentException("Negative time");
                if (this.isInvalid()) {
                    return false;
                }
                return File.fs_$LI$().setLastModifiedTime(this, time);
            };
            File.prototype.setReadOnly = function () {
                if (this.isInvalid()) {
                    return false;
                }
                return File.fs_$LI$().setReadOnly(this);
            };
            File.prototype.setWritable = function (writable, ownerOnly) {
                if (ownerOnly === void 0) { ownerOnly = true; }
                if (this.isInvalid()) {
                    return false;
                }
                return File.fs_$LI$().setPermission(this, java.io.FileSystem.ACCESS_WRITE, writable, ownerOnly);
            };
            File.prototype.setReadable = function (readable, ownerOnly) {
                if (ownerOnly === void 0) { ownerOnly = true; }
                if (this.isInvalid()) {
                    return false;
                }
                return File.fs_$LI$().setPermission(this, java.io.FileSystem.ACCESS_READ, readable, ownerOnly);
            };
            File.prototype.setExecutable = function (executable, ownerOnly) {
                if (ownerOnly === void 0) { ownerOnly = true; }
                if (this.isInvalid()) {
                    return false;
                }
                return File.fs_$LI$().setPermission(this, java.io.FileSystem.ACCESS_EXECUTE, executable, ownerOnly);
            };
            File.prototype.canExecute = function () {
                if (this.isInvalid()) {
                    return false;
                }
                return File.fs_$LI$().checkAccess(this, java.io.FileSystem.ACCESS_EXECUTE);
            };
            File.listRoots = function () {
                return File.fs_$LI$().listRoots();
            };
            File.prototype.getTotalSpace = function () {
                if (this.isInvalid()) {
                    return 0;
                }
                return File.fs_$LI$().getSpace(this, java.io.FileSystem.SPACE_TOTAL);
            };
            File.prototype.getFreeSpace = function () {
                if (this.isInvalid()) {
                    return 0;
                }
                return File.fs_$LI$().getSpace(this, java.io.FileSystem.SPACE_FREE);
            };
            File.prototype.getUsableSpace = function () {
                if (this.isInvalid()) {
                    return 0;
                }
                return File.fs_$LI$().getSpace(this, java.io.FileSystem.SPACE_USABLE);
            };
            File.createTempFile = function (prefix, suffix, directory) {
                if (directory === void 0) { directory = null; }
                if (prefix.length < 3)
                    throw new java.lang.IllegalArgumentException("Prefix string too short");
                if (suffix == null)
                    suffix = ".tmp";
                var tmpdir = (directory != null) ? directory : File.TempDirectory.location();
                var f;
                do {
                    f = File.TempDirectory.generateFile(prefix, suffix, tmpdir);
                } while (((File.fs_$LI$().getBooleanAttributes(f) & java.io.FileSystem.BA_EXISTS) !== 0));
                if (!File.fs_$LI$().createFileExclusively(f.getPath()))
                    throw new java.io.IOException("Unable to create temporary file");
                return f;
            };
            File.prototype.compareTo = function (pathname) {
                var _this = this;
                if (((pathname != null && pathname instanceof java.io.File) || pathname === null)) {
                    return (function () {
                        return File.fs_$LI$().compare(_this, pathname);
                    })();
                }
                else
                    throw new Error('invalid overload');
            };
            File.prototype.equals = function (obj) {
                if ((obj != null) && (obj != null && obj instanceof java.io.File)) {
                    return this.compareTo(obj) === 0;
                }
                return false;
            };
            File.prototype.hashCode = function () {
                return File.fs_$LI$().hashCode(this);
            };
            File.prototype.toString = function () {
                return this.getPath();
            };
            File.serialVersionUID = 301077366599181567;
            return File;
        }());
        io.File = File;
        var File;
        (function (File) {
            (function (PathStatus) {
                PathStatus[PathStatus["INVALID"] = 0] = "INVALID";
                PathStatus[PathStatus["CHECKED"] = 1] = "CHECKED";
            })(File.PathStatus || (File.PathStatus = {}));
            var PathStatus = File.PathStatus;
            var TempDirectory = (function () {
                function TempDirectory() {
                }
                TempDirectory.tmpdir_$LI$ = function () { if (TempDirectory.tmpdir == null)
                    TempDirectory.tmpdir = new java.io.File(java.lang.System.getProperty("java.io.tmpdir")); return TempDirectory.tmpdir; };
                ;
                TempDirectory.location = function () {
                    return TempDirectory.tmpdir_$LI$();
                };
                TempDirectory.generateFile = function (prefix, suffix, dir) {
                    var n = Math.round(Math.random()) * javaemul.internal.LongHelper.MAX_VALUE;
                    if (n === javaemul.internal.LongHelper.MIN_VALUE) {
                        n = 0;
                    }
                    else {
                        n = Math.abs(n);
                    }
                    prefix = (new java.io.File(prefix)).getName();
                    var name = prefix + ('' + n) + suffix;
                    var f = new java.io.File(dir, name);
                    if (!(name === f.getName()) || f.isInvalid()) {
                        throw new java.io.IOException("Unable to create temporary file, " + f);
                    }
                    return f;
                };
                return TempDirectory;
            }());
            File.TempDirectory = TempDirectory;
        })(File = io.File || (io.File = {}));
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * A helper to detect concurrent modifications to collections. This is implemented as a helper
         * utility so that we could remove the checks easily by a flag.
         */
        var ConcurrentModificationDetector = (function () {
            function ConcurrentModificationDetector() {
            }
            ConcurrentModificationDetector.API_CHECK_$LI$ = function () { if (ConcurrentModificationDetector.API_CHECK == null)
                ConcurrentModificationDetector.API_CHECK = (java.lang.System.getProperty("jre.checks.api", "ENABLED") === "ENABLED"); return ConcurrentModificationDetector.API_CHECK; };
            ;
            ConcurrentModificationDetector.structureChanged = function (map) {
                if (!ConcurrentModificationDetector.API_CHECK_$LI$()) {
                    return;
                }
                var modCount = javaemul.internal.JsUtils.getIntProperty(map, ConcurrentModificationDetector.MOD_COUNT_PROPERTY) | 0;
                javaemul.internal.JsUtils.setIntProperty(map, ConcurrentModificationDetector.MOD_COUNT_PROPERTY, modCount + 1);
            };
            ConcurrentModificationDetector.recordLastKnownStructure = function (host, iterator) {
                if (!ConcurrentModificationDetector.API_CHECK_$LI$()) {
                    return;
                }
                var modCount = javaemul.internal.JsUtils.getIntProperty(host, ConcurrentModificationDetector.MOD_COUNT_PROPERTY);
                javaemul.internal.JsUtils.setIntProperty(iterator, ConcurrentModificationDetector.MOD_COUNT_PROPERTY, modCount);
            };
            ConcurrentModificationDetector.checkStructuralChange = function (host, iterator) {
                if (!ConcurrentModificationDetector.API_CHECK_$LI$()) {
                    return;
                }
                if (javaemul.internal.JsUtils.getIntProperty(iterator, ConcurrentModificationDetector.MOD_COUNT_PROPERTY) !== javaemul.internal.JsUtils.getIntProperty(host, ConcurrentModificationDetector.MOD_COUNT_PROPERTY)) {
                    throw new java.util.ConcurrentModificationException();
                }
            };
            ConcurrentModificationDetector.MOD_COUNT_PROPERTY = "_gwt_modCount";
            return ConcurrentModificationDetector;
        }());
        util.ConcurrentModificationDetector = ConcurrentModificationDetector;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        var logging;
        (function (logging) {
            /**
             * An emulation of the java.util.logging.Logger class. See
             * <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/logging/Logger.html">
             * The Java API doc for details</a>
             */
            var Logger = (function () {
                function Logger(name, resourceName) {
                    this.level = null;
                    this.useParentHandlers = false;
                    if (Logger.LOGGING_FALSE_$LI$()) {
                        return;
                    }
                    this.name = name;
                    this.useParentHandlers = true;
                    this.handlers = new java.util.ArrayList();
                }
                Logger.__static_initialize = function () { if (!Logger.__static_initialized) {
                    Logger.__static_initialized = true;
                    Logger.__static_initializer_0();
                } };
                Logger.LOGGING_ENABLED_$LI$ = function () { Logger.__static_initialize(); if (Logger.LOGGING_ENABLED == null)
                    Logger.LOGGING_ENABLED = java.lang.System.getProperty("gwt.logging.enabled", "TRUE"); return Logger.LOGGING_ENABLED; };
                ;
                Logger.LOGGING_WARNING_$LI$ = function () { Logger.__static_initialize(); if (Logger.LOGGING_WARNING == null)
                    Logger.LOGGING_WARNING = (Logger.LOGGING_ENABLED_$LI$() === "WARNING"); return Logger.LOGGING_WARNING; };
                ;
                Logger.LOGGING_SEVERE_$LI$ = function () { Logger.__static_initialize(); if (Logger.LOGGING_SEVERE == null)
                    Logger.LOGGING_SEVERE = (Logger.LOGGING_ENABLED_$LI$() === "SEVERE"); return Logger.LOGGING_SEVERE; };
                ;
                Logger.LOGGING_FALSE_$LI$ = function () { Logger.__static_initialize(); if (Logger.LOGGING_FALSE == null)
                    Logger.LOGGING_FALSE = (Logger.LOGGING_ENABLED_$LI$() === "FALSE"); return Logger.LOGGING_FALSE; };
                ;
                Logger.__static_initializer_0 = function () {
                    Logger.assertLoggingValues();
                };
                Logger.getGlobal = function () {
                    return Logger.getLogger(Logger.GLOBAL_LOGGER_NAME);
                };
                Logger.getLogger = function (name) {
                    if (Logger.LOGGING_FALSE_$LI$()) {
                        return new Logger(name, null);
                    }
                    return java.util.logging.LogManager.getLogManager().ensureLogger(name);
                };
                Logger.assertLoggingValues = function () {
                    if ((Logger.LOGGING_ENABLED_$LI$() === "FALSE") || (Logger.LOGGING_ENABLED_$LI$() === "TRUE") || (Logger.LOGGING_ENABLED_$LI$() === "SEVERE") || (Logger.LOGGING_ENABLED_$LI$() === "WARNING")) {
                        return;
                    }
                    throw new Error("Undefined value for gwt.logging.enabled: \'" + Logger.LOGGING_ENABLED_$LI$() + "\'. Allowed values are TRUE, FALSE, SEVERE, WARNING");
                };
                Logger.prototype.addHandler = function (handler) {
                    if (Logger.LOGGING_FALSE_$LI$()) {
                        return;
                    }
                    this.handlers.add(handler);
                };
                Logger.prototype.config = function (msg) {
                    if (Logger.LOGGING_FALSE_$LI$() || Logger.LOGGING_SEVERE_$LI$() || Logger.LOGGING_WARNING_$LI$()) {
                        return;
                    }
                    this.log(java.util.logging.Level.CONFIG_$LI$(), msg);
                };
                Logger.prototype.fine = function (msg) {
                    if (Logger.LOGGING_FALSE_$LI$() || Logger.LOGGING_SEVERE_$LI$() || Logger.LOGGING_WARNING_$LI$()) {
                        return;
                    }
                    this.log(java.util.logging.Level.FINE_$LI$(), msg);
                };
                Logger.prototype.finer = function (msg) {
                    if (Logger.LOGGING_FALSE_$LI$() || Logger.LOGGING_SEVERE_$LI$() || Logger.LOGGING_WARNING_$LI$()) {
                        return;
                    }
                    this.log(java.util.logging.Level.FINER_$LI$(), msg);
                };
                Logger.prototype.finest = function (msg) {
                    if (Logger.LOGGING_FALSE_$LI$() || Logger.LOGGING_SEVERE_$LI$() || Logger.LOGGING_WARNING_$LI$()) {
                        return;
                    }
                    this.log(java.util.logging.Level.FINEST_$LI$(), msg);
                };
                Logger.prototype.info = function (msg) {
                    if (Logger.LOGGING_FALSE_$LI$() || Logger.LOGGING_SEVERE_$LI$() || Logger.LOGGING_WARNING_$LI$()) {
                        return;
                    }
                    this.log(java.util.logging.Level.INFO_$LI$(), msg);
                };
                Logger.prototype.warning = function (msg) {
                    if (Logger.LOGGING_FALSE_$LI$() || Logger.LOGGING_SEVERE_$LI$()) {
                        return;
                    }
                    this.log(java.util.logging.Level.WARNING_$LI$(), msg);
                };
                Logger.prototype.severe = function (msg) {
                    if (Logger.LOGGING_FALSE_$LI$()) {
                        return;
                    }
                    this.log(java.util.logging.Level.SEVERE_$LI$(), msg);
                };
                Logger.prototype.getHandlers = function () {
                    if (Logger.LOGGING_FALSE_$LI$()) {
                        return new Array(0);
                    }
                    return this.handlers.toArray(new Array(this.handlers.size()));
                };
                Logger.prototype.getLevel = function () {
                    return Logger.LOGGING_FALSE_$LI$() ? null : this.level;
                };
                Logger.prototype.getName = function () {
                    return Logger.LOGGING_FALSE_$LI$() ? null : this.name;
                };
                Logger.prototype.getParent = function () {
                    return Logger.LOGGING_FALSE_$LI$() ? null : this.parent;
                };
                Logger.prototype.getUseParentHandlers = function () {
                    return Logger.LOGGING_FALSE_$LI$() ? false : this.useParentHandlers;
                };
                Logger.prototype.isLoggable = function (messageLevel) {
                    return Logger.LOGGING_FALSE_$LI$() ? false : this.getEffectiveLevel().intValue() <= messageLevel.intValue();
                };
                Logger.prototype.log$java_util_logging_Level$java_lang_String = function (level, msg) {
                    this.log(level, msg, null);
                };
                Logger.prototype.log = function (level, msg, thrown) {
                    var _this = this;
                    if (((level != null && level instanceof java.util.logging.Level) || level === null) && ((typeof msg === 'string') || msg === null) && ((thrown != null && thrown instanceof Error) || thrown === null)) {
                        return (function () {
                            if (Logger.LOGGING_FALSE_$LI$()) {
                                return;
                            }
                            if (Logger.LOGGING_SEVERE_$LI$()) {
                                if (level.intValue() >= 1000) {
                                    _this.actuallyLog(level, msg, thrown);
                                }
                            }
                            else if (Logger.LOGGING_WARNING_$LI$()) {
                                if (level.intValue() >= java.util.logging.Level.WARNING_$LI$().intValue()) {
                                    _this.actuallyLog(level, msg, thrown);
                                }
                            }
                            else {
                                _this.actuallyLog(level, msg, thrown);
                            }
                        })();
                    }
                    else if (((level != null && level instanceof java.util.logging.Level) || level === null) && ((typeof msg === 'string') || msg === null) && thrown === undefined) {
                        return this.log$java_util_logging_Level$java_lang_String(level, msg);
                    }
                    else if (((level != null && level instanceof java.util.logging.LogRecord) || level === null) && msg === undefined && thrown === undefined) {
                        return this.log$java_util_logging_LogRecord(level);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Logger.prototype.log$java_util_logging_LogRecord = function (record) {
                    if (Logger.LOGGING_FALSE_$LI$()) {
                        return;
                    }
                    if (Logger.LOGGING_SEVERE_$LI$()) {
                        if (record.getLevel().intValue() >= 1000) {
                            this.actuallyLog(record);
                        }
                    }
                    else if (Logger.LOGGING_WARNING_$LI$()) {
                        if (record.getLevel().intValue() >= java.util.logging.Level.WARNING_$LI$().intValue()) {
                            this.actuallyLog(record);
                        }
                    }
                    else {
                        this.actuallyLog(record);
                    }
                };
                Logger.prototype.removeHandler = function (handler) {
                    if (Logger.LOGGING_FALSE_$LI$()) {
                        return;
                    }
                    this.handlers.remove(handler);
                };
                Logger.prototype.setLevel = function (newLevel) {
                    if (Logger.LOGGING_FALSE_$LI$()) {
                        return;
                    }
                    this.level = newLevel;
                };
                Logger.prototype.setParent = function (newParent) {
                    if (Logger.LOGGING_FALSE_$LI$()) {
                        return;
                    }
                    if (newParent != null) {
                        this.parent = newParent;
                    }
                };
                Logger.prototype.setUseParentHandlers = function (newUseParentHandlers) {
                    if (Logger.LOGGING_FALSE_$LI$()) {
                        return;
                    }
                    this.useParentHandlers = newUseParentHandlers;
                };
                Logger.prototype.getEffectiveLevel = function () {
                    if (this.level != null) {
                        return this.level;
                    }
                    var logger = this.getParent();
                    while ((logger != null)) {
                        var effectiveLevel = logger.getLevel();
                        if (effectiveLevel != null) {
                            return effectiveLevel;
                        }
                        logger = logger.getParent();
                    }
                    ;
                    return java.util.logging.Level.INFO_$LI$();
                };
                Logger.prototype.actuallyLog = function (level, msg, thrown) {
                    var _this = this;
                    if (((level != null && level instanceof java.util.logging.Level) || level === null) && ((typeof msg === 'string') || msg === null) && ((thrown != null && thrown instanceof Error) || thrown === null)) {
                        return (function () {
                            if (_this.isLoggable(level)) {
                                var record = new java.util.logging.LogRecord(level, msg);
                                record.setThrown(thrown);
                                record.setLoggerName(_this.getName());
                                _this.actuallyLog(record);
                            }
                        })();
                    }
                    else if (((level != null && level instanceof java.util.logging.LogRecord) || level === null) && msg === undefined && thrown === undefined) {
                        return this.actuallyLog$java_util_logging_LogRecord(level);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Logger.prototype.actuallyLog$java_util_logging_LogRecord = function (record) {
                    if (this.isLoggable(record.getLevel())) {
                        {
                            var array186 = this.getHandlers();
                            for (var index185 = 0; index185 < array186.length; index185++) {
                                var handler = array186[index185];
                                {
                                    handler.publish(record);
                                }
                            }
                        }
                        var logger = this.getUseParentHandlers() ? this.getParent() : null;
                        while ((logger != null)) {
                            {
                                var array188 = logger.getHandlers();
                                for (var index187 = 0; index187 < array188.length; index187++) {
                                    var handler = array188[index187];
                                    {
                                        handler.publish(record);
                                    }
                                }
                            }
                            logger = logger.getUseParentHandlers() ? logger.getParent() : null;
                        }
                        ;
                    }
                };
                Logger.__static_initialized = false;
                Logger.GLOBAL_LOGGER_NAME = "global";
                return Logger;
            }());
            logging.Logger = Logger;
        })(logging = util.logging || (util.logging = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var javaemul;
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * A utility class that provides utility functions to do precondition checks inside GWT-SDK.
         */
        var InternalPreconditions = (function () {
            function InternalPreconditions() {
            }
            InternalPreconditions.CHECKED_MODE_$LI$ = function () { if (InternalPreconditions.CHECKED_MODE == null)
                InternalPreconditions.CHECKED_MODE = (java.lang.System.getProperty("jre.checkedMode", "ENABLED") === "ENABLED"); return InternalPreconditions.CHECKED_MODE; };
            ;
            InternalPreconditions.TYPE_CHECK_$LI$ = function () { if (InternalPreconditions.TYPE_CHECK == null)
                InternalPreconditions.TYPE_CHECK = (java.lang.System.getProperty("jre.checks.type", "ENABLED") === "ENABLED"); return InternalPreconditions.TYPE_CHECK; };
            ;
            InternalPreconditions.API_CHECK_$LI$ = function () { if (InternalPreconditions.API_CHECK == null)
                InternalPreconditions.API_CHECK = (java.lang.System.getProperty("jre.checks.api", "ENABLED") === "ENABLED"); return InternalPreconditions.API_CHECK; };
            ;
            InternalPreconditions.BOUND_CHECK_$LI$ = function () { if (InternalPreconditions.BOUND_CHECK == null)
                InternalPreconditions.BOUND_CHECK = (java.lang.System.getProperty("jre.checks.bounds", "ENABLED") === "ENABLED"); return InternalPreconditions.BOUND_CHECK; };
            ;
            InternalPreconditions.checkType = function (expression) {
                if (InternalPreconditions.TYPE_CHECK_$LI$()) {
                    InternalPreconditions.checkCriticalType(expression);
                }
                else if (InternalPreconditions.CHECKED_MODE_$LI$()) {
                    try {
                        InternalPreconditions.checkCriticalType(expression);
                    }
                    catch (e) {
                        throw new java.lang.AssertionError(e);
                    }
                    ;
                }
            };
            InternalPreconditions.checkCriticalType = function (expression) {
                if (!expression) {
                    throw new java.lang.ClassCastException();
                }
            };
            /**
             * Ensures the truth of an expression that verifies array type.
             */
            InternalPreconditions.checkArrayType$boolean = function (expression) {
                if (InternalPreconditions.TYPE_CHECK_$LI$()) {
                    InternalPreconditions.checkCriticalArrayType(expression);
                }
                else if (InternalPreconditions.CHECKED_MODE_$LI$()) {
                    try {
                        InternalPreconditions.checkCriticalArrayType(expression);
                    }
                    catch (e) {
                        throw new java.lang.AssertionError(e);
                    }
                    ;
                }
            };
            InternalPreconditions.checkCriticalArrayType$boolean = function (expression) {
                if (!expression) {
                    throw new java.lang.ArrayStoreException();
                }
            };
            /**
             * Ensures the truth of an expression that verifies array type.
             */
            InternalPreconditions.checkArrayType = function (expression, errorMessage) {
                if (((typeof expression === 'boolean') || expression === null) && ((errorMessage != null) || errorMessage === null)) {
                    return (function () {
                        if (InternalPreconditions.TYPE_CHECK_$LI$()) {
                            InternalPreconditions.checkCriticalArrayType(expression, errorMessage);
                        }
                        else if (InternalPreconditions.CHECKED_MODE_$LI$()) {
                            try {
                                InternalPreconditions.checkCriticalArrayType(expression, errorMessage);
                            }
                            catch (e) {
                                throw new java.lang.AssertionError(e);
                            }
                            ;
                        }
                    })();
                }
                else if (((typeof expression === 'boolean') || expression === null) && errorMessage === undefined) {
                    return javaemul.internal.InternalPreconditions.checkArrayType$boolean(expression);
                }
                else
                    throw new Error('invalid overload');
            };
            InternalPreconditions.checkCriticalArrayType = function (expression, errorMessage) {
                if (((typeof expression === 'boolean') || expression === null) && ((errorMessage != null) || errorMessage === null)) {
                    return (function () {
                        if (!expression) {
                            throw new java.lang.ArrayStoreException(/* valueOf */ new String(errorMessage).toString());
                        }
                    })();
                }
                else if (((typeof expression === 'boolean') || expression === null) && errorMessage === undefined) {
                    return javaemul.internal.InternalPreconditions.checkCriticalArrayType$boolean(expression);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Ensures the truth of an expression involving existence of an element.
             */
            InternalPreconditions.checkElement$boolean = function (expression) {
                if (InternalPreconditions.API_CHECK_$LI$()) {
                    InternalPreconditions.checkCriticalElement(expression);
                }
                else if (InternalPreconditions.CHECKED_MODE_$LI$()) {
                    try {
                        InternalPreconditions.checkCriticalElement(expression);
                    }
                    catch (e) {
                        throw new java.lang.AssertionError(e);
                    }
                    ;
                }
            };
            /**
             * Ensures the truth of an expression involving existence of an element.
             * <p>
             * For cases where failing fast is pretty important and not failing early could cause bugs that
             * are much harder to debug.
             */
            InternalPreconditions.checkCriticalElement$boolean = function (expression) {
                if (!expression) {
                    throw new java.util.NoSuchElementException();
                }
            };
            /**
             * Ensures the truth of an expression involving existence of an element.
             */
            InternalPreconditions.checkElement = function (expression, errorMessage) {
                if (((typeof expression === 'boolean') || expression === null) && ((errorMessage != null) || errorMessage === null)) {
                    return (function () {
                        if (InternalPreconditions.API_CHECK_$LI$()) {
                            InternalPreconditions.checkCriticalElement(expression, errorMessage);
                        }
                        else if (InternalPreconditions.CHECKED_MODE_$LI$()) {
                            try {
                                InternalPreconditions.checkCriticalElement(expression, errorMessage);
                            }
                            catch (e) {
                                throw new java.lang.AssertionError(e);
                            }
                            ;
                        }
                    })();
                }
                else if (((typeof expression === 'boolean') || expression === null) && errorMessage === undefined) {
                    return javaemul.internal.InternalPreconditions.checkElement$boolean(expression);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Ensures the truth of an expression involving existence of an element.
             * <p>
             * For cases where failing fast is pretty important and not failing early could cause bugs that
             * are much harder to debug.
             */
            InternalPreconditions.checkCriticalElement = function (expression, errorMessage) {
                if (((typeof expression === 'boolean') || expression === null) && ((errorMessage != null) || errorMessage === null)) {
                    return (function () {
                        if (!expression) {
                            throw new java.util.NoSuchElementException(/* valueOf */ new String(errorMessage).toString());
                        }
                    })();
                }
                else if (((typeof expression === 'boolean') || expression === null) && errorMessage === undefined) {
                    return javaemul.internal.InternalPreconditions.checkCriticalElement$boolean(expression);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Ensures the truth of an expression involving one or more parameters to the calling method.
             */
            InternalPreconditions.checkArgument$boolean = function (expression) {
                if (InternalPreconditions.API_CHECK_$LI$()) {
                    InternalPreconditions.checkCriticalArgument(expression);
                }
                else if (InternalPreconditions.CHECKED_MODE_$LI$()) {
                    try {
                        InternalPreconditions.checkCriticalArgument(expression);
                    }
                    catch (e) {
                        throw new java.lang.AssertionError(e);
                    }
                    ;
                }
            };
            /**
             * Ensures the truth of an expression involving one or more parameters to the calling method.
             * <p>
             * For cases where failing fast is pretty important and not failing early could cause bugs that
             * are much harder to debug.
             */
            InternalPreconditions.checkCriticalArgument$boolean = function (expression) {
                if (!expression) {
                    throw new java.lang.IllegalArgumentException();
                }
            };
            /**
             * Ensures the truth of an expression involving one or more parameters to the calling method.
             */
            InternalPreconditions.checkArgument$boolean$java_lang_Object = function (expression, errorMessage) {
                if (InternalPreconditions.API_CHECK_$LI$()) {
                    InternalPreconditions.checkCriticalArgument(expression, errorMessage);
                }
                else if (InternalPreconditions.CHECKED_MODE_$LI$()) {
                    try {
                        InternalPreconditions.checkCriticalArgument(expression, errorMessage);
                    }
                    catch (e) {
                        throw new java.lang.AssertionError(e);
                    }
                    ;
                }
            };
            /**
             * Ensures the truth of an expression involving one or more parameters to the calling method.
             * <p>
             * For cases where failing fast is pretty important and not failing early could cause bugs that
             * are much harder to debug.
             */
            InternalPreconditions.checkCriticalArgument$boolean$java_lang_Object = function (expression, errorMessage) {
                if (!expression) {
                    throw new java.lang.IllegalArgumentException(/* valueOf */ new String(errorMessage).toString());
                }
            };
            /**
             * Ensures the truth of an expression involving one or more parameters to the calling method.
             */
            InternalPreconditions.checkArgument = function (expression, errorMessageTemplate) {
                var _this = this;
                var errorMessageArgs = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    errorMessageArgs[_i - 2] = arguments[_i];
                }
                if (((typeof expression === 'boolean') || expression === null) && ((typeof errorMessageTemplate === 'string') || errorMessageTemplate === null) && ((errorMessageArgs != null && errorMessageArgs instanceof Array) || errorMessageArgs === null)) {
                    return (function () {
                        if (InternalPreconditions.API_CHECK_$LI$()) {
                            InternalPreconditions.checkCriticalArgument.apply(_this, [expression, errorMessageTemplate].concat(errorMessageArgs));
                        }
                        else if (InternalPreconditions.CHECKED_MODE_$LI$()) {
                            try {
                                InternalPreconditions.checkCriticalArgument.apply(_this, [expression, errorMessageTemplate].concat(errorMessageArgs));
                            }
                            catch (e) {
                                throw new java.lang.AssertionError(e);
                            }
                            ;
                        }
                    })();
                }
                else if (((typeof expression === 'boolean') || expression === null) && ((errorMessageTemplate != null) || errorMessageTemplate === null) && errorMessageArgs === undefined) {
                    return javaemul.internal.InternalPreconditions.checkArgument$boolean$java_lang_Object(expression, errorMessageTemplate);
                }
                else if (((typeof expression === 'boolean') || expression === null) && errorMessageTemplate === undefined && errorMessageArgs === undefined) {
                    return javaemul.internal.InternalPreconditions.checkArgument$boolean(expression);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Ensures the truth of an expression involving one or more parameters to the calling method.
             * <p>
             * For cases where failing fast is pretty important and not failing early could cause bugs that
             * are much harder to debug.
             */
            InternalPreconditions.checkCriticalArgument = function (expression, errorMessageTemplate) {
                var _this = this;
                var errorMessageArgs = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    errorMessageArgs[_i - 2] = arguments[_i];
                }
                if (((typeof expression === 'boolean') || expression === null) && ((typeof errorMessageTemplate === 'string') || errorMessageTemplate === null) && ((errorMessageArgs != null && errorMessageArgs instanceof Array) || errorMessageArgs === null)) {
                    return (function () {
                        if (!expression) {
                            throw new java.lang.IllegalArgumentException(InternalPreconditions.format.apply(_this, [errorMessageTemplate].concat(errorMessageArgs)));
                        }
                    })();
                }
                else if (((typeof expression === 'boolean') || expression === null) && ((errorMessageTemplate != null) || errorMessageTemplate === null) && errorMessageArgs === undefined) {
                    return javaemul.internal.InternalPreconditions.checkCriticalArgument$boolean$java_lang_Object(expression, errorMessageTemplate);
                }
                else if (((typeof expression === 'boolean') || expression === null) && errorMessageTemplate === undefined && errorMessageArgs === undefined) {
                    return javaemul.internal.InternalPreconditions.checkCriticalArgument$boolean(expression);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Ensures the truth of an expression involving the state of the calling instance, but not
             * involving any parameters to the calling method.
             *
             * @param expression a boolean expression
             * @throws IllegalStateException if {@code expression} is false
             */
            InternalPreconditions.checkState$boolean = function (expression) {
                if (InternalPreconditions.API_CHECK_$LI$()) {
                    InternalPreconditions.checkCritcalState(expression);
                }
                else if (InternalPreconditions.CHECKED_MODE_$LI$()) {
                    try {
                        InternalPreconditions.checkCritcalState(expression);
                    }
                    catch (e) {
                        throw new java.lang.AssertionError(e);
                    }
                    ;
                }
            };
            /**
             * Ensures the truth of an expression involving the state of the calling instance, but not
             * involving any parameters to the calling method.
             * <p>
             * For cases where failing fast is pretty important and not failing early could cause bugs that
             * are much harder to debug.
             */
            InternalPreconditions.checkCritcalState = function (expression) {
                if (!expression) {
                    throw new java.lang.IllegalStateException();
                }
            };
            /**
             * Ensures the truth of an expression involving the state of the calling instance, but not
             * involving any parameters to the calling method.
             */
            InternalPreconditions.checkState = function (expression, errorMessage) {
                if (((typeof expression === 'boolean') || expression === null) && ((errorMessage != null) || errorMessage === null)) {
                    return (function () {
                        if (InternalPreconditions.API_CHECK_$LI$()) {
                            InternalPreconditions.checkCriticalState(expression, errorMessage);
                        }
                        else if (InternalPreconditions.CHECKED_MODE_$LI$()) {
                            try {
                                InternalPreconditions.checkCriticalState(expression, errorMessage);
                            }
                            catch (e) {
                                throw new java.lang.AssertionError(e);
                            }
                            ;
                        }
                    })();
                }
                else if (((typeof expression === 'boolean') || expression === null) && errorMessage === undefined) {
                    return javaemul.internal.InternalPreconditions.checkState$boolean(expression);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Ensures the truth of an expression involving the state of the calling instance, but not
             * involving any parameters to the calling method.
             */
            InternalPreconditions.checkCriticalState = function (expression, errorMessage) {
                if (!expression) {
                    throw new java.lang.IllegalStateException(/* valueOf */ new String(errorMessage).toString());
                }
            };
            /**
             * Ensures that an object reference passed as a parameter to the calling method is not null.
             */
            InternalPreconditions.checkNotNull$java_lang_Object = function (reference) {
                if (InternalPreconditions.API_CHECK_$LI$()) {
                    InternalPreconditions.checkCriticalNotNull(reference);
                }
                else if (InternalPreconditions.CHECKED_MODE_$LI$()) {
                    try {
                        InternalPreconditions.checkCriticalNotNull(reference);
                    }
                    catch (e) {
                        throw new java.lang.AssertionError(e);
                    }
                    ;
                }
                return reference;
            };
            InternalPreconditions.checkCriticalNotNull$java_lang_Object = function (reference) {
                if (reference == null) {
                    throw new java.lang.NullPointerException();
                }
                return reference;
            };
            /**
             * Ensures that an object reference passed as a parameter to the calling method is not null.
             */
            InternalPreconditions.checkNotNull = function (reference, errorMessage) {
                if (((reference != null) || reference === null) && ((errorMessage != null) || errorMessage === null)) {
                    return (function () {
                        if (InternalPreconditions.API_CHECK_$LI$()) {
                            InternalPreconditions.checkCriticalNotNull(reference, errorMessage);
                        }
                        else if (InternalPreconditions.CHECKED_MODE_$LI$()) {
                            try {
                                InternalPreconditions.checkCriticalNotNull(reference, errorMessage);
                            }
                            catch (e) {
                                throw new java.lang.AssertionError(e);
                            }
                            ;
                        }
                    })();
                }
                else if (((reference != null) || reference === null) && errorMessage === undefined) {
                    return javaemul.internal.InternalPreconditions.checkNotNull$java_lang_Object(reference);
                }
                else
                    throw new Error('invalid overload');
            };
            InternalPreconditions.checkCriticalNotNull = function (reference, errorMessage) {
                if (((reference != null) || reference === null) && ((errorMessage != null) || errorMessage === null)) {
                    return (function () {
                        if (reference == null) {
                            throw new java.lang.NullPointerException(/* valueOf */ new String(errorMessage).toString());
                        }
                    })();
                }
                else if (((reference != null) || reference === null) && errorMessage === undefined) {
                    return javaemul.internal.InternalPreconditions.checkCriticalNotNull$java_lang_Object(reference);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Ensures that {@code size} specifies a valid array size (i.e. non-negative).
             */
            InternalPreconditions.checkArraySize = function (size) {
                if (InternalPreconditions.API_CHECK_$LI$()) {
                    InternalPreconditions.checkCriticalArraySize(size);
                }
                else if (InternalPreconditions.CHECKED_MODE_$LI$()) {
                    try {
                        InternalPreconditions.checkCriticalArraySize(size);
                    }
                    catch (e) {
                        throw new java.lang.AssertionError(e);
                    }
                    ;
                }
            };
            InternalPreconditions.checkCriticalArraySize = function (size) {
                if (size < 0) {
                    throw new java.lang.NegativeArraySizeException("Negative array size: " + size);
                }
            };
            /**
             * Ensures that {@code index} specifies a valid <i>element</i> in an array, list or string of size
             * {@code size}. An element index may range from zero, inclusive, to {@code size}, exclusive.
             */
            InternalPreconditions.checkElementIndex = function (index, size) {
                if (InternalPreconditions.BOUND_CHECK_$LI$()) {
                    InternalPreconditions.checkCriticalElementIndex(index, size);
                }
                else if (InternalPreconditions.CHECKED_MODE_$LI$()) {
                    try {
                        InternalPreconditions.checkCriticalElementIndex(index, size);
                    }
                    catch (e) {
                        throw new java.lang.AssertionError(e);
                    }
                    ;
                }
            };
            InternalPreconditions.checkCriticalElementIndex = function (index, size) {
                if (index < 0 || index >= size) {
                    throw new java.lang.IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
                }
            };
            /**
             * Ensures that {@code index} specifies a valid <i>position</i> in an array, list or string of
             * size {@code size}. A position index may range from zero to {@code size}, inclusive.
             */
            InternalPreconditions.checkPositionIndex = function (index, size) {
                if (InternalPreconditions.BOUND_CHECK_$LI$()) {
                    InternalPreconditions.checkCriticalPositionIndex(index, size);
                }
                else if (InternalPreconditions.CHECKED_MODE_$LI$()) {
                    try {
                        InternalPreconditions.checkCriticalPositionIndex(index, size);
                    }
                    catch (e) {
                        throw new java.lang.AssertionError(e);
                    }
                    ;
                }
            };
            InternalPreconditions.checkCriticalPositionIndex = function (index, size) {
                if (index < 0 || index > size) {
                    throw new java.lang.IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
                }
            };
            /**
             * Ensures that {@code start} and {@code end} specify a valid <i>positions</i> in an array, list
             * or string of size {@code size}, and are in order. A position index may range from zero to
             * {@code size}, inclusive.
             */
            InternalPreconditions.checkPositionIndexes = function (start, end, size) {
                if (InternalPreconditions.BOUND_CHECK_$LI$()) {
                    InternalPreconditions.checkCriticalPositionIndexes(start, end, size);
                }
                else if (InternalPreconditions.CHECKED_MODE_$LI$()) {
                    try {
                        InternalPreconditions.checkCriticalPositionIndexes(start, end, size);
                    }
                    catch (e) {
                        throw new java.lang.AssertionError(e);
                    }
                    ;
                }
            };
            /**
             * Ensures that {@code start} and {@code end} specify a valid <i>positions</i> in an array, list
             * or string of size {@code size}, and are in order. A position index may range from zero to
             * {@code size}, inclusive.
             */
            InternalPreconditions.checkCriticalPositionIndexes = function (start, end, size) {
                if (start < 0) {
                    throw new java.lang.IndexOutOfBoundsException("fromIndex: " + start + " < 0");
                }
                if (end > size) {
                    throw new java.lang.IndexOutOfBoundsException("toIndex: " + end + " > size " + size);
                }
                if (start > end) {
                    throw new java.lang.IllegalArgumentException("fromIndex: " + start + " > toIndex: " + end);
                }
            };
            /**
             * Checks that bounds are correct.
             *
             * @throw StringIndexOutOfBoundsException if the range is not legal
             */
            InternalPreconditions.checkStringBounds = function (start, end, size) {
                if (start < 0) {
                    throw new java.lang.StringIndexOutOfBoundsException("fromIndex: " + start + " < 0");
                }
                if (end > size) {
                    throw new java.lang.StringIndexOutOfBoundsException("toIndex: " + end + " > size " + size);
                }
                if (end < start) {
                    throw new java.lang.StringIndexOutOfBoundsException("fromIndex: " + start + " > toIndex: " + end);
                }
            };
            /**
             * Substitutes each {@code %s} in {@code template} with an argument. These are matched by
             * position: the first {@code %s} gets {@code args[0]}, etc.  If there are more arguments than
             * placeholders, the unmatched arguments will be appended to the end of the formatted message in
             * square braces.
             */
            InternalPreconditions.format = function (template) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                template = new String(template).toString();
                var builder = new java.lang.StringBuilder(template.length + 16 * args.length);
                var templateStart = 0;
                var i = 0;
                while ((i < args.length)) {
                    var placeholderStart = template.indexOf("%s", templateStart);
                    if (placeholderStart === -1) {
                        break;
                    }
                    builder.append(template.substring(templateStart, placeholderStart));
                    builder.append(args[i++]);
                    templateStart = placeholderStart + 2;
                }
                ;
                builder.append(template.substring(templateStart));
                if (i < args.length) {
                    builder.append(" [");
                    builder.append(args[i++]);
                    while ((i < args.length)) {
                        builder.append(", ");
                        builder.append(args[i++]);
                    }
                    ;
                    builder.append(']');
                }
                return builder.toString();
            };
            return InternalPreconditions;
        }());
        internal.InternalPreconditions = InternalPreconditions;
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * Implementation of Map interface based on a hash table. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/HashMap.html">[Sun
         * docs]</a>
         *
         * @param <K> key type
         * @param <V> value type
         */
        var HashMap = (function (_super) {
            __extends(HashMap, _super);
            function HashMap(ignored, alsoIgnored) {
                if (((typeof ignored === 'number') || ignored === null) && ((typeof alsoIgnored === 'number') || alsoIgnored === null)) {
                    _super.call(this, ignored, alsoIgnored);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.util.Map", "java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (((ignored != null && ignored["__interfaces"] != null && ignored["__interfaces"].indexOf("java.util.Map") >= 0) || ignored === null) && alsoIgnored === undefined) {
                    var toBeCopied = ignored;
                    _super.call(this, toBeCopied);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.util.Map", "java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (((typeof ignored === 'number') || ignored === null) && alsoIgnored === undefined) {
                    _super.call(this, ignored);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.util.Map", "java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (ignored === undefined && alsoIgnored === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.util.Map", "java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            HashMap.prototype.clone = function () {
                return new HashMap(this);
            };
            HashMap.prototype._equals = function (value1, value2) {
                return java.util.Objects.equals(value1, value2);
            };
            HashMap.prototype.getHashCode = function (key) {
                var hashCode = key.toString();
                return javaemul.internal.Coercions.ensureInt(hashCode);
            };
            return HashMap;
        }(java.util.AbstractHashMap));
        util.HashMap = HashMap;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * Map using reference equality on keys. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/IdentityHashMap.html">[Sun
         * docs]</a>
         *
         * @param <K> key type
         * @param <V> value type
         */
        var IdentityHashMap = (function (_super) {
            __extends(IdentityHashMap, _super);
            function IdentityHashMap(toBeCopied) {
                if (((toBeCopied != null && toBeCopied["__interfaces"] != null && toBeCopied["__interfaces"].indexOf("java.util.Map") >= 0) || toBeCopied === null)) {
                    _super.call(this, toBeCopied);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.util.Map", "java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (((typeof toBeCopied === 'number') || toBeCopied === null)) {
                    var ignored = toBeCopied;
                    _super.call(this, ignored);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.util.Map", "java.io.Serializable"] });
                    (function () {
                    })();
                }
                else if (toBeCopied === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.util.Map", "java.io.Serializable"] });
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            IdentityHashMap.prototype.clone = function () {
                return new IdentityHashMap(this);
            };
            IdentityHashMap.prototype.equals = function (obj) {
                if (obj === this) {
                    return true;
                }
                if (!(obj != null && obj["__interfaces"] != null && obj["__interfaces"].indexOf("java.util.Map") >= 0)) {
                    return false;
                }
                var otherMap = obj;
                if (this.size() !== otherMap.size()) {
                    return false;
                }
                for (var index189 = otherMap.entrySet().iterator(); index189.hasNext();) {
                    var entry = index189.next();
                    {
                        var otherKey = entry.getKey();
                        var otherValue = entry.getValue();
                        if (!this.containsKey(otherKey)) {
                            return false;
                        }
                        if (otherValue !== this.get(otherKey)) {
                            return false;
                        }
                    }
                }
                return true;
            };
            IdentityHashMap.prototype.hashCode = function () {
                var hashCode = 0;
                for (var index190 = this.entrySet().iterator(); index190.hasNext();) {
                    var entry = index190.next();
                    {
                        hashCode += java.lang.System.identityHashCode(entry.getKey());
                        hashCode += java.lang.System.identityHashCode(entry.getValue());
                    }
                }
                return hashCode;
            };
            IdentityHashMap.prototype._equals = function (value1, value2) {
                return value1 === value2;
            };
            IdentityHashMap.prototype.getHashCode = function (key) {
                return javaemul.internal.HashCodes.getObjectIdentityHashCode(key);
            };
            return IdentityHashMap;
        }(java.util.AbstractHashMap));
        util.IdentityHashMap = IdentityHashMap;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * Implements a TreeMap using a red-black tree. This guarantees O(log n)
         * performance on lookups, inserts, and deletes while maintaining linear
         * in-order traversal time. Null keys and values are fully supported if the
         * comparator supports them (the default comparator does not).
         *
         * @param <K> key type
         * @param <V> value type
         */
        var TreeMap = (function (_super) {
            __extends(TreeMap, _super);
            function TreeMap(c) {
                var _this = this;
                if (((c != null && c["__interfaces"] != null && c["__interfaces"].indexOf("java.util.Comparator") >= 0) || c === null)) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Map", "java.util.NavigableMap", "java.util.SortedMap", "java.io.Serializable"] });
                    this.__size = 0;
                    (function () {
                        _this.root = null;
                        if (c == null) {
                            c = java.util.Comparators.natural();
                        }
                        _this.cmp = c;
                    })();
                }
                else if (((c != null && c["__interfaces"] != null && c["__interfaces"].indexOf("java.util.SortedMap") >= 0) || c === null)) {
                    var map = c;
                    {
                        var c = javaemul.internal.InternalPreconditions.checkNotNull(map).comparator();
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Map", "java.util.NavigableMap", "java.util.SortedMap", "java.io.Serializable"] });
                        this.__size = 0;
                        (function () {
                            _this.root = null;
                            if (c == null) {
                                c = java.util.Comparators.natural();
                            }
                            _this.cmp = c;
                        })();
                    }
                    (function () {
                        _this.putAll(map);
                    })();
                }
                else if (((c != null && c["__interfaces"] != null && c["__interfaces"].indexOf("java.util.Map") >= 0) || c === null)) {
                    var map = c;
                    {
                        {
                            var c = null;
                            _super.call(this);
                            Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Map", "java.util.NavigableMap", "java.util.SortedMap", "java.io.Serializable"] });
                            this.__size = 0;
                            (function () {
                                _this.root = null;
                                if (c == null) {
                                    c = java.util.Comparators.natural();
                                }
                                _this.cmp = c;
                            })();
                        }
                        (function () {
                        })();
                    }
                    (function () {
                        _this.putAll(map);
                    })();
                }
                else if (c === undefined) {
                    {
                        var c = null;
                        _super.call(this);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Map", "java.util.NavigableMap", "java.util.SortedMap", "java.io.Serializable"] });
                        this.__size = 0;
                        (function () {
                            _this.root = null;
                            if (c == null) {
                                c = java.util.Comparators.natural();
                            }
                            _this.cmp = c;
                        })();
                    }
                    (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            TreeMap.SubMapType_All_$LI$ = function () { if (TreeMap.SubMapType_All == null)
                TreeMap.SubMapType_All = new TreeMap.SubMapType(); return TreeMap.SubMapType_All; };
            ;
            TreeMap.SubMapType_Head_$LI$ = function () { if (TreeMap.SubMapType_Head == null)
                TreeMap.SubMapType_Head = new TreeMap.SubMapTypeHead(); return TreeMap.SubMapType_Head; };
            ;
            TreeMap.SubMapType_Range_$LI$ = function () { if (TreeMap.SubMapType_Range == null)
                TreeMap.SubMapType_Range = new TreeMap.SubMapTypeRange(); return TreeMap.SubMapType_Range; };
            ;
            TreeMap.SubMapType_Tail_$LI$ = function () { if (TreeMap.SubMapType_Tail == null)
                TreeMap.SubMapType_Tail = new TreeMap.SubMapTypeTail(); return TreeMap.SubMapType_Tail; };
            ;
            TreeMap.otherChild = function (child) {
                return 1 - child;
            };
            TreeMap.prototype.clear = function () {
                this.root = null;
                this.__size = 0;
            };
            TreeMap.prototype.comparator = function () {
                if (this.cmp === java.util.Comparators.natural()) {
                    return null;
                }
                return this.cmp;
            };
            TreeMap.prototype.entrySet = function () {
                return new TreeMap.EntrySet(this);
            };
            TreeMap.prototype.headMap = function (toKey, inclusive) {
                var _this = this;
                if (((toKey != null) || toKey === null) && ((typeof inclusive === 'boolean') || inclusive === null)) {
                    return (function () {
                        return new TreeMap.SubMap(_this, TreeMap.SubMapType_Head_$LI$(), null, false, toKey, inclusive);
                    })();
                }
                else if (((toKey != null) || toKey === null) && inclusive === undefined) {
                    return this.headMap$java_lang_Object(toKey);
                }
                else
                    throw new Error('invalid overload');
            };
            TreeMap.prototype.put = function (key, value) {
                if (((key != null) || key === null) && ((value != null) || value === null)) {
                    return this.put$java_lang_Object$java_lang_Object(key, value);
                }
                else
                    throw new Error('invalid overload');
            };
            TreeMap.prototype.put$java_lang_Object$java_lang_Object = function (key, value) {
                var node = new TreeMap.Node(key, value);
                var state = new TreeMap.State();
                this.root = this.insert(this.root, node, state);
                if (!state.found) {
                    ++this.__size;
                }
                this.root.isRed = false;
                return state.value;
            };
            TreeMap.prototype.remove = function (k) {
                var key = k;
                var state = new TreeMap.State();
                this.removeWithState(key, state);
                return state.value;
            };
            TreeMap.prototype.size = function () {
                return this.__size;
            };
            TreeMap.prototype.subMap = function (fromKey, fromInclusive, toKey, toInclusive) {
                var _this = this;
                if (((fromKey != null) || fromKey === null) && ((typeof fromInclusive === 'boolean') || fromInclusive === null) && ((toKey != null) || toKey === null) && ((typeof toInclusive === 'boolean') || toInclusive === null)) {
                    return (function () {
                        return new TreeMap.SubMap(_this, TreeMap.SubMapType_Range_$LI$(), fromKey, fromInclusive, toKey, toInclusive);
                    })();
                }
                else if (((fromKey != null) || fromKey === null) && ((fromInclusive != null) || fromInclusive === null) && toKey === undefined && toInclusive === undefined) {
                    return this.subMap$java_lang_Object$java_lang_Object(fromKey, fromInclusive);
                }
                else
                    throw new Error('invalid overload');
            };
            TreeMap.prototype.tailMap = function (fromKey, inclusive) {
                var _this = this;
                if (((fromKey != null) || fromKey === null) && ((typeof inclusive === 'boolean') || inclusive === null)) {
                    return (function () {
                        return new TreeMap.SubMap(_this, TreeMap.SubMapType_Tail_$LI$(), fromKey, inclusive, null, false);
                    })();
                }
                else if (((fromKey != null) || fromKey === null) && inclusive === undefined) {
                    return this.tailMap$java_lang_Object(fromKey);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Returns the first node which compares greater than the given key.
             *
             * @param key the key to search for
             * @return the next node, or null if there is none
             */
            TreeMap.prototype.getNodeAfter = function (key, inclusive) {
                var foundNode = null;
                var node = this.root;
                while ((node != null)) {
                    var c = this.cmp.compare(key, node.getKey());
                    if (inclusive && c === 0) {
                        return node;
                    }
                    if (c >= 0) {
                        node = node.child[TreeMap.RIGHT];
                    }
                    else {
                        foundNode = node;
                        node = node.child[TreeMap.LEFT];
                    }
                }
                ;
                return foundNode;
            };
            /**
             * Returns the last node which is strictly less than the given key.
             *
             * @param key the key to search for
             * @return the previous node, or null if there is none
             */
            TreeMap.prototype.getNodeBefore = function (key, inclusive) {
                var foundNode = null;
                var node = this.root;
                while ((node != null)) {
                    var c = this.cmp.compare(key, node.getKey());
                    if (inclusive && c === 0) {
                        return node;
                    }
                    if (c <= 0) {
                        node = node.child[TreeMap.LEFT];
                    }
                    else {
                        foundNode = node;
                        node = node.child[TreeMap.RIGHT];
                    }
                }
                ;
                return foundNode;
            };
            /**
             * Used for testing. Validate that the tree meets all red-black correctness
             * requirements. These include:
             *
             * <pre>
             * - root is black
             * - no children of a red node may be red
             * - the black height of every path through the three to a leaf is exactly the same
             * </pre>
             *
             * @throws RuntimeException if any correctness errors are detected.
             */
            TreeMap.prototype.assertCorrectness$ = function () {
                this.assertCorrectness(this.root, true);
            };
            TreeMap.prototype.descendingEntryIterator = function () {
                return new TreeMap.DescendingEntryIterator(this);
            };
            TreeMap.prototype.entryIterator = function () {
                return new TreeMap.EntryIterator(this);
            };
            /**
             * Internal helper function for public {@link #assertCorrectness()}.
             *
             * @param tree the subtree to validate.
             * @param isRed true if the parent of this node is red.
             * @return the black height of this subtree.
             * @throws RuntimeException if this RB-tree is not valid.
             */
            TreeMap.prototype.assertCorrectness = function (tree, isRed) {
                var _this = this;
                if (((tree != null && tree instanceof java.util.TreeMap.Node) || tree === null) && ((typeof isRed === 'boolean') || isRed === null)) {
                    return (function () {
                        if (tree == null) {
                            return 0;
                        }
                        if (isRed && tree.isRed) {
                            throw new Error("Two red nodes adjacent");
                        }
                        var leftNode = tree.child[TreeMap.LEFT];
                        if (leftNode != null && _this.cmp.compare(leftNode.getKey(), tree.getKey()) > 0) {
                            throw new Error("Left child " + leftNode + " larger than " + tree);
                        }
                        var rightNode = tree.child[TreeMap.RIGHT];
                        if (rightNode != null && _this.cmp.compare(rightNode.getKey(), tree.getKey()) < 0) {
                            throw new Error("Right child " + rightNode + " smaller than " + tree);
                        }
                        var leftHeight = _this.assertCorrectness(leftNode, tree.isRed);
                        var rightHeight = _this.assertCorrectness(rightNode, tree.isRed);
                        if (leftHeight !== 0 && rightHeight !== 0 && leftHeight !== rightHeight) {
                            throw new Error("Black heights don\'t match");
                        }
                        return tree.isRed ? leftHeight : leftHeight + 1;
                    })();
                }
                else if (tree === undefined && isRed === undefined) {
                    return this.assertCorrectness$();
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Finds an entry given a key and returns the node.
             *
             * @param key the search key
             * @return the node matching the key or null
             */
            TreeMap.prototype.getEntry = function (key) {
                var tree = this.root;
                while ((tree != null)) {
                    var c = this.cmp.compare(key, tree.getKey());
                    if (c === 0) {
                        return tree;
                    }
                    var childNum = c < 0 ? TreeMap.LEFT : TreeMap.RIGHT;
                    tree = tree.child[childNum];
                }
                ;
                return null;
            };
            /**
             * Returns the left-most node of the tree, or null if empty.
             */
            TreeMap.prototype.getFirstEntry = function () {
                if (this.root == null) {
                    return null;
                }
                var node = this.root;
                var nextNode;
                while (((nextNode = node.child[TreeMap.LEFT]) != null)) {
                    node = nextNode;
                }
                ;
                return node;
            };
            /**
             * Returns the right-most node of the tree, or null if empty.
             */
            TreeMap.prototype.getLastEntry = function () {
                if (this.root == null) {
                    return null;
                }
                var node = this.root;
                var nextNode;
                while (((nextNode = node.child[TreeMap.RIGHT]) != null)) {
                    node = nextNode;
                }
                ;
                return node;
            };
            TreeMap.prototype.getCeilingEntry = function (key) {
                return this.getNodeAfter(key, true);
            };
            TreeMap.prototype.getFloorEntry = function (key) {
                return this.getNodeBefore(key, true);
            };
            TreeMap.prototype.getHigherEntry = function (key) {
                return this.getNodeAfter(key, false);
            };
            TreeMap.prototype.getLowerEntry = function (key) {
                return this.getNodeBefore(key, false);
            };
            TreeMap.prototype.removeEntry = function (entry) {
                var state = new TreeMap.State();
                state.matchValue = true;
                state.value = entry.getValue();
                return this.removeWithState(entry.getKey(), state);
            };
            TreeMap.prototype.inOrderAdd = function (list, type, current, fromKey, fromInclusive, toKey, toInclusive) {
                if (current == null) {
                    return;
                }
                var leftNode = current.child[TreeMap.LEFT];
                if (leftNode != null) {
                    this.inOrderAdd(list, type, leftNode, fromKey, fromInclusive, toKey, toInclusive);
                }
                if (this.inRange(type, current.getKey(), fromKey, fromInclusive, toKey, toInclusive)) {
                    list.add(current);
                }
                var rightNode = current.child[TreeMap.RIGHT];
                if (rightNode != null) {
                    this.inOrderAdd(list, type, rightNode, fromKey, fromInclusive, toKey, toInclusive);
                }
            };
            TreeMap.prototype.inRange = function (type, key, fromKey, fromInclusive, toKey, toInclusive) {
                if (type.fromKeyValid() && this.smaller(key, fromKey, !fromInclusive)) {
                    return false;
                }
                if (type.toKeyValid() && this.larger(key, toKey, !toInclusive)) {
                    return false;
                }
                return true;
            };
            /**
             * Insert a node into a subtree, collecting state about the insertion.
             *
             * If the same key already exists, the value of the node is overwritten with
             * the value from the new node instead.
             *
             * @param tree subtree to insert into
             * @param newNode new node to insert
             * @param state result of the insertion: state.found true if the key already
             * existed in the tree state.value the old value if the key existed
             * @return the new subtree root
             */
            TreeMap.prototype.insert = function (tree, newNode, state) {
                if (tree == null) {
                    return newNode;
                }
                else {
                    var c = this.cmp.compare(newNode.getKey(), tree.getKey());
                    if (c === 0) {
                        state.value = tree.setValue(newNode.getValue());
                        state.found = true;
                        return tree;
                    }
                    var childNum = c < 0 ? TreeMap.LEFT : TreeMap.RIGHT;
                    tree.child[childNum] = this.insert(tree.child[childNum], newNode, state);
                    if (this.isRed(tree.child[childNum])) {
                        if (this.isRed(tree.child[TreeMap.otherChild(childNum)])) {
                            tree.isRed = true;
                            tree.child[TreeMap.LEFT].isRed = false;
                            tree.child[TreeMap.RIGHT].isRed = false;
                        }
                        else {
                            if (this.isRed(tree.child[childNum].child[childNum])) {
                                tree = this.rotateSingle(tree, TreeMap.otherChild(childNum));
                            }
                            else if (this.isRed(tree.child[childNum].child[TreeMap.otherChild(childNum)])) {
                                tree = this.rotateDouble(tree, TreeMap.otherChild(childNum));
                            }
                        }
                    }
                }
                return tree;
            };
            /**
             * Returns true if <code>node</code> is red. Note that null pointers are
             * considered black.
             */
            TreeMap.prototype.isRed = function (node) {
                return node != null && node.isRed;
            };
            /**
             * Returns true if <code>a</code> is greater than or equal to <code>b</code>.
             */
            TreeMap.prototype.larger = function (a, b, orEqual) {
                var compare = this.cmp.compare(a, b);
                return compare > 0 || (orEqual && compare === 0);
            };
            /**
             * Returns true if <code>a</code> is less than or equal to <code>b</code>.
             */
            TreeMap.prototype.smaller = function (a, b, orEqual) {
                var compare = this.cmp.compare(a, b);
                return compare < 0 || (orEqual && compare === 0);
            };
            /**
             * Remove a key from the tree, returning whether it was found and its value.
             *
             * @param key key to remove
             * @param state return state, not null
             * @return true if the value was found
             */
            TreeMap.prototype.removeWithState = function (key, state) {
                if (this.root == null) {
                    return false;
                }
                var found = null;
                var parent = null;
                var head = new TreeMap.Node(null, null);
                var dir = TreeMap.RIGHT;
                head.child[TreeMap.RIGHT] = this.root;
                var node = head;
                while ((node.child[dir] != null)) {
                    var last = dir;
                    var grandparent = parent;
                    parent = node;
                    node = node.child[dir];
                    var c = this.cmp.compare(key, node.getKey());
                    dir = c < 0 ? TreeMap.LEFT : TreeMap.RIGHT;
                    if (c === 0 && (!state.matchValue || java.util.Objects.equals(node.getValue(), state.value))) {
                        found = node;
                    }
                    if (!this.isRed(node) && !this.isRed(node.child[dir])) {
                        if (this.isRed(node.child[TreeMap.otherChild(dir)])) {
                            parent = parent.child[last] = this.rotateSingle(node, dir);
                        }
                        else if (!this.isRed(node.child[TreeMap.otherChild(dir)])) {
                            var sibling = parent.child[TreeMap.otherChild(last)];
                            if (sibling != null) {
                                if (!this.isRed(sibling.child[TreeMap.otherChild(last)]) && !this.isRed(sibling.child[last])) {
                                    parent.isRed = false;
                                    sibling.isRed = true;
                                    node.isRed = true;
                                }
                                else {
                                    var dir2 = grandparent.child[TreeMap.RIGHT] === parent ? TreeMap.RIGHT : TreeMap.LEFT;
                                    if (this.isRed(sibling.child[last])) {
                                        grandparent.child[dir2] = this.rotateDouble(parent, last);
                                    }
                                    else if (this.isRed(sibling.child[TreeMap.otherChild(last)])) {
                                        grandparent.child[dir2] = this.rotateSingle(parent, last);
                                    }
                                    node.isRed = grandparent.child[dir2].isRed = true;
                                    grandparent.child[dir2].child[TreeMap.LEFT].isRed = false;
                                    grandparent.child[dir2].child[TreeMap.RIGHT].isRed = false;
                                }
                            }
                        }
                    }
                }
                ;
                if (found != null) {
                    state.found = true;
                    state.value = found.getValue();
                    if (node !== found) {
                        var newNode = new TreeMap.Node(node.getKey(), node.getValue());
                        this.replaceNode(head, found, newNode);
                        if (parent === found) {
                            parent = newNode;
                        }
                    }
                    parent.child[parent.child[TreeMap.RIGHT] === node ? TreeMap.RIGHT : TreeMap.LEFT] = node.child[node.child[TreeMap.LEFT] == null ? TreeMap.RIGHT : TreeMap.LEFT];
                    this.__size--;
                }
                this.root = head.child[TreeMap.RIGHT];
                if (this.root != null) {
                    this.root.isRed = false;
                }
                return state.found;
            };
            /**
             * replace 'node' with 'newNode' in the tree rooted at 'head'. Could have
             * avoided this traversal if each node maintained a parent pointer.
             */
            TreeMap.prototype.replaceNode = function (head, node, newNode) {
                var parent = head;
                var direction = (parent.getKey() == null || this.cmp.compare(node.getKey(), parent.getKey()) > 0) ? TreeMap.RIGHT : TreeMap.LEFT;
                while ((parent.child[direction] !== node)) {
                    parent = parent.child[direction];
                    direction = this.cmp.compare(node.getKey(), parent.getKey()) > 0 ? TreeMap.RIGHT : TreeMap.LEFT;
                }
                ;
                parent.child[direction] = newNode;
                newNode.isRed = node.isRed;
                newNode.child[TreeMap.LEFT] = node.child[TreeMap.LEFT];
                newNode.child[TreeMap.RIGHT] = node.child[TreeMap.RIGHT];
                node.child[TreeMap.LEFT] = null;
                node.child[TreeMap.RIGHT] = null;
            };
            /**
             * Perform a double rotation, first rotating the child which will become the
             * root in the opposite direction, then rotating the root in the specified
             * direction.
             *
             * <pre>
             * A                                               F
             * B   C    becomes (with rotateDirection=0)       A   C
             * D E F G                                         B E   G
             * D
             * </pre>
             *
             * @param tree root of the subtree to rotate
             * @param rotateDirection the direction to rotate: 0=left, 1=right
             * @return the new root of the rotated subtree
             */
            TreeMap.prototype.rotateDouble = function (tree, rotateDirection) {
                var otherChildDir = TreeMap.otherChild(rotateDirection);
                tree.child[otherChildDir] = this.rotateSingle(tree.child[otherChildDir], otherChildDir);
                return this.rotateSingle(tree, rotateDirection);
            };
            /**
             * Perform a single rotation, pushing the root of the subtree to the specified
             * direction.
             *
             * <pre>
             * A                                              B
             * B   C     becomes (with rotateDirection=1)     D   A
             * D E                                              E   C
             * </pre>
             *
             * @param tree the root of the subtree to rotate
             * @param rotateDirection the direction to rotate: 0=left rotation, 1=right
             * @return the new root of the rotated subtree
             */
            TreeMap.prototype.rotateSingle = function (tree, rotateDirection) {
                var otherChildDir = TreeMap.otherChild(rotateDirection);
                var save = tree.child[otherChildDir];
                tree.child[otherChildDir] = save.child[rotateDirection];
                save.child[rotateDirection] = tree;
                tree.isRed = true;
                save.isRed = false;
                return save;
            };
            TreeMap.LEFT = 0;
            TreeMap.RIGHT = 1;
            return TreeMap;
        }(java.util.AbstractNavigableMap));
        util.TreeMap = TreeMap;
        var TreeMap;
        (function (TreeMap) {
            /**
             * Iterator for <code>descendingMap().entrySet()</code>.
             */
            var DescendingEntryIterator = (function () {
                /**
                 * Create an iterator which may return only a restricted range.
                 *
                 * @param fromKey the first key to return in the iterator.
                 * @param toKey the upper bound of keys to return.
                 */
                function DescendingEntryIterator(__parent, type, fromKey, fromInclusive, toKey, toInclusive) {
                    if (type === void 0) { type = java.util.TreeMap.SubMapType_All_$LI$(); }
                    if (fromKey === void 0) { fromKey = null; }
                    if (fromInclusive === void 0) { fromInclusive = false; }
                    if (toKey === void 0) { toKey = null; }
                    if (toInclusive === void 0) { toInclusive = false; }
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Iterator"] });
                    this.__parent = __parent;
                    var list = new java.util.ArrayList();
                    this.__parent.inOrderAdd(list, type, this.__parent.root, fromKey, fromInclusive, toKey, toInclusive);
                    this.iter = list.listIterator(list.size());
                }
                DescendingEntryIterator.prototype.forEachRemaining = function (consumer) {
                    javaemul.internal.InternalPreconditions.checkNotNull(consumer);
                    while ((this.hasNext())) {
                        consumer(this.next());
                    }
                    ;
                };
                DescendingEntryIterator.prototype.hasNext = function () {
                    return this.iter.hasPrevious();
                };
                DescendingEntryIterator.prototype.next = function () {
                    return this.last = this.iter.previous();
                };
                DescendingEntryIterator.prototype.remove = function () {
                    this.iter.remove();
                    this.__parent.removeEntry(this.last);
                    this.last = null;
                };
                return DescendingEntryIterator;
            }());
            TreeMap.DescendingEntryIterator = DescendingEntryIterator;
            /**
             * Iterator for <code>EntrySet</code>.
             */
            var EntryIterator = (function () {
                /**
                 * Create an iterator which may return only a restricted range.
                 *
                 * @param fromKey the first key to return in the iterator.
                 * @param toKey the upper bound of keys to return.
                 */
                function EntryIterator(__parent, type, fromKey, fromInclusive, toKey, toInclusive) {
                    if (type === void 0) { type = java.util.TreeMap.SubMapType_All_$LI$(); }
                    if (fromKey === void 0) { fromKey = null; }
                    if (fromInclusive === void 0) { fromInclusive = false; }
                    if (toKey === void 0) { toKey = null; }
                    if (toInclusive === void 0) { toInclusive = false; }
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Iterator"] });
                    this.__parent = __parent;
                    var list = new java.util.ArrayList();
                    this.__parent.inOrderAdd(list, type, this.__parent.root, fromKey, fromInclusive, toKey, toInclusive);
                    this.iter = list.listIterator();
                }
                EntryIterator.prototype.forEachRemaining = function (consumer) {
                    javaemul.internal.InternalPreconditions.checkNotNull(consumer);
                    while ((this.hasNext())) {
                        consumer(this.next());
                    }
                    ;
                };
                EntryIterator.prototype.hasNext = function () {
                    return this.iter.hasNext();
                };
                EntryIterator.prototype.next = function () {
                    return this.last = this.iter.next();
                };
                EntryIterator.prototype.remove = function () {
                    this.iter.remove();
                    this.__parent.removeEntry(this.last);
                    this.last = null;
                };
                return EntryIterator;
            }());
            TreeMap.EntryIterator = EntryIterator;
            var EntrySet = (function (_super) {
                __extends(EntrySet, _super);
                function EntrySet(__parent) {
                    _super.call(this, __parent);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Collection", "java.util.Set", "java.lang.Iterable"] });
                    this.__parent = __parent;
                }
                EntrySet.prototype.clear = function () {
                    this.__parent.clear();
                };
                return EntrySet;
            }(java.util.AbstractNavigableMap.EntrySet));
            TreeMap.EntrySet = EntrySet;
            /**
             * Tree node.
             *
             * @param <K> key type
             * @param <V> value type
             */
            var Node = (function (_super) {
                __extends(Node, _super);
                /**
                 * Create a node of the specified color.
                 *
                 * @param key
                 * @param value
                 * @param isRed true if this should be a red node, false for black
                 */
                function Node(key, value, isRed) {
                    if (isRed === void 0) { isRed = true; }
                    _super.call(this, key, value);
                    this.child = new Array(2);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Map.Entry"] });
                    this.isRed = false;
                    this.isRed = isRed;
                }
                return Node;
            }(util.AbstractMap.SimpleEntry));
            TreeMap.Node = Node;
            /**
             * A state object which is passed down the tree for both insert and remove.
             * All uses make use of the done flag to indicate when no further rebalancing
             * of the tree is required. Remove methods use the found flag to indicate when
             * the desired key has been found. value is used both to return the value of a
             * removed node as well as to pass in a value which must match (used for
             * entrySet().remove(entry)), and the matchValue flag is used to request this
             * behavior.
             *
             * @param <V> value type
             */
            var State = (function () {
                function State() {
                    this.done = false;
                    this.found = false;
                    this.matchValue = false;
                }
                State.prototype.toString = function () {
                    return "State: mv=" + this.matchValue + " value=" + this.value + " done=" + this.done + " found=" + this.found;
                };
                return State;
            }());
            TreeMap.State = State;
            var SubMap = (function (_super) {
                __extends(SubMap, _super);
                function SubMap(__parent, type, fromKey, fromInclusive, toKey, toInclusive) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Map", "java.util.NavigableMap", "java.util.SortedMap"] });
                    this.__parent = __parent;
                    this.fromInclusive = false;
                    this.toInclusive = false;
                    if (type === java.util.TreeMap.SubMapType_Range_$LI$()) {
                        if (this.__parent.cmp.compare(toKey, fromKey) < 0) {
                            throw new java.lang.IllegalArgumentException("subMap: " + toKey + " less than " + fromKey);
                        }
                    }
                    if (type === java.util.TreeMap.SubMapType_Head_$LI$()) {
                        this.__parent.cmp.compare(toKey, toKey);
                    }
                    if (type === java.util.TreeMap.SubMapType_Tail_$LI$()) {
                        this.__parent.cmp.compare(fromKey, fromKey);
                    }
                    if (type === java.util.TreeMap.SubMapType_All_$LI$()) {
                    }
                    this.type = type;
                    this.fromKey = fromKey;
                    this.fromInclusive = fromInclusive;
                    this.toKey = toKey;
                    this.toInclusive = toInclusive;
                }
                SubMap.prototype.comparator = function () {
                    return this.__parent.comparator();
                };
                SubMap.prototype.entrySet = function () {
                    return new SubMap.SubMap$0(this);
                };
                SubMap.prototype.headMap = function (toKey, toInclusive) {
                    var _this = this;
                    if (((toKey != null) || toKey === null) && ((typeof toInclusive === 'boolean') || toInclusive === null)) {
                        return (function () {
                            if (_this.type.toKeyValid() && _this.__parent.cmp.compare(toKey, _this.toKey) > 0) {
                                throw new java.lang.IllegalArgumentException("subMap: " + toKey + " greater than " + _this.toKey);
                            }
                            if (_this.type.fromKeyValid()) {
                                return _this.__parent.subMap(_this.fromKey, _this.fromInclusive, toKey, toInclusive);
                            }
                            else {
                                return _this.__parent.headMap(toKey, toInclusive);
                            }
                        })();
                    }
                    else if (((toKey != null) || toKey === null) && toInclusive === undefined) {
                        return this.headMap$java_lang_Object(toKey);
                    }
                    else
                        throw new Error('invalid overload');
                };
                SubMap.prototype.isEmpty = function () {
                    return this.getFirstEntry() == null;
                };
                SubMap.prototype.put = function (key, value) {
                    if (((key != null) || key === null) && ((value != null) || value === null)) {
                        return this.put$java_lang_Object$java_lang_Object(key, value);
                    }
                    else
                        throw new Error('invalid overload');
                };
                SubMap.prototype.put$java_lang_Object$java_lang_Object = function (key, value) {
                    if (!this.inRange(key)) {
                        throw new java.lang.IllegalArgumentException(key + " outside the range " + this.fromKey + " to " + this.toKey);
                    }
                    return this.__parent.put(key, value);
                };
                SubMap.prototype.remove = function (k) {
                    var key = k;
                    if (!this.inRange(key)) {
                        return null;
                    }
                    return this.__parent.remove(key);
                };
                SubMap.prototype.size = function () {
                    var count = 0;
                    for (var it = this.entryIterator(); it.hasNext(); it.next()) {
                        count++;
                    }
                    return count;
                };
                SubMap.prototype.subMap = function (newFromKey, newFromInclusive, newToKey, newToInclusive) {
                    var _this = this;
                    if (((newFromKey != null) || newFromKey === null) && ((typeof newFromInclusive === 'boolean') || newFromInclusive === null) && ((newToKey != null) || newToKey === null) && ((typeof newToInclusive === 'boolean') || newToInclusive === null)) {
                        return (function () {
                            if (_this.type.fromKeyValid() && _this.__parent.cmp.compare(newFromKey, _this.fromKey) < 0) {
                                throw new java.lang.IllegalArgumentException("subMap: " + newFromKey + " less than " + _this.fromKey);
                            }
                            if (_this.type.toKeyValid() && _this.__parent.cmp.compare(newToKey, _this.toKey) > 0) {
                                throw new java.lang.IllegalArgumentException("subMap: " + newToKey + " greater than " + _this.toKey);
                            }
                            return _this.__parent.subMap(newFromKey, newFromInclusive, newToKey, newToInclusive);
                        })();
                    }
                    else if (((newFromKey != null) || newFromKey === null) && ((newFromInclusive != null) || newFromInclusive === null) && newToKey === undefined && newToInclusive === undefined) {
                        return this.subMap$java_lang_Object$java_lang_Object(newFromKey, newFromInclusive);
                    }
                    else
                        throw new Error('invalid overload');
                };
                SubMap.prototype.tailMap = function (fromKey, fromInclusive) {
                    var _this = this;
                    if (((fromKey != null) || fromKey === null) && ((typeof fromInclusive === 'boolean') || fromInclusive === null)) {
                        return (function () {
                            if (_this.type.fromKeyValid() && _this.__parent.cmp.compare(fromKey, _this.fromKey) < 0) {
                                throw new java.lang.IllegalArgumentException("subMap: " + fromKey + " less than " + _this.fromKey);
                            }
                            if (_this.type.toKeyValid()) {
                                return _this.__parent.subMap(fromKey, fromInclusive, _this.toKey, _this.toInclusive);
                            }
                            else {
                                return _this.__parent.tailMap(fromKey, fromInclusive);
                            }
                        })();
                    }
                    else if (((fromKey != null) || fromKey === null) && fromInclusive === undefined) {
                        return this.tailMap$java_lang_Object(fromKey);
                    }
                    else
                        throw new Error('invalid overload');
                };
                SubMap.prototype.descendingEntryIterator = function () {
                    return new TreeMap.DescendingEntryIterator(this.__parent, this.type, this.fromKey, this.fromInclusive, this.toKey, this.toInclusive);
                };
                SubMap.prototype.entryIterator = function () {
                    return new TreeMap.EntryIterator(this.__parent, this.type, this.fromKey, this.fromInclusive, this.toKey, this.toInclusive);
                };
                SubMap.prototype.getEntry = function (key) {
                    return this.guardInRange(this.__parent.getEntry(key));
                };
                SubMap.prototype.getFirstEntry = function () {
                    var entry;
                    if (this.type.fromKeyValid()) {
                        if (this.fromInclusive) {
                            entry = this.__parent.getCeilingEntry(this.fromKey);
                        }
                        else {
                            entry = this.__parent.getHigherEntry(this.fromKey);
                        }
                    }
                    else {
                        entry = this.__parent.getFirstEntry();
                    }
                    return this.guardInRange(entry);
                };
                SubMap.prototype.getLastEntry = function () {
                    var entry;
                    if (this.type.toKeyValid()) {
                        if (this.toInclusive) {
                            entry = this.__parent.getFloorEntry(this.toKey);
                        }
                        else {
                            entry = this.__parent.getLowerEntry(this.toKey);
                        }
                    }
                    else {
                        entry = this.__parent.getLastEntry();
                    }
                    return this.guardInRange(entry);
                };
                SubMap.prototype.getCeilingEntry = function (key) {
                    return this.guardInRange(this.__parent.getCeilingEntry(key));
                };
                SubMap.prototype.getFloorEntry = function (key) {
                    return this.guardInRange(this.__parent.getFloorEntry(key));
                };
                SubMap.prototype.getHigherEntry = function (key) {
                    return this.guardInRange(this.__parent.getHigherEntry(key));
                };
                SubMap.prototype.getLowerEntry = function (key) {
                    return this.guardInRange(this.__parent.getLowerEntry(key));
                };
                SubMap.prototype.removeEntry = function (entry) {
                    return this.inRange(entry.getKey()) && this.__parent.removeEntry(entry);
                };
                SubMap.prototype.guardInRange = function (entry) {
                    return entry != null && this.inRange(entry.getKey()) ? entry : null;
                };
                SubMap.prototype.inRange = function (key) {
                    return this.__parent.inRange(this.type, key, this.fromKey, this.fromInclusive, this.toKey, this.toInclusive);
                };
                return SubMap;
            }(java.util.AbstractNavigableMap));
            TreeMap.SubMap = SubMap;
            var SubMap;
            (function (SubMap) {
                var SubMap$0 = (function (_super) {
                    __extends(SubMap$0, _super);
                    function SubMap$0(__parent) {
                        _super.call(this, __parent);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Collection", "java.util.Set", "java.lang.Iterable"] });
                        this.__parent = __parent;
                    }
                    SubMap$0.prototype.isEmpty = function () {
                        return this.__parent.isEmpty();
                    };
                    return SubMap$0;
                }(TreeMap.SubMap.EntrySet));
                SubMap.SubMap$0 = SubMap$0;
            })(SubMap = TreeMap.SubMap || (TreeMap.SubMap = {}));
            var SubMapType = (function () {
                function SubMapType() {
                }
                /**
                 * Returns true if this submap type uses a from-key.
                 */
                SubMapType.prototype.fromKeyValid = function () {
                    return false;
                };
                /**
                 * Returns true if this submap type uses a to-key.
                 */
                SubMapType.prototype.toKeyValid = function () {
                    return false;
                };
                return SubMapType;
            }());
            TreeMap.SubMapType = SubMapType;
            var SubMapTypeHead = (function (_super) {
                __extends(SubMapTypeHead, _super);
                function SubMapTypeHead() {
                    _super.apply(this, arguments);
                }
                SubMapTypeHead.prototype.toKeyValid = function () {
                    return true;
                };
                return SubMapTypeHead;
            }(TreeMap.SubMapType));
            TreeMap.SubMapTypeHead = SubMapTypeHead;
            var SubMapTypeRange = (function (_super) {
                __extends(SubMapTypeRange, _super);
                function SubMapTypeRange() {
                    _super.apply(this, arguments);
                }
                SubMapTypeRange.prototype.fromKeyValid = function () {
                    return true;
                };
                SubMapTypeRange.prototype.toKeyValid = function () {
                    return true;
                };
                return SubMapTypeRange;
            }(TreeMap.SubMapType));
            TreeMap.SubMapTypeRange = SubMapTypeRange;
            var SubMapTypeTail = (function (_super) {
                __extends(SubMapTypeTail, _super);
                function SubMapTypeTail() {
                    _super.apply(this, arguments);
                }
                SubMapTypeTail.prototype.fromKeyValid = function () {
                    return true;
                };
                return SubMapTypeTail;
            }(TreeMap.SubMapType));
            TreeMap.SubMapTypeTail = SubMapTypeTail;
        })(TreeMap = util.TreeMap || (util.TreeMap = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
"Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org";
var java;
(function (java) {
    var util;
    (function (util) {
        /**
         * Hash table implementation of the Map interface with predictable iteration
         * order. <a href=
         * "http://java.sun.com/j2se/1.5.0/docs/api/java/util/LinkedHashMap.html">[Sun
         * docs]</a>
         *
         * @param <K>
         * key type.
         * @param <V>
         * value type.
         */
        var LinkedHashMap = (function (_super) {
            __extends(LinkedHashMap, _super);
            function LinkedHashMap(ignored, alsoIgnored, accessOrder) {
                var _this = this;
                if (((typeof ignored === 'number') || ignored === null) && ((typeof alsoIgnored === 'number') || alsoIgnored === null) && ((typeof accessOrder === 'boolean') || accessOrder === null)) {
                    _super.call(this, ignored, alsoIgnored);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.util.Map", "java.io.Serializable"] });
                    this.accessOrder = false;
                    (function () {
                        _this.head = new LinkedHashMap.ChainEntry(_this);
                        _this.map = new java.util.HashMap();
                        _this.accessOrder = accessOrder;
                        _this.resetChainEntries();
                    })();
                }
                else if (((typeof ignored === 'number') || ignored === null) && ((typeof alsoIgnored === 'number') || alsoIgnored === null) && accessOrder === undefined) {
                    _super.call(this, ignored, alsoIgnored);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.util.Map", "java.io.Serializable"] });
                    this.accessOrder = false;
                    (function () {
                        _this.head = new LinkedHashMap.ChainEntry(_this);
                        _this.map = new java.util.HashMap();
                        _this.resetChainEntries();
                    })();
                }
                else if (((ignored != null && ignored["__interfaces"] != null && ignored["__interfaces"].indexOf("java.util.Map") >= 0) || ignored === null) && alsoIgnored === undefined && accessOrder === undefined) {
                    var toBeCopied = ignored;
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.util.Map", "java.io.Serializable"] });
                    this.accessOrder = false;
                    (function () {
                        _this.head = new LinkedHashMap.ChainEntry(_this);
                        _this.map = new java.util.HashMap();
                        _this.resetChainEntries();
                        _this.putAll(toBeCopied);
                    })();
                }
                else if (((typeof ignored === 'number') || ignored === null) && alsoIgnored === undefined && accessOrder === undefined) {
                    {
                        var alsoIgnored = 0;
                        _super.call(this, ignored, alsoIgnored);
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.util.Map", "java.io.Serializable"] });
                        this.accessOrder = false;
                        (function () {
                            _this.head = new LinkedHashMap.ChainEntry(_this);
                            _this.map = new java.util.HashMap();
                            _this.resetChainEntries();
                        })();
                    }
                    (function () {
                    })();
                }
                else if (ignored === undefined && alsoIgnored === undefined && accessOrder === undefined) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.lang.Cloneable", "java.util.Map", "java.io.Serializable"] });
                    this.accessOrder = false;
                    (function () {
                        _this.head = new LinkedHashMap.ChainEntry(_this);
                        _this.map = new java.util.HashMap();
                        _this.resetChainEntries();
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            LinkedHashMap.prototype.clear = function () {
                this.map.clear();
                this.resetChainEntries();
            };
            LinkedHashMap.prototype.resetChainEntries = function () {
                this.head.prev = this.head;
                this.head.next = this.head;
            };
            LinkedHashMap.prototype.clone = function () {
                return new LinkedHashMap(this);
            };
            LinkedHashMap.prototype.containsKey = function (key) {
                return this.map.containsKey(key);
            };
            LinkedHashMap.prototype.containsValue = function (value) {
                var node = this.head.next;
                while ((node !== this.head)) {
                    if (java.util.Objects.equals(node.getValue(), value)) {
                        return true;
                    }
                    node = node.next;
                }
                ;
                return false;
            };
            LinkedHashMap.prototype.entrySet = function () {
                return new LinkedHashMap.EntrySet(this);
            };
            LinkedHashMap.prototype.get = function (key) {
                var entry = this.map.get(key);
                if (entry != null) {
                    this.recordAccess(entry);
                    return entry.getValue();
                }
                return null;
            };
            LinkedHashMap.prototype.put = function (key, value) {
                if (((key != null) || key === null) && ((value != null) || value === null)) {
                    return this.put$java_lang_Object$java_lang_Object(key, value);
                }
                else
                    throw new Error('invalid overload');
            };
            LinkedHashMap.prototype.put$java_lang_Object$java_lang_Object = function (key, value) {
                var old = this.map.get(key);
                if (old == null) {
                    var newEntry = new LinkedHashMap.ChainEntry(this, key, value);
                    this.map.put(key, newEntry);
                    newEntry.addToEnd();
                    var eldest = this.head.next;
                    if (this.removeEldestEntry(eldest)) {
                        eldest.remove();
                        this.map.remove(eldest.getKey());
                    }
                    return null;
                }
                else {
                    var oldValue = old.setValue(value);
                    this.recordAccess(old);
                    return oldValue;
                }
            };
            LinkedHashMap.prototype.remove = function (key) {
                var entry = this.map.remove(key);
                if (entry != null) {
                    entry.remove();
                    return entry.getValue();
                }
                return null;
            };
            LinkedHashMap.prototype.size = function () {
                return this.map.size();
            };
            LinkedHashMap.prototype.removeEldestEntry = function (eldest) {
                return false;
            };
            LinkedHashMap.prototype.recordAccess = function (entry) {
                if (this.accessOrder) {
                    entry.remove();
                    entry.addToEnd();
                }
            };
            return LinkedHashMap;
        }(java.util.HashMap));
        util.LinkedHashMap = LinkedHashMap;
        var LinkedHashMap;
        (function (LinkedHashMap) {
            /**
             * The entry we use includes next/prev pointers for a doubly-linked circular
             * list with a head node. This reduces the special cases we have to deal
             * with in the list operations.
             *
             * Note that we duplicate the key from the underlying hash map so we can
             * find the eldest entry. The alternative would have been to modify HashMap
             * so more of the code was directly usable here, but this would have added
             * some overhead to HashMap, or to reimplement most of the HashMap code here
             * with small modifications. Paying a small storage cost only if you use
             * LinkedHashMap and minimizing code size seemed like a better tradeoff
             */
            var ChainEntry = (function (_super) {
                __extends(ChainEntry, _super);
                function ChainEntry(__parent, key, value) {
                    if (key === void 0) { key = null; }
                    if (value === void 0) { value = null; }
                    _super.call(this, key, value);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Map.Entry"] });
                    this.__parent = __parent;
                }
                /**
                 * Add this node to the end of the chain.
                 */
                ChainEntry.prototype.addToEnd = function () {
                    var tail = this.__parent.head.prev;
                    this.prev = tail;
                    this.next = this.__parent.head;
                    tail.next = this.__parent.head.prev = this;
                };
                /**
                 * Remove this node from any list it may be a part of.
                 */
                ChainEntry.prototype.remove = function () {
                    this.next.prev = this.prev;
                    this.prev.next = this.next;
                    this.next = this.prev = null;
                };
                return ChainEntry;
            }(util.AbstractMap.SimpleEntry));
            LinkedHashMap.ChainEntry = ChainEntry;
            var EntrySet = (function (_super) {
                __extends(EntrySet, _super);
                function EntrySet(__parent) {
                    _super.call(this);
                    Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Collection", "java.util.Set", "java.lang.Iterable"] });
                    this.__parent = __parent;
                }
                EntrySet.prototype.clear = function () {
                    this.__parent.clear();
                };
                EntrySet.prototype.contains = function (o) {
                    if (o != null && o["__interfaces"] != null && o["__interfaces"].indexOf("java.util.Map.Entry") >= 0) {
                        return this.__parent.containsEntry(o);
                    }
                    return false;
                };
                EntrySet.prototype.iterator = function () {
                    return new EntrySet.EntryIterator(this);
                };
                EntrySet.prototype.remove = function (index) {
                    if (((index != null) || index === null)) {
                        return this.remove$java_lang_Object(index);
                    }
                    else
                        throw new Error('invalid overload');
                };
                EntrySet.prototype.remove$java_lang_Object = function (entry) {
                    if (this.contains(entry)) {
                        var key = entry.getKey();
                        this.__parent.remove(key);
                        return true;
                    }
                    return false;
                };
                EntrySet.prototype.size = function () {
                    return this.__parent.size();
                };
                return EntrySet;
            }(java.util.AbstractSet));
            LinkedHashMap.EntrySet = EntrySet;
            var EntrySet;
            (function (EntrySet) {
                var EntryIterator = (function () {
                    function EntryIterator(__parent) {
                        Object.defineProperty(this, '__interfaces', { configurable: true, value: ["java.util.Iterator"] });
                        this.__parent = __parent;
                        this.__next = this.__parent.__parent.head.next;
                        java.util.ConcurrentModificationDetector.recordLastKnownStructure(this.__parent.__parent.map, this);
                    }
                    EntryIterator.prototype.forEachRemaining = function (consumer) {
                        javaemul.internal.InternalPreconditions.checkNotNull(consumer);
                        while ((this.hasNext())) {
                            consumer(this.next());
                        }
                        ;
                    };
                    EntryIterator.prototype.hasNext = function () {
                        return this.__next !== this.__parent.__parent.head;
                    };
                    EntryIterator.prototype.next = function () {
                        java.util.ConcurrentModificationDetector.checkStructuralChange(this.__parent.__parent.map, this);
                        javaemul.internal.InternalPreconditions.checkCriticalElement(this.hasNext());
                        this.last = this.__next;
                        this.__next = this.__next.next;
                        return this.last;
                    };
                    EntryIterator.prototype.remove = function () {
                        javaemul.internal.InternalPreconditions.checkState(this.last != null);
                        java.util.ConcurrentModificationDetector.checkStructuralChange(this.__parent.__parent.map, this);
                        this.last.remove();
                        this.__parent.__parent.map.remove(this.last.getKey());
                        java.util.ConcurrentModificationDetector.recordLastKnownStructure(this.__parent.__parent.map, this);
                        this.last = null;
                    };
                    return EntryIterator;
                }());
                EntrySet.EntryIterator = EntryIterator;
            })(EntrySet = LinkedHashMap.EntrySet || (LinkedHashMap.EntrySet = {}));
        })(LinkedHashMap = util.LinkedHashMap || (util.LinkedHashMap = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
java.util.TreeMap.SubMapType_Tail_$LI$();
java.util.TreeMap.SubMapType_Range_$LI$();
java.util.TreeMap.SubMapType_Head_$LI$();
java.util.TreeMap.SubMapType_All_$LI$();
javaemul.internal.InternalPreconditions.BOUND_CHECK_$LI$();
javaemul.internal.InternalPreconditions.API_CHECK_$LI$();
javaemul.internal.InternalPreconditions.TYPE_CHECK_$LI$();
javaemul.internal.InternalPreconditions.CHECKED_MODE_$LI$();
java.util.logging.Logger.LOGGING_FALSE_$LI$();
java.util.logging.Logger.LOGGING_SEVERE_$LI$();
java.util.logging.Logger.LOGGING_WARNING_$LI$();
java.util.logging.Logger.LOGGING_ENABLED_$LI$();
java.util.logging.Logger.__static_initialize();
java.util.ConcurrentModificationDetector.API_CHECK_$LI$();
java.io.File.TempDirectory.tmpdir_$LI$();
java.io.File.pathSeparator_$LI$();
java.io.File.pathSeparatorChar_$LI$();
java.io.File.separator_$LI$();
java.io.File.separatorChar_$LI$();
java.io.File.fs_$LI$();
java.util.Collections.RandomHolder.rnd_$LI$();
java.util.Collections.ReverseComparator.INSTANCE_$LI$();
java.util.Collections.EmptyListIterator.INSTANCE_$LI$();
java.util.Collections.EMPTY_SET_$LI$();
java.util.Collections.EMPTY_MAP_$LI$();
java.util.Collections.EMPTY_LIST_$LI$();
java.awt.geom.Area.EmptyCurves_$LI$();
java.lang.System.out_$LI$();
java.lang.System.err_$LI$();
java.nio.charset.StandardCharsets.UTF_8_$LI$();
java.nio.charset.StandardCharsets.ISO_8859_1_$LI$();
java.applet.Applet.__static_initialize();
sun.awt.geom.AreaOp.EmptyChainList_$LI$();
sun.awt.geom.AreaOp.EmptyLinkList_$LI$();
sun.awt.geom.AreaOp.YXTopComparator_$LI$();
javaemul.internal.ShortHelper.BoxedValues.boxedValues_$LI$();
javaemul.internal.ShortHelper.TYPE_$LI$();
javaemul.internal.ShortHelper.MAX_VALUE_$LI$();
javaemul.internal.ShortHelper.MIN_VALUE_$LI$();
javaemul.internal.LongHelper.BoxedValues.boxedValues_$LI$();
javaemul.internal.IntegerHelper.ReverseNibbles.reverseNibbles_$LI$();
javaemul.internal.IntegerHelper.BoxedValues.boxedValues_$LI$();
javaemul.internal.FloatHelper.POSITIVE_INFINITY_$LI$();
javaemul.internal.FloatHelper.NEGATIVE_INFINITY_$LI$();
javaemul.internal.FloatHelper.NaN_$LI$();
javaemul.internal.DoubleHelper.PowersTable.invPowers_$LI$();
javaemul.internal.DoubleHelper.PowersTable.powers_$LI$();
javaemul.internal.DoubleHelper.POSITIVE_INFINITY_$LI$();
javaemul.internal.DoubleHelper.NEGATIVE_INFINITY_$LI$();
javaemul.internal.DoubleHelper.NaN_$LI$();
javaemul.internal.ByteHelper.BoxedValues.boxedValues_$LI$();
javaemul.internal.ByteHelper.TYPE_$LI$();
javaemul.internal.ByteHelper.MAX_VALUE_$LI$();
javaemul.internal.ByteHelper.MIN_VALUE_$LI$();
javaemul.internal.StringHelper.CASE_INSENSITIVE_ORDER_$LI$();
java.security.MessageDigest.Md5Digest.padding_$LI$();
javaemul.internal.EmulatedCharset.ISO_8859_1_$LI$();
javaemul.internal.EmulatedCharset.ISO_LATIN_1_$LI$();
javaemul.internal.EmulatedCharset.UTF_8_$LI$();
java.awt.geom.Path2D.Iterator.curvecoords_$LI$();
java.awt.geom.Path2D.SEG_CLOSE_$LI$();
java.awt.geom.Path2D.SEG_CUBICTO_$LI$();
java.awt.geom.Path2D.SEG_QUADTO_$LI$();
java.awt.geom.Path2D.SEG_LINETO_$LI$();
java.awt.geom.Path2D.SEG_MOVETO_$LI$();
java.awt.geom.Path2D.WIND_NON_ZERO_$LI$();
java.awt.geom.Path2D.WIND_EVEN_ODD_$LI$();
javaemul.internal.StringHashCache.front_$LI$();
javaemul.internal.StringHashCache.back_$LI$();
javaemul.internal.NumberHelper.__ParseLong.maxValueForRadix_$LI$();
javaemul.internal.NumberHelper.__ParseLong.maxLengthForRadix_$LI$();
javaemul.internal.NumberHelper.__ParseLong.maxDigitsRadixPower_$LI$();
javaemul.internal.NumberHelper.__ParseLong.maxDigitsForRadix_$LI$();
javaemul.internal.NumberHelper.__ParseLong.__static_initialize();
javaemul.internal.MathHelper.PI_UNDER_180_$LI$();
javaemul.internal.MathHelper.PI_OVER_180_$LI$();
javaemul.internal.MathHelper.MIN_VALUE_$LI$();
javaemul.internal.MathHelper.MAX_VALUE_$LI$();
javaemul.internal.MathHelper.EPSILON_$LI$();
javaemul.internal.JreHelper.LOG10E_$LI$();
javaemul.internal.CharacterHelper.BoxedValues.boxedValues_$LI$();
javaemul.internal.CharacterHelper.TYPE_$LI$();
javaemul.internal.BooleanHelper.TYPE_$LI$();
java.util.Random.twoToTheXMinus48_$LI$();
java.util.Random.twoToTheXMinus24_$LI$();
java.util.Random.__static_initialize();
java.util.OptionalLong.EMPTY_$LI$();
java.util.OptionalInt.EMPTY_$LI$();
java.util.OptionalDouble.EMPTY_$LI$();
java.util.Optional.EMPTY_$LI$();
java.util.logging.Level.WARNING_$LI$();
java.util.logging.Level.SEVERE_$LI$();
java.util.logging.Level.OFF_$LI$();
java.util.logging.Level.INFO_$LI$();
java.util.logging.Level.FINEST_$LI$();
java.util.logging.Level.FINER_$LI$();
java.util.logging.Level.FINE_$LI$();
java.util.logging.Level.CONFIG_$LI$();
java.util.logging.Level.ALL_$LI$();
java.util.Locale.defaultLocale_$LI$();
java.util.Locale.US_$LI$();
java.util.Locale.ENGLISH_$LI$();
java.util.Locale.ROOT_$LI$();
java.util.InternalJsMapFactory.jsMapCtor_$LI$();
java.util.Date.StringData.MONTHS_$LI$();
java.util.Date.StringData.DAYS_$LI$();
java.util.Date.ONE_HOUR_IN_MILLISECONDS_$LI$();
java.util.Comparators.NATURAL_$LI$();
java.lang.Class.classes_$LI$();
java.lang.Class.constructors_$LI$();
java.io.FileSystem.__static_initialize();
java.awt.geom.RoundRectIterator.types_$LI$();
java.awt.geom.RoundRectIterator.ctrlpts_$LI$();
java.awt.geom.RoundRectIterator.acv_$LI$();
java.awt.geom.RoundRectIterator.cv_$LI$();
java.awt.geom.RoundRectIterator.c_$LI$();
java.awt.geom.RoundRectIterator.b_$LI$();
java.awt.geom.RoundRectIterator.a_$LI$();
java.awt.geom.RoundRectIterator.angle_$LI$();
java.awt.geom.EllipseIterator.ctrlpts_$LI$();
java.awt.geom.EllipseIterator.ncv_$LI$();
java.awt.geom.EllipseIterator.pcv_$LI$();
java.awt.geom.AffineTransform.rot90conversion_$LI$();
java.awt.geom.AffineTransform.HI_SHEAR_$LI$();
java.awt.geom.AffineTransform.HI_SCALE_$LI$();
java.awt.geom.AffineTransform.HI_TRANSLATE_$LI$();
java.awt.geom.AffineTransform.HI_IDENTITY_$LI$();
java.awt.geom.AffineTransform.TYPE_MASK_ROTATION_$LI$();
java.awt.geom.AffineTransform.TYPE_MASK_SCALE_$LI$();
