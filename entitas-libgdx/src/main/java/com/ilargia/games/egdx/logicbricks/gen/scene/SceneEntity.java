package com.ilargia.games.egdx.logicbricks.gen.scene;

import com.ilargia.games.entitas.api.*;
import com.ilargia.games.entitas.Entity;
import java.util.Stack;
import com.ilargia.games.egdx.logicbricks.component.scene.Background;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import com.ilargia.games.egdx.logicbricks.data.Bounds;
import com.ilargia.games.entitas.api.IComponent;
import com.ilargia.games.egdx.logicbricks.component.scene.CChainLight;
import box2dLight.ChainLight;
import box2dLight.PointLight;
import com.badlogic.gdx.graphics.Color;
import com.ilargia.games.egdx.logicbricks.component.scene.CConeLight;
import box2dLight.ConeLight;
import com.ilargia.games.egdx.logicbricks.component.scene.CDirectionalLight;
import box2dLight.DirectionalLight;
import com.ilargia.games.egdx.logicbricks.component.scene.CPointLight;
import com.ilargia.games.egdx.logicbricks.component.scene.Camera;
import com.ilargia.games.egdx.logicbricks.component.scene.Catch;
import com.ilargia.games.egdx.logicbricks.component.scene.GUI;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.ilargia.games.egdx.logicbricks.component.scene.GameWorld;
import com.ilargia.games.egdx.logicbricks.component.scene.ParallaxLayer;
import com.badlogic.gdx.graphics.Texture;
import com.ilargia.games.egdx.logicbricks.component.scene.Tiled;

/**
 * ---------------------------------------------------------------------------
 * '<auto-generated>' This code was generated by CodeGeneratorApp.
 * ---------------------------------------------------------------------------
 */
public class SceneEntity extends Entity {

	public SceneEntity() {
	}

	public Background getBackground() {
		return (Background) getComponent(SceneComponentsLookup.Background);
	}

	public boolean hasBackground() {
		return hasComponent(SceneComponentsLookup.Background);
	}

	public SceneEntity addBackground(TextureRegion image) {
		Background component = (Background) recoverComponent(SceneComponentsLookup.Background);
		if (component == null) {
			component = new Background(image);
		} else {
			component.image = image;
		}
		addComponent(SceneComponentsLookup.Background, component);
		return this;
	}

	public SceneEntity replaceBackground(TextureRegion image) {
		Background component = (Background) recoverComponent(SceneComponentsLookup.Background);
		if (component == null) {
			component = new Background(image);
		} else {
			component.image = image;
		}
		replaceComponent(SceneComponentsLookup.Background, component);
		return this;
	}

	public SceneEntity removeBackground() {
		removeComponent(SceneComponentsLookup.Background);
		return this;
	}

	public CChainLight getCChainLight() {
		return (CChainLight) getComponent(SceneComponentsLookup.CChainLight);
	}

	public boolean hasCChainLight() {
		return hasComponent(SceneComponentsLookup.CChainLight);
	}

	public SceneEntity addCChainLight(int raysNum, Color color, float distance,
			int rayDirecction, float[] chain) {
		CChainLight component = (CChainLight) recoverComponent(SceneComponentsLookup.CChainLight);
		if (component == null) {
			component = new CChainLight(raysNum, color, distance,
					rayDirecction, chain);
		} else {
			component.raysNum = raysNum;
			component.color = color;
			component.distance = distance;
			component.rayDirecction = rayDirecction;
			component.chain = chain;
			component.light = null;
		}
		addComponent(SceneComponentsLookup.CChainLight, component);
		return this;
	}

	public SceneEntity replaceCChainLight(int raysNum, Color color,
			float distance, int rayDirecction, float[] chain) {
		CChainLight component = (CChainLight) recoverComponent(SceneComponentsLookup.CChainLight);
		if (component == null) {
			component = new CChainLight(raysNum, color, distance,
					rayDirecction, chain);
		} else {
			component.raysNum = raysNum;
			component.color = color;
			component.distance = distance;
			component.rayDirecction = rayDirecction;
			component.chain = chain;
			component.light = null;
		}
		replaceComponent(SceneComponentsLookup.CChainLight, component);
		return this;
	}

	public SceneEntity removeCChainLight() {
		removeComponent(SceneComponentsLookup.CChainLight);
		return this;
	}

	public CConeLight getCConeLight() {
		return (CConeLight) getComponent(SceneComponentsLookup.CConeLight);
	}

	public boolean hasCConeLight() {
		return hasComponent(SceneComponentsLookup.CConeLight);
	}

	public SceneEntity addCConeLight(int raysNum, Color color, float distance,
			Vector2 position, float directionDegree, float coneDegree) {
		CConeLight component = (CConeLight) recoverComponent(SceneComponentsLookup.CConeLight);
		if (component == null) {
			component = new CConeLight(raysNum, color, distance, position,
					directionDegree, coneDegree);
		} else {
			component.raysNum = raysNum;
			component.color = color;
			component.distance = distance;
			component.position = position;
			component.directionDegree = directionDegree;
			component.coneDegree = coneDegree;
			component.light = null;
		}
		addComponent(SceneComponentsLookup.CConeLight, component);
		return this;
	}

	public SceneEntity replaceCConeLight(int raysNum, Color color,
			float distance, Vector2 position, float directionDegree,
			float coneDegree) {
		CConeLight component = (CConeLight) recoverComponent(SceneComponentsLookup.CConeLight);
		if (component == null) {
			component = new CConeLight(raysNum, color, distance, position,
					directionDegree, coneDegree);
		} else {
			component.raysNum = raysNum;
			component.color = color;
			component.distance = distance;
			component.position = position;
			component.directionDegree = directionDegree;
			component.coneDegree = coneDegree;
			component.light = null;
		}
		replaceComponent(SceneComponentsLookup.CConeLight, component);
		return this;
	}

	public SceneEntity removeCConeLight() {
		removeComponent(SceneComponentsLookup.CConeLight);
		return this;
	}

	public CDirectionalLight getCDirectionalLight() {
		return (CDirectionalLight) getComponent(SceneComponentsLookup.CDirectionalLight);
	}

	public boolean hasCDirectionalLight() {
		return hasComponent(SceneComponentsLookup.CDirectionalLight);
	}

	public SceneEntity addCDirectionalLight(int raysNum, Color color,
			float direcction) {
		CDirectionalLight component = (CDirectionalLight) recoverComponent(SceneComponentsLookup.CDirectionalLight);
		if (component == null) {
			component = new CDirectionalLight(raysNum, color, direcction);
		} else {
			component.raysNum = raysNum;
			component.color = color;
			component.direcction = direcction;
			component.light = null;
		}
		addComponent(SceneComponentsLookup.CDirectionalLight, component);
		return this;
	}

	public SceneEntity replaceCDirectionalLight(int raysNum, Color color,
			float direcction) {
		CDirectionalLight component = (CDirectionalLight) recoverComponent(SceneComponentsLookup.CDirectionalLight);
		if (component == null) {
			component = new CDirectionalLight(raysNum, color, direcction);
		} else {
			component.raysNum = raysNum;
			component.color = color;
			component.direcction = direcction;
			component.light = null;
		}
		replaceComponent(SceneComponentsLookup.CDirectionalLight, component);
		return this;
	}

	public SceneEntity removeCDirectionalLight() {
		removeComponent(SceneComponentsLookup.CDirectionalLight);
		return this;
	}

	public CPointLight getCPointLight() {
		return (CPointLight) getComponent(SceneComponentsLookup.CPointLight);
	}

	public boolean hasCPointLight() {
		return hasComponent(SceneComponentsLookup.CPointLight);
	}

	public SceneEntity addCPointLight(int raysNum, Color color, float distance,
			Vector2 position) {
		CPointLight component = (CPointLight) recoverComponent(SceneComponentsLookup.CPointLight);
		if (component == null) {
			component = new CPointLight(raysNum, color, distance, position);
		} else {
			component.raysNum = raysNum;
			component.color = color;
			component.distance = distance;
			component.position = position;
			component.light = null;
		}
		addComponent(SceneComponentsLookup.CPointLight, component);
		return this;
	}

	public SceneEntity replaceCPointLight(int raysNum, Color color,
			float distance, Vector2 position) {
		CPointLight component = (CPointLight) recoverComponent(SceneComponentsLookup.CPointLight);
		if (component == null) {
			component = new CPointLight(raysNum, color, distance, position);
		} else {
			component.raysNum = raysNum;
			component.color = color;
			component.distance = distance;
			component.position = position;
			component.light = null;
		}
		replaceComponent(SceneComponentsLookup.CPointLight, component);
		return this;
	}

	public SceneEntity removeCPointLight() {
		removeComponent(SceneComponentsLookup.CPointLight);
		return this;
	}

	public Camera getCamera() {
		return (Camera) getComponent(SceneComponentsLookup.Camera);
	}

	public boolean hasCamera() {
		return hasComponent(SceneComponentsLookup.Camera);
	}

	public SceneEntity addCamera(com.badlogic.gdx.graphics.Camera camera) {
		Camera component = (Camera) recoverComponent(SceneComponentsLookup.Camera);
		if (component == null) {
			component = new Camera();
		}
		component.camera = camera;
		addComponent(SceneComponentsLookup.Camera, component);
		return this;
	}

	public SceneEntity replaceCamera(com.badlogic.gdx.graphics.Camera camera) {
		Camera component = (Camera) recoverComponent(SceneComponentsLookup.Camera);
		if (component == null) {
			component = new Camera();
		}
		component.camera = camera;
		replaceComponent(SceneComponentsLookup.Camera, component);
		return this;
	}

	public SceneEntity removeCamera() {
		removeComponent(SceneComponentsLookup.Camera);
		return this;
	}

	public Catch getCatch() {
		return (Catch) getComponent(SceneComponentsLookup.Catch);
	}

	public boolean hasCatch() {
		return hasComponent(SceneComponentsLookup.Catch);
	}

	public SceneEntity addCatch(boolean catchBack, boolean catchMenu) {
		Catch component = (Catch) recoverComponent(SceneComponentsLookup.Catch);
		if (component == null) {
			component = new Catch();
		}
		component.catchBack = catchBack;
		component.catchMenu = catchMenu;
		addComponent(SceneComponentsLookup.Catch, component);
		return this;
	}

	public SceneEntity replaceCatch(boolean catchBack, boolean catchMenu) {
		Catch component = (Catch) recoverComponent(SceneComponentsLookup.Catch);
		if (component == null) {
			component = new Catch();
		}
		component.catchBack = catchBack;
		component.catchMenu = catchMenu;
		replaceComponent(SceneComponentsLookup.Catch, component);
		return this;
	}

	public SceneEntity removeCatch() {
		removeComponent(SceneComponentsLookup.Catch);
		return this;
	}

	public GUI getGUI() {
		return (GUI) getComponent(SceneComponentsLookup.GUI);
	}

	public boolean hasGUI() {
		return hasComponent(SceneComponentsLookup.GUI);
	}

	public SceneEntity addGUI(Stage stage) {
		GUI component = (GUI) recoverComponent(SceneComponentsLookup.GUI);
		if (component == null) {
			component = new GUI();
		}
		component.stage = stage;
		addComponent(SceneComponentsLookup.GUI, component);
		return this;
	}

	public SceneEntity replaceGUI(Stage stage) {
		GUI component = (GUI) recoverComponent(SceneComponentsLookup.GUI);
		if (component == null) {
			component = new GUI();
		}
		component.stage = stage;
		replaceComponent(SceneComponentsLookup.GUI, component);
		return this;
	}

	public SceneEntity removeGUI() {
		removeComponent(SceneComponentsLookup.GUI);
		return this;
	}

	public GameWorld getGameWorld() {
		return (GameWorld) getComponent(SceneComponentsLookup.GameWorld);
	}

	public boolean hasGameWorld() {
		return hasComponent(SceneComponentsLookup.GameWorld);
	}

	public SceneEntity addGameWorld(float width, float height,
			float metresToPixels, Color backGroundColor) {
		GameWorld component = (GameWorld) recoverComponent(SceneComponentsLookup.GameWorld);
		if (component == null) {
			component = new GameWorld(width, height, metresToPixels,
					backGroundColor);
		} else {
			component.width = width;
			component.height = height;
			component.metresToPixels = metresToPixels;
			component.pixelsToMetres = 1.0f / metresToPixels;
			component.backGroundColor = backGroundColor;
		}
		addComponent(SceneComponentsLookup.GameWorld, component);
		return this;
	}

	public SceneEntity replaceGameWorld(float width, float height,
			float metresToPixels, Color backGroundColor) {
		GameWorld component = (GameWorld) recoverComponent(SceneComponentsLookup.GameWorld);
		if (component == null) {
			component = new GameWorld(width, height, metresToPixels,
					backGroundColor);
		} else {
			component.width = width;
			component.height = height;
			component.metresToPixels = metresToPixels;
			component.pixelsToMetres = 1.0f / metresToPixels;
			component.backGroundColor = backGroundColor;
		}
		replaceComponent(SceneComponentsLookup.GameWorld, component);
		return this;
	}

	public SceneEntity removeGameWorld() {
		removeComponent(SceneComponentsLookup.GameWorld);
		return this;
	}

	public ParallaxLayer getParallaxLayer() {
		return (ParallaxLayer) getComponent(SceneComponentsLookup.ParallaxLayer);
	}

	public boolean hasParallaxLayer() {
		return hasComponent(SceneComponentsLookup.ParallaxLayer);
	}

	public SceneEntity addParallaxLayer(TextureRegion background,
			Vector2 parallaxRatio, Vector2 startPosition, Vector2 padding) {
		ParallaxLayer component = (ParallaxLayer) recoverComponent(SceneComponentsLookup.ParallaxLayer);
		if (component == null) {
			component = new ParallaxLayer(background, parallaxRatio,
					startPosition, padding);
		} else {
			component.background = background;
			component.parallaxRatio = parallaxRatio;
			component.startPosition = startPosition;
			component.padding = padding;
			component.layer = 0;
		}
		addComponent(SceneComponentsLookup.ParallaxLayer, component);
		return this;
	}

	public SceneEntity replaceParallaxLayer(TextureRegion background,
			Vector2 parallaxRatio, Vector2 startPosition, Vector2 padding) {
		ParallaxLayer component = (ParallaxLayer) recoverComponent(SceneComponentsLookup.ParallaxLayer);
		if (component == null) {
			component = new ParallaxLayer(background, parallaxRatio,
					startPosition, padding);
		} else {
			component.background = background;
			component.parallaxRatio = parallaxRatio;
			component.startPosition = startPosition;
			component.padding = padding;
			component.layer = 0;
		}
		replaceComponent(SceneComponentsLookup.ParallaxLayer, component);
		return this;
	}

	public SceneEntity removeParallaxLayer() {
		removeComponent(SceneComponentsLookup.ParallaxLayer);
		return this;
	}

	public Tiled getTiled() {
		return (Tiled) getComponent(SceneComponentsLookup.Tiled);
	}

	public boolean hasTiled() {
		return hasComponent(SceneComponentsLookup.Tiled);
	}

	public SceneEntity addTiled(String tileMapName, float unitScale) {
		Tiled component = (Tiled) recoverComponent(SceneComponentsLookup.Tiled);
		if (component == null) {
			component = new Tiled();
		}
		component.tileMapName = tileMapName;
		component.unitScale = unitScale;
		addComponent(SceneComponentsLookup.Tiled, component);
		return this;
	}

	public SceneEntity replaceTiled(String tileMapName, float unitScale) {
		Tiled component = (Tiled) recoverComponent(SceneComponentsLookup.Tiled);
		if (component == null) {
			component = new Tiled();
		}
		component.tileMapName = tileMapName;
		component.unitScale = unitScale;
		replaceComponent(SceneComponentsLookup.Tiled, component);
		return this;
	}

	public SceneEntity removeTiled() {
		removeComponent(SceneComponentsLookup.Tiled);
		return this;
	}
}