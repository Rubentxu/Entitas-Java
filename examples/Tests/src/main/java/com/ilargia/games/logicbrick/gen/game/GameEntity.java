package com.ilargia.games.logicbrick.gen.game;

import com.ilargia.games.entitas.api.*;
import com.ilargia.games.entitas.Entity;
import java.util.Stack;
import com.ilargia.games.logicbrick.component.game.Animations;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.ilargia.games.entitas.api.IComponent;
import java.util.Map;
import com.ilargia.games.logicbrick.component.game.Character;
import com.ilargia.games.logicbrick.data.StateCharacter;
import com.ilargia.games.logicbrick.component.game.CollisionSensorComponents;
import com.ilargia.games.entitas.factories.EntitasCollections;
import com.ilargia.games.logicbrick.component.sensor.CollisionSensor;
import com.ilargia.games.logicbrick.gen.sensor.SensorEntity;
import java.util.List;
import com.ilargia.games.logicbrick.component.game.DelaySensorComponents;
import com.ilargia.games.logicbrick.component.sensor.DelaySensor;
import com.ilargia.games.logicbrick.component.game.Destroy;
import com.ilargia.games.logicbrick.component.game.Identity;
import com.ilargia.games.logicbrick.component.game.Interactive;
import com.ilargia.games.logicbrick.component.game.Movable;
import com.ilargia.games.logicbrick.component.game.OnGround;
import com.ilargia.games.logicbrick.component.game.Player;
import com.ilargia.games.logicbrick.component.game.RigidBody;
import com.badlogic.gdx.physics.box2d.Body;
import com.ilargia.games.logicbrick.component.game.TextureView;
import com.badlogic.gdx.graphics.Color;
import com.ilargia.games.logicbrick.data.Bounds;

/**
 * ---------------------------------------------------------------------------
 * '<auto-generated>' This code was generated by CodeGeneratorApp.
 * ---------------------------------------------------------------------------
 */
public class GameEntity extends Entity {

	public Destroy DestroyComponent = new Destroy();
	public Interactive InteractiveComponent = new Interactive();
	public OnGround OnGroundComponent = new OnGround();
	public Player PlayerComponent = new Player();

	public GameEntity() {
	}

	public Animations getAnimations() {
		return (Animations) getComponent(GameComponentsLookup.Animations);
	}

	public boolean hasAnimations() {
		return hasComponent(GameComponentsLookup.Animations);
	}

	public GameEntity addAnimations(
			Map<String, Animation<TextureRegion>> animationStates,
			Animation<TextureRegion> currentAnimation, float time) {
		Animations component = (Animations) recoverComponent(GameComponentsLookup.Animations);
		if (component == null) {
			component = new Animations();
		}
		component.animationStates = animationStates;
		component.currentAnimation = currentAnimation;
		component.time = time;
		addComponent(GameComponentsLookup.Animations, component);
		return this;
	}

	public GameEntity replaceAnimations(
			Map<String, Animation<TextureRegion>> animationStates,
			Animation<TextureRegion> currentAnimation, float time) {
		Animations component = (Animations) recoverComponent(GameComponentsLookup.Animations);
		if (component == null) {
			component = new Animations();
		}
		component.animationStates = animationStates;
		component.currentAnimation = currentAnimation;
		component.time = time;
		replaceComponent(GameComponentsLookup.Animations, component);
		return this;
	}

	public GameEntity removeAnimations() {
		removeComponent(GameComponentsLookup.Animations);
		return this;
	}

	public Character getCharacter() {
		return (Character) getComponent(GameComponentsLookup.Character);
	}

	public boolean hasCharacter() {
		return hasComponent(GameComponentsLookup.Character);
	}

	public GameEntity addCharacter(String tag, StateCharacter currentState,
			boolean facingLeft) {
		Character component = (Character) recoverComponent(GameComponentsLookup.Character);
		if (component == null) {
			component = new Character();
		}
		component.tag = tag;
		component.currentState = currentState;
		component.facingLeft = facingLeft;
		addComponent(GameComponentsLookup.Character, component);
		return this;
	}

	public GameEntity replaceCharacter(String tag, StateCharacter currentState,
			boolean facingLeft) {
		Character component = (Character) recoverComponent(GameComponentsLookup.Character);
		if (component == null) {
			component = new Character();
		}
		component.tag = tag;
		component.currentState = currentState;
		component.facingLeft = facingLeft;
		replaceComponent(GameComponentsLookup.Character, component);
		return this;
	}

	public GameEntity removeCharacter() {
		removeComponent(GameComponentsLookup.Character);
		return this;
	}

	public CollisionSensorComponents getCollisionSensorComponents() {
		return (CollisionSensorComponents) getComponent(GameComponentsLookup.CollisionSensorComponents);
	}

	public boolean hasCollisionSensorComponents() {
		return hasComponent(GameComponentsLookup.CollisionSensorComponents);
	}

	public GameEntity addCollisionSensorComponents(SensorEntity sensor) {
		CollisionSensorComponents component = (CollisionSensorComponents) recoverComponent(GameComponentsLookup.CollisionSensorComponents);
		if (component == null) {
			component = new CollisionSensorComponents(sensor);
		} else {
			if (component.collisionSensors == null) {
				component.collisionSensors = EntitasCollections
						.createList(CollisionSensor.class);
			} else {
				for (SensorEntity collisionSensor : component.collisionSensors) {
					collisionSensor.release(component);
				}
				component.collisionSensors.clear();
			}
			if (sensor.hasCollisionSensor()) {
				sensor.retain(component);
				component.collisionSensors.add(sensor);
			}
		}
		addComponent(GameComponentsLookup.CollisionSensorComponents, component);
		return this;
	}

	public GameEntity replaceCollisionSensorComponents(SensorEntity sensor) {
		CollisionSensorComponents component = (CollisionSensorComponents) recoverComponent(GameComponentsLookup.CollisionSensorComponents);
		if (component == null) {
			component = new CollisionSensorComponents(sensor);
		} else {
			if (component.collisionSensors == null) {
				component.collisionSensors = EntitasCollections
						.createList(CollisionSensor.class);
			} else {
				for (SensorEntity collisionSensor : component.collisionSensors) {
					collisionSensor.release(component);
				}
				component.collisionSensors.clear();
			}
			if (sensor.hasCollisionSensor()) {
				sensor.retain(component);
				component.collisionSensors.add(sensor);
			}
		}
		replaceComponent(GameComponentsLookup.CollisionSensorComponents,
				component);
		return this;
	}

	public GameEntity removeCollisionSensorComponents() {
		removeComponent(GameComponentsLookup.CollisionSensorComponents);
		return this;
	}

	public DelaySensorComponents getDelaySensorComponents() {
		return (DelaySensorComponents) getComponent(GameComponentsLookup.DelaySensorComponents);
	}

	public boolean hasDelaySensorComponents() {
		return hasComponent(GameComponentsLookup.DelaySensorComponents);
	}

	public GameEntity addDelaySensorComponents(SensorEntity sensor) {
		DelaySensorComponents component = (DelaySensorComponents) recoverComponent(GameComponentsLookup.DelaySensorComponents);
		if (component == null) {
			component = new DelaySensorComponents(sensor);
		} else {
			if (component.delaySensors == null) {
				component.delaySensors = EntitasCollections
						.createList(DelaySensor.class);
			} else {
				for (SensorEntity delaySensor : component.delaySensors) {
					delaySensor.release(component);
				}
				component.delaySensors.clear();
			}
			if (sensor.hasDelaySensor()) {
				sensor.retain(component);
				component.delaySensors.add(sensor);
			}
		}
		addComponent(GameComponentsLookup.DelaySensorComponents, component);
		return this;
	}

	public GameEntity replaceDelaySensorComponents(SensorEntity sensor) {
		DelaySensorComponents component = (DelaySensorComponents) recoverComponent(GameComponentsLookup.DelaySensorComponents);
		if (component == null) {
			component = new DelaySensorComponents(sensor);
		} else {
			if (component.delaySensors == null) {
				component.delaySensors = EntitasCollections
						.createList(DelaySensor.class);
			} else {
				for (SensorEntity delaySensor : component.delaySensors) {
					delaySensor.release(component);
				}
				component.delaySensors.clear();
			}
			if (sensor.hasDelaySensor()) {
				sensor.retain(component);
				component.delaySensors.add(sensor);
			}
		}
		replaceComponent(GameComponentsLookup.DelaySensorComponents, component);
		return this;
	}

	public GameEntity removeDelaySensorComponents() {
		removeComponent(GameComponentsLookup.DelaySensorComponents);
		return this;
	}

	public boolean isDestroy() {
		return hasComponent(GameComponentsLookup.Destroy);
	}

	public GameEntity setDestroy(boolean value) {
		if (value != hasComponent(GameComponentsLookup.Destroy)) {
			if (value) {
				addComponent(GameComponentsLookup.Destroy, DestroyComponent);
			} else {
				removeComponent(GameComponentsLookup.Destroy);
			}
		}
		return this;
	}

	public Identity getIdentity() {
		return (Identity) getComponent(GameComponentsLookup.Identity);
	}

	public boolean hasIdentity() {
		return hasComponent(GameComponentsLookup.Identity);
	}

	public GameEntity addIdentity(String type, String tags) {
		Identity component = (Identity) recoverComponent(GameComponentsLookup.Identity);
		if (component == null) {
			component = new Identity();
		}
		component.type = type;
		component.tags = tags;
		addComponent(GameComponentsLookup.Identity, component);
		return this;
	}

	public GameEntity replaceIdentity(String type, String tags) {
		Identity component = (Identity) recoverComponent(GameComponentsLookup.Identity);
		if (component == null) {
			component = new Identity();
		}
		component.type = type;
		component.tags = tags;
		replaceComponent(GameComponentsLookup.Identity, component);
		return this;
	}

	public GameEntity removeIdentity() {
		removeComponent(GameComponentsLookup.Identity);
		return this;
	}

	public boolean isInteractive() {
		return hasComponent(GameComponentsLookup.Interactive);
	}

	public GameEntity setInteractive(boolean value) {
		if (value != hasComponent(GameComponentsLookup.Interactive)) {
			if (value) {
				addComponent(GameComponentsLookup.Interactive,
						InteractiveComponent);
			} else {
				removeComponent(GameComponentsLookup.Interactive);
			}
		}
		return this;
	}

	public Movable getMovable() {
		return (Movable) getComponent(GameComponentsLookup.Movable);
	}

	public boolean hasMovable() {
		return hasComponent(GameComponentsLookup.Movable);
	}

	public GameEntity addMovable(float maxVelocity, float jumpForce) {
		Movable component = (Movable) recoverComponent(GameComponentsLookup.Movable);
		if (component == null) {
			component = new Movable();
		}
		component.maxVelocity = maxVelocity;
		component.jumpForce = jumpForce;
		addComponent(GameComponentsLookup.Movable, component);
		return this;
	}

	public GameEntity replaceMovable(float maxVelocity, float jumpForce) {
		Movable component = (Movable) recoverComponent(GameComponentsLookup.Movable);
		if (component == null) {
			component = new Movable();
		}
		component.maxVelocity = maxVelocity;
		component.jumpForce = jumpForce;
		replaceComponent(GameComponentsLookup.Movable, component);
		return this;
	}

	public GameEntity removeMovable() {
		removeComponent(GameComponentsLookup.Movable);
		return this;
	}

	public boolean isOnGround() {
		return hasComponent(GameComponentsLookup.OnGround);
	}

	public GameEntity setOnGround(boolean value) {
		if (value != hasComponent(GameComponentsLookup.OnGround)) {
			if (value) {
				addComponent(GameComponentsLookup.OnGround, OnGroundComponent);
			} else {
				removeComponent(GameComponentsLookup.OnGround);
			}
		}
		return this;
	}

	public boolean isPlayer() {
		return hasComponent(GameComponentsLookup.Player);
	}

	public GameEntity setPlayer(boolean value) {
		if (value != hasComponent(GameComponentsLookup.Player)) {
			if (value) {
				addComponent(GameComponentsLookup.Player, PlayerComponent);
			} else {
				removeComponent(GameComponentsLookup.Player);
			}
		}
		return this;
	}

	public RigidBody getRigidBody() {
		return (RigidBody) getComponent(GameComponentsLookup.RigidBody);
	}

	public boolean hasRigidBody() {
		return hasComponent(GameComponentsLookup.RigidBody);
	}

	public GameEntity addRigidBody(Body body) {
		RigidBody component = (RigidBody) recoverComponent(GameComponentsLookup.RigidBody);
		if (component == null) {
			component = new RigidBody();
		}
		component.body = body;
		addComponent(GameComponentsLookup.RigidBody, component);
		return this;
	}

	public GameEntity replaceRigidBody(Body body) {
		RigidBody component = (RigidBody) recoverComponent(GameComponentsLookup.RigidBody);
		if (component == null) {
			component = new RigidBody();
		}
		component.body = body;
		replaceComponent(GameComponentsLookup.RigidBody, component);
		return this;
	}

	public GameEntity removeRigidBody() {
		removeComponent(GameComponentsLookup.RigidBody);
		return this;
	}

	public TextureView getTextureView() {
		return (TextureView) getComponent(GameComponentsLookup.TextureView);
	}

	public boolean hasTextureView() {
		return hasComponent(GameComponentsLookup.TextureView);
	}

	public GameEntity addTextureView(TextureRegion texture, Bounds bounds,
			boolean flipX, boolean flipY, int opacity, int layer, Color tint) {
		TextureView component = (TextureView) recoverComponent(GameComponentsLookup.TextureView);
		if (component == null) {
			component = new TextureView(texture, bounds, flipX, flipY, opacity,
					layer, tint);
		} else {
			component.texture = texture;
			component.bounds = bounds;
			component.flipX = flipX;
			component.flipY = flipY;
			component.opacity = opacity;
			component.layer = layer;
			component.tint = tint;
		}
		addComponent(GameComponentsLookup.TextureView, component);
		return this;
	}

	public GameEntity replaceTextureView(TextureRegion texture, Bounds bounds,
			boolean flipX, boolean flipY, int opacity, int layer, Color tint) {
		TextureView component = (TextureView) recoverComponent(GameComponentsLookup.TextureView);
		if (component == null) {
			component = new TextureView(texture, bounds, flipX, flipY, opacity,
					layer, tint);
		} else {
			component.texture = texture;
			component.bounds = bounds;
			component.flipX = flipX;
			component.flipY = flipY;
			component.opacity = opacity;
			component.layer = layer;
			component.tint = tint;
		}
		replaceComponent(GameComponentsLookup.TextureView, component);
		return this;
	}

	public GameEntity removeTextureView() {
		removeComponent(GameComponentsLookup.TextureView);
		return this;
	}
}